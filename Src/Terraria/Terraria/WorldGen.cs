using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using GameManager.Audio;
using GameManager.Chat;
using GameManager.DataStructures;
using GameManager.Enums;
using GameManager.GameContent;
using GameManager.GameContent.Achievements;
using GameManager.GameContent.Biomes;
using GameManager.GameContent.Creative;
using GameManager.GameContent.Events;
using GameManager.GameContent.Generation;
using GameManager.GameContent.Tile_Entities;
using GameManager.GameContent.UI.States;
using GameManager.Graphics.Capture;
using GameManager.ID;
using GameManager.IO;
using GameManager.Localization;
using GameManager.Map;
using GameManager.ObjectData;
using GameManager.Utilities;
using GameManager.WorldBuilding;

namespace GameManager
{
	public class WorldGen
	{
		public static class SavedOreTiers
		{
			public static int Copper = 7;

			public static int Iron = 6;

			public static int Silver = 9;

			public static int Gold = 8;

			public static int Cobalt = 107;

			public static int Mythril = 108;

			public static int Adamantite = 111;
		}

		public static class Hooks
		{
			public delegate void WorldGenConfigProcessEvent(WorldGenConfiguration config);

			public static event WorldGenConfigProcessEvent OnWorldGenConfigProcess;

			public static event Action OnWorldLoad;

			public static void Initialize()
			{
				Player.Hooks.OnEnterWorld += delegate(Player player)
				{
					if (player.whoAmI == Main.myPlayer)
					{
						WorldLoaded();
						if (Main.netMode != 1)
						{
							Main.FixUIScale();
						}
					}
				};
				OnWorldLoad += mysticLogsEvent.StartWorld;
				OnWorldLoad += Main.checkHalloween;
				OnWorldLoad += Main.checkXMas;
			}

			public static void WorldLoaded()
			{
				if (Hooks.OnWorldLoad != null)
				{
					Hooks.OnWorldLoad();
				}
			}

			public static void ClearWorld()
			{
				PressurePlateHelper.Reset();
				TownManager.Clear();
				NPC.ResetKillCount();
				Main.instance.ClearCachedTileDraws();
				MapHelper.ResetMapData();
			}

			public static void ProcessWorldGenConfig(WorldGenConfiguration config)
			{
				if (Hooks.OnWorldGenConfigProcess != null)
				{
					Hooks.OnWorldGenConfigProcess(config);
				}
			}
		}

		public static class Spread
		{
			public static void Wall(int x, int y, int wallType)
			{
				if (!InWorld(x, y))
				{
					return;
				}
				ushort wall = (ushort)wallType;
				List<Point> list = new List<Point>();
				List<Point> list2 = new List<Point>();
				HashSet<Point> hashSet = new HashSet<Point>();
				list2.Add(new Point(x, y));
				while (list2.Count > 0)
				{
					list.Clear();
					list.AddRange(list2);
					list2.Clear();
					while (list.Count > 0)
					{
						Point item = list[0];
						if (!InWorld(item.X, item.Y, 1))
						{
							list.Remove(item);
							continue;
						}
						hashSet.Add(item);
						list.Remove(item);
						Tile tile = Main.tile[item.X, item.Y];
						if (SolidTile(item.X, item.Y) || tile.wall != 0)
						{
							if (tile.active() && tile.wall == 0)
							{
								tile.wall = wall;
							}
							continue;
						}
						tile.wall = wall;
						Point item2 = new Point(item.X - 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X + 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X, item.Y - 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X, item.Y + 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
					}
				}
			}

			public static void Wall2(int x, int y, int wallType)
			{
				if (!InWorld(x, y))
				{
					return;
				}
				ushort num = (ushort)wallType;
				int num2 = 0;
				int maxWallOut = maxWallOut2;
				List<Point> list = new List<Point>();
				List<Point> list2 = new List<Point>();
				HashSet<Point> hashSet = new HashSet<Point>();
				list2.Add(new Point(x, y));
				while (list2.Count > 0)
				{
					list.Clear();
					list.AddRange(list2);
					list2.Clear();
					while (list.Count > 0)
					{
						Point item = list[0];
						if (!InWorld(item.X, item.Y, 1))
						{
							list.Remove(item);
							continue;
						}
						hashSet.Add(item);
						list.Remove(item);
						Tile tile = Main.tile[item.X, item.Y];
						if (!SolidTile(item.X, item.Y) && tile.wall != num && tile.wall != 4 && tile.wall != 40 && tile.wall != 3 && tile.wall != 87 && tile.wall != 34)
						{
							if (num == 63 && tile.wall == 0)
							{
								list.Remove(item);
								continue;
							}
							num2++;
							if (num2 >= maxWallOut)
							{
								list.Remove(item);
								continue;
							}
							tile.wall = num;
							Point item2 = new Point(item.X - 1, item.Y);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							item2 = new Point(item.X + 1, item.Y);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							item2 = new Point(item.X, item.Y - 1);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							item2 = new Point(item.X, item.Y + 1);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							if (num == 63)
							{
								item2 = new Point(item.X - 1, item.Y - 1);
								if (!hashSet.Contains(item2))
								{
									list2.Add(item2);
								}
								item2 = new Point(item.X + 1, item.Y - 1);
								if (!hashSet.Contains(item2))
								{
									list2.Add(item2);
								}
								item2 = new Point(item.X - 1, item.Y + 1);
								if (!hashSet.Contains(item2))
								{
									list2.Add(item2);
								}
								item2 = new Point(item.X + 1, item.Y + 1);
								if (!hashSet.Contains(item2))
								{
									list2.Add(item2);
								}
								item2 = new Point(item.X - 2, item.Y);
								if (!hashSet.Contains(item2))
								{
									list2.Add(item2);
								}
								item2 = new Point(item.X + 2, item.Y);
								if (!hashSet.Contains(item2))
								{
									list2.Add(item2);
								}
							}
						}
						else if (tile.active() && tile.wall != num && tile.wall != 4 && tile.wall != 40 && tile.wall != 3 && tile.wall != 87 && tile.wall != 34)
						{
							tile.wall = num;
						}
					}
				}
			}

			public static void Moss(int x, int y)
			{
				if (!InWorld(x, y))
				{
					return;
				}
				ushort mossWall = WorldGen.mossWall;
				ushort mossTile = WorldGen.mossTile;
				List<Point> list = new List<Point>();
				List<Point> list2 = new List<Point>();
				HashSet<Point> hashSet = new HashSet<Point>();
				list2.Add(new Point(x, y));
				while (list2.Count > 0)
				{
					list.Clear();
					list.AddRange(list2);
					list2.Clear();
					while (list.Count > 0)
					{
						Point item = list[0];
						if (!InWorld(item.X, item.Y, 1))
						{
							list.Remove(item);
							continue;
						}
						hashSet.Add(item);
						list.Remove(item);
						Tile tile = Main.tile[item.X, item.Y];
						if (SolidTile(item.X, item.Y) || tile.wall != 0)
						{
							if (tile.active())
							{
								if (tile.wall == 0)
								{
									tile.wall = mossWall;
								}
								if (tile.type == 1)
								{
									tile.type = mossTile;
								}
							}
							continue;
						}
						tile.wall = mossWall;
						Point item2 = new Point(item.X - 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X + 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X, item.Y - 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X, item.Y + 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
					}
				}
			}

			public static void Gem(int x, int y)
			{
				if (!InWorld(x, y))
				{
					return;
				}
				List<Point> list = new List<Point>();
				List<Point> list2 = new List<Point>();
				HashSet<Point> hashSet = new HashSet<Point>();
				list2.Add(new Point(x, y));
				while (list2.Count > 0)
				{
					list.Clear();
					list.AddRange(list2);
					list2.Clear();
					while (list.Count > 0)
					{
						Point item = list[0];
						if (!InWorld(item.X, item.Y, 1))
						{
							list.Remove(item);
							continue;
						}
						hashSet.Add(item);
						list.Remove(item);
						Tile tile = Main.tile[item.X, item.Y];
						if (SolidTile(item.X, item.Y) || tile.wall != 0)
						{
							if (tile.active())
							{
								if (Gemmable(tile.type))
								{
									tile.type = randGemTile();
								}
								Tile tile2 = Main.tile[item.X - 1, item.Y];
								if (Gemmable(tile2.type))
								{
									tile2.type = randGemTile();
								}
								tile2 = Main.tile[item.X + 1, item.Y];
								if (Gemmable(tile2.type))
								{
									tile2.type = randGemTile();
								}
								tile2 = Main.tile[item.X, item.Y - 1];
								if (Gemmable(tile2.type))
								{
									tile2.type = randGemTile();
								}
								tile2 = Main.tile[item.X, item.Y + 1];
								if (Gemmable(tile2.type))
								{
									tile2.type = randGemTile();
								}
							}
						}
						else
						{
							tile.wall = (ushort)(48 + randGem());
							if (!tile.active() && genRand.Next(2) == 0)
							{
								PlaceTile(item.X, item.Y, 178, mute: true, forced: false, -1, randGem());
							}
							Point item2 = new Point(item.X - 1, item.Y);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							item2 = new Point(item.X + 1, item.Y);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							item2 = new Point(item.X, item.Y - 1);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							item2 = new Point(item.X, item.Y + 1);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
						}
					}
				}
			}

			public static void Spider(int x, int y)
			{
				if (!InWorld(x, y))
				{
					return;
				}
				byte wall = 62;
				List<Point> list = new List<Point>();
				List<Point> list2 = new List<Point>();
				HashSet<Point> hashSet = new HashSet<Point>();
				list2.Add(new Point(x, y));
				while (list2.Count > 0)
				{
					list.Clear();
					list.AddRange(list2);
					list2.Clear();
					while (list.Count > 0)
					{
						Point item = list[0];
						if (!InWorld(item.X, item.Y, 1))
						{
							list.Remove(item);
							continue;
						}
						hashSet.Add(item);
						list.Remove(item);
						Tile tile = Main.tile[item.X, item.Y];
						if (SolidTile(item.X, item.Y) || tile.wall != 0)
						{
							if (tile.active() && tile.wall == 0)
							{
								tile.wall = wall;
							}
							continue;
						}
						tile.wall = wall;
						SquareWallFrame(item.X, item.Y);
						if (!tile.active())
						{
							tile.liquid = 0;
							tile.lava(lava: false);
							if (SolidTile(item.X, item.Y + 1) && genRand.Next(3) == 0)
							{
								if (genRand.Next(15) == 0)
								{
									AddBuriedChest(item.X, item.Y, 939, notNearOtherChests: true, 15, trySlope: false, 0);
								}
								else
								{
									PlacePot(item.X, item.Y, 28, genRand.Next(19, 21));
								}
							}
							if (!tile.active())
							{
								if (SolidTile(item.X, item.Y - 1) && genRand.Next(3) == 0)
								{
									PlaceTight(item.X, item.Y, spiders: true);
								}
								else if (SolidTile(item.X, item.Y + 1))
								{
									PlaceTile(item.X, item.Y, 187, mute: true, forced: false, -1, 9 + genRand.Next(5));
									if (genRand.Next(3) == 0)
									{
										if (!tile.active())
										{
											PlaceSmallPile(item.X, item.Y, 34 + genRand.Next(4), 1, 185);
										}
										if (!tile.active())
										{
											PlaceSmallPile(item.X, item.Y, 48 + genRand.Next(6), 0, 185);
										}
									}
								}
							}
						}
						Point item2 = new Point(item.X - 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X + 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X, item.Y - 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X, item.Y + 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
					}
				}
			}

			public static void WallDungeon(int x, int y, int wallType)
			{
				if (!InWorld(x, y))
				{
					return;
				}
				ushort num = (ushort)wallType;
				List<Point> list = new List<Point>();
				List<Point> list2 = new List<Point>();
				HashSet<Point> hashSet = new HashSet<Point>();
				list2.Add(new Point(x, y));
				while (list2.Count > 0)
				{
					list.Clear();
					list.AddRange(list2);
					list2.Clear();
					while (list.Count > 0)
					{
						Point item = list[0];
						if (!InWorld(item.X, item.Y, 1))
						{
							list.Remove(item);
							continue;
						}
						hashSet.Add(item);
						list.Remove(item);
						Tile tile = Main.tile[item.X, item.Y];
						if (!SolidTile(item.X, item.Y) && tile.wall != num && tile.wall > 0 && tile.wall != 244)
						{
							tile.wall = num;
							Point item2 = new Point(item.X - 1, item.Y);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							item2 = new Point(item.X + 1, item.Y);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							item2 = new Point(item.X, item.Y - 1);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							item2 = new Point(item.X, item.Y + 1);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
						}
						else if (tile.active())
						{
							tile.wall = num;
						}
					}
				}
			}

			private static bool Gemmable(int type)
			{
				if (type != 0 && type != 1 && type != 40 && type != 59 && type != 60 && type != 70 && type != 147)
				{
					return type == 161;
				}
				return true;
			}
		}

		public struct GrowTreeSettings
		{
			public delegate bool IsTileFitForTreeGroundTest(int tileType);

			public delegate bool IsWallTypeFitForTreeBack(int wallType);

			public static class Profiles
			{
				public static GrowTreeSettings GemTree_Ruby;

				public static GrowTreeSettings GemTree_Diamond;

				public static GrowTreeSettings GemTree_Topaz;

				public static GrowTreeSettings GemTree_Amethyst;

				public static GrowTreeSettings GemTree_Sappphire;

				public static GrowTreeSettings GemTree_Emerald;

				public static GrowTreeSettings GemTree_Amber;

				public static GrowTreeSettings VanityTree_Sakura;

				public static GrowTreeSettings VanityTree_Willow;

				public static bool TryGetFromItemId(int itemType, out GrowTreeSettings profile)
				{
					switch (itemType)
					{
					default:
						profile = default(GrowTreeSettings);
						return false;
					case 4857:
						profile = GemTree_Amber;
						return true;
					case 4852:
						profile = GemTree_Amethyst;
						return true;
					case 4856:
						profile = GemTree_Diamond;
						return true;
					case 4854:
						profile = GemTree_Emerald;
						return true;
					case 4855:
						profile = GemTree_Ruby;
						return true;
					case 4853:
						profile = GemTree_Sappphire;
						return true;
					case 4851:
						profile = GemTree_Topaz;
						return true;
					case 4907:
						profile = VanityTree_Willow;
						return true;
					case 4871:
						profile = VanityTree_Sakura;
						return true;
					}
				}

				static Profiles()
				{
					GrowTreeSettings growTreeSettings = new GrowTreeSettings
					{
						GroundTest = GemTreeGroundTest,
						WallTest = GemTreeWallTest,
						TreeHeightMax = 12,
						TreeHeightMin = 7,
						TreeTileType = 587,
						TreeTopPaddingNeeded = 4,
						SaplingTileType = 590
					};
					GemTree_Ruby = growTreeSettings;
					growTreeSettings = new GrowTreeSettings
					{
						GroundTest = GemTreeGroundTest,
						WallTest = GemTreeWallTest,
						TreeHeightMax = 12,
						TreeHeightMin = 7,
						TreeTileType = 588,
						TreeTopPaddingNeeded = 4,
						SaplingTileType = 590
					};
					GemTree_Diamond = growTreeSettings;
					growTreeSettings = new GrowTreeSettings
					{
						GroundTest = GemTreeGroundTest,
						WallTest = GemTreeWallTest,
						TreeHeightMax = 12,
						TreeHeightMin = 7,
						TreeTileType = 583,
						TreeTopPaddingNeeded = 4,
						SaplingTileType = 590
					};
					GemTree_Topaz = growTreeSettings;
					growTreeSettings = new GrowTreeSettings
					{
						GroundTest = GemTreeGroundTest,
						WallTest = GemTreeWallTest,
						TreeHeightMax = 12,
						TreeHeightMin = 7,
						TreeTileType = 584,
						TreeTopPaddingNeeded = 4,
						SaplingTileType = 590
					};
					GemTree_Amethyst = growTreeSettings;
					growTreeSettings = new GrowTreeSettings
					{
						GroundTest = GemTreeGroundTest,
						WallTest = GemTreeWallTest,
						TreeHeightMax = 12,
						TreeHeightMin = 7,
						TreeTileType = 585,
						TreeTopPaddingNeeded = 4,
						SaplingTileType = 590
					};
					GemTree_Sappphire = growTreeSettings;
					growTreeSettings = new GrowTreeSettings
					{
						GroundTest = GemTreeGroundTest,
						WallTest = GemTreeWallTest,
						TreeHeightMax = 12,
						TreeHeightMin = 7,
						TreeTileType = 586,
						TreeTopPaddingNeeded = 4,
						SaplingTileType = 590
					};
					GemTree_Emerald = growTreeSettings;
					growTreeSettings = new GrowTreeSettings
					{
						GroundTest = GemTreeGroundTest,
						WallTest = GemTreeWallTest,
						TreeHeightMax = 12,
						TreeHeightMin = 7,
						TreeTileType = 589,
						TreeTopPaddingNeeded = 4,
						SaplingTileType = 590
					};
					GemTree_Amber = growTreeSettings;
					growTreeSettings = new GrowTreeSettings
					{
						GroundTest = VanityTreeGroundTest,
						WallTest = DefaultTreeWallTest,
						TreeHeightMax = 12,
						TreeHeightMin = 7,
						TreeTileType = 596,
						TreeTopPaddingNeeded = 4,
						SaplingTileType = 595
					};
					VanityTree_Sakura = growTreeSettings;
					growTreeSettings = new GrowTreeSettings
					{
						GroundTest = VanityTreeGroundTest,
						WallTest = DefaultTreeWallTest,
						TreeHeightMax = 12,
						TreeHeightMin = 7,
						TreeTileType = 616,
						TreeTopPaddingNeeded = 4,
						SaplingTileType = 615
					};
					VanityTree_Willow = growTreeSettings;
				}
			}

			public ushort TreeTileType;

			public int TreeHeightMin;

			public int TreeHeightMax;

			public int TreeTopPaddingNeeded;

			public IsTileFitForTreeGroundTest GroundTest;

			public IsWallTypeFitForTreeBack WallTest;

			public ushort SaplingTileType;
		}

		public struct CheckTreeSettings
		{
			public delegate bool GroundValidTest(int groundTileType);

			public GroundValidTest IsGroundValid;
		}

		public enum SpecialKillTileContext
		{
			None,
			MowingTheGrass
		}

		public delegate bool GetTreeFoliageDataMethod(int i, int j, int xoffset, int treeFrame, int treeStyle, out int floorY, out int topTextureFrameWidth, out int topTextureFrameHeight);

		public static TownRoomManager TownManager = new TownRoomManager();

		private static int lAltarX;

		private static int lAltarY;

		private static Queue<Action<StructureMap>> _postGenActions = new Queue<Action<StructureMap>>();

		public static int tileReframeCount;

		public static bool noMapUpdate;

		public static double worldSurfaceLow;

		public static int tLeft;

		public static int tRight;

		public static int tTop;

		public static int tBottom;

		public static int tRooms;

		public static int[] mossType = new int[3];

		public static ushort neonMossType;

		public static int copperBar = 20;

		public static int ironBar = 22;

		public static int silverBar = 21;

		public static int goldBar = 19;

		private const int NUM_SEASHELL_STYLES = 2;

		public static int treeBG1;

		public static int treeBG2;

		public static int treeBG3;

		public static int treeBG4;

		public static int corruptBG;

		public static int jungleBG;

		public static int snowBG;

		public static int hallowBG;

		public static int crimsonBG;

		public static int desertBG;

		public static int oceanBG;

		public static int mushroomBG;

		public static int underworldBG;

		private static ushort crackedType = 481;

		public static int oceanDistance = 250;

		public static int beachDistance = 380;

		public static bool skipDesertTileCheck = false;

		public static bool crimson;

		public static ushort mossTile = 179;

		public static ushort mossWall = 54;

		public static bool[] gem = new bool[6];

		public static int[] tileCounts = new int[623];

		public static int totalEvil;

		public static int totalBlood;

		public static int totalGood;

		public static int totalSolid;

		public static int totalEvil2;

		public static int totalBlood2;

		public static int totalGood2;

		public static int totalSolid2;

		public static byte tEvil;

		public static byte tBlood;

		public static byte tGood;

		public static string currentWorldSeed;

		public static bool dungeonLake = false;

		public static int totalX;

		public static int totalD;

		public static bool IsGeneratingHardMode;

		private static Vector2[] heartPos = new Vector2[100];

		private static int heartCount;

		public static int maxTreeShakes = 200;

		public static int numTreeShakes = 0;

		public static int[] treeShakeX = new int[maxTreeShakes];

		public static int[] treeShakeY = new int[maxTreeShakes];

		public static int lavaLine;

		public static int waterLine;

		public static bool noTileActions;

		public static bool spawnEye;

		public static int spawnHardBoss;

		public static int numLarva;

		public static int[] larvaX = new int[100];

		public static int[] larvaY = new int[100];

		public static volatile bool gen;

		public static bool shadowOrbSmashed;

		public static int shadowOrbCount;

		public static int altarCount;

		public static bool spawnMeteor;

		public static bool loadFailed = false;

		public static bool loadSuccess = false;

		public static bool worldCleared;

		public static bool worldBackup;

		public static bool loadBackup = false;

		private static int lastMaxTilesX;

		private static int lastMaxTilesY;

		private static bool mergeUp;

		private static bool mergeDown;

		private static bool mergeLeft;

		private static bool mergeRight;

		private static bool stopDrops;

		public static bool mudWall;

		private static int grassSpread;

		public static bool noLiquidCheck;

		public static bool AllowedToSpreadInfections = true;

		[ThreadStatic]
		public static UnifiedRandom _genRand;

		[ThreadStatic]
		public static int _genRandSeed = -2;

		public static int _lastSeed;

		public static string statusText = "";

		public static bool destroyObject;

		public static int spawnDelay;

		public static int prioritizedTownNPCType;

		public static int numTileCount;

		public static int maxTileCount = 3500;

		public static int maxWallOut2 = 5000;

		public static Dictionary<Point, bool> CountedTiles = new Dictionary<Point, bool>(maxTileCount);

		public static int lavaCount;

		public static int iceCount;

		public static int rockCount;

		public static int shroomCount;

		public static int maxRoomTiles = 750;

		public static int numRoomTiles;

		public static int[] roomX = new int[maxRoomTiles];

		public static int[] roomY = new int[maxRoomTiles];

		public static int roomCeilingsCount;

		public static int[] roomCeilingX = new int[maxRoomTiles];

		public static int[] roomCeilingY = new int[maxRoomTiles];

		public static int roomX1;

		public static int roomX2;

		public static int roomY1;

		public static int roomY2;

		public static bool canSpawn;

		public static bool[] houseTile = new bool[623];

		public static int bestX;

		public static int bestY;

		public static int hiScore;

		public static int dungeonX;

		public static int dungeonY;

		public static Vector2 lastDungeonHall = Vector2.Zero;

		public static int maxDRooms = 100;

		public static int numDRooms;

		public static int[] dRoomX = new int[maxDRooms];

		public static int[] dRoomY = new int[maxDRooms];

		public static int[] dRoomSize = new int[maxDRooms];

		private static bool[] dRoomTreasure = new bool[maxDRooms];

		private static int[] dRoomL = new int[maxDRooms];

		private static int[] dRoomR = new int[maxDRooms];

		private static int[] dRoomT = new int[maxDRooms];

		private static int[] dRoomB = new int[maxDRooms];

		private static int numDDoors;

		private static int[] DDoorX = new int[500];

		private static int[] DDoorY = new int[500];

		private static int[] DDoorPos = new int[500];

		private static int numDungeonPlatforms;

		private static int[] dungeonPlatformX = new int[500];

		private static int[] dungeonPlatformY = new int[500];

		private static bool generatedShadowKey;

		private static int JungleItemCount;

		private static int[] JChestX = new int[100];

		private static int[] JChestY = new int[100];

		private static int numJChests;

		public static int dEnteranceX;

		public static bool dSurface;

		private static double dxStrength1;

		private static double dyStrength1;

		private static double dxStrength2;

		private static double dyStrength2;

		private static int dMinX;

		private static int dMaxX;

		private static int dMinY;

		private static int dMaxY;

		private static int numIslandHouses;

		private static int houseCount;

		private static bool[] skyLake = new bool[30];

		private static int[] floatingIslandHouseX = new int[30];

		private static int[] floatingIslandHouseY = new int[30];

		private static int[] floatingIslandStyle = new int[30];

		private static int numMCaves;

		private static int[] mCaveX = new int[30];

		private static int[] mCaveY = new int[30];

		public static int WorldGenParam_Evil = -1;

		private static int maxTunnels = 50;

		private static int numTunnels;

		private static int[] tunnelX = new int[maxTunnels];

		private static int maxOrePatch = 50;

		private static int numOrePatch;

		private static int[] orePatchX = new int[maxOrePatch];

		private static int maxOasis = 20;

		private static int numOasis = 0;

		private static Vector2[] oasisPosition = new Vector2[maxOasis];

		private static int[] oasisWidth = new int[maxOasis];

		private static int oasisHeight = 20;

		private static int maxMushroomBiomes = 50;

		private static int numMushroomBiomes = 0;

		private static Vector2[] mushroomBiomesPosition = new Vector2[maxMushroomBiomes];

		private static int maxLakes = 50;

		private static int numLakes = 0;

		private static int[] LakeX = new int[maxLakes];

		private static int maxOceanCaveTreasure = 2;

		private static int numOceanCaveTreasure = 0;

		private static Point[] oceanCaveTreasure = new Point[maxOceanCaveTreasure];

		private static int cactusWaterWidth = 50;

		private static int cactusWaterHeight = 25;

		private static int cactusWaterLimit = 25;

		private static int JungleX;

		private static int hellChest;

		private static int[] hellChestItem = new int[7];

		private static bool roomTorch;

		private static bool roomDoor;

		private static bool roomChair;

		private static bool roomTable;

		private static bool roomOccupied;

		private static bool roomEvil;

		public static Point16[] statueList;

		public static List<int> StatuesWithTraps = new List<int>(new int[4]
		{
			4,
			7,
			10,
			18
		});

		public static Rectangle UndergroundDesertLocation = Rectangle.Empty;

		public static Rectangle UndergroundDesertHiveLocation = Rectangle.Empty;

		public static MysticLogFairiesEvent mysticLogsEvent = new MysticLogFairiesEvent();

		private static bool currentlyTryingToUseAlternateHousingSpot;

		private static int sharedRoomX;

		public static TownNPCRoomCheckFailureReason roomCheckFailureReason = TownNPCRoomCheckFailureReason.None;

		public static bool generatingWorld = false;

		private static int[,] trapDiag = new int[4, 2];

		private static int tileCounterNum;

		private static int tileCounterMax = 20;

		private static int[] tileCounterX = new int[tileCounterMax];

		private static int[] tileCounterY = new int[tileCounterMax];

		private static WorldGenerator _generator;

		public static int SmallConsecutivesFound = 0;

		public static int SmallConsecutivesEliminated = 0;

		public static bool drunkWorldGen = false;

		public static bool getGoodWorldGen = false;

		public static bool drunkWorldGenText = false;

		public static bool placingTraps = false;

		public const bool USE_FRAMING_SKIP_FOR_UNIMPORTANT_TILES_IN_WORLDGEN = false;

		public static bool notTheBees = false;

		private static int catTailDistance = 8;

		public static TreeTopsInfo TreeTops = new TreeTopsInfo();

		public static BackgroundChangeFlashInfo BackgroundsCache = new BackgroundChangeFlashInfo();

		private static bool fossilBreak = false;

		private const bool BUBBLES_SOLID_STATE_FOR_HOUSING = true;

		private static bool skipFramingDuringGen = false;

		public static UnifiedRandom genRand
		{
			get
			{
				if (_lastSeed != _genRandSeed)
				{
					_genRand = new UnifiedRandom(_lastSeed);
					_genRandSeed = _lastSeed;
				}
				if (_genRand == null)
				{
					_genRand = new UnifiedRandom(_lastSeed);
					_genRandSeed = _lastSeed;
				}
				return _genRand;
			}
		}

		public static double oceanLevel => (Main.worldSurface + Main.rockLayer) / 2.0 + 40.0;

		public static bool SkipFramingBecauseOfGen
		{
			get
			{
				if (generatingWorld)
				{
					return skipFramingDuringGen;
				}
				return false;
			}
		}

		public static void SetupStatueList()
		{
			List<Point16> list = new List<Point16>();
			for (int i = 0; i < 44; i++)
			{
				list.Add(new Point16(105, i));
			}
			list[34] = new Point16(349, 0);
			list[43] = new Point16(105, 50);
			list.Add(new Point16(105, 63));
			list.Add(new Point16(105, 64));
			list.Add(new Point16(105, 65));
			list.Add(new Point16(105, 66));
			list.Add(new Point16(105, 68));
			list.Add(new Point16(105, 69));
			list.Add(new Point16(105, 70));
			list.Add(new Point16(105, 71));
			list.Add(new Point16(105, 72));
			list.Add(new Point16(105, 73));
			list.Add(new Point16(105, 75));
			list.Add(new Point16(105, 51));
			list.Add(new Point16(105, 52));
			list.Add(new Point16(105, 53));
			list.Add(new Point16(105, 54));
			list.Add(new Point16(105, 55));
			list.Add(new Point16(105, 56));
			list.Add(new Point16(105, 57));
			list.Add(new Point16(105, 58));
			list.Add(new Point16(105, 59));
			list.Add(new Point16(105, 60));
			list.Add(new Point16(105, 61));
			list.Add(new Point16(105, 62));
			list.Add(new Point16(105, 77));
			list.Add(new Point16(105, 78));
			if (Main.expertMode)
			{
				list.Add(new Point16(105, 67));
				list.Add(new Point16(105, 74));
			}
			statueList = list.ToArray();
		}

		public static void PlaceStatueTrap(int x, int y)
		{
			for (int i = -10; i <= 10; i++)
			{
				for (int j = -10; j <= 10; j++)
				{
					Tile testTile = Main.tile[x + i, y + j + 1];
					Tile tile = Main.tile[x + i, y + j];
					if (!tile.active() && SolidTile2(testTile))
					{
						PlaceTile(x + i, y + j, 135, mute: true);
						if (tile.active() && tile.type == 135)
						{
							WorldUtils.WireLine(new Point(x, y), new Point(x + i, y + j));
							return;
						}
					}
				}
			}
		}

		public static bool EmptyLiquid(int x, int y)
		{
			if (!InWorld(x, y))
			{
				return false;
			}
			Tile tile = Main.tile[x, y];
			if (tile == null)
			{
				return false;
			}
			tile.liquidType();
			if (tile.nactive() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type])
			{
				return false;
			}
			tile.Clear(TileDataType.Liquid);
			SquareTileFrame(x, y, resetFrame: false);
			if (Main.netMode == 1)
			{
				NetMessage.sendWater(x, y);
			}
			else
			{
				Liquid.AddWater(x, y);
			}
			return true;
		}

		public static bool PlaceLiquid(int x, int y, byte liquidType, byte amount)
		{
			if (!InWorld(x, y))
			{
				return false;
			}
			Tile tile = Main.tile[x, y];
			if (tile == null)
			{
				return false;
			}
			byte b = tile.liquidType();
			if (tile.nactive() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type])
			{
				return false;
			}
			if (tile.liquid == 0 || liquidType == b)
			{
				tile.liquidType(liquidType);
				if (amount + tile.liquid > 255)
				{
					amount = (byte)(255 - tile.liquid);
				}
				tile.liquid += amount;
				SquareTileFrame(x, y);
				if (Main.netMode != 0)
				{
					NetMessage.sendWater(x, y);
				}
				return true;
			}
			ushort num = 0;
			if ((liquidType == 0 && b == 1) || (liquidType == 1 && b == 0))
			{
				num = 56;
			}
			else if ((liquidType == 0 && b == 2) || (liquidType == 2 && b == 0))
			{
				num = 229;
			}
			else if ((liquidType == 1 && b == 2) || (liquidType == 2 && b == 1))
			{
				num = 230;
			}
			if (num != 0)
			{
				tile.liquid = 0;
				tile.liquidType(0);
				PlaceTile(x, y, num, mute: true);
				SquareTileFrame(x, y);
				if (Main.netMode != 0)
				{
					NetMessage.SendTileSquare(-1, x - 1, y - 1, 3, (num == 56) ? TileChangeType.LavaWater : TileChangeType.HoneyLava);
				}
				return true;
			}
			return false;
		}

		public static bool MoveTownNPC(int x, int y, int n)
		{
			if (!StartRoomCheck(x, y))
			{
				string newText = Lang.inter[40].Value;
				switch (roomCheckFailureReason)
				{
				case TownNPCRoomCheckFailureReason.HoleInWallIsTooBig:
					newText = Language.GetTextValue("TownNPCHousingFailureReasons.HoleInWallIsTooBig");
					break;
				case TownNPCRoomCheckFailureReason.RoomCheckStartedInASolidTile:
					newText = Language.GetTextValue("TownNPCHousingFailureReasons.RoomCheckStartedInASolidTile");
					break;
				case TownNPCRoomCheckFailureReason.RoomIsTooBig:
					newText = Language.GetTextValue("TownNPCHousingFailureReasons.RoomIsTooBig");
					break;
				case TownNPCRoomCheckFailureReason.RoomIsTooSmall:
					newText = Language.GetTextValue("TownNPCHousingFailureReasons.RoomIsTooSmall");
					break;
				case TownNPCRoomCheckFailureReason.TooCloseToWorldEdge:
					newText = Language.GetTextValue("TownNPCHousingFailureReasons.TooCloseToWorldEdge");
					break;
				}
				Main.NewText(newText, byte.MaxValue, 240, 20);
				return false;
			}
			if (!RoomNeeds(prioritizedTownNPCType))
			{
				int num = 0;
				int num2 = ((!roomTorch) ? 1 : 0) + ((!roomDoor) ? 1 : 0) + ((!roomTable) ? 1 : 0) + ((!roomChair) ? 1 : 0);
				string[] array = new string[num2];
				if (!roomTorch)
				{
					array[num] = Language.GetTextValue("Game.HouseLightSource");
					num++;
				}
				if (!roomDoor)
				{
					array[num] = Language.GetTextValue("Game.HouseDoor");
					num++;
				}
				if (!roomTable)
				{
					array[num] = Language.GetTextValue("Game.HouseTable");
					num++;
				}
				if (!roomChair)
				{
					array[num] = Language.GetTextValue("Game.HouseChair");
					num++;
				}
				string key = "Game.HouseMissing_" + num2;
				object[] args = array;
				Main.NewText(Language.GetTextValue(key, args), byte.MaxValue, 240, 20);
				return false;
			}
			int type = prioritizedTownNPCType;
			if (n >= 0)
			{
				type = Main.npc[n].type;
			}
			ScoreRoom(-1, type);
			if (hiScore <= 0)
			{
				if (roomOccupied)
				{
					Main.NewText(Lang.inter[41].Value, byte.MaxValue, 240, 20);
				}
				else if (roomEvil)
				{
					Main.NewText(Lang.inter[42].Value, byte.MaxValue, 240, 20);
				}
				else
				{
					Main.NewText(Lang.inter[40].Value, byte.MaxValue, 240, 20);
				}
				return false;
			}
			if (n >= 0 && !CheckSpecialTownNPCSpawningConditions(Main.npc[n].type))
			{
				Main.NewText(Lang.inter[55].Value + " " + Main.npc[n].TypeName, byte.MaxValue, 240, 20);
				return false;
			}
			return true;
		}

		public static void moveRoom(int x, int y, int n)
		{
			if (Main.netMode == 1)
			{
				NetMessage.SendData(60, -1, -1, null, n, x, y);
				return;
			}
			prioritizedTownNPCType = Main.npc[n].type;
			Main.npc[n].homeless = true;
			SpawnTownNPC(x, y);
			TownManager.SetRoom(Main.npc[n].type, Main.npc[n].homeTileX, Main.npc[n].homeTileY);
		}

		public static bool IsNPCEvictable(int n)
		{
			if (n < 0)
			{
				return false;
			}
			Rectangle hitbox = Main.LocalPlayer.Hitbox;
			hitbox.Inflate(Main.LogicCheckScreenWidth / 2, Main.LogicCheckScreenHeight / 2);
			NPC nPC = Main.npc[n];
			Rectangle value = new Rectangle(nPC.homeTileX * 16, nPC.homeTileY * 16, 16, 16);
			return hitbox.Intersects(value);
		}

		public static void kickOut(int n)
		{
			if (Main.netMode == 1)
			{
				NetMessage.SendData(60, -1, -1, null, n, 0f, 0f, 1f);
				return;
			}
			Main.npc[n].homeless = true;
			TownManager.KickOut(Main.npc[n]);
		}

		public static bool IsThereASpawnablePrioritizedTownNPC(int x, int y, bool canSpawnNewTownNPC)
		{
			if (CheckSpecialTownNPCSpawningConditions(prioritizedTownNPCType) && NPC.AnyNPCs(prioritizedTownNPCType))
			{
				canSpawnNewTownNPC = false;
				return true;
			}
			List<int> list = new List<int>();
			TownManager.AddOccupantsToList(x, y, list);
			for (int i = 0; i < list.Count; i++)
			{
				int num = list[i];
				if (Main.townNPCCanSpawn[num] && !NPC.AnyNPCs(num) && CheckSpecialTownNPCSpawningConditions(num))
				{
					prioritizedTownNPCType = num;
					canSpawnNewTownNPC = true;
					return true;
				}
			}
			for (int j = 0; j < 663; j++)
			{
				if (!Main.townNPCCanSpawn[j] || !CheckSpecialTownNPCSpawningConditions(j))
				{
					continue;
				}
				if (NPC.AnyNPCs(j))
				{
					Main.townNPCCanSpawn[j] = false;
					continue;
				}
				if (TownManager.HasRoomQuick(j))
				{
					prioritizedTownNPCType = j;
					canSpawnNewTownNPC = true;
					return true;
				}
				if (!NPCID.Sets.IsTownPet[prioritizedTownNPCType] || NPCID.Sets.IsTownPet[j])
				{
					prioritizedTownNPCType = j;
					canSpawnNewTownNPC = true;
					return true;
				}
			}
			return false;
		}

		public static bool IsThereASpawnablePrioritizedTownNPC_Old(int x, int y)
		{
			if (CheckSpecialTownNPCSpawningConditions(prioritizedTownNPCType) && NPC.AnyNPCs(prioritizedTownNPCType))
			{
				return true;
			}
			List<int> list = new List<int>();
			TownManager.AddOccupantsToList(x, y, list);
			for (int i = 0; i < list.Count; i++)
			{
				int num = list[i];
				if (Main.townNPCCanSpawn[num] && !NPC.AnyNPCs(num) && CheckSpecialTownNPCSpawningConditions(num))
				{
					prioritizedTownNPCType = num;
					return true;
				}
			}
			int num2 = -1;
			for (int j = 0; j < 663; j++)
			{
				if (!Main.townNPCCanSpawn[j] || !CheckSpecialTownNPCSpawningConditions(j))
				{
					continue;
				}
				if (NPC.AnyNPCs(j))
				{
					Main.townNPCCanSpawn[j] = false;
				}
				else if (TownManager.HasRoomQuick(j))
				{
					if (num2 == -1)
					{
						num2 = j;
					}
				}
				else if (!NPCID.Sets.IsTownPet[prioritizedTownNPCType] || NPCID.Sets.IsTownPet[j])
				{
					prioritizedTownNPCType = j;
					return true;
				}
			}
			if (num2 != -1)
			{
				prioritizedTownNPCType = num2;
				return true;
			}
			return false;
		}

		public static bool CheckSpecialTownNPCSpawningConditions(int type)
		{
			if (type == 160)
			{
				if ((double)roomY2 > Main.worldSurface)
				{
					return false;
				}
				int num = 0;
				int num2 = roomX1 - Main.buffScanAreaWidth / 2 / 16 - 1 - Lighting.OffScreenTiles;
				int num3 = roomX2 + Main.buffScanAreaWidth / 2 / 16 + 1 + Lighting.OffScreenTiles;
				int num4 = roomY1 - Main.buffScanAreaHeight / 2 / 16 - 1 - Lighting.OffScreenTiles;
				int num5 = roomY2 + Main.buffScanAreaHeight / 2 / 16 + 1 + Lighting.OffScreenTiles;
				if (num2 < 0)
				{
					num2 = 0;
				}
				if (num3 >= Main.maxTilesX)
				{
					num3 = Main.maxTilesX - 1;
				}
				if (num4 < 0)
				{
					num4 = 0;
				}
				if (num5 >= Main.maxTilesY)
				{
					num5 = Main.maxTilesY - 1;
				}
				for (int i = num2 + 1; i < num3; i++)
				{
					for (int j = num4 + 2; j < num5 + 2; j++)
					{
						Tile tile = Main.tile[i, j];
						if (tile.active() && (tile.type == 70 || tile.type == 71 || tile.type == 72 || tile.type == 528))
						{
							num++;
						}
					}
				}
				if (num >= SceneMetrics.MushroomTileThreshold)
				{
					return true;
				}
				return false;
			}
			return true;
		}

		public static void UnspawnTravelNPC()
		{
			int num = -1;
			for (int i = 0; i < 200; i++)
			{
				if (Main.npc[i].active && Main.npc[i].type == 368)
				{
					num = i;
					break;
				}
			}
			if (num < 0)
			{
				return;
			}
			int num2 = (int)(Main.npc[num].Center.X / 16f);
			int num3 = (int)(Main.npc[num].Center.Y / 16f);
			bool flag = true;
			Rectangle value = new Rectangle(num2 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, num3 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
			for (int j = 0; j < 255; j++)
			{
				if (Main.player[j].active && new Rectangle((int)Main.player[j].position.X, (int)Main.player[j].position.Y, Main.player[j].width, Main.player[j].height).Intersects(value))
				{
					flag = false;
					break;
				}
			}
			if (flag)
			{
				string fullName = Main.npc[num].FullName;
				if (Main.netMode == 0)
				{
					Main.NewText(Lang.misc[35].Format(fullName), 50, 125);
				}
				else if (Main.netMode == 2)
				{
					ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[35].Key, Main.npc[num].GetFullNetName()), new Color(50, 125, 255));
				}
				Main.npc[num].active = false;
				Main.npc[num].netSkip = -1;
				Main.npc[num].life = 0;
				NetMessage.SendData(23, -1, -1, null, num);
			}
		}

		public static void SpawnTravelNPC()
		{
			if (Main.eclipse || !Main.dayTime || (Main.invasionType > 0 && Main.invasionDelay == 0 && Main.invasionSize > 0))
			{
				return;
			}
			for (int i = 0; i < 200; i++)
			{
				if (Main.npc[i].active && Main.npc[i].type == 368)
				{
					return;
				}
			}
			Chest.SetupTravelShop();
			NetMessage.SendTravelShop(-1);
			int num = 0;
			int[] array = new int[200];
			int num2 = 0;
			for (int j = 0; j < 200; j++)
			{
				if (Main.npc[j].active && Main.npc[j].townNPC && Main.npc[j].type != 37 && !Main.npc[j].homeless)
				{
					array[num2] = j;
					num2++;
				}
			}
			if (num2 == 0)
			{
				return;
			}
			num = array[Main.rand.Next(num2)];
			bestX = Main.npc[num].homeTileX;
			bestY = Main.npc[num].homeTileY;
			int minValue = bestX;
			int num3 = bestX;
			int num4 = bestY;
			int num5 = bestX;
			while (num5 > bestX - 10 && (SolidTile(num5, num4) || Main.tileSolidTop[Main.tile[num5, num4].type]) && (!Main.tile[num5, num4 - 1].active() || !Main.tileSolid[Main.tile[num5, num4 - 1].type] || Main.tileSolidTop[Main.tile[num5, num4 - 1].type]) && (!Main.tile[num5, num4 - 2].active() || !Main.tileSolid[Main.tile[num5, num4 - 2].type] || Main.tileSolidTop[Main.tile[num5, num4 - 2].type]) && (!Main.tile[num5, num4 - 3].active() || !Main.tileSolid[Main.tile[num5, num4 - 3].type] || Main.tileSolidTop[Main.tile[num5, num4 - 3].type]))
			{
				minValue = num5;
				num5--;
			}
			for (int k = bestX; k < bestX + 10 && (SolidTile(k, num4) || Main.tileSolidTop[Main.tile[k, num4].type]) && (!Main.tile[k, num4 - 1].active() || !Main.tileSolid[Main.tile[k, num4 - 1].type] || Main.tileSolidTop[Main.tile[k, num4 - 1].type]) && (!Main.tile[k, num4 - 2].active() || !Main.tileSolid[Main.tile[k, num4 - 2].type] || Main.tileSolidTop[Main.tile[k, num4 - 2].type]) && (!Main.tile[k, num4 - 3].active() || !Main.tileSolid[Main.tile[k, num4 - 3].type] || Main.tileSolidTop[Main.tile[k, num4 - 3].type]); k++)
			{
				num3 = k;
			}
			for (int l = 0; l < 30; l++)
			{
				int num6 = Main.rand.Next(minValue, num3 + 1);
				if (l < 20)
				{
					if (num6 < bestX - 1 || num6 > bestX + 1)
					{
						bestX = num6;
						break;
					}
				}
				else if (num6 != bestX)
				{
					bestX = num6;
					break;
				}
			}
			int num7 = bestX;
			int num8 = bestY;
			bool flag = false;
			if (!flag && !((double)num8 > Main.worldSurface))
			{
				for (int m = 20; m < 500; m++)
				{
					for (int n = 0; n < 2; n++)
					{
						num7 = ((n != 0) ? (bestX - m * 2) : (bestX + m * 2));
						if (num7 > 10 && num7 < Main.maxTilesX - 10)
						{
							int num9 = bestY - m;
							double num10 = bestY + m;
							if (num9 < 10)
							{
								num9 = 10;
							}
							if (num10 > Main.worldSurface)
							{
								num10 = Main.worldSurface;
							}
							for (int num11 = num9; (double)num11 < num10; num11++)
							{
								num8 = num11;
								if (!Main.tile[num7, num8].nactive() || !Main.tileSolid[Main.tile[num7, num8].type])
								{
									continue;
								}
								if (Main.tile[num7, num8 - 3].liquid != 0 || Main.tile[num7, num8 - 2].liquid != 0 || Main.tile[num7, num8 - 1].liquid != 0 || Collision.SolidTiles(num7 - 1, num7 + 1, num8 - 3, num8 - 1))
								{
									break;
								}
								flag = true;
								Rectangle value = new Rectangle(num7 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, num8 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
								for (int num12 = 0; num12 < 255; num12++)
								{
									if (Main.player[num12].active && new Rectangle((int)Main.player[num12].position.X, (int)Main.player[num12].position.Y, Main.player[num12].width, Main.player[num12].height).Intersects(value))
									{
										flag = false;
										break;
									}
								}
								break;
							}
						}
						if (flag)
						{
							break;
						}
					}
					if (flag)
					{
						break;
					}
				}
			}
			int num13 = NPC.NewNPC(num7 * 16, num8 * 16, 368, 1);
			Main.npc[num13].homeTileX = bestX;
			Main.npc[num13].homeTileY = bestY;
			Main.npc[num13].homeless = true;
			if (num7 < bestX)
			{
				Main.npc[num13].direction = 1;
			}
			else if (num7 > bestX)
			{
				Main.npc[num13].direction = -1;
			}
			Main.npc[num13].netUpdate = true;
			string fullName = Main.npc[num13].FullName;
			if (Main.netMode == 0)
			{
				Main.NewText(Language.GetTextValue("Announcement.HasArrived", fullName), 50, 125);
			}
			else if (Main.netMode == 2)
			{
				ChatHelper.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasArrived", Main.npc[num13].GetFullNetName()), new Color(50, 125, 255));
			}
		}

		public static TownNPCSpawnResult SpawnTownNPC(int x, int y)
		{
			if (Main.wallHouse[Main.tile[x, y].wall])
			{
				canSpawn = true;
			}
			if (!canSpawn)
			{
				return TownNPCSpawnResult.Blocked;
			}
			if (!StartRoomCheck(x, y))
			{
				return TownNPCSpawnResult.Blocked;
			}
			if (!RoomNeeds(prioritizedTownNPCType))
			{
				return TownNPCSpawnResult.Blocked;
			}
			int num = FindAHomelessNPC();
			int type = prioritizedTownNPCType;
			if (num != -1)
			{
				type = Main.npc[num].type;
			}
			ScoreRoom(-1, type);
			if (hiScore <= 0)
			{
				return TownNPCSpawnResult.Blocked;
			}
			bool canSpawnNewTownNPC = true;
			if (!IsThereASpawnablePrioritizedTownNPC(bestX, bestY, canSpawnNewTownNPC))
			{
				return TownNPCSpawnResult.Blocked;
			}
			type = prioritizedTownNPCType;
			if (num != -1)
			{
				Main.townNPCCanSpawn[prioritizedTownNPCType] = false;
				Main.npc[num].homeTileX = bestX;
				Main.npc[num].homeTileY = bestY;
				Main.npc[num].homeless = false;
				AchievementsHelper.NotifyProgressionEvent(8);
				prioritizedTownNPCType = 0;
				return TownNPCSpawnResult.RelocatedHomeless;
			}
			if (canSpawnNewTownNPC && num == -1)
			{
				if (TownManager.HasRoom(type, out var roomPosition) && !currentlyTryingToUseAlternateHousingSpot)
				{
					int num2 = bestX;
					int num3 = bestY;
					currentlyTryingToUseAlternateHousingSpot = true;
					TownNPCSpawnResult townNPCSpawnResult = SpawnTownNPC(roomPosition.X, roomPosition.Y - 2);
					currentlyTryingToUseAlternateHousingSpot = false;
					bestX = num2;
					bestY = num3;
					if (townNPCSpawnResult == TownNPCSpawnResult.Successful)
					{
						return townNPCSpawnResult;
					}
				}
				int num4 = bestX;
				int num5 = bestY;
				int npcTypeToSpawn = prioritizedTownNPCType;
				if (IsRoomConsideredAlreadyOccupied(num4, num5, npcTypeToSpawn))
				{
					return TownNPCSpawnResult.BlockedInfiHousing;
				}
				bool flag = false;
				if (!flag)
				{
					flag = true;
					Rectangle value = new Rectangle(num4 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, num5 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
					for (int i = 0; i < 255; i++)
					{
						if (Main.player[i].active && new Rectangle((int)Main.player[i].position.X, (int)Main.player[i].position.Y, Main.player[i].width, Main.player[i].height).Intersects(value))
						{
							flag = false;
							break;
						}
					}
				}
				if (!flag && !((double)num5 > Main.worldSurface))
				{
					for (int j = 1; j < 500; j++)
					{
						for (int k = 0; k < 2; k++)
						{
							num4 = ((k != 0) ? (bestX - j) : (bestX + j));
							if (num4 > 10 && num4 < Main.maxTilesX - 10)
							{
								int num6 = bestY - j;
								double num7 = bestY + j;
								if (num6 < 10)
								{
									num6 = 10;
								}
								if (num7 > Main.worldSurface)
								{
									num7 = Main.worldSurface;
								}
								for (int l = num6; (double)l < num7; l++)
								{
									num5 = l;
									if (!Main.tile[num4, num5].nactive() || !Main.tileSolid[Main.tile[num4, num5].type])
									{
										continue;
									}
									if (Collision.SolidTiles(num4 - 1, num4 + 1, num5 - 3, num5 - 1))
									{
										break;
									}
									flag = true;
									Rectangle value2 = new Rectangle(num4 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, num5 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
									for (int m = 0; m < 255; m++)
									{
										if (Main.player[m].active && new Rectangle((int)Main.player[m].position.X, (int)Main.player[m].position.Y, Main.player[m].width, Main.player[m].height).Intersects(value2))
										{
											flag = false;
											break;
										}
									}
									break;
								}
							}
							if (flag)
							{
								break;
							}
						}
						if (flag)
						{
							break;
						}
					}
				}
				int num8 = NPC.NewNPC(num4 * 16, num5 * 16, type, 1);
				Main.townNPCCanSpawn[type] = false;
				Main.npc[num8].homeTileX = bestX;
				Main.npc[num8].homeTileY = bestY;
				if (num4 < bestX)
				{
					Main.npc[num8].direction = 1;
				}
				else if (num4 > bestX)
				{
					Main.npc[num8].direction = -1;
				}
				Main.npc[num8].netUpdate = true;
				string fullName = Main.npc[num8].FullName;
				if (Main.netMode == 0)
				{
					Main.NewText(Language.GetTextValue("Announcement.HasArrived", fullName), 50, 125);
				}
				else if (Main.netMode == 2)
				{
					ChatHelper.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasArrived", Main.npc[num8].GetFullNetName()), new Color(50, 125, 255));
				}
				AchievementsHelper.NotifyProgressionEvent(8);
				if (Main.npc[num8].type == 160)
				{
					AchievementsHelper.NotifyProgressionEvent(18);
				}
				CheckAchievement_RealEstate();
				prioritizedTownNPCType = 0;
			}
			return TownNPCSpawnResult.Successful;
		}

		private static int FindAHomelessNPC()
		{
			int result = -1;
			for (int i = 0; i < 200; i++)
			{
				if (Main.npc[i].active && Main.npc[i].homeless && Main.npc[i].type == prioritizedTownNPCType && CheckSpecialTownNPCSpawningConditions(Main.npc[i].type))
				{
					result = i;
					break;
				}
			}
			return result;
		}

		private static bool IsRoomConsideredAlreadyOccupied(int spawnTileX, int spawnTileY, int npcTypeToSpawn)
		{
			bool result = false;
			for (int i = 0; i < 200; i++)
			{
				NPC nPC = Main.npc[i];
				if (nPC.active && nPC.townNPC && !nPC.homeless && nPC.homeTileX == spawnTileX && nPC.homeTileY == spawnTileY && !TownManager.CanNPCsLiveWithEachOther(npcTypeToSpawn, nPC))
				{
					result = true;
					break;
				}
			}
			return result;
		}

		public static void CheckAchievement_RealEstate()
		{
			bool[] array = new bool[663];
			for (int i = 0; i < 200; i++)
			{
				if (Main.npc[i].active && Main.npc[i].type >= 0 && Main.npc[i].type < 663)
				{
					array[Main.npc[i].type] = true;
				}
			}
			if (array[38] && array[17] && array[107] && array[19] && array[22] && array[124] && array[228] && array[178] && array[18] && array[229] && array[209] && array[54] && array[108] && array[160] && array[20] && array[369] && array[207] && array[227] && array[208] && array[441] && array[353] && array[588] && array[633])
			{
				AchievementsHelper.NotifyProgressionEvent(17);
			}
		}

		public static bool RoomNeeds(int npcType)
		{
			roomChair = false;
			roomDoor = false;
			roomTable = false;
			roomTorch = false;
			for (int i = 0; i < TileID.Sets.RoomNeeds.CountsAsChair.Length; i++)
			{
				if (houseTile[TileID.Sets.RoomNeeds.CountsAsChair[i]])
				{
					roomChair = true;
					break;
				}
			}
			for (int j = 0; j < TileID.Sets.RoomNeeds.CountsAsTable.Length; j++)
			{
				if (houseTile[TileID.Sets.RoomNeeds.CountsAsTable[j]])
				{
					roomTable = true;
					break;
				}
			}
			for (int k = 0; k < TileID.Sets.RoomNeeds.CountsAsTorch.Length; k++)
			{
				if (houseTile[TileID.Sets.RoomNeeds.CountsAsTorch[k]])
				{
					roomTorch = true;
					break;
				}
			}
			for (int l = 0; l < TileID.Sets.RoomNeeds.CountsAsDoor.Length; l++)
			{
				if (houseTile[TileID.Sets.RoomNeeds.CountsAsDoor[l]])
				{
					roomDoor = true;
					break;
				}
			}
			if (roomChair && roomTable && roomDoor && roomTorch)
			{
				canSpawn = true;
			}
			else
			{
				canSpawn = false;
			}
			return canSpawn;
		}

		public static void QuickFindHome(int npc)
		{
			bool flag = Main.tileSolid[379];
			Main.tileSolid[379] = true;
			if (Main.npc[npc].homeTileX > 10 && Main.npc[npc].homeTileY > 10 && Main.npc[npc].homeTileX < Main.maxTilesX - 10 && Main.npc[npc].homeTileY < Main.maxTilesY)
			{
				canSpawn = false;
				StartRoomCheck(Main.npc[npc].homeTileX, Main.npc[npc].homeTileY - 1);
				if (!canSpawn)
				{
					for (int i = Main.npc[npc].homeTileX - 1; i < Main.npc[npc].homeTileX + 2; i++)
					{
						for (int j = Main.npc[npc].homeTileY - 1; j < Main.npc[npc].homeTileY + 2 && !StartRoomCheck(i, j); j++)
						{
						}
					}
				}
				if (!canSpawn)
				{
					int num = 10;
					for (int k = Main.npc[npc].homeTileX - num; k <= Main.npc[npc].homeTileX + num; k += 2)
					{
						for (int l = Main.npc[npc].homeTileY - num; l <= Main.npc[npc].homeTileY + num && !StartRoomCheck(k, l); l += 2)
						{
						}
					}
				}
				if (canSpawn)
				{
					RoomNeeds(Main.npc[npc].type);
					if (canSpawn)
					{
						ScoreRoom(npc, Main.npc[npc].type);
					}
					if (canSpawn && hiScore > 0)
					{
						canSpawn = IsRoomConsideredOccupiedForNPCIndex(npc);
					}
					if (canSpawn && hiScore > 0)
					{
						Main.npc[npc].homeTileX = bestX;
						Main.npc[npc].homeTileY = bestY;
						Main.npc[npc].homeless = false;
						AchievementsHelper.NotifyProgressionEvent(8);
						canSpawn = false;
					}
					else
					{
						Main.npc[npc].homeless = true;
					}
				}
				else
				{
					Main.npc[npc].homeless = true;
				}
			}
			Main.tileSolid[379] = flag;
		}

		private static bool IsRoomConsideredOccupiedForNPCIndex(int npc)
		{
			bool result = true;
			for (int i = 0; i < 200; i++)
			{
				if (i != npc)
				{
					NPC nPC = Main.npc[i];
					if (nPC.active && nPC.townNPC && !nPC.homeless && nPC.homeTileX == bestX && nPC.homeTileY == bestY && !TownManager.CanNPCsLiveWithEachOther(Main.npc[npc], nPC))
					{
						result = false;
						break;
					}
				}
			}
			return result;
		}

		private static bool ScoreRoom_IsThisRoomOccupiedBySomeone(int ignoreNPC = -1, int npcTypeAsking = -1)
		{
			for (int i = 0; i < 200; i++)
			{
				if (!Main.npc[i].active || !Main.npc[i].townNPC || ignoreNPC == i || Main.npc[i].homeless)
				{
					continue;
				}
				for (int j = 0; j < numRoomTiles; j++)
				{
					if (Main.npc[i].homeTileX != roomX[j] || Main.npc[i].homeTileY != roomY[j])
					{
						continue;
					}
					bool flag = false;
					for (int k = 0; k < numRoomTiles; k++)
					{
						if (Main.npc[i].homeTileX == roomX[k] && Main.npc[i].homeTileY - 1 == roomY[k])
						{
							if (!TownManager.CanNPCsLiveWithEachOther(npcTypeAsking, Main.npc[i]))
							{
								flag = true;
								break;
							}
							sharedRoomX = Main.npc[i].homeTileX;
						}
					}
					if (flag)
					{
						return true;
					}
				}
			}
			return false;
		}

		public static void CountTileTypesInArea(int[] tileTypeCounts, int startX, int endX, int startY, int endY)
		{
			for (int i = startX; i <= endX; i++)
			{
				for (int j = startY; j <= endY; j++)
				{
					if (Main.tile[i, j].active())
					{
						tileTypeCounts[Main.tile[i, j].type]++;
					}
				}
			}
		}

		public static int GetTileTypeCountByCategory(int[] tileTypeCounts, TileScanGroup group)
		{
			switch (group)
			{
			case TileScanGroup.None:
				return 0;
			case TileScanGroup.Corruption:
				return tileTypeCounts[23] + tileTypeCounts[24] + tileTypeCounts[25] + tileTypeCounts[32] + tileTypeCounts[112] + tileTypeCounts[163] + tileTypeCounts[400] + tileTypeCounts[398] + -5 * tileTypeCounts[27];
			case TileScanGroup.Crimson:
				return tileTypeCounts[199] + tileTypeCounts[203] + tileTypeCounts[200] + tileTypeCounts[401] + tileTypeCounts[399] + tileTypeCounts[234] + tileTypeCounts[352] - 5 * tileTypeCounts[27];
			case TileScanGroup.Hallow:
				return tileTypeCounts[109] + tileTypeCounts[110] + tileTypeCounts[113] + tileTypeCounts[117] + tileTypeCounts[116] + tileTypeCounts[164] + tileTypeCounts[403] + tileTypeCounts[402];
			case TileScanGroup.TotalGoodEvil:
			{
				int tileTypeCountByCategory = GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.Hallow);
				int tileTypeCountByCategory2 = GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.Corruption);
				int tileTypeCountByCategory3 = GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.Crimson);
				int num = 5 * tileTypeCounts[27];
				int num2 = tileTypeCountByCategory2 + tileTypeCountByCategory3 + num;
				return tileTypeCountByCategory - num2;
			}
			default:
				return 0;
			}
		}

		public static void ScoreRoom(int ignoreNPC = -1, int npcTypeAskingToScoreRoom = -1)
		{
			roomOccupied = false;
			roomEvil = false;
			sharedRoomX = -1;
			if (ScoreRoom_IsThisRoomOccupiedBySomeone(ignoreNPC, npcTypeAskingToScoreRoom))
			{
				roomOccupied = true;
				hiScore = -1;
				return;
			}
			hiScore = 0;
			int num = 0;
			int num2 = 50;
			int num3 = 40;
			int num4 = roomX1 - Main.buffScanAreaWidth / 2 / 16 - 1 - num3;
			int num5 = roomX2 + Main.buffScanAreaWidth / 2 / 16 + 1 + num3;
			int num6 = roomY1 - Main.buffScanAreaHeight / 2 / 16 - 1 - num3;
			int num7 = roomY2 + Main.buffScanAreaHeight / 2 / 16 + 1 + num3;
			if (num4 < 5)
			{
				num4 = 5;
			}
			if (num5 >= Main.maxTilesX - 5)
			{
				num5 = Main.maxTilesX - 6;
			}
			if (num6 < 5)
			{
				num6 = 5;
			}
			if (num7 >= Main.maxTilesY - 5)
			{
				num7 = Main.maxTilesY - 6;
			}
			int[] tileTypeCounts = new int[623];
			CountTileTypesInArea(tileTypeCounts, num4 + 1, num5 - 1, num6 + 2, num7 + 1);
			int num8 = -GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.TotalGoodEvil);
			if (num8 < 50)
			{
				num8 = 0;
			}
			num2 -= num8;
			if (num2 <= -250)
			{
				hiScore = num2;
				roomEvil = true;
				return;
			}
			num4 = roomX1;
			num5 = roomX2;
			num6 = roomY1;
			num7 = roomY2;
			for (int i = num4 + 1; i < num5; i++)
			{
				for (int j = num6 + 2; j < num7 + 2; j++)
				{
					if (!Main.tile[i, j].nactive() || !ScoreRoom_CanBeHomeSpot(i, j))
					{
						continue;
					}
					num = num2;
					if (!Main.tileSolid[Main.tile[i, j].type] || Main.tileSolidTop[Main.tile[i, j].type] || Collision.SolidTiles(i - 1, i + 1, j - 3, j - 1) || !Main.tile[i - 1, j].nactive() || !Main.tileSolid[Main.tile[i - 1, j].type] || !Main.tile[i + 1, j].nactive() || !Main.tileSolid[Main.tile[i + 1, j].type])
					{
						continue;
					}
					int num9 = 0;
					int num10 = 0;
					for (int k = i - 2; k < i + 3; k++)
					{
						for (int l = j - 4; l < j; l++)
						{
							Tile tile = Main.tile[k, l];
							if (tile.nactive() && !TileID.Sets.IgnoredInHouseScore[tile.type])
							{
								if (k == i)
								{
									num9++;
								}
								else if (TileID.Sets.BasicChest[tile.type])
								{
									num10++;
								}
								else
								{
									num = ((tile.type != 10 && tile.type != 388) ? ((!IsOpenDoorAnchorFrame(k, l)) ? ((!Main.tileSolid[tile.type]) ? (num + 5) : (num - 5)) : (num - 20)) : (num - 20));
								}
							}
						}
					}
					if (sharedRoomX >= 0 && num >= 1 && Math.Abs(sharedRoomX - i) < 3)
					{
						num = 1;
					}
					if (num > 0 && num10 > 0)
					{
						num -= 30 * num10;
						if (num < 1)
						{
							num = 1;
						}
					}
					if (num > 0 && num9 > 0)
					{
						num -= 15 * num9;
						if (num <= 0)
						{
							num = 0;
						}
					}
					if (num <= hiScore)
					{
						continue;
					}
					bool flag = Housing_CheckIfInRoom(i, j);
					bool[] array = new bool[3];
					for (int m = 1; m <= 3; m++)
					{
						if (!Main.tile[i, j - m].active() || !Main.tileSolid[Main.tile[i, j - m].type])
						{
							array[m - 1] = true;
						}
						if (!Housing_CheckIfInRoom(i, j - m))
						{
							array[m - 1] = false;
						}
					}
					bool[] array2 = array;
					for (int n = 0; n < array2.Length; n++)
					{
						if (!array2[n])
						{
							flag = false;
							break;
						}
					}
					if (flag && !Housing_CheckIfIsCeiling(i, j))
					{
						hiScore = num;
						bestX = i;
						bestY = j;
					}
				}
			}
		}

		private static bool ScoreRoom_CanBeHomeSpot(int x, int y)
		{
			Tile tile = Main.tile[x, y];
			if (tile.active())
			{
				ushort type = tile.type;
				if (type == 379)
				{
					return false;
				}
			}
			return true;
		}

		private static bool Housing_CheckIfIsCeiling(int i, int j)
		{
			bool result = false;
			for (int k = 0; k < roomCeilingsCount; k++)
			{
				if (roomCeilingX[k] == i)
				{
					if (roomCeilingY[k] == j)
					{
						result = true;
					}
					break;
				}
			}
			return result;
		}

		private static bool Housing_CheckIfInRoom(int i, int j)
		{
			bool result = false;
			for (int k = 0; k < numRoomTiles; k++)
			{
				if (roomX[k] == i && roomY[k] == j)
				{
					result = true;
					break;
				}
			}
			return result;
		}

		public static bool StartRoomCheck(int x, int y)
		{
			roomX1 = x;
			roomX2 = x;
			roomY1 = y;
			roomY2 = y;
			numRoomTiles = 0;
			roomCeilingsCount = 0;
			for (int i = 0; i < 623; i++)
			{
				houseTile[i] = false;
			}
			canSpawn = true;
			if (Main.tile[x, y].nactive() && Main.tileSolid[Main.tile[x, y].type])
			{
				roomCheckFailureReason = TownNPCRoomCheckFailureReason.RoomCheckStartedInASolidTile;
				canSpawn = false;
				return false;
			}
			roomCheckFailureReason = TownNPCRoomCheckFailureReason.None;
			CheckRoom(x, y);
			if (!canSpawn)
			{
				return false;
			}
			if (numRoomTiles < 60)
			{
				roomCheckFailureReason = TownNPCRoomCheckFailureReason.RoomIsTooSmall;
				canSpawn = false;
				return false;
			}
			if (canSpawn)
			{
				return true;
			}
			return false;
		}

		public static void CheckRoom(int x, int y)
		{
			if (!canSpawn)
			{
				return;
			}
			if (x < 10 || y < 10 || x >= Main.maxTilesX - 10 || y >= lastMaxTilesY - 10)
			{
				roomCheckFailureReason = TownNPCRoomCheckFailureReason.TooCloseToWorldEdge;
				canSpawn = false;
				return;
			}
			for (int i = 0; i < numRoomTiles; i++)
			{
				if (roomX[i] == x && roomY[i] == y)
				{
					return;
				}
			}
			roomX[numRoomTiles] = x;
			roomY[numRoomTiles] = y;
			bool flag = false;
			for (int j = 0; j < roomCeilingsCount; j++)
			{
				if (roomCeilingX[j] == x)
				{
					flag = true;
					if (roomCeilingY[j] > y)
					{
						roomCeilingY[j] = y;
					}
					break;
				}
			}
			if (!flag)
			{
				roomCeilingX[roomCeilingsCount] = x;
				roomCeilingY[roomCeilingsCount] = y;
				roomCeilingsCount++;
			}
			numRoomTiles++;
			if (numRoomTiles >= maxRoomTiles)
			{
				roomCheckFailureReason = TownNPCRoomCheckFailureReason.RoomIsTooBig;
				canSpawn = false;
				return;
			}
			if (Main.tile[x, y].nactive())
			{
				houseTile[Main.tile[x, y].type] = true;
				if (Main.tileSolid[Main.tile[x, y].type] || (Main.tile[x, y].type == 11 && (Main.tile[x, y].frameX == 0 || Main.tile[x, y].frameX == 54 || Main.tile[x, y].frameX == 72 || Main.tile[x, y].frameX == 126)) || Main.tile[x, y].type == 389 || (Main.tile[x, y].type == 386 && ((Main.tile[x, y].frameX < 36 && Main.tile[x, y].frameY == 18) || (Main.tile[x, y].frameX >= 36 && Main.tile[x, y].frameY == 0))))
				{
					return;
				}
			}
			if (x < roomX1)
			{
				roomX1 = x;
			}
			if (x > roomX2)
			{
				roomX2 = x;
			}
			if (y < roomY1)
			{
				roomY1 = y;
			}
			if (y > roomY2)
			{
				roomY2 = y;
			}
			bool flag2 = false;
			bool flag3 = false;
			for (int k = -2; k < 3; k++)
			{
				if (Main.wallHouse[Main.tile[x + k, y].wall])
				{
					flag2 = true;
				}
				if (Main.tile[x + k, y].nactive() && (Main.tileSolid[Main.tile[x + k, y].type] || TileID.Sets.HousingWalls[Main.tile[x + k, y].type]))
				{
					flag2 = true;
				}
				if (Main.wallHouse[Main.tile[x, y + k].wall])
				{
					flag3 = true;
				}
				if (Main.tile[x, y + k].nactive() && (Main.tileSolid[Main.tile[x, y + k].type] || TileID.Sets.HousingWalls[Main.tile[x, y + k].type]))
				{
					flag3 = true;
				}
			}
			if (!flag2 || !flag3)
			{
				roomCheckFailureReason = TownNPCRoomCheckFailureReason.HoleInWallIsTooBig;
				canSpawn = false;
				return;
			}
			for (int l = x - 1; l < x + 2; l++)
			{
				for (int m = y - 1; m < y + 2; m++)
				{
					if ((l != x || m != y) && canSpawn)
					{
						CheckRoom(l, m);
					}
				}
			}
		}

		public static void dropMeteor()
		{
			bool flag = true;
			if (Main.netMode == 1)
			{
				return;
			}
			for (int i = 0; i < 255; i++)
			{
				if (Main.player[i].active)
				{
					flag = false;
					break;
				}
			}
			int num = 0;
			float num2 = Main.maxTilesX / 4200;
			int num3 = (int)(400f * num2);
			for (int j = 5; j < Main.maxTilesX - 5; j++)
			{
				for (int k = 5; (double)k < Main.worldSurface; k++)
				{
					if (Main.tile[j, k].active() && Main.tile[j, k].type == 37)
					{
						num++;
						if (num > num3)
						{
							return;
						}
					}
				}
			}
			float num4 = 600f;
			while (!flag)
			{
				float num5 = (float)Main.maxTilesX * 0.08f;
				int num6 = Main.rand.Next(150, Main.maxTilesX - 150);
				while ((float)num6 > (float)Main.spawnTileX - num5 && (float)num6 < (float)Main.spawnTileX + num5)
				{
					num6 = Main.rand.Next(150, Main.maxTilesX - 150);
				}
				for (int l = (int)(Main.worldSurface * 0.3); l < Main.maxTilesY; l++)
				{
					if (!Main.tile[num6, l].active() || !Main.tileSolid[Main.tile[num6, l].type] || TileID.Sets.Platforms[Main.tile[num6, l].type])
					{
						continue;
					}
					int num7 = 0;
					int num8 = 15;
					for (int m = num6 - num8; m < num6 + num8; m++)
					{
						for (int n = l - num8; n < l + num8; n++)
						{
							if (SolidTile(m, n))
							{
								num7++;
								if (Main.tile[m, n].type == 189 || Main.tile[m, n].type == 202)
								{
									num7 -= 100;
								}
							}
							else if (Main.tile[m, n].liquid > 0)
							{
								num7--;
							}
						}
					}
					if ((float)num7 >= num4)
					{
						flag = meteor(num6, l);
						if (!flag)
						{
						}
					}
					else
					{
						num4 -= 0.5f;
					}
					break;
				}
				if (num4 < 100f)
				{
					break;
				}
			}
		}

		public static bool meteor(int i, int j, bool ignorePlayers = false)
		{
			if (i < 50 || i > Main.maxTilesX - 50)
			{
				return false;
			}
			if (j < 50 || j > Main.maxTilesY - 50)
			{
				return false;
			}
			int num = 35;
			Rectangle rectangle = new Rectangle((i - num) * 16, (j - num) * 16, num * 2 * 16, num * 2 * 16);
			for (int k = 0; k < 255; k++)
			{
				if (Main.player[k].active && !ignorePlayers)
				{
					Rectangle value = new Rectangle((int)(Main.player[k].position.X + (float)(Main.player[k].width / 2) - (float)(NPC.sWidth / 2) - (float)NPC.safeRangeX), (int)(Main.player[k].position.Y + (float)(Main.player[k].height / 2) - (float)(NPC.sHeight / 2) - (float)NPC.safeRangeY), NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
					if (rectangle.Intersects(value))
					{
						return false;
					}
				}
			}
			for (int l = 0; l < 200; l++)
			{
				if (Main.npc[l].active)
				{
					Rectangle value2 = new Rectangle((int)Main.npc[l].position.X, (int)Main.npc[l].position.Y, Main.npc[l].width, Main.npc[l].height);
					if (rectangle.Intersects(value2))
					{
						return false;
					}
				}
			}
			for (int m = i - num; m < i + num; m++)
			{
				for (int n = j - num; n < j + num; n++)
				{
					if (Main.tile[m, n].active())
					{
						if (TileID.Sets.BasicChest[Main.tile[m, n].type] || Main.tileDungeon[Main.tile[m, n].type])
						{
							return false;
						}
						switch (Main.tile[m, n].type)
						{
						case 226:
						case 470:
						case 475:
						case 488:
						case 597:
							return false;
						}
					}
				}
			}
			stopDrops = true;
			num = genRand.Next(17, 23);
			for (int num2 = i - num; num2 < i + num; num2++)
			{
				for (int num3 = j - num; num3 < j + num; num3++)
				{
					if (num3 <= j + Main.rand.Next(-2, 3) - 5)
					{
						continue;
					}
					float num4 = Math.Abs(i - num2);
					float num5 = Math.Abs(j - num3);
					if ((double)(float)Math.Sqrt(num4 * num4 + num5 * num5) < (double)num * 0.9 + (double)Main.rand.Next(-4, 5))
					{
						if (!Main.tileSolid[Main.tile[num2, num3].type])
						{
							Main.tile[num2, num3].active(active: false);
						}
						Main.tile[num2, num3].type = 37;
					}
				}
			}
			num = genRand.Next(8, 14);
			for (int num6 = i - num; num6 < i + num; num6++)
			{
				for (int num7 = j - num; num7 < j + num; num7++)
				{
					if (num7 > j + Main.rand.Next(-2, 3) - 4)
					{
						float num8 = Math.Abs(i - num6);
						float num9 = Math.Abs(j - num7);
						if ((double)(float)Math.Sqrt(num8 * num8 + num9 * num9) < (double)num * 0.8 + (double)Main.rand.Next(-3, 4))
						{
							Main.tile[num6, num7].active(active: false);
						}
					}
				}
			}
			num = genRand.Next(25, 35);
			for (int num10 = i - num; num10 < i + num; num10++)
			{
				for (int num11 = j - num; num11 < j + num; num11++)
				{
					float num12 = Math.Abs(i - num10);
					float num13 = Math.Abs(j - num11);
					if ((double)(float)Math.Sqrt(num12 * num12 + num13 * num13) < (double)num * 0.7)
					{
						if (TileID.Sets.GetsDestroyedForMeteors[Main.tile[num10, num11].type])
						{
							KillTile(num10, num11);
						}
						Main.tile[num10, num11].liquid = 0;
					}
					if (Main.tile[num10, num11].type == 37)
					{
						if (!SolidTile(num10 - 1, num11) && !SolidTile(num10 + 1, num11) && !SolidTile(num10, num11 - 1) && !SolidTile(num10, num11 + 1))
						{
							Main.tile[num10, num11].active(active: false);
						}
						else if ((Main.tile[num10, num11].halfBrick() || Main.tile[num10 - 1, num11].topSlope()) && !SolidTile(num10, num11 + 1))
						{
							Main.tile[num10, num11].active(active: false);
						}
					}
					SquareTileFrame(num10, num11);
					SquareWallFrame(num10, num11);
				}
			}
			num = genRand.Next(23, 32);
			for (int num14 = i - num; num14 < i + num; num14++)
			{
				for (int num15 = j - num; num15 < j + num; num15++)
				{
					if (num15 <= j + genRand.Next(-3, 4) - 3 || !Main.tile[num14, num15].active() || Main.rand.Next(10) != 0)
					{
						continue;
					}
					float num16 = Math.Abs(i - num14);
					float num17 = Math.Abs(j - num15);
					if ((double)(float)Math.Sqrt(num16 * num16 + num17 * num17) < (double)num * 0.8)
					{
						if (TileID.Sets.GetsDestroyedForMeteors[Main.tile[num14, num15].type])
						{
							KillTile(num14, num15);
						}
						Main.tile[num14, num15].type = 37;
						SquareTileFrame(num14, num15);
					}
				}
			}
			num = genRand.Next(30, 38);
			for (int num18 = i - num; num18 < i + num; num18++)
			{
				for (int num19 = j - num; num19 < j + num; num19++)
				{
					if (num19 <= j + genRand.Next(-2, 3) || !Main.tile[num18, num19].active() || Main.rand.Next(20) != 0)
					{
						continue;
					}
					float num20 = Math.Abs(i - num18);
					float num21 = Math.Abs(j - num19);
					if ((double)(float)Math.Sqrt(num20 * num20 + num21 * num21) < (double)num * 0.85)
					{
						if (TileID.Sets.GetsDestroyedForMeteors[Main.tile[num18, num19].type])
						{
							KillTile(num18, num19);
						}
						Main.tile[num18, num19].type = 37;
						SquareTileFrame(num18, num19);
					}
				}
			}
			stopDrops = false;
			if (Main.netMode == 0)
			{
				Main.NewText(Lang.gen[59].Value, 50, byte.MaxValue, 130);
			}
			else if (Main.netMode == 2)
			{
				ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.gen[59].Key), new Color(50, 255, 130));
			}
			if (Main.netMode != 1)
			{
				NetMessage.SendTileSquare(-1, i, j, 40);
			}
			return true;
		}

		public static void setWorldSize()
		{
			Main.bottomWorld = Main.maxTilesY * 16;
			Main.rightWorld = Main.maxTilesX * 16;
			Main.maxSectionsX = Main.maxTilesX / 200;
			Main.maxSectionsY = Main.maxTilesY / 150;
		}

		public static void worldGenCallback(object threadContext)
		{
			SoundEngine.PlaySound(10);
			clearWorld();
			GenerateWorld(Main.ActiveWorldFileData.Seed, threadContext as GenerationProgress);
			WorldFile.SaveWorld(Main.ActiveWorldFileData.IsCloudSave, resetTime: true);
			if (Main.menuMode == 10 || Main.menuMode == 888)
			{
				Main.menuMode = 6;
			}
			SoundEngine.PlaySound(10);
			generatingWorld = false;
		}

		public static Task CreateNewWorld(GenerationProgress progress = null)
		{
			generatingWorld = true;
			Main.rand = new UnifiedRandom(Main.ActiveWorldFileData.Seed);
			gen = true;
			Main.menuMode = 888;
			try
			{
				Main.MenuUI.SetState(new UIWorldLoad());
			}
			catch
			{
			}
			return Task.Factory.StartNew(worldGenCallback, progress);
		}

		public static void JustQuit()
		{
			try
			{
				SoundEngine.PlaySound(34, -1, -1, 0);
				SoundEngine.PlaySound(35, -1, -1, 0);
			}
			catch
			{
			}
			Main.invasionProgress = -1;
			Main.invasionProgressDisplayLeft = 0;
			Main.invasionProgressAlpha = 0f;
			Main.invasionProgressIcon = 0;
			Main.menuMode = 10;
			Main.gameMenu = true;
			SoundEngine.StopTrackedSounds();
			CaptureInterface.ResetFocus();
			Main.ActivePlayerFileData.StopPlayTimer();
			Main.fastForwardTime = false;
			Main.UpdateTimeRate();
			if (Main.netMode == 0)
			{
				Main.GoToWorldSelect();
				Main.player[Main.myPlayer].position = new Vector2(0f, 0f);
			}
			else if (Main.netMode == 1)
			{
				Main.menuMode = 0;
				Netplay.Disconnect = true;
				Main.netMode = 0;
			}
		}

		public static void SaveAndQuitCallBack(object threadContext)
		{
			int netMode = Main.netMode;
			try
			{
				SoundEngine.PlaySound(34, -1, -1, 0);
				SoundEngine.PlaySound(35, -1, -1, 0);
			}
			catch
			{
			}
			if (netMode == 0)
			{
				WorldFile.CacheSaveTime();
			}
			Main.invasionProgress = -1;
			Main.invasionProgressDisplayLeft = 0;
			Main.invasionProgressAlpha = 0f;
			Main.invasionProgressIcon = 0;
			Main.menuMode = 10;
			Main.gameMenu = true;
			SoundEngine.StopTrackedSounds();
			CaptureInterface.ResetFocus();
			Main.ActivePlayerFileData.StopPlayTimer();
			Player.SavePlayer(Main.ActivePlayerFileData);
			Player.ClearPlayerTempInfo();
			Rain.ClearRain();
			if (netMode == 0)
			{
				WorldFile.SaveWorld();
				SoundEngine.PlaySound(10);
			}
			else
			{
				Netplay.Disconnect = true;
				Main.netMode = 0;
			}
			Main.fastForwardTime = false;
			Main.UpdateTimeRate();
			Main.menuMode = 0;
			if (threadContext != null)
			{
				((Action)threadContext)();
			}
		}

		public static void SaveAndQuit(Action callback = null)
		{
			SoundEngine.PlaySound(11);
			ThreadPool.QueueUserWorkItem(SaveAndQuitCallBack, callback);
		}

		public static void playWorldCallBack(object threadContext)
		{
			if (Main.rand == null)
			{
				Main.rand = new UnifiedRandom((int)DateTime.Now.Ticks);
			}
			for (int i = 0; i < 255; i++)
			{
				if (i != Main.myPlayer)
				{
					Main.player[i].active = false;
				}
			}
			noMapUpdate = true;
			WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
			if (loadFailed || !loadSuccess)
			{
				WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
				if (loadFailed || !loadSuccess)
				{
					bool isCloudSave = Main.ActiveWorldFileData.IsCloudSave;
					if (FileUtilities.Exists(Main.worldPathName + ".bak", isCloudSave))
					{
						worldBackup = true;
					}
					else
					{
						worldBackup = false;
					}
					if (!Main.dedServ)
					{
						if (worldBackup)
						{
							Main.menuMode = 200;
						}
						else
						{
							Main.menuMode = 201;
						}
						return;
					}
					if (!worldBackup)
					{
						Console.WriteLine(Language.GetTextValue("Error.LoadFailedNoBackup"));
						return;
					}
					FileUtilities.Copy(Main.worldPathName, Main.worldPathName + ".bad", isCloudSave);
					FileUtilities.Copy(Main.worldPathName + ".bak", Main.worldPathName, isCloudSave);
					FileUtilities.Delete(Main.worldPathName + ".bak", isCloudSave);
					WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
					if (loadFailed || !loadSuccess)
					{
						WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
						if (loadFailed || !loadSuccess)
						{
							FileUtilities.Copy(Main.worldPathName, Main.worldPathName + ".bak", isCloudSave);
							FileUtilities.Copy(Main.worldPathName + ".bad", Main.worldPathName, isCloudSave);
							FileUtilities.Delete(Main.worldPathName + ".bad", isCloudSave);
							Console.WriteLine(Language.GetTextValue("Error.LoadFailed"));
							return;
						}
					}
				}
			}
			if (Main.mapEnabled)
			{
				Main.Map.Load();
			}
			if (Main.netMode != 2)
			{
				Main.sectionManager.SetAllFramesLoaded();
			}
			while (Main.loadMapLock)
			{
				float num = (float)Main.loadMapLastX / (float)Main.maxTilesX;
				Main.statusText = Lang.gen[68].Value + " " + (int)(num * 100f + 1f) + "%";
				Thread.Sleep(0);
				if (!Main.mapEnabled)
				{
					break;
				}
			}
			if (Main.gameMenu)
			{
				Main.gameMenu = false;
			}
			if (Main.netMode == 0 && Main.anglerWhoFinishedToday.Contains(Main.player[Main.myPlayer].name))
			{
				Main.anglerQuestFinished = true;
			}
			Main.player[Main.myPlayer].Spawn(PlayerSpawnContext.SpawningIntoWorld);
			Main.ActivePlayerFileData.StartPlayTimer();
			_lastSeed = Main.ActiveWorldFileData.Seed;
			Player.Hooks.EnterWorld(Main.myPlayer);
			WorldFile.SetOngoingToTemps();
			SoundEngine.PlaySound(11);
			Main.resetClouds = true;
			noMapUpdate = false;
		}

		public static void playWorld()
		{
			ThreadPool.QueueUserWorkItem(playWorldCallBack, 1);
		}

		public static void saveAndPlayCallBack(object threadContext)
		{
			WorldFile.SaveWorld();
		}

		public static void saveAndPlay()
		{
			ThreadPool.QueueUserWorkItem(saveAndPlayCallBack, 1);
		}

		public static void saveToonWhilePlayingCallBack(object threadContext)
		{
			Player.SavePlayer(Main.ActivePlayerFileData);
		}

		public static void saveToonWhilePlaying()
		{
			ThreadPool.QueueUserWorkItem(saveToonWhilePlayingCallBack, 1);
		}

		public static void serverLoadWorldCallBack()
		{
			Main.rand = new UnifiedRandom((int)DateTime.Now.Ticks);
			WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
			if (loadFailed || !loadSuccess)
			{
				WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
				if (loadFailed || !loadSuccess)
				{
					bool isCloudSave = Main.ActiveWorldFileData.IsCloudSave;
					if (FileUtilities.Exists(Main.worldPathName + ".bak", isCloudSave))
					{
						worldBackup = true;
					}
					else
					{
						worldBackup = false;
					}
					if (!Main.dedServ)
					{
						if (worldBackup)
						{
							Main.menuMode = 200;
						}
						else
						{
							Main.menuMode = 201;
						}
						return;
					}
					if (!worldBackup)
					{
						Console.WriteLine(Language.GetTextValue("Error.LoadFailedNoBackup"));
						return;
					}
					FileUtilities.Copy(Main.worldPathName + ".bak", Main.worldPathName, isCloudSave);
					FileUtilities.Delete(Main.worldPathName + ".bak", isCloudSave);
					WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
					if (loadFailed || !loadSuccess)
					{
						WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
						if (loadFailed || !loadSuccess)
						{
							Console.WriteLine(Language.GetTextValue("Error.LoadFailed"));
							return;
						}
					}
				}
			}
			_lastSeed = Main.ActiveWorldFileData.Seed;
			SoundEngine.PlaySound(10);
			WorldFile.SetOngoingToTemps();
			Hooks.WorldLoaded();
		}

		public static Task serverLoadWorld()
		{
			return Task.Factory.StartNew(serverLoadWorldCallBack);
		}

		public static void clearWorld()
		{
			Main.getGoodWorld = false;
			Main.drunkWorld = false;
			NPC.ResetBadgerHatTime();
			NPC.freeCake = false;
			Main.mapDelay = 2;
			Main.ResetWindCounter(resetExtreme: true);
			TownManager = new TownRoomManager();
			Hooks.ClearWorld();
			TileEntity.Clear();
			Main.checkXMas();
			Main.checkHalloween();
			if (Main.mapReady)
			{
				for (int i = 0; i < lastMaxTilesX; i++)
				{
					_ = (float)i / (float)lastMaxTilesX;
					Main.statusText = Lang.gen[65].Value;
				}
				Main.Map.Clear();
			}
			NPC.MoonLordCountdown = 0;
			Main.forceHalloweenForToday = false;
			Main.forceXMasForToday = false;
			NPC.RevengeManager.Reset();
			Main.pumpkinMoon = false;
			Main.clearMap = true;
			Main.mapTime = 0;
			Main.updateMap = false;
			Main.mapReady = false;
			Main.refreshMap = false;
			Main.eclipse = false;
			Main.slimeRain = false;
			Main.slimeRainTime = 0.0;
			Main.slimeWarningTime = 0;
			Main.sundialCooldown = 0;
			Main.fastForwardTime = false;
			BirthdayParty.WorldClear();
			LanternNight.WorldClear();
			mysticLogsEvent.WorldClear();
			Sandstorm.WorldClear();
			Main.UpdateTimeRate();
			Main.wofNPCIndex = -1;
			NPC.waveKills = 0f;
			spawnHardBoss = 0;
			totalSolid2 = 0;
			totalGood2 = 0;
			totalEvil2 = 0;
			totalBlood2 = 0;
			totalSolid = 0;
			totalGood = 0;
			totalEvil = 0;
			totalBlood = 0;
			WorldFile.ResetTemps();
			Main.maxRaining = 0f;
			totalX = 0;
			totalD = 0;
			tEvil = 0;
			tBlood = 0;
			tGood = 0;
			spawnEye = false;
			prioritizedTownNPCType = 0;
			shadowOrbCount = 0;
			altarCount = 0;
			SavedOreTiers.Copper = -1;
			SavedOreTiers.Iron = -1;
			SavedOreTiers.Silver = -1;
			SavedOreTiers.Gold = -1;
			SavedOreTiers.Cobalt = -1;
			SavedOreTiers.Mythril = -1;
			SavedOreTiers.Adamantite = -1;
			Main.cloudBGActive = 0f;
			Main.raining = false;
			Main.hardMode = false;
			Main.helpText = 0;
			Main.BartenderHelpTextIndex = 0;
			Main.dungeonX = 0;
			Main.dungeonY = 0;
			NPC.downedBoss1 = false;
			NPC.downedBoss2 = false;
			NPC.downedBoss3 = false;
			NPC.downedQueenBee = false;
			NPC.downedSlimeKing = false;
			NPC.downedMechBossAny = false;
			NPC.downedMechBoss1 = false;
			NPC.downedMechBoss2 = false;
			NPC.downedMechBoss3 = false;
			NPC.downedFishron = false;
			NPC.downedAncientCultist = false;
			NPC.downedMoonlord = false;
			NPC.downedHalloweenKing = false;
			NPC.downedHalloweenTree = false;
			NPC.downedChristmasIceQueen = false;
			NPC.downedChristmasSantank = false;
			NPC.downedChristmasTree = false;
			NPC.downedPlantBoss = false;
			NPC.downedGolemBoss = false;
			NPC.downedEmpressOfLight = false;
			NPC.downedQueenSlime = false;
			NPC.combatBookWasUsed = false;
			NPC.savedStylist = false;
			NPC.savedGoblin = false;
			NPC.savedWizard = false;
			NPC.savedMech = false;
			NPC.savedTaxCollector = false;
			NPC.savedAngler = false;
			NPC.savedBartender = false;
			NPC.savedGolfer = false;
			NPC.boughtCat = false;
			NPC.boughtDog = false;
			NPC.boughtBunny = false;
			NPC.downedGoblins = false;
			NPC.downedClown = false;
			NPC.downedFrost = false;
			NPC.downedPirates = false;
			NPC.downedMartians = false;
			NPC.downedTowerSolar = (NPC.downedTowerVortex = (NPC.downedTowerNebula = (NPC.downedTowerStardust = (NPC.LunarApocalypseIsUp = false))));
			NPC.TowerActiveSolar = (NPC.TowerActiveVortex = (NPC.TowerActiveNebula = (NPC.TowerActiveStardust = false)));
			DD2Event.ResetProgressEntirely();
			NPC.ClearFoundActiveNPCs();
			Main.BestiaryTracker.Reset();
			Main.PylonSystem.Reset();
			CreativePowerManager.Instance.Reset();
			Main.CreativeMenu.Reset();
			shadowOrbSmashed = false;
			spawnMeteor = false;
			stopDrops = false;
			Main.invasionDelay = 0;
			Main.invasionType = 0;
			Main.invasionSize = 0;
			Main.invasionWarn = 0;
			Main.invasionX = 0.0;
			Main.invasionSizeStart = 0;
			Main.treeX[0] = Main.maxTilesX;
			Main.treeX[1] = Main.maxTilesX;
			Main.treeX[2] = Main.maxTilesX;
			Main.treeStyle[0] = 0;
			Main.treeStyle[1] = 0;
			Main.treeStyle[2] = 0;
			Main.treeStyle[3] = 0;
			noLiquidCheck = false;
			Liquid.numLiquid = 0;
			LiquidBuffer.numLiquidBuffer = 0;
			if (Main.netMode == 1 || lastMaxTilesX > Main.maxTilesX || lastMaxTilesY > Main.maxTilesY)
			{
				for (int j = 0; j < lastMaxTilesX; j++)
				{
					float num = (float)j / (float)lastMaxTilesX;
					Main.statusText = Lang.gen[46].Value + " " + (int)(num * 100f + 1f) + "%";
					for (int k = 0; k < lastMaxTilesY; k++)
					{
						Main.tile[j, k] = null;
					}
				}
			}
			lastMaxTilesX = Main.maxTilesX;
			lastMaxTilesY = Main.maxTilesY;
			if (Main.netMode != 2)
			{
				Main.sectionManager = new WorldSections(Main.maxTilesX / 200, Main.maxTilesY / 150);
			}
			if (Main.netMode != 1)
			{
				for (int l = 0; l < Main.maxTilesX; l++)
				{
					float num2 = (float)l / (float)Main.maxTilesX;
					Main.statusText = Lang.gen[47].Value + " " + (int)(num2 * 100f + 1f) + "%";
					for (int m = 0; m < Main.maxTilesY; m++)
					{
						if (Main.tile[l, m] == null)
						{
							Main.tile[l, m] = new Tile();
						}
						else
						{
							Main.tile[l, m].ClearEverything();
						}
					}
				}
			}
			for (int n = 0; n < Main.countsAsHostForGameplay.Length; n++)
			{
				Main.countsAsHostForGameplay[n] = false;
			}
			CombatText.clearAll();
			for (int num3 = 0; num3 < 6000; num3++)
			{
				Main.dust[num3] = new Dust();
				Main.dust[num3].dustIndex = num3;
			}
			for (int num4 = 0; num4 < 600; num4++)
			{
				Main.gore[num4] = new Gore();
			}
			for (int num5 = 0; num5 < 400; num5++)
			{
				Main.item[num5] = new Item();
				Main.timeItemSlotCannotBeReusedFor[num5] = 0;
			}
			for (int num6 = 0; num6 < 200; num6++)
			{
				Main.npc[num6] = new NPC();
			}
			for (int num7 = 0; num7 < 1000; num7++)
			{
				Main.projectile[num7] = new Projectile();
			}
			for (int num8 = 0; num8 < 8000; num8++)
			{
				Main.chest[num8] = null;
			}
			for (int num9 = 0; num9 < 1000; num9++)
			{
				Main.sign[num9] = null;
			}
			for (int num10 = 0; num10 < Liquid.maxLiquid; num10++)
			{
				Main.liquid[num10] = new Liquid();
			}
			for (int num11 = 0; num11 < 50000; num11++)
			{
				Main.liquidBuffer[num11] = new LiquidBuffer();
			}
			setWorldSize();
			Star.SpawnStars();
			worldCleared = true;
		}

		public static void setBG(int bg, int style)
		{
			switch (bg)
			{
			case 0:
				treeBG1 = style;
				SetForestBGSet(style, Main.treeMntBGSet1, Main.treeBGSet1);
				break;
			case 10:
				treeBG2 = style;
				SetForestBGSet(style, Main.treeMntBGSet2, Main.treeBGSet2);
				break;
			case 11:
				treeBG3 = style;
				SetForestBGSet(style, Main.treeMntBGSet3, Main.treeBGSet3);
				break;
			case 12:
				treeBG4 = style;
				SetForestBGSet(style, Main.treeMntBGSet4, Main.treeBGSet4);
				break;
			case 1:
				corruptBG = style;
				switch (style)
				{
				default:
					Main.corruptBG[0] = 12;
					Main.corruptBG[1] = 13;
					Main.corruptBG[2] = 14;
					break;
				case 1:
					Main.corruptBG[0] = 56;
					Main.corruptBG[1] = 57;
					Main.corruptBG[2] = 58;
					break;
				case 2:
					Main.corruptBG[0] = 211;
					Main.corruptBG[1] = 212;
					Main.corruptBG[2] = 213;
					break;
				case 3:
					Main.corruptBG[0] = 225;
					Main.corruptBG[1] = 226;
					Main.corruptBG[2] = 227;
					break;
				case 4:
					Main.corruptBG[0] = 240;
					Main.corruptBG[1] = 241;
					Main.corruptBG[2] = 242;
					break;
				}
				break;
			case 2:
				jungleBG = style;
				switch (style)
				{
				default:
					Main.jungleBG[0] = 15;
					Main.jungleBG[1] = 16;
					Main.jungleBG[2] = 17;
					break;
				case 1:
					Main.jungleBG[0] = 59;
					Main.jungleBG[1] = 60;
					Main.jungleBG[2] = 61;
					break;
				case 2:
					Main.jungleBG[0] = 222;
					Main.jungleBG[1] = 223;
					Main.jungleBG[2] = 224;
					break;
				case 3:
					Main.jungleBG[0] = 237;
					Main.jungleBG[1] = 238;
					Main.jungleBG[2] = 239;
					break;
				case 4:
					Main.jungleBG[0] = 284;
					Main.jungleBG[1] = 285;
					Main.jungleBG[2] = 286;
					break;
				case 5:
					Main.jungleBG[0] = 271;
					Main.jungleBG[1] = 272;
					Main.jungleBG[2] = 273;
					break;
				}
				break;
			case 3:
				snowBG = style;
				Main.snowMntBG[0] = 35;
				Main.snowMntBG[1] = 36;
				switch (style)
				{
				default:
					Main.snowBG[0] = 37;
					Main.snowBG[1] = 38;
					Main.snowBG[2] = 39;
					break;
				case 1:
					Main.snowBG[0] = 97;
					Main.snowBG[1] = 96;
					Main.snowBG[2] = 95;
					break;
				case 2:
					Main.snowMntBG[0] = 98;
					Main.snowMntBG[1] = 99;
					Main.snowBG[0] = -1;
					Main.snowBG[1] = -1;
					Main.snowBG[2] = -1;
					break;
				case 21:
					Main.snowMntBG[0] = 98;
					Main.snowMntBG[1] = 99;
					Main.snowBG[0] = 95;
					Main.snowBG[1] = 96;
					Main.snowBG[2] = 97;
					break;
				case 22:
					Main.snowMntBG[0] = 98;
					Main.snowMntBG[1] = 99;
					Main.snowBG[0] = 37;
					Main.snowBG[1] = 38;
					Main.snowBG[2] = 39;
					break;
				case 3:
					Main.snowMntBG[0] = 98;
					Main.snowMntBG[1] = 100;
					Main.snowBG[0] = -1;
					Main.snowBG[1] = -1;
					Main.snowBG[2] = -1;
					break;
				case 31:
					Main.snowMntBG[0] = 98;
					Main.snowMntBG[1] = 100;
					Main.snowBG[0] = 95;
					Main.snowBG[1] = 96;
					Main.snowBG[2] = 97;
					break;
				case 32:
					Main.snowMntBG[0] = 98;
					Main.snowMntBG[1] = 100;
					Main.snowBG[0] = 37;
					Main.snowBG[1] = 38;
					Main.snowBG[2] = 39;
					break;
				case 4:
					Main.snowMntBG[0] = 98;
					Main.snowMntBG[1] = 101;
					Main.snowBG[0] = -1;
					Main.snowBG[1] = -1;
					Main.snowBG[2] = -1;
					break;
				case 41:
					Main.snowMntBG[0] = 98;
					Main.snowMntBG[1] = 101;
					Main.snowBG[0] = 95;
					Main.snowBG[1] = 96;
					Main.snowBG[2] = 97;
					break;
				case 42:
					Main.snowMntBG[0] = 98;
					Main.snowMntBG[1] = 101;
					Main.snowBG[0] = 37;
					Main.snowBG[1] = 38;
					Main.snowBG[2] = 39;
					break;
				case 5:
					Main.snowMntBG[0] = -1;
					Main.snowMntBG[1] = -1;
					Main.snowBG[0] = 258;
					Main.snowBG[1] = 259;
					Main.snowBG[2] = 260;
					break;
				case 6:
					Main.snowMntBG[0] = -1;
					Main.snowMntBG[1] = -1;
					Main.snowBG[0] = 263;
					Main.snowBG[1] = 264;
					Main.snowBG[2] = 265;
					break;
				case 7:
					Main.snowMntBG[0] = 269;
					Main.snowMntBG[1] = 270;
					Main.snowBG[0] = 267;
					Main.snowBG[1] = 266;
					Main.snowBG[2] = 268;
					break;
				}
				break;
			case 4:
				hallowBG = style;
				switch (style)
				{
				default:
					Main.hallowBG[0] = 29;
					Main.hallowBG[1] = 30;
					Main.hallowBG[2] = 31;
					break;
				case 1:
					Main.hallowBG[0] = 102;
					Main.hallowBG[1] = 103;
					Main.hallowBG[2] = 104;
					break;
				case 2:
					Main.hallowBG[0] = 219;
					Main.hallowBG[1] = 220;
					Main.hallowBG[2] = 221;
					break;
				case 3:
					Main.hallowBG[0] = 243;
					Main.hallowBG[1] = 244;
					Main.hallowBG[2] = 245;
					break;
				case 4:
					Main.hallowBG[0] = -1;
					Main.hallowBG[1] = 261;
					Main.hallowBG[2] = 262;
					break;
				}
				break;
			case 5:
				crimsonBG = style;
				switch (style)
				{
				default:
					Main.crimsonBG[0] = 43;
					Main.crimsonBG[1] = 44;
					Main.crimsonBG[2] = 45;
					break;
				case 1:
					Main.crimsonBG[0] = 105;
					Main.crimsonBG[1] = 106;
					Main.crimsonBG[2] = 107;
					break;
				case 2:
					Main.crimsonBG[0] = 174;
					Main.crimsonBG[1] = -1;
					Main.crimsonBG[2] = 175;
					break;
				case 3:
					Main.crimsonBG[0] = 214;
					Main.crimsonBG[1] = 215;
					Main.crimsonBG[2] = 216;
					break;
				case 4:
					Main.crimsonBG[0] = -1;
					Main.crimsonBG[1] = 229;
					Main.crimsonBG[2] = 230;
					break;
				case 5:
					Main.crimsonBG[0] = 255;
					Main.crimsonBG[1] = 256;
					Main.crimsonBG[2] = 257;
					break;
				}
				break;
			case 6:
				desertBG = style;
				switch (style)
				{
				default:
					Main.desertBG[0] = 21;
					Main.desertBG[1] = 20;
					Main.desertBG[2] = -1;
					break;
				case 1:
					Main.desertBG[0] = 108;
					Main.desertBG[1] = 109;
					Main.desertBG[2] = -1;
					break;
				case 2:
					Main.desertBG[0] = 207;
					Main.desertBG[1] = 208;
					Main.desertBG[2] = -1;
					break;
				case 3:
					Main.desertBG[0] = 217;
					Main.desertBG[1] = 218;
					Main.desertBG[2] = -1;
					break;
				case 4:
					Main.desertBG[0] = 248;
					Main.desertBG[1] = 249;
					Main.desertBG[2] = 250;
					break;
				}
				break;
			case 7:
				oceanBG = style;
				switch (style)
				{
				default:
					Main.oceanBG = 28;
					break;
				case 1:
					Main.oceanBG = 110;
					break;
				case 2:
					Main.oceanBG = 111;
					break;
				case 3:
					Main.oceanBG = 209;
					break;
				case 4:
					Main.oceanBG = 210;
					break;
				case 5:
					Main.oceanBG = 283;
					break;
				}
				break;
			case 8:
				mushroomBG = style;
				switch (style)
				{
				default:
					Main.mushroomBG[0] = 46;
					Main.mushroomBG[1] = 47;
					Main.mushroomBG[2] = 48;
					break;
				case 1:
					Main.mushroomBG[0] = 231;
					Main.mushroomBG[1] = 232;
					Main.mushroomBG[2] = 233;
					break;
				case 2:
					Main.mushroomBG[0] = 234;
					Main.mushroomBG[1] = 235;
					Main.mushroomBG[2] = 236;
					break;
				case 3:
					Main.mushroomBG[0] = 287;
					Main.mushroomBG[1] = 288;
					Main.mushroomBG[2] = 289;
					break;
				}
				break;
			case 9:
				underworldBG = style;
				switch (style)
				{
				default:
					Main.underworldBG[0] = 0;
					Main.underworldBG[1] = 1;
					Main.underworldBG[2] = 2;
					Main.underworldBG[3] = 3;
					Main.underworldBG[4] = 4;
					break;
				case 1:
					Main.underworldBG[0] = 5;
					Main.underworldBG[1] = 6;
					Main.underworldBG[2] = 7;
					Main.underworldBG[3] = 8;
					Main.underworldBG[4] = 9;
					break;
				case 2:
					Main.underworldBG[0] = 10;
					Main.underworldBG[1] = 11;
					Main.underworldBG[2] = 12;
					Main.underworldBG[3] = 13;
					Main.underworldBG[4] = 9;
					break;
				}
				break;
			}
		}

		private static void SetForestBGSet(int style, int[] mountainSet, int[] treeSet)
		{
			mountainSet[0] = 7;
			mountainSet[1] = 8;
			switch (style)
			{
			case 1:
				treeSet[0] = 50;
				treeSet[1] = 51;
				treeSet[2] = 52;
				break;
			case 2:
				treeSet[0] = 53;
				treeSet[1] = 54;
				treeSet[2] = 55;
				break;
			case 3:
				mountainSet[1] = 90;
				treeSet[0] = 91;
				treeSet[1] = -1;
				treeSet[2] = 92;
				break;
			case 31:
				mountainSet[1] = 90;
				treeSet[0] = 91;
				treeSet[1] = -1;
				treeSet[2] = 11;
				break;
			case 4:
				mountainSet[0] = 93;
				mountainSet[1] = 94;
				treeSet[0] = -1;
				treeSet[1] = -1;
				treeSet[2] = -1;
				break;
			case 5:
				mountainSet[0] = 93;
				mountainSet[1] = 94;
				treeSet[0] = -1;
				treeSet[1] = -1;
				treeSet[2] = 55;
				break;
			case 51:
				mountainSet[0] = 93;
				mountainSet[1] = 94;
				treeSet[0] = -1;
				treeSet[1] = -1;
				treeSet[2] = 11;
				break;
			case 6:
				mountainSet[0] = 171;
				mountainSet[1] = 172;
				treeSet[0] = 173;
				treeSet[1] = -1;
				treeSet[2] = -1;
				break;
			case 7:
				mountainSet[0] = 176;
				mountainSet[1] = 177;
				treeSet[0] = 178;
				treeSet[1] = -1;
				treeSet[2] = -1;
				break;
			case 71:
				mountainSet[0] = 176;
				mountainSet[1] = 177;
				treeSet[0] = 178;
				treeSet[1] = -1;
				treeSet[2] = 11;
				break;
			case 72:
				mountainSet[0] = 176;
				mountainSet[1] = 177;
				treeSet[0] = 178;
				treeSet[1] = -1;
				treeSet[2] = 52;
				break;
			case 73:
				mountainSet[0] = 176;
				mountainSet[1] = 177;
				treeSet[0] = 178;
				treeSet[1] = -1;
				treeSet[2] = 55;
				break;
			case 8:
				mountainSet[0] = 179;
				mountainSet[1] = 180;
				treeSet[0] = 184;
				treeSet[1] = -1;
				treeSet[2] = -1;
				break;
			case 9:
				mountainSet[0] = 277;
				mountainSet[1] = 278;
				treeSet[0] = 279;
				treeSet[1] = -1;
				treeSet[2] = -1;
				break;
			case 10:
				mountainSet[0] = 280;
				mountainSet[1] = 281;
				treeSet[0] = 282;
				treeSet[1] = -1;
				treeSet[2] = -1;
				break;
			default:
				treeSet[0] = 9;
				treeSet[1] = 10;
				treeSet[2] = 11;
				break;
			}
		}

		public static void RandomizeWeather()
		{
			Main.numClouds = genRand.Next(10, 200);
			Main.windSpeedCurrent = 0f;
			while (Main.windSpeedCurrent == 0f)
			{
				Main.windSpeedCurrent = (float)genRand.Next(-400, 401) * 0.001f;
				Main.windSpeedTarget = Main.windSpeedCurrent;
			}
			Cloud.resetClouds();
		}

		public static void RandomizeMoonState()
		{
			Main.moonType = genRand.Next(9);
		}

		public static void RandomizeBackgroundBasedOnPlayer(UnifiedRandom random, Player player)
		{
			if (player.ZoneGlowshroom)
			{
				int num = mushroomBG;
				while (num == mushroomBG)
				{
					setBG(8, random.Next(4));
				}
			}
			else if (player.ZoneUnderworldHeight)
			{
				int num = underworldBG;
				while (num == underworldBG)
				{
					setBG(9, random.Next(3));
				}
			}
			else if (player.ZoneDesert)
			{
				int num = desertBG;
				while (num == desertBG)
				{
					setBG(6, random.Next(5));
				}
			}
			else if (player.ZoneHallow)
			{
				int num = hallowBG;
				while (num == hallowBG)
				{
					setBG(4, random.Next(5));
				}
			}
			else if (player.ZoneCorrupt)
			{
				int num = corruptBG;
				while (num == corruptBG)
				{
					setBG(1, random.Next(5));
				}
			}
			else if (player.ZoneCrimson)
			{
				int num = crimsonBG;
				while (num == crimsonBG)
				{
					setBG(5, random.Next(6));
				}
			}
			else if (player.ZoneJungle)
			{
				int num = jungleBG;
				while (num == jungleBG)
				{
					setBG(2, random.Next(6));
				}
			}
			else if (player.ZoneSnow)
			{
				int num = snowBG;
				while (num == snowBG)
				{
					snowBG = random.Next(8);
					if (snowBG == 2 && random.Next(2) == 0)
					{
						if (random.Next(2) == 0)
						{
							snowBG = 21;
						}
						else
						{
							snowBG = 22;
						}
					}
					if (snowBG == 3 && random.Next(2) == 0)
					{
						if (random.Next(2) == 0)
						{
							snowBG = 31;
						}
						else
						{
							snowBG = 32;
						}
					}
					if (snowBG == 4 && random.Next(2) == 0)
					{
						if (random.Next(2) == 0)
						{
							snowBG = 41;
						}
						else
						{
							snowBG = 42;
						}
					}
					setBG(3, snowBG);
				}
			}
			else if (player.ZoneBeach)
			{
				int num = oceanBG;
				while (num == oceanBG)
				{
					setBG(7, random.Next(6));
				}
			}
			else
			{
				int num2 = (int)(player.Center.X / 16f);
				if (num2 < Main.treeX[0])
				{
					int num = treeBG1;
					while (num == treeBG1)
					{
						treeBG1 = RollRandomForestBGStyle(random);
					}
					setBG(0, treeBG1);
				}
				else if (num2 < Main.treeX[1])
				{
					int num = treeBG2;
					while (num == treeBG2)
					{
						treeBG2 = RollRandomForestBGStyle(random);
					}
					setBG(10, treeBG2);
				}
				else if (num2 < Main.treeX[2])
				{
					int num = treeBG3;
					while (num == treeBG3)
					{
						treeBG3 = RollRandomForestBGStyle(random);
					}
					setBG(11, treeBG3);
				}
				else
				{
					int num = treeBG4;
					while (num == treeBG4)
					{
						treeBG4 = RollRandomForestBGStyle(random);
					}
					setBG(12, treeBG4);
				}
			}
			BackgroundsCache.UpdateCache();
		}

		public static void RandomizeBackgrounds(UnifiedRandom random)
		{
			treeBG1 = RollRandomForestBGStyle(random);
			for (treeBG2 = RollRandomForestBGStyle(random); treeBG2 == treeBG1; treeBG2 = RollRandomForestBGStyle(random))
			{
			}
			treeBG3 = RollRandomForestBGStyle(random);
			while (treeBG3 == treeBG1 || treeBG3 == treeBG2)
			{
				treeBG3 = RollRandomForestBGStyle(random);
			}
			treeBG4 = RollRandomForestBGStyle(random);
			while (treeBG4 == treeBG1 || treeBG4 == treeBG2 || treeBG4 == treeBG3)
			{
				treeBG4 = RollRandomForestBGStyle(random);
			}
			setBG(0, treeBG1);
			setBG(10, treeBG2);
			setBG(11, treeBG3);
			setBG(12, treeBG4);
			setBG(1, random.Next(5));
			setBG(2, random.Next(6));
			snowBG = random.Next(8);
			if (snowBG == 2 && random.Next(2) == 0)
			{
				if (random.Next(2) == 0)
				{
					snowBG = 21;
				}
				else
				{
					snowBG = 22;
				}
			}
			if (snowBG == 3 && random.Next(2) == 0)
			{
				if (random.Next(2) == 0)
				{
					snowBG = 31;
				}
				else
				{
					snowBG = 32;
				}
			}
			if (snowBG == 4 && random.Next(2) == 0)
			{
				if (random.Next(2) == 0)
				{
					snowBG = 41;
				}
				else
				{
					snowBG = 42;
				}
			}
			setBG(3, snowBG);
			setBG(4, random.Next(5));
			setBG(5, random.Next(6));
			setBG(6, random.Next(5));
			setBG(7, random.Next(6));
			setBG(8, random.Next(4));
			setBG(9, random.Next(3));
		}

		private static int RollRandomForestBGStyle(UnifiedRandom random)
		{
			int num = random.Next(11);
			if ((num == 1 || num == 2) && random.Next(2) == 0)
			{
				num = random.Next(11);
			}
			if (num == 0)
			{
				num = random.Next(11);
			}
			if (num == 3 && random.Next(3) == 0)
			{
				num = 31;
			}
			if (num == 5 && random.Next(2) == 0)
			{
				num = 51;
			}
			if (num == 7 && random.Next(4) == 0)
			{
				num = random.Next(71, 74);
			}
			return num;
		}

		public static void RandomizeTreeStyle()
		{
			if (Main.maxTilesX == 4200)
			{
				Main.treeX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.5 - (double)((float)Main.maxTilesX * 0.25f)), (int)((double)Main.maxTilesX * 0.5 + (double)((float)Main.maxTilesX * 0.25f)));
				Main.treeStyle[0] = genRand.Next(6);
				Main.treeStyle[1] = genRand.Next(6);
				while (Main.treeStyle[1] == Main.treeStyle[0])
				{
					Main.treeStyle[1] = genRand.Next(6);
				}
				Main.treeX[1] = Main.maxTilesX;
				Main.treeX[2] = Main.maxTilesX;
				for (int i = 0; i < 2; i++)
				{
					if (Main.treeStyle[i] == 0 && genRand.Next(3) != 0)
					{
						Main.treeStyle[i] = 4;
					}
				}
				return;
			}
			if (Main.maxTilesX == 6400)
			{
				Main.treeX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.334 - (double)((float)Main.maxTilesX * 0.2f)), (int)((double)Main.maxTilesX * 0.334 + (double)((float)Main.maxTilesX * 0.2f)));
				Main.treeX[1] = genRand.Next((int)((double)Main.maxTilesX * 0.667 - (double)((float)Main.maxTilesX * 0.2f)), (int)((double)Main.maxTilesX * 0.667 + (double)((float)Main.maxTilesX * 0.2f)));
				Main.treeStyle[0] = genRand.Next(6);
				Main.treeStyle[1] = genRand.Next(6);
				Main.treeStyle[2] = genRand.Next(6);
				while (Main.treeStyle[1] == Main.treeStyle[0])
				{
					Main.treeStyle[1] = genRand.Next(6);
				}
				while (Main.treeStyle[2] == Main.treeStyle[0] || Main.treeStyle[2] == Main.treeStyle[1])
				{
					Main.treeStyle[2] = genRand.Next(6);
				}
				Main.treeX[2] = Main.maxTilesX;
				for (int j = 0; j < 3; j++)
				{
					if (Main.treeStyle[j] == 0 && genRand.Next(3) != 0)
					{
						Main.treeStyle[j] = 4;
					}
				}
				return;
			}
			Main.treeX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.25 - (double)((float)Main.maxTilesX * 0.15f)), (int)((double)Main.maxTilesX * 0.25 + (double)((float)Main.maxTilesX * 0.15f)));
			Main.treeX[1] = genRand.Next((int)((double)Main.maxTilesX * 0.5 - (double)((float)Main.maxTilesX * 0.15f)), (int)((double)Main.maxTilesX * 0.5 + (double)((float)Main.maxTilesX * 0.15f)));
			Main.treeX[2] = genRand.Next((int)((double)Main.maxTilesX * 0.75 - (double)((float)Main.maxTilesX * 0.15f)), (int)((double)Main.maxTilesX * 0.75 + (double)((float)Main.maxTilesX * 0.15f)));
			Main.treeStyle[0] = genRand.Next(6);
			Main.treeStyle[1] = genRand.Next(6);
			Main.treeStyle[2] = genRand.Next(6);
			Main.treeStyle[3] = genRand.Next(6);
			while (Main.treeStyle[1] == Main.treeStyle[0])
			{
				Main.treeStyle[1] = genRand.Next(6);
			}
			while (Main.treeStyle[2] == Main.treeStyle[0] || Main.treeStyle[2] == Main.treeStyle[1])
			{
				Main.treeStyle[2] = genRand.Next(6);
			}
			while (Main.treeStyle[3] == Main.treeStyle[0] || Main.treeStyle[3] == Main.treeStyle[1] || Main.treeStyle[3] == Main.treeStyle[2])
			{
				Main.treeStyle[3] = genRand.Next(6);
			}
			for (int k = 0; k < 4; k++)
			{
				if (Main.treeStyle[k] == 0 && genRand.Next(3) != 0)
				{
					Main.treeStyle[k] = 4;
				}
			}
		}

		public static void RandomizeCaveBackgrounds()
		{
			int maxValue = 8;
			if (Main.maxTilesX == 4200)
			{
				Main.caveBackX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.5 - (double)((float)Main.maxTilesX * 0.25f)), (int)((double)Main.maxTilesX * 0.5 + (double)((float)Main.maxTilesX * 0.25f)));
				Main.caveBackX[1] = Main.maxTilesX;
				Main.caveBackX[2] = Main.maxTilesX;
				Main.caveBackStyle[0] = genRand.Next(maxValue);
				Main.caveBackStyle[1] = genRand.Next(maxValue);
				while (Main.caveBackStyle[1] == Main.caveBackStyle[0])
				{
					Main.caveBackStyle[1] = genRand.Next(maxValue);
				}
			}
			else if (Main.maxTilesX == 6400)
			{
				Main.caveBackX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.334 - (double)((float)Main.maxTilesX * 0.2f)), (int)((double)Main.maxTilesX * 0.334 + (double)((float)Main.maxTilesX * 0.2f)));
				Main.caveBackX[1] = genRand.Next((int)((double)Main.maxTilesX * 0.667 - (double)((float)Main.maxTilesX * 0.2f)), (int)((double)Main.maxTilesX * 0.667 + (double)((float)Main.maxTilesX * 0.2f)));
				Main.caveBackX[2] = Main.maxTilesX;
				Main.caveBackStyle[0] = genRand.Next(maxValue);
				Main.caveBackStyle[1] = genRand.Next(maxValue);
				Main.caveBackStyle[2] = genRand.Next(maxValue);
				while (Main.caveBackStyle[1] == Main.caveBackStyle[0])
				{
					Main.caveBackStyle[1] = genRand.Next(maxValue);
				}
				while (Main.caveBackStyle[2] == Main.caveBackStyle[0] || Main.caveBackStyle[2] == Main.caveBackStyle[1])
				{
					Main.caveBackStyle[2] = genRand.Next(maxValue);
				}
			}
			else
			{
				Main.caveBackX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.25 - (double)((float)Main.maxTilesX * 0.15f)), (int)((double)Main.maxTilesX * 0.25 + (double)((float)Main.maxTilesX * 0.15f)));
				Main.caveBackX[1] = genRand.Next((int)((double)Main.maxTilesX * 0.5 - (double)((float)Main.maxTilesX * 0.15f)), (int)((double)Main.maxTilesX * 0.5 + (double)((float)Main.maxTilesX * 0.15f)));
				Main.caveBackX[2] = genRand.Next((int)((double)Main.maxTilesX * 0.75 - (double)((float)Main.maxTilesX * 0.15f)), (int)((double)Main.maxTilesX * 0.75 + (double)((float)Main.maxTilesX * 0.15f)));
				Main.caveBackStyle[0] = genRand.Next(maxValue);
				Main.caveBackStyle[1] = genRand.Next(maxValue);
				Main.caveBackStyle[2] = genRand.Next(maxValue);
				Main.caveBackStyle[3] = genRand.Next(maxValue);
				while (Main.caveBackStyle[1] == Main.caveBackStyle[0])
				{
					Main.caveBackStyle[1] = genRand.Next(maxValue);
				}
				while (Main.caveBackStyle[2] == Main.caveBackStyle[0] || Main.caveBackStyle[2] == Main.caveBackStyle[1])
				{
					Main.caveBackStyle[2] = genRand.Next(maxValue);
				}
				while (Main.caveBackStyle[3] == Main.caveBackStyle[0] || Main.caveBackStyle[3] == Main.caveBackStyle[1] || Main.caveBackStyle[3] == Main.caveBackStyle[2])
				{
					Main.caveBackStyle[3] = genRand.Next(maxValue);
				}
			}
			Main.iceBackStyle = genRand.Next(4);
			Main.hellBackStyle = genRand.Next(3);
			Main.jungleBackStyle = genRand.Next(2);
		}

		private static void ResetGenerator()
		{
			numOrePatch = 0;
			numTunnels = 0;
			numLakes = 0;
			numMushroomBiomes = 0;
			numOceanCaveTreasure = 0;
			numOasis = 0;
			mudWall = false;
			hellChest = 0;
			JungleX = 0;
			numMCaves = 0;
			numIslandHouses = 0;
			houseCount = 0;
			dEnteranceX = 0;
			numDRooms = 0;
			numDDoors = 0;
			generatedShadowKey = false;
			numDungeonPlatforms = 0;
			numJChests = 0;
			JungleItemCount = 0;
		}

		public static bool mayanTrap(int x2, int y2)
		{
			int num = 1;
			if (genRand.Next(3) == 0)
			{
				num = 0;
			}
			int num2 = y2;
			while (!SolidOrSlopedTile(x2, num2))
			{
				num2++;
				if (num2 >= Main.maxTilesY - 300)
				{
					return false;
				}
			}
			if (Main.tile[x2, num2].type == 232 || Main.tile[x2, num2].type == 10)
			{
				return false;
			}
			num2--;
			if (Main.tile[x2, num2].liquid > 0 && Main.tile[x2, num2].lava())
			{
				return false;
			}
			if (num == -1 && genRand.Next(20) == 0)
			{
				num = 2;
			}
			else if (num == -1)
			{
				num = genRand.Next(2);
			}
			if (Main.tile[x2, num2].nactive() || Main.tile[x2 - 1, num2].nactive() || Main.tile[x2 + 1, num2].nactive() || Main.tile[x2, num2 - 1].nactive() || Main.tile[x2 - 1, num2 - 1].nactive() || Main.tile[x2 + 1, num2 - 1].nactive() || Main.tile[x2, num2 - 2].nactive() || Main.tile[x2 - 1, num2 - 2].nactive() || Main.tile[x2 + 1, num2 - 2].nactive())
			{
				return false;
			}
			if (Main.tile[x2, num2 + 1].type == 10)
			{
				return false;
			}
			if (Main.tile[x2, num2 + 1].type == 48)
			{
				return false;
			}
			if (Main.tile[x2, num2 + 1].type == 232)
			{
				return false;
			}
			switch (num)
			{
			case 0:
			{
				int num12 = x2;
				int num13 = num2;
				num13 -= genRand.Next(3);
				while (!SolidOrSlopedTile(num12, num13))
				{
					num12--;
				}
				int num14 = num12;
				for (num12 = x2; !SolidOrSlopedTile(num12, num13); num12++)
				{
				}
				int num15 = num12;
				int num16 = x2 - num14;
				int num17 = num15 - x2;
				bool flag = false;
				bool flag2 = false;
				if (num16 > 5 && num16 < 50)
				{
					flag = true;
				}
				if (num17 > 5 && num17 < 50)
				{
					flag2 = true;
				}
				if (flag && !SolidOrSlopedTile(num14, num13 + 1))
				{
					flag = false;
				}
				if (flag2 && !SolidOrSlopedTile(num15, num13 + 1))
				{
					flag2 = false;
				}
				if (flag && (Main.tile[num14, num13].type == 10 || Main.tile[num14, num13].type == 48 || Main.tile[num14, num13 + 1].type == 10 || Main.tile[num14, num13 + 1].type == 48))
				{
					flag = false;
				}
				if (flag2 && (Main.tile[num15, num13].type == 10 || Main.tile[num15, num13].type == 48 || Main.tile[num15, num13 + 1].type == 10 || Main.tile[num15, num13 + 1].type == 48))
				{
					flag2 = false;
				}
				int num18 = 0;
				if (flag && flag2)
				{
					num18 = 1;
					num12 = num14;
					if (genRand.Next(2) == 0)
					{
						num12 = num15;
						num18 = -1;
					}
				}
				else if (flag2)
				{
					num12 = num15;
					num18 = -1;
				}
				else
				{
					if (!flag)
					{
						return false;
					}
					num12 = num14;
					num18 = 1;
				}
				if (Main.tile[num12, num13].wall != 87)
				{
					return false;
				}
				if (Main.tile[num12, num13].type == 190)
				{
					return false;
				}
				if (Main.tile[num12, num13].type == 135)
				{
					return false;
				}
				if (Main.tile[num12, num13].type == 137)
				{
					return false;
				}
				if (Main.tile[num12, num13].type == 232)
				{
					return false;
				}
				if (Main.tile[num12, num13].type == 237)
				{
					return false;
				}
				if (Main.tile[num12, num13].type == 10)
				{
					return false;
				}
				PlaceTile(x2, num2, 135, mute: true, forced: true, -1, 6);
				KillTile(num12, num13);
				int num19 = genRand.Next(3);
				if (Main.tile[x2, num2].wire())
				{
					num19 = 0;
				}
				if (Main.tile[x2, num2].wire2())
				{
					num19 = 1;
				}
				if (Main.tile[x2, num2].wire3())
				{
					num19 = 2;
				}
				int num20 = Math.Abs(num12 - x2);
				int style2 = 1;
				if (num20 < 10 && genRand.Next(3) != 0)
				{
					style2 = 2;
				}
				PlaceTile(num12, num13, 137, mute: true, forced: true, -1, style2);
				if (num18 == 1)
				{
					Main.tile[num12, num13].frameX += 18;
				}
				int num21 = genRand.Next(5);
				int num22 = num13;
				while (num21 > 0)
				{
					num21--;
					num22--;
					if (!SolidTile(num12, num22) || !SolidTile(num12 - num18, num22) || SolidOrSlopedTile(num12 + num18, num22))
					{
						break;
					}
					PlaceTile(num12, num22, 137, mute: true, forced: true, -1, style2);
					if (num18 == 1)
					{
						Main.tile[num12, num22].frameX += 18;
					}
					switch (num19)
					{
					case 0:
						Main.tile[num12, num22].wire(wire: true);
						break;
					case 1:
						Main.tile[num12, num22].wire2(wire2: true);
						break;
					case 2:
						Main.tile[num12, num22].wire3(wire3: true);
						break;
					}
				}
				int num23 = x2;
				int num24 = num2;
				while (num23 != num12 || num24 != num13)
				{
					switch (num19)
					{
					case 0:
						Main.tile[num23, num24].wire(wire: true);
						break;
					case 1:
						Main.tile[num23, num24].wire2(wire2: true);
						break;
					case 2:
						Main.tile[num23, num24].wire3(wire3: true);
						break;
					}
					if (num23 > num12)
					{
						num23--;
					}
					if (num23 < num12)
					{
						num23++;
					}
					switch (num19)
					{
					case 0:
						Main.tile[num23, num24].wire(wire: true);
						break;
					case 1:
						Main.tile[num23, num24].wire2(wire2: true);
						break;
					case 2:
						Main.tile[num23, num24].wire3(wire3: true);
						break;
					}
					if (num24 > num13)
					{
						num24--;
					}
					if (num24 < num13)
					{
						num24++;
					}
					switch (num19)
					{
					case 0:
						Main.tile[num23, num24].wire(wire: true);
						break;
					case 1:
						Main.tile[num23, num24].wire2(wire2: true);
						break;
					case 2:
						Main.tile[num23, num24].wire3(wire3: true);
						break;
					}
				}
				return true;
			}
			case 1:
			{
				int num3 = x2;
				int num4 = num2;
				while (!SolidOrSlopedTile(num3, num4))
				{
					num4--;
					if ((double)num4 < Main.worldSurface)
					{
						return false;
					}
				}
				int num5 = Math.Abs(num4 - num2);
				if (num5 < 3)
				{
					return false;
				}
				int num6 = genRand.Next(3);
				if (Main.tile[x2, num2].wire())
				{
					num6 = 0;
				}
				if (Main.tile[x2, num2].wire2())
				{
					num6 = 1;
				}
				if (Main.tile[x2, num2].wire3())
				{
					num6 = 2;
				}
				int style = 3;
				if (num5 < 16 && genRand.Next(3) != 0)
				{
					style = 4;
				}
				if (Main.tile[num3, num4].type == 135)
				{
					return false;
				}
				if (Main.tile[num3, num4].type == 137)
				{
					return false;
				}
				if (Main.tile[num3, num4].type == 232)
				{
					return false;
				}
				if (Main.tile[num3, num4].type == 237)
				{
					return false;
				}
				if (Main.tile[num3, num4].type == 10)
				{
					return false;
				}
				if (Main.tile[num3, num4].wall != 87)
				{
					return false;
				}
				PlaceTile(x2, num2, 135, mute: true, forced: true, -1, 6);
				PlaceTile(num3, num4, 137, mute: true, forced: true, -1, style);
				for (int i = 0; i < 2; i++)
				{
					int num7 = genRand.Next(1, 5);
					int num8 = num3;
					int num9 = -1;
					if (i == 1)
					{
						num9 = 1;
					}
					while (num7 > 0)
					{
						num7--;
						num8 += num9;
						if (!SolidTile(num8, num4 - 1) || SolidOrSlopedTile(num8, num4 + 1))
						{
							break;
						}
						PlaceTile(num8, num4, 137, mute: true, forced: true, -1, style);
						switch (num6)
						{
						case 0:
							Main.tile[num8, num4].wire(wire: true);
							break;
						case 1:
							Main.tile[num8, num4].wire2(wire2: true);
							break;
						case 2:
							Main.tile[num8, num4].wire3(wire3: true);
							break;
						}
					}
				}
				int num10 = x2;
				int num11 = num2;
				while (num10 != num3 || num11 != num4)
				{
					switch (num6)
					{
					case 0:
						Main.tile[num10, num11].wire(wire: true);
						break;
					case 1:
						Main.tile[num10, num11].wire2(wire2: true);
						break;
					case 2:
						Main.tile[num10, num11].wire3(wire3: true);
						break;
					}
					if (num10 > num3)
					{
						num10--;
					}
					if (num10 < num3)
					{
						num10++;
					}
					switch (num6)
					{
					case 0:
						Main.tile[num10, num11].wire(wire: true);
						break;
					case 1:
						Main.tile[num10, num11].wire2(wire2: true);
						break;
					case 2:
						Main.tile[num10, num11].wire3(wire3: true);
						break;
					}
					if (num11 > num4)
					{
						num11--;
					}
					if (num11 < num4)
					{
						num11++;
					}
					switch (num6)
					{
					case 0:
						Main.tile[num10, num11].wire(wire: true);
						break;
					case 1:
						Main.tile[num10, num11].wire2(wire2: true);
						break;
					case 2:
						Main.tile[num10, num11].wire3(wire3: true);
						break;
					}
				}
				return true;
			}
			default:
				return false;
			}
		}

		public static bool placeLavaTrap(int x, int y)
		{
			int num = 5;
			int num2 = 50;
			int num3 = 40;
			int num4 = 20;
			int num5 = 4;
			if (Main.tile[x, y].active() || Main.tile[x, y].liquid < byte.MaxValue || !Main.tile[x, y].lava())
			{
				return false;
			}
			int num6 = 0;
			for (int i = x - num; i <= x + num; i++)
			{
				for (int j = y - num; j <= y + num; j++)
				{
					if (Main.tile[i, j].lava() && !Main.tile[i, j].active() && Main.tile[i, j].liquid == byte.MaxValue)
					{
						num6++;
					}
				}
			}
			if (num6 < num2)
			{
				return false;
			}
			int num7 = y;
			while (!Main.tile[x, num7].active())
			{
				num7++;
				if (num7 > Main.maxTilesY - 200)
				{
					return false;
				}
			}
			if (!Main.tileSolid[Main.tile[x, num7].type] || Main.tileSolidTop[Main.tile[x, num7].type])
			{
				return false;
			}
			int num8 = num7;
			for (int k = x - num4; k <= x + num4; k++)
			{
				for (int l = num7 - num4; l <= num7 + num4; l++)
				{
					if (Main.tile[k, l].wire())
					{
						return false;
					}
				}
			}
			while (Main.tile[x, num7].active() && Main.tileSolid[Main.tile[x, num7].type] && !Main.tileSolidTop[Main.tile[x, num7].type])
			{
				num7++;
				if (num7 > Main.maxTilesY - 200)
				{
					return false;
				}
			}
			Tile tile = Main.tile[x, num7 - 1];
			if (Main.tileDungeon[tile.type] || tile.type == 225 || tile.type == 226)
			{
				return false;
			}
			int num9 = num7;
			while (!Main.tile[x, num7].active())
			{
				num7++;
				if (num7 > Main.maxTilesY - 200 || Main.tile[x, num7].liquid > 0)
				{
					return false;
				}
			}
			if (!Main.tileSolid[Main.tile[x, num7].type] || Main.tileSolidTop[Main.tile[x, num7].type])
			{
				return false;
			}
			int num10 = num7 - 1;
			if (num10 - num8 > num3)
			{
				return false;
			}
			if (num10 - num9 < num5)
			{
				return false;
			}
			Main.tile[x, num7].slope(0);
			Main.tile[x, num7].halfBrick(halfBrick: false);
			PlaceTile(x, num10, 135, mute: false, forced: true, -1, 7);
			for (int m = num8; m <= num10; m++)
			{
				Main.tile[x, m].wire(wire: true);
				if (m < num9)
				{
					Main.tile[x, m].slope(0);
					Main.tile[x, m].halfBrick(halfBrick: false);
					Main.tile[x, m].actuator(actuator: true);
				}
			}
			return true;
		}

		public static bool IsTileNearby(int x, int y, int type, int distance)
		{
			for (int i = x - distance; i <= x + distance; i++)
			{
				for (int j = y - distance; j <= y + distance; j++)
				{
					if (InWorld(i, j) && Main.tile[i, j].active() && Main.tile[i, j].type == type)
					{
						return true;
					}
				}
			}
			return false;
		}

		public static bool placeTrap(int x2, int y2, int type = -1)
		{
			int num = y2;
			bool flag = false;
			bool flag2 = false;
			while (!SolidTile(x2, num))
			{
				num++;
				if (num > Main.maxTilesY - 10)
				{
					return false;
				}
				if (num >= Main.maxTilesY - 300)
				{
					flag2 = true;
				}
			}
			num--;
			if (IsTileNearby(x2, num, 70, 20))
			{
				return false;
			}
			if (Main.tile[x2, num].wall == 87)
			{
				return false;
			}
			if (Main.tile[x2, num].liquid > 0 && Main.tile[x2, num].lava())
			{
				flag = true;
			}
			if (type == -1 && genRand.Next(20) == 0)
			{
				type = 2;
			}
			else if (type == -1 && num > lavaLine + 30 && genRand.Next(6) != 0)
			{
				type = 3;
			}
			else if (type == -1)
			{
				type = genRand.Next(2);
			}
			if (!InWorld(x2, num, 3))
			{
				return false;
			}
			if (flag && type != 3)
			{
				return false;
			}
			if (flag2 && type != 3)
			{
				return false;
			}
			if (Main.tile[x2, num].nactive() || Main.tile[x2 - 1, num].nactive() || Main.tile[x2 + 1, num].nactive() || Main.tile[x2, num - 1].nactive() || Main.tile[x2 - 1, num - 1].nactive() || Main.tile[x2 + 1, num - 1].nactive() || Main.tile[x2, num - 2].nactive() || Main.tile[x2 - 1, num - 2].nactive() || Main.tile[x2 + 1, num - 2].nactive())
			{
				return false;
			}
			if (Main.tile[x2, num + 1].type == 48)
			{
				return false;
			}
			if (Main.tile[x2, num + 1].type == 232)
			{
				return false;
			}
			if (type == 1)
			{
				for (int i = x2 - 3; i <= x2 + 3; i++)
				{
					for (int j = num - 3; j <= num + 3; j++)
					{
						if (Main.tile[i, j].type == 147 || Main.tile[i, j].type == 161)
						{
							type = 0;
						}
					}
				}
			}
			switch (type)
			{
			case 0:
			{
				int num20 = x2;
				int num21 = num;
				num21 -= genRand.Next(3);
				while (!SolidTile(num20, num21) && !Main.tileCracked[Main.tile[num20, num21].type])
				{
					num20--;
					if (num20 < 0)
					{
						return false;
					}
				}
				int num22 = num20;
				num20 = x2;
				while (!SolidTile(num20, num21) && !Main.tileCracked[Main.tile[num20, num21].type])
				{
					num20++;
					if (num20 > Main.maxTilesX)
					{
						return false;
					}
				}
				int num23 = num20;
				int num24 = x2 - num22;
				int num25 = num23 - x2;
				bool flag5 = false;
				bool flag6 = false;
				if (num24 > 5 && num24 < 50)
				{
					flag5 = true;
				}
				if (num25 > 5 && num25 < 50)
				{
					flag6 = true;
				}
				if (flag5 && !SolidTile(num22, num21 + 1))
				{
					flag5 = false;
				}
				if (flag6 && !SolidTile(num23, num21 + 1))
				{
					flag6 = false;
				}
				if (flag5 && (Main.tile[num22, num21].type == 10 || Main.tile[num22, num21].type == 48 || Main.tile[num22, num21 + 1].type == 10 || Main.tile[num22, num21 + 1].type == 48))
				{
					flag5 = false;
				}
				if (flag6 && (Main.tile[num23, num21].type == 10 || Main.tile[num23, num21].type == 48 || Main.tile[num23, num21 + 1].type == 10 || Main.tile[num23, num21 + 1].type == 48))
				{
					flag6 = false;
				}
				int num26 = 0;
				if (flag5 && flag6)
				{
					num26 = 1;
					num20 = num22;
					if (genRand.Next(2) == 0)
					{
						num20 = num23;
						num26 = -1;
					}
				}
				else if (flag6)
				{
					num20 = num23;
					num26 = -1;
				}
				else
				{
					if (!flag5)
					{
						trapDiag[type, 0]++;
						return false;
					}
					num20 = num22;
					num26 = 1;
				}
				if (Main.tile[num20, num21].type == 190)
				{
					trapDiag[type, 0]++;
					return false;
				}
				if (Main.tile[x2, num].wall > 0)
				{
					PlaceTile(x2, num, 135, mute: true, forced: true, -1, 2);
				}
				else
				{
					PlaceTile(x2, num, 135, mute: true, forced: true, -1, genRand.Next(2, 4));
				}
				KillTile(num20, num21);
				PlaceTile(num20, num21, 137, mute: true, forced: true);
				if (num26 == 1)
				{
					Main.tile[num20, num21].frameX += 18;
				}
				int num27 = x2;
				int num28 = num;
				while (num27 != num20 || num28 != num21)
				{
					Main.tile[num27, num28].wire(wire: true);
					if (num27 > num20)
					{
						num27--;
					}
					if (num27 < num20)
					{
						num27++;
					}
					Main.tile[num27, num28].wire(wire: true);
					if (num28 > num21)
					{
						num28--;
					}
					if (num28 < num21)
					{
						num28++;
					}
					Main.tile[num27, num28].wire(wire: true);
				}
				trapDiag[type, 1]++;
				return true;
			}
			case 1:
			{
				int num9 = x2;
				int num10 = num - 8;
				num9 += genRand.Next(-1, 2);
				if (IsTileNearby(num9, num10, 138, 10))
				{
					return false;
				}
				bool flag3 = true;
				while (flag3)
				{
					bool flag4 = true;
					int num11 = 0;
					for (int num12 = num9 - 2; num12 <= num9 + 3; num12++)
					{
						for (int num13 = num10; num13 <= num10 + 3; num13++)
						{
							if (!SolidTile(num12, num13))
							{
								flag4 = false;
							}
							if (Main.tile[num12, num13].active() && (Main.tile[num12, num13].type == 0 || Main.tile[num12, num13].type == 1 || Main.tile[num12, num13].type == 59))
							{
								num11++;
							}
						}
					}
					num10--;
					if ((double)num10 < Main.worldSurface)
					{
						trapDiag[type, 0]++;
						return false;
					}
					if (flag4 && num11 > 2)
					{
						flag3 = false;
					}
				}
				if (num - num10 <= 5 || num - num10 >= 40)
				{
					trapDiag[type, 0]++;
					return false;
				}
				for (int num14 = num9; num14 <= num9 + 1; num14++)
				{
					for (int num15 = num10; num15 <= num; num15++)
					{
						KillTile(num14, num15);
					}
				}
				for (int num16 = num9 - 2; num16 <= num9 + 3; num16++)
				{
					for (int num17 = num10 - 2; num17 <= num10 + 3; num17++)
					{
						if (SolidTile(num16, num17))
						{
							Main.tile[num16, num17].type = 1;
						}
					}
				}
				PlaceTile(x2, num, 135, mute: true, forced: true, -1, 7);
				PlaceTile(num9, num10 + 2, 130, mute: true);
				PlaceTile(num9 + 1, num10 + 2, 130, mute: true);
				PlaceTile(num9 + 1, num10 + 1, 138, mute: true);
				num10 += 2;
				Main.tile[num9, num10].wire(wire: true);
				Main.tile[num9 + 1, num10].wire(wire: true);
				num10++;
				PlaceTile(num9, num10, 130, mute: true);
				PlaceTile(num9 + 1, num10, 130, mute: true);
				Main.tile[num9, num10].wire(wire: true);
				Main.tile[num9 + 1, num10].wire(wire: true);
				PlaceTile(num9, num10 + 1, 130, mute: true);
				PlaceTile(num9 + 1, num10 + 1, 130, mute: true);
				Main.tile[num9, num10 + 1].wire(wire: true);
				Main.tile[num9 + 1, num10 + 1].wire(wire: true);
				int num18 = x2;
				int num19 = num;
				while (num18 != num9 || num19 != num10)
				{
					Main.tile[num18, num19].wire(wire: true);
					if (num18 > num9)
					{
						num18--;
					}
					if (num18 < num9)
					{
						num18++;
					}
					Main.tile[num18, num19].wire(wire: true);
					if (num19 > num10)
					{
						num19--;
					}
					if (num19 < num10)
					{
						num19++;
					}
					Main.tile[num18, num19].wire(wire: true);
				}
				trapDiag[type, 1]++;
				return true;
			}
			case 2:
			{
				int num3 = genRand.Next(4, 7);
				int num4 = x2;
				num4 += genRand.Next(-1, 2);
				int num5 = num;
				for (int m = 0; m < num3; m++)
				{
					num5++;
					if (!SolidTile(num4, num5))
					{
						trapDiag[type, 0]++;
						return false;
					}
				}
				for (int n = num4 - 2; n <= num4 + 2; n++)
				{
					for (int num6 = num5 - 2; num6 <= num5 + 2; num6++)
					{
						if (!SolidTile(n, num6))
						{
							return false;
						}
					}
				}
				KillTile(num4, num5);
				Main.tile[num4, num5].active(active: true);
				Main.tile[num4, num5].type = 141;
				Main.tile[num4, num5].frameX = 0;
				Main.tile[num4, num5].frameY = (short)(18 * genRand.Next(2));
				PlaceTile(x2, num, 135, mute: true, forced: true, -1, genRand.Next(2, 4));
				int num7 = x2;
				int num8 = num;
				while (num7 != num4 || num8 != num5)
				{
					Main.tile[num7, num8].wire(wire: true);
					if (num7 > num4)
					{
						num7--;
					}
					if (num7 < num4)
					{
						num7++;
					}
					Main.tile[num7, num8].wire(wire: true);
					if (num8 > num5)
					{
						num8--;
					}
					if (num8 < num5)
					{
						num8++;
					}
					Main.tile[num7, num8].wire(wire: true);
				}
				trapDiag[type, 1]++;
				break;
			}
			case 3:
			{
				if (Main.tile[x2 + 1, num].active())
				{
					return false;
				}
				for (int k = x2; k <= x2 + 1; k++)
				{
					int j2 = num + 1;
					if (!SolidTile(k, j2))
					{
						return false;
					}
				}
				int num2 = genRand.Next(2);
				for (int l = 0; l < 2; l++)
				{
					Main.tile[x2 + l, num].active(active: true);
					Main.tile[x2 + l, num].type = 443;
					Main.tile[x2 + l, num].frameX = (short)(18 * l + 36 * num2);
					Main.tile[x2 + l, num].frameY = 0;
				}
				return true;
			}
			}
			return false;
		}

		public static int countWires(int x, int y, int size)
		{
			int num = 0;
			for (int i = x - size; i <= x + size; i++)
			{
				for (int j = y - size; j <= y + size; j++)
				{
					if (InWorld(i, j))
					{
						if (Main.tile[i, j].wire())
						{
							num++;
						}
						if (Main.tile[i, j].wire2())
						{
							num++;
						}
						if (Main.tile[i, j].wire3())
						{
							num++;
						}
						if (Main.tile[i, j].wire4())
						{
							num++;
						}
					}
				}
			}
			return num;
		}

		public static int countTiles(int x, int y, bool jungle = false, bool lavaOk = false)
		{
			numTileCount = 0;
			shroomCount = 0;
			lavaCount = 0;
			iceCount = 0;
			rockCount = 0;
			CountedTiles.Clear();
			nextCount(x, y, jungle, lavaOk);
			return numTileCount;
		}

		public static void nextCount(int x, int y, bool jungle = false, bool lavaOk = false)
		{
			if (numTileCount >= maxTileCount)
			{
				return;
			}
			if (x <= 1 || x >= Main.maxTilesX - 1 || y <= 1 || y >= Main.maxTilesY - 1)
			{
				numTileCount = maxTileCount;
			}
			else
			{
				if (CountedTiles.ContainsKey(new Point(x, y)))
				{
					return;
				}
				if (Main.tile[x, y].wall == 244)
				{
					numTileCount = maxTileCount;
					return;
				}
				if (!jungle)
				{
					if (Main.tile[x, y].wall != 0)
					{
						numTileCount = maxTileCount;
						return;
					}
					if (!lavaOk)
					{
						if (Main.tile[x, y].lava() && Main.tile[x, y].liquid > 0)
						{
							lavaCount++;
							numTileCount = maxTileCount;
							return;
						}
					}
					else if (Main.tile[x, y].lava() && Main.tile[x, y].liquid > 0)
					{
						lavaCount++;
					}
				}
				if (Main.tile[x, y].active())
				{
					if (Main.tile[x, y].type == 70)
					{
						shroomCount++;
					}
					if (Main.tile[x, y].type == 1)
					{
						rockCount++;
					}
					if (Main.tile[x, y].type == 147 || Main.tile[x, y].type == 161)
					{
						iceCount++;
					}
				}
				if (!SolidTile(x, y))
				{
					CountedTiles.Add(new Point(x, y), value: true);
					numTileCount++;
					nextCount(x - 1, y, jungle, lavaOk);
					nextCount(x + 1, y, jungle, lavaOk);
					nextCount(x, y - 1, jungle, lavaOk);
					nextCount(x, y + 1, jungle, lavaOk);
				}
			}
		}

		public static int countDirtTiles(int x, int y)
		{
			numTileCount = 0;
			CountedTiles.Clear();
			nextDirtCount(x, y);
			return numTileCount;
		}

		public static void nextDirtCount(int x, int y)
		{
			if (numTileCount >= maxTileCount)
			{
				return;
			}
			if (x <= 1 || x >= Main.maxTilesX - 1 || y <= 1 || y >= Main.maxTilesY - 1)
			{
				numTileCount = maxTileCount;
			}
			else if (!CountedTiles.ContainsKey(new Point(x, y)))
			{
				if (Main.tile[x, y].active() && (Main.tile[x, y].type == 147 || Main.tile[x, y].type == 161))
				{
					numTileCount = maxTileCount;
				}
				else if (Main.tile[x, y].wall == 244 || Main.tile[x, y].wall == 83 || Main.tile[x, y].wall == 3 || Main.tile[x, y].wall == 187 || Main.tile[x, y].wall == 216)
				{
					numTileCount = maxTileCount;
				}
				else if (!SolidTile(x, y) && (Main.tile[x, y].wall == 2 || Main.tile[x, y].wall == 59))
				{
					CountedTiles.Add(new Point(x, y), value: true);
					numTileCount++;
					nextDirtCount(x - 1, y);
					nextDirtCount(x + 1, y);
					nextDirtCount(x, y - 1);
					nextDirtCount(x, y + 1);
					nextDirtCount(x - 1, y - 1);
					nextDirtCount(x - 1, y + 1);
					nextDirtCount(x + 1, y - 1);
					nextDirtCount(x + 1, y + 1);
					nextDirtCount(x - 2, y);
					nextDirtCount(x + 2, y);
				}
			}
		}

		public static bool InWorld(int x, int y, int fluff = 0)
		{
			if (x < fluff || x >= Main.maxTilesX - fluff || y < fluff || y >= Main.maxTilesY - fluff)
			{
				return false;
			}
			return true;
		}

		public static void gemCave(int x, int y)
		{
			countTiles(x, y);
			for (int i = 0; i < 6; i++)
			{
				gem[i] = false;
			}
			gem[genRand.Next(6)] = true;
			for (int j = 0; j < 6; j++)
			{
				if (genRand.Next(6) == 0)
				{
					gem[j] = true;
				}
			}
			Spread.Gem(x, y);
		}

		public static int randGem()
		{
			int num = genRand.Next(6);
			while (!gem[num])
			{
				num = genRand.Next(6);
			}
			return num;
		}

		public static ushort randGemTile()
		{
			if (genRand.Next(20) != 0)
			{
				return 1;
			}
			return (ushort)randGem() switch
			{
				0 => 67, 
				1 => 66, 
				2 => 63, 
				3 => 65, 
				4 => 64, 
				_ => 68, 
			};
		}

		public static void randMoss()
		{
			neonMossType = genRand.NextFromList(new ushort[3]
			{
				539,
				536,
				534
			});
			mossType[0] = genRand.Next(5);
			mossType[1] = genRand.Next(5);
			while (mossType[1] == mossType[0])
			{
				mossType[1] = genRand.Next(5);
			}
			mossType[2] = genRand.Next(5);
			while (mossType[2] == mossType[0] || mossType[2] == mossType[1])
			{
				mossType[2] = genRand.Next(5);
			}
		}

		public static void neonMossBiome(int i, int j, int maxY = 99999)
		{
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = genRand.NextFloat() * 4f - 2f;
			vector2.Y = genRand.NextFloat() * 4f - 2f;
			if (vector2.X == 0f)
			{
				vector2.X = 1f;
			}
			while (vector2.Length() < 4f)
			{
				vector2 *= 1.5f;
			}
			double num = genRand.Next(60, 80);
			double num2 = genRand.Next(30, 40);
			float num3 = Main.maxTilesX / 4200;
			if (getGoodWorldGen)
			{
				num3 *= 1.5f;
			}
			num *= (double)num3;
			num2 *= (double)num3;
			while (num2 > 0.0)
			{
				num *= 0.98000001907348633;
				num2 -= 1.0;
				int num4 = (int)((double)vector.X - num);
				int num5 = (int)((double)vector.X + num);
				int num6 = (int)((double)vector.Y - num);
				int num7 = (int)((double)vector.Y + num);
				if (num4 < 1)
				{
					num4 = 1;
				}
				if (num5 > Main.maxTilesX - 1)
				{
					num5 = Main.maxTilesX - 1;
				}
				if (num6 < 1)
				{
					num6 = 1;
				}
				if (num7 > Main.maxTilesY - 1)
				{
					num7 = Main.maxTilesY - 1;
				}
				if ((double)num6 < Main.rockLayer)
				{
					num6 = (int)Main.rockLayer;
					if (vector2.Y < 5f)
					{
						vector2.Y = 5f;
					}
				}
				if (num7 > maxY)
				{
					num7 = maxY;
					if (vector2.Y > -5f)
					{
						vector2.Y = -5f;
					}
				}
				double num8 = num * (double)(1f + genRand.NextFloat() * 0.4f - 0.2f);
				for (int k = num4; k < num5; k++)
				{
					for (int l = num6; l < num7; l++)
					{
						if ((double)new Vector2(Math.Abs((float)k - vector.X), Math.Abs((float)l - vector.Y)).Length() < num8 * 0.8 && TileType(k, l) == 1 && (!Main.tile[k - 1, l].active() || !Main.tile[k + 1, l].active() || !Main.tile[k, l - 1].active() || !Main.tile[k, l + 1].active()))
						{
							SpreadGrass(k - 1, l, 1, neonMossType, repeat: true, 0);
						}
					}
				}
				vector += vector2;
				vector2.X += genRand.NextFloat() * 4f - 2f;
				vector2.Y += genRand.NextFloat() * 4f - 2f;
				vector2.Y = MathHelper.Clamp(vector2.Y, -10f, 10f);
				vector2.X = MathHelper.Clamp(vector2.X, -10f, 10f);
			}
		}

		public static void setMoss(int x, int y)
		{
			int num = 0;
			num = ((!((double)x < (double)Main.maxTilesX * 0.334)) ? (((double)x < (double)Main.maxTilesX * 0.667) ? 1 : 2) : 0);
			mossWall = (ushort)(54 + mossType[num]);
			mossTile = (ushort)(179 + mossType[num]);
		}

		public static void FillWallHolesInArea(Rectangle worldCoordsArea)
		{
			int num = Math.Max(worldCoordsArea.Left, 0);
			int num2 = Math.Min(worldCoordsArea.Right, Main.maxTilesX);
			int num3 = 0;
			for (int i = num; i <= num2; i++)
			{
				if (i >= 0 && i < Main.maxTilesX)
				{
					num3 += FillWallHolesInColumn(i, worldCoordsArea.Top, worldCoordsArea.Bottom);
				}
			}
		}

		private static int FillWallHolesInColumn(int x, int startY, int endY)
		{
			int num = 0;
			x = Utils.Clamp(x, 2, Main.maxTilesX - 1 - 2);
			startY = Math.Max(startY, 2);
			endY = Math.Min(endY, Main.maxTilesY - 2);
			bool flag = false;
			for (int i = startY; i < endY; i++)
			{
				if (Main.tile[x, i].wall == 0)
				{
					if (flag)
					{
						flag = false;
						if (FillWallHolesInSpot(x, i, 150))
						{
							num++;
						}
					}
				}
				else
				{
					flag = true;
				}
			}
			return num;
		}

		private static bool FillWallHolesInSpot(int originX, int originY, int maxWallsThreshold)
		{
			if (!InWorld(originX, originY, 2))
			{
				return false;
			}
			List<Point> list = new List<Point>();
			List<Point> list2 = new List<Point>();
			HashSet<Point> hashSet = new HashSet<Point>();
			Dictionary<ushort, int> dictionary = new Dictionary<ushort, int>();
			list2.Add(new Point(originX, originY));
			while (list2.Count > 0)
			{
				list.Clear();
				list.AddRange(list2);
				list2.Clear();
				while (list.Count > 0)
				{
					if (hashSet.Count >= maxWallsThreshold)
					{
						return false;
					}
					Point item = list[0];
					if (hashSet.Contains(item))
					{
						list.Remove(item);
						continue;
					}
					if (!InWorld(item.X, item.Y, 1))
					{
						list.Remove(item);
						continue;
					}
					hashSet.Add(item);
					list.Remove(item);
					Tile tile = Main.tile[item.X, item.Y];
					if (tile.wall != 0)
					{
						if (dictionary.ContainsKey(tile.wall))
						{
							dictionary[tile.wall] = dictionary[tile.wall] + 1;
						}
						else
						{
							dictionary[tile.wall] = 1;
						}
						continue;
					}
					bool flag = false;
					if (!flag)
					{
						int y = item.Y;
						for (int i = item.X - 1; i <= item.X + 1; i++)
						{
							if (!Main.tile[i, y].active())
							{
								flag = true;
								break;
							}
						}
					}
					if (!flag)
					{
						int x = item.X;
						for (int j = item.Y - 1; j <= item.Y + 1; j++)
						{
							if (!Main.tile[x, j].active())
							{
								flag = true;
								break;
							}
						}
					}
					if (flag)
					{
						Point item2 = new Point(item.X - 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X + 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X, item.Y - 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X, item.Y + 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
					}
				}
			}
			if (hashSet.Count == 1)
			{
				return false;
			}
			ushort wall = 0;
			int num = -1;
			foreach (KeyValuePair<ushort, int> item3 in dictionary)
			{
				if (item3.Value > num)
				{
					wall = item3.Key;
					num = item3.Value;
				}
			}
			if (num == -1)
			{
				wall = 2;
			}
			foreach (Point item4 in hashSet)
			{
				Tile tile2 = Main.tile[item4.X, item4.Y];
				if (tile2.wall == 0)
				{
					tile2.wall = wall;
				}
			}
			return true;
		}

		public static void tileCountAndDestroy()
		{
			for (int i = 10; i < Main.maxTilesX - 10; i++)
			{
				for (int j = 10; j < Main.maxTilesY - 10; j++)
				{
					if (Main.tile[i, j].active() && tileCounter(i, j) < tileCounterMax)
					{
						tileCounterKill();
					}
				}
			}
		}

		public static int tileCounter(int x, int y)
		{
			tileCounterNum = 0;
			tileCounterNext(x, y);
			return tileCounterNum;
		}

		public static void tileCounterNext(int x, int y)
		{
			if (tileCounterNum >= tileCounterMax || x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5 || !Main.tile[x, y].active() || !Main.tileSolid[Main.tile[x, y].type] || !TileID.Sets.CanBeClearedDuringGeneration[Main.tile[x, y].type])
			{
				return;
			}
			for (int i = 0; i < tileCounterNum; i++)
			{
				if (tileCounterX[i] == x && tileCounterY[i] == y)
				{
					return;
				}
			}
			tileCounterX[tileCounterNum] = x;
			tileCounterY[tileCounterNum] = y;
			tileCounterNum++;
			tileCounterNext(x - 1, y);
			tileCounterNext(x + 1, y);
			tileCounterNext(x, y - 1);
			tileCounterNext(x, y + 1);
		}

		public static void tileCounterKill()
		{
			for (int i = 0; i < tileCounterNum; i++)
			{
				int num = tileCounterX[i];
				int num2 = tileCounterY[i];
				Main.tile[num, num2].active(active: false);
			}
		}

		private static void AddGenerationPass(string name, WorldGenLegacyMethod method)
		{
			_generator.Append(new PassLegacy(name, method));
		}

		private static void AddGenerationPass(GenPass pass)
		{
			_generator.Append(pass);
		}

		private static void AddGenerationPass(string name, float weight, WorldGenLegacyMethod method)
		{
			_generator.Append(new PassLegacy(name, method, weight));
		}

		public static bool checkUnderground(int x, int y)
		{
			try
			{
				int num = 120;
				int num2 = 80;
				int num3 = 3;
				if ((double)y > Main.worldSurface + (double)num2)
				{
					return true;
				}
				if ((double)y < Main.worldSurface / 2.0)
				{
					return false;
				}
				int num4 = y - num2;
				int num5 = x - num / 2;
				int num6 = 0;
				if (num5 < 0)
				{
					num5 = 0;
				}
				if (num5 >= Main.maxTilesX - num)
				{
					num5 = Main.maxTilesX - num - 1;
				}
				for (int i = num5; i < num5 + num; i++)
				{
					for (int j = num4; j < num4 + num3; j++)
					{
						if (SolidTile(i, j) || Main.tile[x, y].wall > 0)
						{
							num6++;
						}
					}
				}
				if ((double)num6 >= (double)(num * num3) * 0.8)
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static int GetNextJungleChestItem()
		{
			int result = 211;
			switch (JungleItemCount % 4)
			{
			case 0:
				result = 211;
				break;
			case 1:
				result = 212;
				break;
			case 2:
				result = 213;
				break;
			case 3:
				result = 964;
				break;
			}
			if (genRand.Next(50) == 0)
			{
				result = 753;
			}
			else if (genRand.Next(30) == 0)
			{
				result = 2292;
			}
			else if (genRand.Next(20) == 0)
			{
				result = 3017;
			}
			JungleItemCount++;
			return result;
		}

		private static void ScanTileColumnAndRemoveClumps(int x)
		{
			int num = 0;
			int y = 0;
			for (int i = 10; i < Main.maxTilesY - 10; i++)
			{
				if (Main.tile[x, i].active() && Main.tileSolid[Main.tile[x, i].type] && TileID.Sets.CanBeClearedDuringGeneration[Main.tile[x, i].type])
				{
					if (num == 0)
					{
						y = i;
					}
					num++;
					continue;
				}
				if (num > 0 && num < tileCounterMax)
				{
					SmallConsecutivesFound++;
					if (tileCounter(x, y) < tileCounterMax)
					{
						SmallConsecutivesEliminated++;
						tileCounterKill();
					}
				}
				num = 0;
			}
		}

		public static void OreHelper(int X, int Y)
		{
			for (int i = X - 1; i <= X + 1; i++)
			{
				for (int j = Y - 1; j <= Y + 1; j++)
				{
					if (Main.tile[i, j].type == 1 || Main.tile[i, j].type == 40)
					{
						Main.tile[i, j].type = 0;
					}
				}
			}
		}

		public static bool StonePatch(int X, int Y)
		{
			int num = Y;
			while (!SolidTile(X, num))
			{
				num++;
				if ((double)num > Main.worldSurface)
				{
					return false;
				}
			}
			if (!TileID.Sets.Conversion.Grass[Main.tile[X, num].type] || !TileID.Sets.Conversion.Grass[Main.tile[X - 1, num].type] || !TileID.Sets.Conversion.Grass[Main.tile[X + 1, num].type])
			{
				return false;
			}
			if (Main.tile[X, num].wall > 0)
			{
				return false;
			}
			for (int i = X - 10; i <= X + 10; i++)
			{
				for (int j = num + 7; j <= num + 30; j++)
				{
					if (!Main.tile[i, j].active() || Main.tileDungeon[Main.tile[i, j].type] || TileID.Sets.Clouds[Main.tile[i, j].type] || TileID.Sets.Conversion.Sand[Main.tile[i, j].type] || Main.tile[i, j].wall == 0 || Main.tile[i, j].type == 199 || Main.tile[i, j].type == 23)
					{
						return false;
					}
				}
			}
			Vector2 value = new Vector2(X, num);
			Vector2 vector = default(Vector2);
			vector.X = genRand.NextFloat() * 0.6f - 0.3f;
			vector.Y = genRand.NextFloat() * 0.5f + 0.5f;
			float num2 = genRand.Next(13, 18);
			int num3 = genRand.Next(13, 19);
			if (genRand.Next(3) == 0)
			{
				num2 += (float)genRand.Next(3);
			}
			if (genRand.Next(3) == 0)
			{
				num3 += genRand.Next(3);
			}
			while (num3 > 0)
			{
				num3--;
				for (int k = X - (int)num2 * 4; (float)k <= (float)X + num2 * 4f; k++)
				{
					for (int l = num - (int)num2 * 4; (float)l <= (float)num + num2 * 4f; l++)
					{
						float num4 = num2 * (0.7f + genRand.NextFloat() * 0.6f) * 0.3f;
						if (genRand.Next(8) == 0)
						{
							num4 *= 2f;
						}
						Vector2 vector2 = value - new Vector2(k, l);
						if (vector2.Length() < num4 * 2f && !Main.tile[k, l].active() && Main.tile[k, l + 1].active() && Main.tile[k, l + 1].type == 1 && genRand.Next(7) == 0 && SolidTile(k - 1, l + 1) && SolidTile(k + 1, l + 1))
						{
							if (genRand.Next(3) != 0)
							{
								PlaceTile(k, l, 186, mute: true, forced: false, -1, genRand.Next(7, 13));
							}
							if (genRand.Next(3) != 0)
							{
								PlaceSmallPile(k, l, genRand.Next(6), 1, 185);
							}
							PlaceSmallPile(k, l, genRand.Next(6), 0, 185);
						}
						if (vector2.Length() < num4)
						{
							if (Main.tileSolid[Main.tile[k, l].type])
							{
								Main.tile[k, l].type = 1;
							}
							if (!gen)
							{
								SquareTileFrame(k, l);
							}
						}
					}
				}
				value += vector;
				vector.X += genRand.NextFloat() * 0.2f - 0.1f;
				vector.Y += genRand.NextFloat() * 0.2f - 0.1f;
				MathHelper.Clamp(vector.X, -0.3f, 0.3f);
				MathHelper.Clamp(vector.Y, 0.5f, 1f);
			}
			return true;
		}

		public static bool ShellPile(int X, int Y)
		{
			int num = Y;
			while (!SolidTile(X, num))
			{
				num++;
				if ((double)num > Main.worldSurface)
				{
					return false;
				}
			}
			if (Main.tile[X, num].type != 53)
			{
				return false;
			}
			if (Main.tile[X, num].wall > 0)
			{
				return false;
			}
			num--;
			Vector2 value = new Vector2(X, num);
			Vector2 vector = default(Vector2);
			vector.X = genRand.NextFloat() * 0.6f - 0.3f;
			vector.Y = genRand.NextFloat() * 0.5f + 0.5f;
			float num2 = genRand.Next(2, 4);
			if (genRand.Next(10) == 0)
			{
				num2 += 1f;
			}
			int num3 = genRand.Next(3, 6);
			while (num3 > 0)
			{
				num3--;
				for (int i = X - (int)num2 * 4; (float)i <= (float)X + num2 * 4f; i++)
				{
					int num4 = num + (int)num2 * 4;
					while ((float)num4 > (float)num - num2 * 4f)
					{
						float num5 = num2 * (float)genRand.Next(70, 91) * 0.01f;
						Vector2 vector2 = value - new Vector2(i, num4);
						vector2.X *= 0.6f;
						if (vector2.Length() < num5)
						{
							if (num4 <= num + 1 || genRand.Next(6) == 0)
							{
								Main.tile[i, num4].type = 495;
								Main.tile[i, num4].active(active: true);
								Main.tile[i, num4].halfBrick(halfBrick: false);
								Main.tile[i, num4].slope(0);
								if (!Main.tile[i, num4 + 1].active())
								{
									Main.tile[i, num4 + 1].type = 495;
									Main.tile[i, num4 + 1].active(active: true);
									Main.tile[i, num4 + 1].halfBrick(halfBrick: false);
									Main.tile[i, num4 + 1].slope(0);
									if (!Main.tile[i, num4 + 2].active())
									{
										Main.tile[i, num4 + 2].type = 53;
										Main.tile[i, num4 + 2].active(active: true);
										Main.tile[i, num4 + 2].halfBrick(halfBrick: false);
										Main.tile[i, num4 + 2].slope(0);
										if (!Main.tile[i, num4 + 3].active())
										{
											Main.tile[i, num4 + 3].type = 397;
											Main.tile[i, num4 + 3].active(active: true);
											Main.tile[i, num4 + 3].halfBrick(halfBrick: false);
											Main.tile[i, num4 + 3].slope(0);
										}
									}
								}
								if (!gen)
								{
									SquareTileFrame(i, num4);
								}
							}
							else if (Main.tile[i, num4].type != 495)
							{
								Main.tile[i, num4].active(active: true);
								Main.tile[i, num4].halfBrick(halfBrick: false);
								Main.tile[i, num4].slope(0);
								Main.tile[i, num4].type = 53;
								if (!gen)
								{
									SquareTileFrame(i, num4);
								}
							}
						}
						num4--;
					}
				}
				value += vector;
				vector.X += genRand.NextFloat() * 0.2f - 0.1f;
				vector.Y += genRand.NextFloat() * 0.2f - 0.1f;
				MathHelper.Clamp(vector.X, -0.3f, 0.3f);
				MathHelper.Clamp(vector.Y, 0.5f, 1f);
			}
			return true;
		}

		public static bool OrePatch(int X, int Y)
		{
			ushort type = (ushort)SavedOreTiers.Copper;
			if (genRand.Next(3) == 0)
			{
				type = (ushort)SavedOreTiers.Iron;
			}
			int num = X;
			int num2 = Y;
			while (!SolidTile(num, num2))
			{
				num2++;
				if ((double)num2 > Main.worldSurface)
				{
					return false;
				}
			}
			if (!TileID.Sets.Conversion.Grass[Main.tile[num, num2].type] || !TileID.Sets.Conversion.Grass[Main.tile[num - 1, num2].type] || !TileID.Sets.Conversion.Grass[Main.tile[num + 1, num2].type])
			{
				return false;
			}
			if (Main.tile[num, num2].wall > 0)
			{
				return false;
			}
			for (int i = num - 10; i <= num + 10; i++)
			{
				for (int j = num2 + 7; j <= num2 + 30; j++)
				{
					if (!Main.tile[i, j].active() || Main.tileDungeon[Main.tile[i, j].type] || TileID.Sets.Clouds[Main.tile[i, j].type] || TileID.Sets.Conversion.Sand[Main.tile[i, j].type] || Main.tile[i, j].wall == 0)
					{
						return false;
					}
				}
			}
			num2 += genRand.Next(2);
			Main.tile[num, num2].type = type;
			Main.tile[num, num2].active(active: true);
			OreHelper(num, num2);
			if (!gen)
			{
				SquareTileFrame(num, num2);
			}
			int num3 = num2;
			while (num2 < num3 + genRand.Next(8, 13))
			{
				num += genRand.Next(-1, 2);
				num2 += genRand.Next(1, 3);
				if (genRand.Next(3) == 0)
				{
					num2++;
				}
				Main.tile[num, num2].type = type;
				Main.tile[num, num2].active(active: true);
				OreHelper(num, num2);
				if (!gen)
				{
					SquareTileFrame(num, num2);
				}
				if (genRand.Next(4) == 0)
				{
					int num4 = num + genRand.Next(-2, 3);
					int num5 = num2 + genRand.Next(2);
					Main.tile[num4, num5].type = type;
					Main.tile[num4, num5].active(active: true);
					OreHelper(num4, num5);
					if (!gen)
					{
						SquareTileFrame(num4, num5);
					}
				}
			}
			Vector2 value = new Vector2(num, num2);
			Vector2 vector = default(Vector2);
			vector.X = genRand.NextFloat() * 0.6f - 0.3f;
			vector.Y = genRand.NextFloat() * 0.5f + 0.5f;
			float num6 = genRand.Next(5, 9);
			int num7 = genRand.Next(9, 14);
			if (genRand.Next(3) == 0)
			{
				num6 += (float)genRand.Next(2);
			}
			if (genRand.Next(3) == 0)
			{
				num7 += genRand.Next(2);
			}
			while (num7 > 0)
			{
				num7--;
				for (int k = num - (int)num6 * 4; (float)k <= (float)num + num6 * 4f; k++)
				{
					for (int l = num2 - (int)num6 * 4; (float)l <= (float)num2 + num6 * 4f; l++)
					{
						float num8 = num6 * (0.5f + genRand.NextFloat() * 0.5f) * 0.1f;
						float num9 = num6 * (0.7f + genRand.NextFloat() * 0.6f) * 0.3f;
						if (genRand.Next(8) == 0)
						{
							num9 *= 2f;
						}
						Vector2 vector2 = value - new Vector2(k, l);
						if (vector2.Length() < num8)
						{
							Main.tile[k, l].active(active: false);
						}
						else if (vector2.Length() < num9)
						{
							Main.tile[k, l].type = type;
							if (genRand.Next(4) == 0)
							{
								Main.tile[k, l].active(active: true);
							}
							OreHelper(k, l);
							if (!gen)
							{
								SquareTileFrame(k, l);
							}
						}
					}
				}
				value += vector;
				vector.X += genRand.NextFloat() * 0.2f - 0.1f;
				vector.Y += genRand.NextFloat() * 0.2f - 0.1f;
				MathHelper.Clamp(vector.X, -0.3f, 0.3f);
				MathHelper.Clamp(vector.Y, 0.5f, 1f);
			}
			return true;
		}

		public static bool PlaceOasis(int X, int Y)
		{
			int i = Y;
			if (!Main.tile[X, i].active() && Main.tile[X, i].wall == 0)
			{
				for (; !Main.tile[X, i].active() && Main.tile[X, i].wall == 0 && (double)i <= Main.worldSurface; i++)
				{
				}
				if ((double)i > Main.worldSurface - 10.0)
				{
					return false;
				}
				if (Main.tile[X, i].type != 53)
				{
					return false;
				}
				int num = 350;
				for (int j = 0; j < numOasis; j++)
				{
					if (Vector2.Distance(oasisPosition[j], new Vector2(X, i)) < (float)num)
					{
						return false;
					}
				}
				int num2 = genRand.Next(45, 61);
				int num3 = oasisHeight;
				int num4 = num2 + 50;
				int num5 = 4;
				for (int k = X - num4; k <= X + num4; k++)
				{
					for (int l = i - num3; l <= i + num3 + num5; l++)
					{
						Tile tile = Main.tile[k, l];
						if (tile.active())
						{
							if (Main.tileSolid[tile.type])
							{
								if ((tile.type == 151 || tile.type == 397) && Math.Abs(k - X) < num2 && Math.Abs(l - i) < num3 / 2)
								{
									return false;
								}
								if (tile.type != 53)
								{
									return false;
								}
							}
						}
						else if ((tile.liquid > 0 || tile.wall > 0) && Math.Abs(k - X) < num2 && Math.Abs(l - i) < num3 / 2)
						{
							return false;
						}
					}
					if (k > X - num2 / 2 && k < X - num2 / 2)
					{
						if (Main.tile[k, i - 6].active())
						{
							return false;
						}
						if (!Main.tile[k, i + 1].active())
						{
							return false;
						}
					}
				}
				int num6 = 5;
				int num7 = i;
				while (!Main.tile[X - num2, i + num6].active() || Main.tile[X - num2, i + num6].wall != 0 || !Main.tile[X + num2, i + num6].active() || Main.tile[X + num2, i + num6].wall != 0)
				{
					i++;
					if (i - num7 > 20)
					{
						break;
					}
				}
				int num8 = num2 / 2;
				int num9 = X - num2 * 3;
				int num10 = X + num2 * 3;
				int num11 = i - num3 * 4;
				int num12 = i + num3 * 3;
				if (num9 < 0)
				{
					num9 = 0;
				}
				if (num10 > Main.maxTilesX)
				{
					num10 = Main.maxTilesX;
				}
				if (num11 < 0)
				{
					num11 = 0;
				}
				if (num12 > Main.maxTilesY)
				{
					num12 = Main.maxTilesY;
				}
				for (int m = num9; m < num10; m++)
				{
					for (int n = num11; n < num12; n++)
					{
						float num13 = (float)Math.Abs(m - X) * 0.7f;
						float num14 = (float)Math.Abs(n - i) * 1.35f;
						double num15 = Math.Sqrt(num13 * num13 + num14 * num14);
						float num16 = (float)num8 * (0.53f + genRand.NextFloat() * 0.04f);
						float num17 = (float)Math.Abs(m - X) / (float)(num10 - X);
						num17 = 1f - num17;
						num17 *= 2.3f;
						num17 *= num17;
						num17 *= num17;
						if (num15 < (double)num16)
						{
							if (n == i + 1)
							{
								Main.tile[m, n].liquid = 127;
							}
							else if (n > i + 1)
							{
								Main.tile[m, n].liquid = byte.MaxValue;
							}
							Main.tile[m, n].lava(lava: false);
							Main.tile[m, n].active(active: false);
						}
						else if (n < i && num13 < num16 + (float)Math.Abs(n - i) * 3f * num17)
						{
							if (Main.tile[m, n].type == 53)
							{
								Main.tile[m, n].active(active: false);
							}
						}
						else if (n >= i && num13 < num16 + (float)Math.Abs(n - i) * num17 && Main.tile[m, n].wall == 0)
						{
							if (Main.tile[m, n].active() && Main.tileSolid[Main.tile[m, n].type] && !Main.tileSolidTop[Main.tile[m, n].type])
							{
								Main.tile[m, n].slope(0);
								Main.tile[m, n].halfBrick(halfBrick: false);
								continue;
							}
							Main.tile[m, n].active(active: true);
							Main.tile[m, n].type = 53;
							Main.tile[m, n].slope(0);
							Main.tile[m, n].halfBrick(halfBrick: false);
						}
					}
				}
				int num18 = 50;
				num9 = X - num2 * 2;
				num10 = X + num2 * 2;
				num12 = i + num3 * 2;
				for (int num19 = num9; num19 < num10; num19++)
				{
					for (int num20 = num12; num20 >= i; num20--)
					{
						float num21 = (float)Math.Abs(num19 - X) * 0.7f;
						float num22 = (float)Math.Abs(num20 - i) * 1.35f;
						double num23 = Math.Sqrt(num21 * num21 + num22 * num22);
						float num24 = (float)num8 * 0.57f;
						if (num23 > (double)num24)
						{
							bool flag = false;
							if (!Main.tile[num19, num20].active() && Main.tile[num19, num20].wall == 0)
							{
								int num25 = -1;
								int num26 = -1;
								for (int num27 = num19; num27 <= num19 + num18 && Main.tile[num27, num20 + 1].active() && Main.tileSolid[Main.tile[num27, num20 + 1].type] && Main.tile[num27, num20].wall <= 0; num27++)
								{
									if (Main.tile[num27, num20].active() && Main.tileSolid[Main.tile[num27, num20].type])
									{
										if (Main.tile[num27, num20].type == 53)
										{
											flag = true;
										}
										num26 = num27;
										break;
									}
									if (Main.tile[num27, num20].active())
									{
										break;
									}
								}
								int num28 = num19;
								while (num28 >= num19 - num18 && Main.tile[num28, num20 + 1].active() && Main.tileSolid[Main.tile[num28, num20 + 1].type] && Main.tile[num28, num20].wall <= 0)
								{
									if (Main.tile[num28, num20].active() && Main.tileSolid[Main.tile[num28, num20].type])
									{
										if (Main.tile[num28, num20].type == 53)
										{
											flag = true;
										}
										num25 = num28;
										break;
									}
									if (Main.tile[num28, num20].active())
									{
										break;
									}
									num28--;
								}
								flag = true;
								if (num25 > -1 && num26 > -1 && flag)
								{
									int num29 = 0;
									for (int num30 = num25 + 1; num30 < num26; num30++)
									{
										if (num26 - num25 > 5 && genRand.Next(5) == 0)
										{
											num29 = genRand.Next(5, 10);
										}
										Main.tile[num30, num20].active(active: true);
										Main.tile[num30, num20].type = 53;
										if (num29 > 0)
										{
											num29--;
											Main.tile[num30, num20 - 1].active(active: true);
											Main.tile[num30, num20 - 1].type = 53;
										}
									}
								}
							}
						}
					}
				}
				if (numOasis < maxOasis)
				{
					oasisPosition[numOasis] = new Vector2(X, i);
					oasisWidth[numOasis] = num2;
					numOasis++;
				}
				return true;
			}
			return false;
		}

		public static bool BiomeTileCheck(int x, int y)
		{
			int num = 50;
			for (int i = x - num; i <= x + num; i++)
			{
				for (int j = y - num; j <= y + num; j++)
				{
					if (!InWorld(i, j))
					{
						continue;
					}
					if (Main.tile[i, j].active())
					{
						int type = Main.tile[i, j].type;
						if (type == 368 || type == 367 || type == 147 || type == 161 || type == 162 || type == 70 || type == 72 || type == 396 || type == 397)
						{
							return true;
						}
					}
					int wall = Main.tile[i, j].wall;
					if (wall == 187 || wall == 216)
					{
						return true;
					}
				}
			}
			return false;
		}

		public static bool oceanDepths(int x, int y)
		{
			if ((double)y > oceanLevel)
			{
				return false;
			}
			if (x < beachDistance || x > Main.maxTilesX - beachDistance)
			{
				return true;
			}
			return false;
		}

		public static void GenerateWorld(int seed, GenerationProgress customProgressObject = null)
		{
			drunkWorldGen = false;
			drunkWorldGenText = false;
			if (seed == 5162020)
			{
				drunkWorldGen = true;
				drunkWorldGenText = true;
				Main.drunkWorld = true;
				Main.rand = new UnifiedRandom();
				seed = Main.rand.Next(999999999);
				if (!Main.dayTime)
				{
					Main.time = 0.0;
				}
			}
			if (notTheBees)
			{
				Main.rand = new UnifiedRandom();
				seed = Main.rand.Next(999999999);
			}
			if (getGoodWorldGen)
			{
				Main.getGoodWorld = true;
				Main.rand = new UnifiedRandom();
				seed = Main.rand.Next(999999999);
			}
			else
			{
				Main.getGoodWorld = false;
			}
			Console.WriteLine("Creating world - Seed: {0} Width: {1}, Height: {2}, Evil: {3}, IsExpert: {4}", seed, Main.maxTilesX, Main.maxTilesY, WorldGenParam_Evil, Main.expertMode);
			Main.lockMenuBGChange = true;
			WorldGenConfiguration configuration = WorldGenConfiguration.FromEmbeddedPath("Terraria.GameContent.WorldBuilding.Configuration.json");
			Hooks.ProcessWorldGenConfig(configuration);
			_lastSeed = seed;
			_generator = new WorldGenerator(seed, configuration);
			_genRand = new UnifiedRandom(seed);
			Main.rand = new UnifiedRandom(seed);
			StructureMap structures = new StructureMap();
			worldSurfaceLow = 0.0;
			double worldSurface = 0.0;
			double worldSurfaceHigh = 0.0;
			double rockLayerLow = 0.0;
			double rockLayer = 0.0;
			double rockLayerHigh = 0.0;
			int copper = 7;
			int iron = 6;
			int silver = 9;
			int gold = 8;
			int dungeonSide = 0;
			ushort jungleHut = (ushort)genRand.Next(5);
			int shellStartXLeft = 0;
			int shellStartYLeft = 0;
			int shellStartXRight = 0;
			int shellStartYRight = 0;
			int howFar = 0;
			int[] PyrX = null;
			int[] PyrY = null;
			int numPyr = 0;
			int jungleMinX = -1;
			int jungleMaxX = -1;
			int[] snowMinX = new int[Main.maxTilesY];
			int[] snowMaxX = new int[Main.maxTilesY];
			int snowTop = 0;
			int snowBottom = 0;
			float dub2 = 0f;
			int skyLakes = 1;
			if (Main.maxTilesX > 8000)
			{
				skyLakes++;
			}
			if (Main.maxTilesX > 6000)
			{
				skyLakes++;
			}
			int num = 275;
			int beachSandRandomCenter = num + 5 + 40;
			int beachSandRandomWidthRange = 20;
			int beachSandDungeonExtraWidth = 40;
			int beachSandJungleExtraWidth = 20;
			int oceanWaterStartRandomMin = 220;
			int oceanWaterStartRandomMax = oceanWaterStartRandomMin + 40;
			int oceanWaterForcedJungleLength = 275;
			int leftBeachEnd = 0;
			int rightBeachStart = 0;
			int minSsandBeforeWater = 50;
			int evilBiomeBeachAvoidance = beachSandRandomCenter + 60;
			int evilBiomeAvoidanceMidFixer = 50;
			int lakesBeachAvoidance = beachSandRandomCenter + 20;
			int smallHolesBeachAvoidance = beachSandRandomCenter + 20;
			_ = beachSandRandomCenter;
			int surfaceCavesBeachAvoidance2 = beachSandRandomCenter + 20;
			int jungleOriginX = 0;
			int snowOriginLeft = 0;
			int snowOriginRight = 0;
			int logX = -1;
			int logY = -1;
			int dungeonLocation = 0;
			AddGenerationPass("Reset", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				numOceanCaveTreasure = 0;
				skipDesertTileCheck = false;
				gen = true;
				Liquid.ReInit();
				noTileActions = true;
				progress.Message = "";
				SetupStatueList();
				RandomizeWeather();
				Main.cloudAlpha = 0f;
				Main.maxRaining = 0f;
				Main.raining = false;
				heartCount = 0;
				Main.checkXMas();
				Main.checkHalloween();
				ResetGenerator();
				UndergroundDesertLocation = Rectangle.Empty;
				UndergroundDesertHiveLocation = Rectangle.Empty;
				numLarva = 0;
				hellChestItem = new int[hellChestItem.Length];
				for (int num907 = 0; num907 < hellChestItem.Length; num907++)
				{
					bool flag62 = true;
					while (flag62)
					{
						flag62 = false;
						hellChestItem[num907] = genRand.Next(hellChestItem.Length);
						for (int num908 = 0; num908 < num907; num908++)
						{
							if (hellChestItem[num908] == hellChestItem[num907])
							{
								flag62 = true;
							}
						}
					}
				}
				int num909 = 86400;
				Main.slimeRainTime = -genRand.Next(num909 * 2, num909 * 3);
				Main.cloudBGActive = -genRand.Next(8640, 86400);
				skipFramingDuringGen = false;
				SavedOreTiers.Copper = 7;
				SavedOreTiers.Iron = 6;
				SavedOreTiers.Silver = 9;
				SavedOreTiers.Gold = 8;
				copperBar = 20;
				ironBar = 22;
				silverBar = 21;
				goldBar = 19;
				if (genRand.Next(2) == 0)
				{
					copper = 166;
					copperBar = 703;
					SavedOreTiers.Copper = 166;
				}
				if (genRand.Next(2) == 0)
				{
					iron = 167;
					ironBar = 704;
					SavedOreTiers.Iron = 167;
				}
				if (genRand.Next(2) == 0)
				{
					silver = 168;
					silverBar = 705;
					SavedOreTiers.Silver = 168;
				}
				if (genRand.Next(2) == 0)
				{
					gold = 169;
					goldBar = 706;
					SavedOreTiers.Gold = 169;
				}
				crimson = genRand.Next(2) == 0;
				if (WorldGenParam_Evil == 0)
				{
					crimson = false;
				}
				if (WorldGenParam_Evil == 1)
				{
					crimson = true;
				}
				if (jungleHut == 0)
				{
					jungleHut = 119;
				}
				else if (jungleHut == 1)
				{
					jungleHut = 120;
				}
				else if (jungleHut == 2)
				{
					jungleHut = 158;
				}
				else if (jungleHut == 3)
				{
					jungleHut = 175;
				}
				else if (jungleHut == 4)
				{
					jungleHut = 45;
				}
				Main.worldID = genRand.Next(int.MaxValue);
				RandomizeTreeStyle();
				RandomizeCaveBackgrounds();
				RandomizeBackgrounds(genRand);
				RandomizeMoonState();
				TreeTops.CopyExistingWorldInfoForWorldGeneration();
				dungeonSide = ((genRand.Next(2) != 0) ? 1 : (-1));
				if (dungeonSide == -1)
				{
					float num910 = 1f - (float)genRand.Next(15, 30) * 0.01f;
					jungleOriginX = (int)((float)Main.maxTilesX * num910);
				}
				else
				{
					float num911 = (float)genRand.Next(15, 30) * 0.01f;
					jungleOriginX = (int)((float)Main.maxTilesX * num911);
				}
				int num912 = genRand.Next(Main.maxTilesX);
				if (drunkWorldGen)
				{
					dungeonSide *= -1;
				}
				if (dungeonSide == 1)
				{
					while ((float)num912 < (float)Main.maxTilesX * 0.6f || (float)num912 > (float)Main.maxTilesX * 0.75f)
					{
						num912 = genRand.Next(Main.maxTilesX);
					}
				}
				else
				{
					while ((float)num912 < (float)Main.maxTilesX * 0.25f || (float)num912 > (float)Main.maxTilesX * 0.4f)
					{
						num912 = genRand.Next(Main.maxTilesX);
					}
				}
				if (drunkWorldGen)
				{
					dungeonSide *= -1;
				}
				int num913 = genRand.Next(50, 90);
				float num914 = Main.maxTilesX / 4200;
				num913 += (int)((float)genRand.Next(20, 40) * num914);
				num913 += (int)((float)genRand.Next(20, 40) * num914);
				int num915 = num912 - num913;
				num913 = genRand.Next(50, 90);
				num913 += (int)((float)genRand.Next(20, 40) * num914);
				num913 += (int)((float)genRand.Next(20, 40) * num914);
				int num916 = num912 + num913;
				if (num915 < 0)
				{
					num915 = 0;
				}
				if (num916 > Main.maxTilesX)
				{
					num916 = Main.maxTilesX;
				}
				snowOriginLeft = num915;
				snowOriginRight = num916;
				leftBeachEnd = genRand.Next(beachSandRandomCenter - beachSandRandomWidthRange, beachSandRandomCenter + beachSandRandomWidthRange);
				if (dungeonSide == 1)
				{
					leftBeachEnd += beachSandDungeonExtraWidth;
				}
				else
				{
					leftBeachEnd += beachSandJungleExtraWidth;
				}
				rightBeachStart = Main.maxTilesX - genRand.Next(beachSandRandomCenter - beachSandRandomWidthRange, beachSandRandomCenter + beachSandRandomWidthRange);
				if (dungeonSide == -1)
				{
					rightBeachStart -= beachSandDungeonExtraWidth;
				}
				else
				{
					rightBeachStart -= beachSandJungleExtraWidth;
				}
				int num917 = 50;
				if (dungeonSide == -1)
				{
					dungeonLocation = genRand.Next(leftBeachEnd + num917, (int)((double)Main.maxTilesX * 0.2));
				}
				else
				{
					dungeonLocation = genRand.Next((int)((double)Main.maxTilesX * 0.8), rightBeachStart - num917);
				}
			});
			AddGenerationPass(new TerrainPass().OnBegin(delegate(GenPass pass)
			{
				TerrainPass obj7 = pass as TerrainPass;
				obj7.LeftBeachSize = leftBeachEnd;
				obj7.RightBeachSize = Main.maxTilesX - rightBeachStart;
			}).OnComplete(delegate(GenPass pass)
			{
				TerrainPass terrainPass = pass as TerrainPass;
				rockLayer = terrainPass.RockLayer;
				rockLayerHigh = terrainPass.RockLayerHigh;
				rockLayerLow = terrainPass.RockLayerLow;
				worldSurface = terrainPass.WorldSurface;
				worldSurfaceHigh = terrainPass.WorldSurfaceHigh;
				worldSurfaceLow = terrainPass.WorldSurfaceLow;
				waterLine = terrainPass.WaterLine;
				lavaLine = terrainPass.LavaLine;
			}));
			AddGenerationPass("Dunes", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[1].Value;
				int random13 = passConfig.Get<WorldGenRange>("Count").GetRandom(genRand);
				float num901 = passConfig.Get<float>("ChanceOfPyramid");
				if (drunkWorldGen)
				{
					num901 = 1f;
				}
				float num902 = (float)Main.maxTilesX / 4200f;
				PyrX = new int[random13 + 3];
				PyrY = new int[random13 + 3];
				DunesBiome dunesBiome = configuration.CreateBiome<DunesBiome>();
				for (int num903 = 0; num903 < random13; num903++)
				{
					progress.Set((float)num903 / (float)random13);
					Point origin5 = Point.Zero;
					bool flag58 = false;
					int num904 = 0;
					while (!flag58)
					{
						origin5 = RandomWorldPoint(0, 500, 0, 500);
						bool flag59 = Math.Abs(origin5.X - jungleOriginX) < (int)(600f * num902);
						bool flag60 = Math.Abs(origin5.X - Main.maxTilesX / 2) < 300;
						bool flag61 = origin5.X > snowOriginLeft - 300 && origin5.Y < snowOriginRight + 300;
						num904++;
						if (num904 >= Main.maxTilesX)
						{
							flag59 = false;
						}
						if (num904 >= Main.maxTilesX * 2)
						{
							flag61 = false;
						}
						flag58 = !(flag59 || flag60 || flag61);
					}
					dunesBiome.Place(origin5, structures);
					if (genRand.NextFloat() <= num901)
					{
						int num905 = genRand.Next(origin5.X - 200, origin5.X + 200);
						for (int num906 = 0; num906 < Main.maxTilesY; num906++)
						{
							if (Main.tile[num905, num906].active())
							{
								PyrX[numPyr] = num905;
								PyrY[numPyr] = num906 + 20;
								numPyr++;
								break;
							}
						}
					}
				}
			});
			AddGenerationPass("Ocean Sand", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Language.GetTextValue("WorldGeneration.OceanSand");
				for (int num890 = 0; num890 < 3; num890++)
				{
					progress.Set((float)num890 / 3f);
					int num891 = genRand.Next(Main.maxTilesX);
					while ((float)num891 > (float)Main.maxTilesX * 0.4f && (float)num891 < (float)Main.maxTilesX * 0.6f)
					{
						num891 = genRand.Next(Main.maxTilesX);
					}
					int num892 = genRand.Next(35, 90);
					if (num890 == 1)
					{
						float num893 = Main.maxTilesX / 4200;
						num892 += (int)((float)genRand.Next(20, 40) * num893);
					}
					if (genRand.Next(3) == 0)
					{
						num892 *= 2;
					}
					if (num890 == 1)
					{
						num892 *= 2;
					}
					int num894 = num891 - num892;
					num892 = genRand.Next(35, 90);
					if (genRand.Next(3) == 0)
					{
						num892 *= 2;
					}
					if (num890 == 1)
					{
						num892 *= 2;
					}
					int num895 = num891 + num892;
					if (num894 < 0)
					{
						num894 = 0;
					}
					if (num895 > Main.maxTilesX)
					{
						num895 = Main.maxTilesX;
					}
					if (num890 == 0)
					{
						num894 = 0;
						num895 = leftBeachEnd;
					}
					else if (num890 == 2)
					{
						num894 = rightBeachStart;
						num895 = Main.maxTilesX;
					}
					else if (num890 == 1)
					{
						continue;
					}
					int num896 = genRand.Next(50, 100);
					for (int num897 = num894; num897 < num895; num897++)
					{
						if (genRand.Next(2) == 0)
						{
							num896 += genRand.Next(-1, 2);
							if (num896 < 50)
							{
								num896 = 50;
							}
							if (num896 > 200)
							{
								num896 = 200;
							}
						}
						for (int num898 = 0; (double)num898 < (Main.worldSurface + Main.rockLayer) / 2.0; num898++)
						{
							if (Main.tile[num897, num898].active())
							{
								if (num897 == (num894 + num895) / 2 && genRand.Next(6) == 0)
								{
									PyrX[numPyr] = num897;
									PyrY[numPyr] = num898;
									numPyr++;
								}
								int num899 = num896;
								if (num897 - num894 < num899)
								{
									num899 = num897 - num894;
								}
								if (num895 - num897 < num899)
								{
									num899 = num895 - num897;
								}
								num899 += genRand.Next(5);
								for (int num900 = num898; num900 < num898 + num899; num900++)
								{
									if (num897 > num894 + genRand.Next(5) && num897 < num895 - genRand.Next(5))
									{
										Main.tile[num897, num900].type = 53;
									}
								}
								break;
							}
						}
					}
				}
			});
			AddGenerationPass("Sand Patches", delegate
			{
				int num886 = (int)((float)Main.maxTilesX * 0.013f);
				for (int num887 = 0; num887 < num886; num887++)
				{
					int num888 = genRand.Next(0, Main.maxTilesX);
					int num889 = genRand.Next((int)Main.worldSurface, (int)Main.rockLayer);
					while ((double)num888 > (double)Main.maxTilesX * 0.46 && (double)num888 < (double)Main.maxTilesX * 0.54 && (double)num889 < Main.worldSurface + 150.0)
					{
						num888 = genRand.Next(0, Main.maxTilesX);
						num889 = genRand.Next((int)Main.worldSurface, (int)Main.rockLayer);
					}
					TileRunner(num888, num889, genRand.Next(15, 70), genRand.Next(20, 130), 53);
				}
			});
			AddGenerationPass("Tunnels", delegate
			{
				for (int num881 = 0; num881 < (int)((double)Main.maxTilesX * 0.0015); num881++)
				{
					if (numTunnels >= maxTunnels - 1)
					{
						break;
					}
					int[] array = new int[10];
					int[] array2 = new int[10];
					int num882 = genRand.Next(450, Main.maxTilesX - 450);
					while ((double)num882 > (double)Main.maxTilesX * 0.4 && (double)num882 < (double)Main.maxTilesX * 0.6)
					{
						num882 = genRand.Next(450, Main.maxTilesX - 450);
					}
					int num883 = 0;
					bool flag57;
					do
					{
						flag57 = false;
						for (int num884 = 0; num884 < 10; num884++)
						{
							for (num882 %= Main.maxTilesX; !Main.tile[num882, num883].active(); num883++)
							{
							}
							if (Main.tile[num882, num883].type == 53)
							{
								flag57 = true;
							}
							array[num884] = num882;
							array2[num884] = num883 - genRand.Next(11, 16);
							num882 += genRand.Next(5, 11);
						}
					}
					while (flag57);
					tunnelX[numTunnels] = array[5];
					numTunnels++;
					for (int num885 = 0; num885 < 10; num885++)
					{
						TileRunner(array[num885], array2[num885], genRand.Next(5, 8), genRand.Next(6, 9), 0, addTile: true, -2f, -0.3f);
						TileRunner(array[num885], array2[num885], genRand.Next(5, 8), genRand.Next(6, 9), 0, addTile: true, 2f, -0.3f);
					}
				}
			});
			AddGenerationPass("Mount Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				numMCaves = 0;
				progress.Message = Lang.gen[2].Value;
				for (int num874 = 0; num874 < (int)((double)Main.maxTilesX * 0.001); num874++)
				{
					progress.Set((float)num874 / (float)Main.maxTilesX * 0.001f);
					int num875 = 0;
					bool flag55 = false;
					bool flag56 = false;
					int num876 = genRand.Next((int)((double)Main.maxTilesX * 0.25), (int)((double)Main.maxTilesX * 0.75));
					while (!flag56)
					{
						flag56 = true;
						while (num876 > Main.maxTilesX / 2 - 90 && num876 < Main.maxTilesX / 2 + 90)
						{
							num876 = genRand.Next((int)((double)Main.maxTilesX * 0.25), (int)((double)Main.maxTilesX * 0.75));
						}
						for (int num877 = 0; num877 < numMCaves; num877++)
						{
							if (Math.Abs(num876 - mCaveX[num877]) < 100)
							{
								num875++;
								flag56 = false;
								break;
							}
						}
						if (num875 >= Main.maxTilesX / 5)
						{
							flag55 = true;
							break;
						}
					}
					if (!flag55)
					{
						for (int num878 = 0; (double)num878 < Main.worldSurface; num878++)
						{
							if (Main.tile[num876, num878].active())
							{
								for (int num879 = num876 - 50; num879 < num876 + 50; num879++)
								{
									for (int num880 = num878 - 25; num880 < num878 + 25; num880++)
									{
										if (Main.tile[num879, num880].active() && (Main.tile[num879, num880].type == 53 || Main.tile[num879, num880].type == 151 || Main.tile[num879, num880].type == 274))
										{
											flag55 = true;
										}
									}
								}
								if (!flag55)
								{
									Mountinater(num876, num878);
									mCaveX[numMCaves] = num876;
									mCaveY[numMCaves] = num878;
									numMCaves++;
									break;
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Dirt Wall Backgrounds", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[3].Value;
				for (int num872 = 1; num872 < Main.maxTilesX - 1; num872++)
				{
					ushort wall3 = 2;
					float value20 = (float)num872 / (float)Main.maxTilesX;
					progress.Set(value20);
					bool flag54 = false;
					howFar += genRand.Next(-1, 2);
					if (howFar < 0)
					{
						howFar = 0;
					}
					if (howFar > 10)
					{
						howFar = 10;
					}
					for (int num873 = 0; (double)num873 < Main.worldSurface + 10.0 && !((double)num873 > Main.worldSurface + (double)howFar); num873++)
					{
						if (Main.tile[num872, num873].active())
						{
							wall3 = (ushort)((Main.tile[num872, num873].type != 147) ? 2 : 40);
						}
						if (flag54 && Main.tile[num872, num873].wall != 64)
						{
							Main.tile[num872, num873].wall = wall3;
						}
						if (Main.tile[num872, num873].active() && Main.tile[num872 - 1, num873].active() && Main.tile[num872 + 1, num873].active() && Main.tile[num872, num873 + 1].active() && Main.tile[num872 - 1, num873 + 1].active() && Main.tile[num872 + 1, num873 + 1].active())
						{
							flag54 = true;
						}
					}
				}
			});
			AddGenerationPass("Rocks In Dirt", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[4].Value;
				float num866 = (float)(Main.maxTilesX * Main.maxTilesY) * 0.00015f;
				for (int num867 = 0; (float)num867 < num866; num867++)
				{
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)worldSurfaceLow + 1), genRand.Next(4, 15), genRand.Next(5, 40), 1);
				}
				progress.Set(0.34f);
				num866 = (float)(Main.maxTilesX * Main.maxTilesY) * 0.0002f;
				for (int num868 = 0; (float)num868 < num866; num868++)
				{
					int num869 = genRand.Next(0, Main.maxTilesX);
					int num870 = genRand.Next((int)worldSurfaceLow, (int)worldSurfaceHigh + 1);
					if (!Main.tile[num869, num870 - 10].active())
					{
						num870 = genRand.Next((int)worldSurfaceLow, (int)worldSurfaceHigh + 1);
					}
					TileRunner(num869, num870, genRand.Next(4, 10), genRand.Next(5, 30), 1);
				}
				progress.Set(0.67f);
				num866 = (float)(Main.maxTilesX * Main.maxTilesY) * 0.0045f;
				for (int num871 = 0; (float)num871 < num866; num871++)
				{
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)worldSurfaceHigh, (int)rockLayerHigh + 1), genRand.Next(2, 7), genRand.Next(2, 23), 1);
				}
			});
			AddGenerationPass("Dirt In Rocks", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[5].Value;
				float num864 = (float)(Main.maxTilesX * Main.maxTilesY) * 0.005f;
				for (int num865 = 0; (float)num865 < num864; num865++)
				{
					progress.Set((float)num865 / num864);
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)rockLayerLow, Main.maxTilesY), genRand.Next(2, 6), genRand.Next(2, 40), 0);
				}
			});
			AddGenerationPass("Clay", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[6].Value;
				for (int num858 = 0; num858 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2E-05); num858++)
				{
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)worldSurfaceLow), genRand.Next(4, 14), genRand.Next(10, 50), 40);
				}
				progress.Set(0.25f);
				for (int num859 = 0; num859 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 5E-05); num859++)
				{
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)worldSurfaceLow, (int)worldSurfaceHigh + 1), genRand.Next(8, 14), genRand.Next(15, 45), 40);
				}
				progress.Set(0.5f);
				for (int num860 = 0; num860 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2E-05); num860++)
				{
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)worldSurfaceHigh, (int)rockLayerHigh + 1), genRand.Next(8, 15), genRand.Next(5, 50), 40);
				}
				progress.Set(0.75f);
				for (int num861 = 5; num861 < Main.maxTilesX - 5; num861++)
				{
					for (int num862 = 1; (double)num862 < Main.worldSurface - 1.0; num862++)
					{
						if (Main.tile[num861, num862].active())
						{
							for (int num863 = num862; num863 < num862 + 5; num863++)
							{
								if (Main.tile[num861, num863].type == 40)
								{
									Main.tile[num861, num863].type = 0;
								}
							}
							break;
						}
					}
				}
			});
			int i2;
			AddGenerationPass("Small Holes", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				i2 = 0;
				progress.Message = Lang.gen[7].Value;
				double num854 = worldSurfaceHigh;
				for (int num855 = 0; num855 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0015); num855++)
				{
					float value19 = (float)((double)num855 / ((double)(Main.maxTilesX * Main.maxTilesY) * 0.0015));
					progress.Set(value19);
					int type12 = -1;
					if (genRand.Next(5) == 0)
					{
						type12 = -2;
					}
					int num856 = genRand.Next(0, Main.maxTilesX);
					int num857 = genRand.Next((int)worldSurfaceHigh, Main.maxTilesY);
					while (((num856 < smallHolesBeachAvoidance || num856 > Main.maxTilesX - smallHolesBeachAvoidance) && (double)num857 < num854) || ((double)num856 > (double)Main.maxTilesX * 0.45 && (double)num856 < (double)Main.maxTilesX * 0.55 && (double)num857 < worldSurface))
					{
						num856 = genRand.Next(0, Main.maxTilesX);
						num857 = genRand.Next((int)worldSurfaceHigh, Main.maxTilesY);
					}
					TileRunner(num856, num857, genRand.Next(2, 5), genRand.Next(2, 20), type12);
					num856 = genRand.Next(0, Main.maxTilesX);
					num857 = genRand.Next((int)worldSurfaceHigh, Main.maxTilesY);
					while (((num856 < smallHolesBeachAvoidance || num856 > Main.maxTilesX - smallHolesBeachAvoidance) && (double)num857 < num854) || ((double)num856 > (double)Main.maxTilesX * 0.45 && (double)num856 < (double)Main.maxTilesX * 0.55 && (double)num857 < worldSurface))
					{
						num856 = genRand.Next(0, Main.maxTilesX);
						num857 = genRand.Next((int)worldSurfaceHigh, Main.maxTilesY);
					}
					TileRunner(num856, num857, genRand.Next(8, 15), genRand.Next(7, 30), type12);
				}
			});
			AddGenerationPass("Dirt Layer Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[8].Value;
				double num850 = worldSurfaceHigh;
				for (int num851 = 0; num851 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 3E-05); num851++)
				{
					float value18 = (float)((double)num851 / ((double)(Main.maxTilesX * Main.maxTilesY) * 3E-05));
					progress.Set(value18);
					if (rockLayerHigh <= (double)Main.maxTilesY)
					{
						int type11 = -1;
						if (genRand.Next(6) == 0)
						{
							type11 = -2;
						}
						int num852 = genRand.Next(0, Main.maxTilesX);
						int num853 = genRand.Next((int)worldSurfaceLow, (int)rockLayerHigh + 1);
						while (((num852 < smallHolesBeachAvoidance || num852 > Main.maxTilesX - smallHolesBeachAvoidance) && (double)num853 < num850) || ((double)num852 >= (double)Main.maxTilesX * 0.45 && (double)num852 <= (double)Main.maxTilesX * 0.55 && (double)num853 < Main.worldSurface))
						{
							num852 = genRand.Next(0, Main.maxTilesX);
							num853 = genRand.Next((int)worldSurfaceLow, (int)rockLayerHigh + 1);
						}
						TileRunner(num852, num853, genRand.Next(5, 15), genRand.Next(30, 200), type11);
					}
				}
			});
			AddGenerationPass("Rock Layer Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[9].Value;
				for (int num849 = 0; num849 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00013); num849++)
				{
					float value17 = (float)((double)num849 / ((double)(Main.maxTilesX * Main.maxTilesY) * 0.00013));
					progress.Set(value17);
					if (rockLayerHigh <= (double)Main.maxTilesY)
					{
						int type10 = -1;
						if (genRand.Next(10) == 0)
						{
							type10 = -2;
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)rockLayerHigh, Main.maxTilesY), genRand.Next(6, 20), genRand.Next(50, 300), type10);
					}
				}
			});
			AddGenerationPass("Surface Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[10].Value;
				for (int num839 = 0; num839 < (int)((double)Main.maxTilesX * 0.002); num839++)
				{
					i2 = genRand.Next(0, Main.maxTilesX);
					while (((float)i2 > (float)Main.maxTilesX * 0.45f && (float)i2 < (float)Main.maxTilesX * 0.55f) || i2 < leftBeachEnd + 20 || i2 > rightBeachStart - 20)
					{
						i2 = genRand.Next(0, Main.maxTilesX);
					}
					for (int num840 = 0; (double)num840 < worldSurfaceHigh; num840++)
					{
						if (Main.tile[i2, num840].active())
						{
							TileRunner(i2, num840, genRand.Next(3, 6), genRand.Next(5, 50), -1, addTile: false, (float)genRand.Next(-10, 11) * 0.1f, 1f);
							break;
						}
					}
				}
				progress.Set(0.2f);
				for (int num841 = 0; num841 < (int)((double)Main.maxTilesX * 0.0007); num841++)
				{
					i2 = genRand.Next(0, Main.maxTilesX);
					while (((float)i2 > (float)Main.maxTilesX * 0.43f && (float)i2 < (float)Main.maxTilesX * 0.57f) || i2 < leftBeachEnd + 20 || i2 > rightBeachStart - 20)
					{
						i2 = genRand.Next(0, Main.maxTilesX);
					}
					for (int num842 = 0; (double)num842 < worldSurfaceHigh; num842++)
					{
						if (Main.tile[i2, num842].active())
						{
							TileRunner(i2, num842, genRand.Next(10, 15), genRand.Next(50, 130), -1, addTile: false, (float)genRand.Next(-10, 11) * 0.1f, 2f);
							break;
						}
					}
				}
				progress.Set(0.4f);
				for (int num843 = 0; num843 < (int)((double)Main.maxTilesX * 0.0003); num843++)
				{
					i2 = genRand.Next(0, Main.maxTilesX);
					while (((float)i2 > (float)Main.maxTilesX * 0.4f && (float)i2 < (float)Main.maxTilesX * 0.6f) || i2 < leftBeachEnd + 20 || i2 > rightBeachStart - 20)
					{
						i2 = genRand.Next(0, Main.maxTilesX);
					}
					for (int num844 = 0; (double)num844 < worldSurfaceHigh; num844++)
					{
						if (Main.tile[i2, num844].active())
						{
							TileRunner(i2, num844, genRand.Next(12, 25), genRand.Next(150, 500), -1, addTile: false, (float)genRand.Next(-10, 11) * 0.1f, 4f);
							TileRunner(i2, num844, genRand.Next(8, 17), genRand.Next(60, 200), -1, addTile: false, (float)genRand.Next(-10, 11) * 0.1f, 2f);
							TileRunner(i2, num844, genRand.Next(5, 13), genRand.Next(40, 170), -1, addTile: false, (float)genRand.Next(-10, 11) * 0.1f, 2f);
							break;
						}
					}
				}
				progress.Set(0.6f);
				for (int num845 = 0; num845 < (int)((double)Main.maxTilesX * 0.0004); num845++)
				{
					i2 = genRand.Next(0, Main.maxTilesX);
					while (((float)i2 > (float)Main.maxTilesX * 0.4f && (float)i2 < (float)Main.maxTilesX * 0.6f) || i2 < leftBeachEnd + 20 || i2 > rightBeachStart - 20)
					{
						i2 = genRand.Next(0, Main.maxTilesX);
					}
					for (int num846 = 0; (double)num846 < worldSurfaceHigh; num846++)
					{
						if (Main.tile[i2, num846].active())
						{
							TileRunner(i2, num846, genRand.Next(7, 12), genRand.Next(150, 250), -1, addTile: false, 0f, 1f, noYChange: true);
							break;
						}
					}
				}
				progress.Set(0.8f);
				float num847 = Main.maxTilesX / 4200;
				for (int num848 = 0; (float)num848 < 5f * num847; num848++)
				{
					try
					{
						Caverer(genRand.Next(surfaceCavesBeachAvoidance2, Main.maxTilesX - surfaceCavesBeachAvoidance2), genRand.Next((int)Main.rockLayer, Main.maxTilesY - 400));
					}
					catch
					{
					}
				}
			});
			AddGenerationPass("Generate Ice Biome", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[56].Value;
				snowTop = (int)Main.worldSurface;
				int num832 = lavaLine - genRand.Next(160, 200);
				int num833 = snowOriginLeft;
				int num834 = snowOriginRight;
				int num835 = 10;
				for (int num836 = 0; num836 <= lavaLine - 140; num836++)
				{
					progress.Set((float)num836 / (float)(lavaLine - 140));
					num833 += genRand.Next(-4, 4);
					num834 += genRand.Next(-3, 5);
					if (num836 > 0)
					{
						num833 = (num833 + snowMinX[num836 - 1]) / 2;
						num834 = (num834 + snowMaxX[num836 - 1]) / 2;
					}
					if (dungeonSide > 0)
					{
						if (genRand.Next(4) == 0)
						{
							num833++;
							num834++;
						}
					}
					else if (genRand.Next(4) == 0)
					{
						num833--;
						num834--;
					}
					snowMinX[num836] = num833;
					snowMaxX[num836] = num834;
					for (int num837 = num833; num837 < num834; num837++)
					{
						if (num836 < num832)
						{
							if (Main.tile[num837, num836].wall == 2)
							{
								Main.tile[num837, num836].wall = 40;
							}
							switch (Main.tile[num837, num836].type)
							{
							case 0:
							case 2:
							case 23:
							case 40:
							case 53:
								Main.tile[num837, num836].type = 147;
								break;
							case 1:
								Main.tile[num837, num836].type = 161;
								break;
							}
						}
						else
						{
							num835 += genRand.Next(-3, 4);
							if (genRand.Next(3) == 0)
							{
								num835 += genRand.Next(-4, 5);
								if (genRand.Next(3) == 0)
								{
									num835 += genRand.Next(-6, 7);
								}
							}
							if (num835 < 0)
							{
								num835 = genRand.Next(3);
							}
							else if (num835 > 50)
							{
								num835 = 50 - genRand.Next(3);
							}
							for (int num838 = num836; num838 < num836 + num835; num838++)
							{
								if (Main.tile[num837, num838].wall == 2)
								{
									Main.tile[num837, num838].wall = 40;
								}
								switch (Main.tile[num837, num838].type)
								{
								case 0:
								case 2:
								case 23:
								case 40:
								case 53:
									Main.tile[num837, num838].type = 147;
									break;
								case 1:
									Main.tile[num837, num838].type = 161;
									break;
								}
							}
						}
					}
					if (snowBottom < num836)
					{
						snowBottom = num836;
					}
				}
			});
			AddGenerationPass("Grass", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				float num828 = (float)(Main.maxTilesX * Main.maxTilesY) * 0.002f;
				for (int num829 = 0; (float)num829 < num828; num829++)
				{
					progress.Set((float)num829 / num828);
					int num830 = genRand.Next(1, Main.maxTilesX - 1);
					int num831 = genRand.Next((int)worldSurfaceLow, (int)worldSurfaceHigh);
					if (num831 >= Main.maxTilesY)
					{
						num831 = Main.maxTilesY - 2;
					}
					if (Main.tile[num830 - 1, num831].active() && Main.tile[num830 - 1, num831].type == 0 && Main.tile[num830 + 1, num831].active() && Main.tile[num830 + 1, num831].type == 0 && Main.tile[num830, num831 - 1].active() && Main.tile[num830, num831 - 1].type == 0 && Main.tile[num830, num831 + 1].active() && Main.tile[num830, num831 + 1].type == 0)
					{
						Main.tile[num830, num831].active(active: true);
						Main.tile[num830, num831].type = 2;
					}
					num830 = genRand.Next(1, Main.maxTilesX - 1);
					num831 = genRand.Next(0, (int)worldSurfaceLow);
					if (num831 >= Main.maxTilesY)
					{
						num831 = Main.maxTilesY - 2;
					}
					if (Main.tile[num830 - 1, num831].active() && Main.tile[num830 - 1, num831].type == 0 && Main.tile[num830 + 1, num831].active() && Main.tile[num830 + 1, num831].type == 0 && Main.tile[num830, num831 - 1].active() && Main.tile[num830, num831 - 1].type == 0 && Main.tile[num830, num831 + 1].active() && Main.tile[num830, num831 + 1].type == 0)
					{
						Main.tile[num830, num831].active(active: true);
						Main.tile[num830, num831].type = 2;
					}
				}
			});
			AddGenerationPass(new JunglePass().OnBegin(delegate(GenPass pass)
			{
				JunglePass obj5 = pass as JunglePass;
				obj5.JungleOriginX = jungleOriginX;
				obj5.DungeonSide = dungeonSide;
				obj5.WorldSurface = worldSurface;
				obj5.LeftBeachEnd = leftBeachEnd;
				obj5.RightBeachStart = rightBeachStart;
			}).OnComplete(delegate(GenPass pass)
			{
				JungleX = (pass as JunglePass).JungleX;
			}));
			AddGenerationPass("Mud Caves To Grass", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[77].Value;
				NotTheBees();
				for (int num823 = 0; num823 < Main.maxTilesX; num823++)
				{
					for (int num824 = 0; num824 < Main.maxTilesY; num824++)
					{
						if (Main.tile[num823, num824].active())
						{
							grassSpread = 0;
							SpreadGrass(num823, num824, 59, 60, repeat: true, 0);
						}
						progress.Set(0.2f * ((float)(num823 * Main.maxTilesY + num824) / (float)(Main.maxTilesX * Main.maxTilesY)));
					}
				}
				SmallConsecutivesFound = 0;
				SmallConsecutivesEliminated = 0;
				float num825 = Main.maxTilesX - 20;
				for (int num826 = 10; num826 < Main.maxTilesX - 10; num826++)
				{
					ScanTileColumnAndRemoveClumps(num826);
					float num827 = (float)(num826 - 10) / num825;
					progress.Set(0.2f + num827 * 0.8f);
				}
			});
			AddGenerationPass("Full Desert", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[78].Value;
				Main.tileSolid[484] = false;
				int num818 = 0;
				int num819 = dungeonSide;
				int num820 = Main.maxTilesX / 2;
				int num821 = genRand.Next(num820) / 8;
				num821 += num820 / 8;
				int x14 = num820 + num821 * -num819;
				if (drunkWorldGen)
				{
					num819 *= -1;
				}
				int num822 = 0;
				DesertBiome desertBiome = configuration.CreateBiome<DesertBiome>();
				while (!desertBiome.Place(new Point(x14, (int)worldSurfaceHigh + 25), structures))
				{
					num821 = genRand.Next(num820) / 2;
					num821 += num820 / 8;
					num821 += genRand.Next(num822 / 12);
					x14 = num820 + num821 * -num819;
					if (++num822 > Main.maxTilesX / 4)
					{
						num819 *= -1;
						num822 = 0;
						num818++;
						if (num818 >= 2)
						{
							skipDesertTileCheck = true;
						}
					}
				}
			});
			AddGenerationPass("Floating Islands", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				numIslandHouses = 0;
				houseCount = 0;
				progress.Message = Lang.gen[12].Value;
				int num808 = (int)((double)Main.maxTilesX * 0.0008);
				int num809 = 0;
				float num810 = num808 + skyLakes;
				for (int num811 = 0; (float)num811 < num810; num811++)
				{
					progress.Set((float)num811 / num810);
					int num812 = Main.maxTilesX;
					while (--num812 > 0)
					{
						bool flag53 = true;
						int num813 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
						while (num813 > Main.maxTilesX / 2 - 150 && num813 < Main.maxTilesX / 2 + 150)
						{
							num813 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
						}
						for (int num814 = 0; num814 < numIslandHouses; num814++)
						{
							if (num813 > floatingIslandHouseX[num814] - 180 && num813 < floatingIslandHouseX[num814] + 180)
							{
								flag53 = false;
								break;
							}
						}
						if (flag53)
						{
							flag53 = false;
							int num815 = 0;
							for (int num816 = 200; (double)num816 < Main.worldSurface; num816++)
							{
								if (Main.tile[num813, num816].active())
								{
									num815 = num816;
									flag53 = true;
									break;
								}
							}
							if (flag53)
							{
								int num817 = 0;
								num812 = -1;
								int val = genRand.Next(90, num815 - 100);
								val = Math.Min(val, (int)worldSurfaceLow - 50);
								if (num809 >= num808)
								{
									skyLake[numIslandHouses] = true;
									CloudLake(num813, val);
								}
								else
								{
									skyLake[numIslandHouses] = false;
									if (drunkWorldGen)
									{
										if (genRand.Next(2) == 0)
										{
											num817 = 3;
											SnowCloudIsland(num813, val);
										}
										else
										{
											num817 = 1;
											DesertCloudIsland(num813, val);
										}
									}
									else
									{
										if (getGoodWorldGen)
										{
											num817 = ((!crimson) ? 4 : 5);
										}
										CloudIsland(num813, val);
									}
								}
								floatingIslandHouseX[numIslandHouses] = num813;
								floatingIslandHouseY[numIslandHouses] = val;
								floatingIslandStyle[numIslandHouses] = num817;
								numIslandHouses++;
								num809++;
							}
						}
					}
				}
			});
			AddGenerationPass("Mushroom Patches", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[13].Value;
				float num789 = Main.maxTilesX / 700;
				if (num789 > (float)maxMushroomBiomes)
				{
					num789 = maxMushroomBiomes;
				}
				for (int num790 = 0; (float)num790 < num789; num790++)
				{
					int num791 = 0;
					bool flag52 = true;
					while (flag52)
					{
						int num792 = genRand.Next((int)((double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.8));
						if (num791 > Main.maxTilesX / 4)
						{
							num792 = genRand.Next((int)((double)Main.maxTilesX * 0.25), (int)((double)Main.maxTilesX * 0.975));
						}
						int num793 = genRand.Next((int)Main.rockLayer + 50, Main.maxTilesY - 300);
						flag52 = false;
						int num794 = 100;
						int num795 = 500;
						for (int num796 = num792 - num794; num796 < num792 + num794; num796 += 3)
						{
							for (int num797 = num793 - num794; num797 < num793 + num794; num797 += 3)
							{
								if (InWorld(num796, num797))
								{
									if (Main.tile[num796, num797].type == 147 || Main.tile[num796, num797].type == 161 || Main.tile[num796, num797].type == 162 || Main.tile[num796, num797].type == 60 || Main.tile[num796, num797].type == 368 || Main.tile[num796, num797].type == 367)
									{
										flag52 = true;
										break;
									}
									if (UndergroundDesertLocation.Contains(new Point(num796, num797)))
									{
										flag52 = true;
										break;
									}
								}
								else
								{
									flag52 = true;
								}
							}
						}
						if (!flag52)
						{
							for (int num798 = 0; num798 < numMushroomBiomes; num798++)
							{
								if (Vector2.Distance(mushroomBiomesPosition[num798], new Vector2(num792, num793)) < (float)num795)
								{
									flag52 = true;
								}
							}
						}
						if (!flag52 && numMushroomBiomes < maxMushroomBiomes)
						{
							ShroomPatch(num792, num793);
							for (int num799 = 0; num799 < 5; num799++)
							{
								int i5 = num792 + genRand.Next(-40, 41);
								int j4 = num793 + genRand.Next(-40, 41);
								ShroomPatch(i5, j4);
							}
							mushroomBiomesPosition[numMushroomBiomes].X = num792;
							mushroomBiomesPosition[numMushroomBiomes].Y = num793;
							numMushroomBiomes++;
						}
						num791++;
						if (num791 > Main.maxTilesX / 2)
						{
							break;
						}
					}
				}
				for (int num800 = 0; num800 < Main.maxTilesX; num800++)
				{
					progress.Set((float)num800 / (float)Main.maxTilesX);
					for (int num801 = (int)Main.worldSurface; num801 < Main.maxTilesY; num801++)
					{
						if (InWorld(num800, num801, 50) && Main.tile[num800, num801].active())
						{
							grassSpread = 0;
							SpreadGrass(num800, num801, 59, 70, repeat: false, 0);
						}
					}
				}
				for (int num802 = 0; num802 < Main.maxTilesX; num802++)
				{
					for (int num803 = (int)Main.worldSurface; num803 < Main.maxTilesY; num803++)
					{
						if (Main.tile[num802, num803].active() && Main.tile[num802, num803].type == 70)
						{
							int type9 = 59;
							for (int num804 = num802 - 1; num804 <= num802 + 1; num804++)
							{
								for (int num805 = num803 - 1; num805 <= num803 + 1; num805++)
								{
									if (Main.tile[num804, num805].active())
									{
										if (!Main.tile[num804 - 1, num805].active() && !Main.tile[num804 + 1, num805].active())
										{
											KillTile(num804, num805);
										}
										else if (!Main.tile[num804, num805 - 1].active() && !Main.tile[num804, num805 + 1].active())
										{
											KillTile(num804, num805);
										}
									}
									else if (Main.tile[num804 - 1, num805].active() && Main.tile[num804 + 1, num805].active())
									{
										PlaceTile(num804, num805, type9);
										if (Main.tile[num804 - 1, num803].type == 70)
										{
											Main.tile[num804 - 1, num803].type = 59;
										}
										if (Main.tile[num804 + 1, num803].type == 70)
										{
											Main.tile[num804 + 1, num803].type = 59;
										}
									}
									else if (Main.tile[num804, num805 - 1].active() && Main.tile[num804, num805 + 1].active())
									{
										PlaceTile(num804, num805, type9);
										if (Main.tile[num804, num803 - 1].type == 70)
										{
											Main.tile[num804, num803 - 1].type = 59;
										}
										if (Main.tile[num804, num803 + 1].type == 70)
										{
											Main.tile[num804, num803 + 1].type = 59;
										}
									}
								}
							}
							if (genRand.Next(4) == 0)
							{
								int num806 = num802 + genRand.Next(-20, 21);
								int num807 = num803 + genRand.Next(-20, 21);
								if (Main.tile[num806, num807].type == 59)
								{
									Main.tile[num806, num807].type = 70;
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Marble", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[80].Value;
				int random12 = passConfig.Get<WorldGenRange>("Count").GetRandom(genRand);
				float num785 = (float)(Main.maxTilesX - 160) / (float)random12;
				MarbleBiome marbleBiome = configuration.CreateBiome<MarbleBiome>();
				int num786 = 0;
				int num787 = 0;
				while (num787 < random12)
				{
					float num788 = (float)num787 / (float)random12;
					progress.Set(num788);
					Point origin4 = RandomRectanglePoint((int)(num788 * (float)(Main.maxTilesX - 160)) + 80, (int)rockLayer + 20, (int)num785, Main.maxTilesY - ((int)rockLayer + 40) - 200);
					while ((double)origin4.X > (double)Main.maxTilesX * 0.45 && (double)origin4.X < (double)Main.maxTilesX * 0.55)
					{
						origin4.X = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
					}
					num786++;
					if (marbleBiome.Place(origin4, structures) || num786 > Main.maxTilesX)
					{
						num787++;
						num786 = 0;
					}
				}
			});
			AddGenerationPass("Granite", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[81].Value;
				int random11 = passConfig.Get<WorldGenRange>("Count").GetRandom(genRand);
				float num780 = (float)(Main.maxTilesX - 200) / (float)random11;
				List<Point> list2 = new List<Point>(random11);
				int num781 = 0;
				int num782 = 0;
				while (num782 < random11)
				{
					float num783 = (float)num782 / (float)random11;
					progress.Set(num783);
					Point point3 = RandomRectanglePoint((int)(num783 * (float)(Main.maxTilesX - 200)) + 100, (int)rockLayer + 20, (int)num780, Main.maxTilesY - ((int)rockLayer + 40) - 200);
					while ((double)point3.X > (double)Main.maxTilesX * 0.45 && (double)point3.X < (double)Main.maxTilesX * 0.55)
					{
						point3.X = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
					}
					num781++;
					if (GraniteBiome.CanPlace(point3, structures))
					{
						list2.Add(point3);
						num782++;
					}
					else if (num781 > Main.maxTilesX)
					{
						num782++;
						num781 = 0;
					}
				}
				GraniteBiome graniteBiome = configuration.CreateBiome<GraniteBiome>();
				for (int num784 = 0; num784 < random11; num784++)
				{
					graniteBiome.Place(list2[num784], structures);
				}
			});
			AddGenerationPass("Dirt To Mud", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[14].Value;
				float num778 = (float)(Main.maxTilesX * Main.maxTilesY) * 0.001f;
				for (int num779 = 0; (float)num779 < num778; num779++)
				{
					progress.Set((float)num779 / num778);
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)rockLayerLow, Main.maxTilesY), genRand.Next(2, 6), genRand.Next(2, 40), 59, addTile: false, 0f, 0f, noYChange: false, overRide: true, 53);
				}
			});
			AddGenerationPass("Silt", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[15].Value;
				for (int num772 = 0; num772 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0001); num772++)
				{
					int num773 = genRand.Next(0, Main.maxTilesX);
					int num774 = genRand.Next((int)rockLayerHigh, Main.maxTilesY);
					if (Main.tile[num773, num774].wall != 187 && Main.tile[num773, num774].wall != 216)
					{
						TileRunner(num773, num774, genRand.Next(5, 12), genRand.Next(15, 50), 123);
					}
				}
				for (int num775 = 0; num775 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0005); num775++)
				{
					int num776 = genRand.Next(0, Main.maxTilesX);
					int num777 = genRand.Next((int)rockLayerHigh, Main.maxTilesY);
					if (Main.tile[num776, num777].wall != 187 && Main.tile[num776, num777].wall != 216)
					{
						TileRunner(num776, num777, genRand.Next(2, 5), genRand.Next(2, 5), 123);
					}
				}
			});
			AddGenerationPass("Shinies", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[16].Value;
				for (int num757 = 0; num757 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 6E-05); num757++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							copper = 7;
						}
						else
						{
							copper = 166;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)worldSurfaceLow, (int)worldSurfaceHigh), genRand.Next(3, 6), genRand.Next(2, 6), copper);
				}
				for (int num758 = 0; num758 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 8E-05); num758++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							copper = 7;
						}
						else
						{
							copper = 166;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)worldSurfaceHigh, (int)rockLayerHigh), genRand.Next(3, 7), genRand.Next(3, 7), copper);
				}
				for (int num759 = 0; num759 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0002); num759++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							copper = 7;
						}
						else
						{
							copper = 166;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)rockLayerLow, Main.maxTilesY), genRand.Next(4, 9), genRand.Next(4, 8), copper);
				}
				for (int num760 = 0; num760 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 3E-05); num760++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							iron = 6;
						}
						else
						{
							iron = 167;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)worldSurfaceLow, (int)worldSurfaceHigh), genRand.Next(3, 7), genRand.Next(2, 5), iron);
				}
				for (int num761 = 0; num761 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 8E-05); num761++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							iron = 6;
						}
						else
						{
							iron = 167;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)worldSurfaceHigh, (int)rockLayerHigh), genRand.Next(3, 6), genRand.Next(3, 6), iron);
				}
				for (int num762 = 0; num762 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0002); num762++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							iron = 6;
						}
						else
						{
							iron = 167;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)rockLayerLow, Main.maxTilesY), genRand.Next(4, 9), genRand.Next(4, 8), iron);
				}
				for (int num763 = 0; num763 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.6E-05); num763++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							silver = 9;
						}
						else
						{
							silver = 168;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)worldSurfaceHigh, (int)rockLayerHigh), genRand.Next(3, 6), genRand.Next(3, 6), silver);
				}
				for (int num764 = 0; num764 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00015); num764++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							silver = 9;
						}
						else
						{
							silver = 168;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)rockLayerLow, Main.maxTilesY), genRand.Next(4, 9), genRand.Next(4, 8), silver);
				}
				for (int num765 = 0; num765 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00017); num765++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							silver = 9;
						}
						else
						{
							silver = 168;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)worldSurfaceLow), genRand.Next(4, 9), genRand.Next(4, 8), silver);
				}
				for (int num766 = 0; num766 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00012); num766++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							gold = 8;
						}
						else
						{
							gold = 169;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)rockLayerLow, Main.maxTilesY), genRand.Next(4, 8), genRand.Next(4, 8), gold);
				}
				for (int num767 = 0; num767 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00012); num767++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							gold = 8;
						}
						else
						{
							gold = 169;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)worldSurfaceLow - 20), genRand.Next(4, 8), genRand.Next(4, 8), gold);
				}
				if (drunkWorldGen)
				{
					for (int num768 = 0; num768 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.25E-05 / 2.0); num768++)
					{
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.rockLayer, Main.maxTilesY), genRand.Next(3, 6), genRand.Next(4, 8), 204);
					}
					for (int num769 = 0; num769 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.25E-05 / 2.0); num769++)
					{
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.rockLayer, Main.maxTilesY), genRand.Next(3, 6), genRand.Next(4, 8), 22);
					}
				}
				if (crimson)
				{
					for (int num770 = 0; num770 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.25E-05); num770++)
					{
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.rockLayer, Main.maxTilesY), genRand.Next(3, 6), genRand.Next(4, 8), 204);
					}
				}
				else
				{
					for (int num771 = 0; num771 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.25E-05); num771++)
					{
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.rockLayer, Main.maxTilesY), genRand.Next(3, 6), genRand.Next(4, 8), 22);
					}
				}
			});
			AddGenerationPass("Webs", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[17].Value;
				for (int num753 = 0; num753 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0006); num753++)
				{
					int num754 = genRand.Next(20, Main.maxTilesX - 20);
					int num755 = genRand.Next((int)worldSurfaceHigh, Main.maxTilesY - 20);
					if (num753 < numMCaves)
					{
						num754 = mCaveX[num753];
						num755 = mCaveY[num753];
					}
					if (!Main.tile[num754, num755].active() && ((double)num755 > Main.worldSurface || Main.tile[num754, num755].wall > 0))
					{
						while (!Main.tile[num754, num755].active() && num755 > (int)worldSurfaceLow)
						{
							num755--;
						}
						num755++;
						int num756 = 1;
						if (genRand.Next(2) == 0)
						{
							num756 = -1;
						}
						for (; !Main.tile[num754, num755].active() && num754 > 10 && num754 < Main.maxTilesX - 10; num754 += num756)
						{
						}
						num754 -= num756;
						if ((double)num755 > Main.worldSurface || Main.tile[num754, num755].wall > 0)
						{
							TileRunner(num754, num755, genRand.Next(4, 11), genRand.Next(2, 4), 51, addTile: true, num756, -1f, noYChange: false, overRide: false);
						}
					}
				}
			});
			AddGenerationPass("Underworld", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[18].Value;
				progress.Set(0f);
				int num737 = Main.maxTilesY - genRand.Next(150, 190);
				for (int num738 = 0; num738 < Main.maxTilesX; num738++)
				{
					num737 += genRand.Next(-3, 4);
					if (num737 < Main.maxTilesY - 190)
					{
						num737 = Main.maxTilesY - 190;
					}
					if (num737 > Main.maxTilesY - 160)
					{
						num737 = Main.maxTilesY - 160;
					}
					for (int num739 = num737 - 20 - genRand.Next(3); num739 < Main.maxTilesY; num739++)
					{
						if (num739 >= num737)
						{
							Main.tile[num738, num739].active(active: false);
							Main.tile[num738, num739].lava(lava: false);
							Main.tile[num738, num739].liquid = 0;
						}
						else
						{
							Main.tile[num738, num739].type = 57;
						}
					}
				}
				int num740 = Main.maxTilesY - genRand.Next(40, 70);
				for (int num741 = 10; num741 < Main.maxTilesX - 10; num741++)
				{
					num740 += genRand.Next(-10, 11);
					if (num740 > Main.maxTilesY - 60)
					{
						num740 = Main.maxTilesY - 60;
					}
					if (num740 < Main.maxTilesY - 100)
					{
						num740 = Main.maxTilesY - 120;
					}
					for (int num742 = num740; num742 < Main.maxTilesY - 10; num742++)
					{
						if (!Main.tile[num741, num742].active())
						{
							Main.tile[num741, num742].lava(lava: true);
							Main.tile[num741, num742].liquid = byte.MaxValue;
						}
					}
				}
				for (int num743 = 0; num743 < Main.maxTilesX; num743++)
				{
					if (genRand.Next(50) == 0)
					{
						int num744 = Main.maxTilesY - 65;
						while (!Main.tile[num743, num744].active() && num744 > Main.maxTilesY - 135)
						{
							num744--;
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), num744 + genRand.Next(20, 50), genRand.Next(15, 20), 1000, 57, addTile: true, 0f, genRand.Next(1, 3), noYChange: true);
					}
				}
				Liquid.QuickWater(-2);
				for (int num745 = 0; num745 < Main.maxTilesX; num745++)
				{
					float num746 = (float)num745 / (float)(Main.maxTilesX - 1);
					progress.Set(num746 / 2f + 0.5f);
					if (genRand.Next(13) == 0)
					{
						int num747 = Main.maxTilesY - 65;
						while ((Main.tile[num745, num747].liquid > 0 || Main.tile[num745, num747].active()) && num747 > Main.maxTilesY - 140)
						{
							num747--;
						}
						if (!drunkWorldGen || genRand.Next(3) == 0 || !((double)num745 > (double)Main.maxTilesX * 0.4) || !((double)num745 < (double)Main.maxTilesX * 0.6))
						{
							TileRunner(num745, num747 - genRand.Next(2, 5), genRand.Next(5, 30), 1000, 57, addTile: true, 0f, genRand.Next(1, 3), noYChange: true);
						}
						float num748 = genRand.Next(1, 3);
						if (genRand.Next(3) == 0)
						{
							num748 *= 0.5f;
						}
						if (!drunkWorldGen || genRand.Next(3) == 0 || !((double)num745 > (double)Main.maxTilesX * 0.4) || !((double)num745 < (double)Main.maxTilesX * 0.6))
						{
							if (genRand.Next(2) == 0)
							{
								TileRunner(num745, num747 - genRand.Next(2, 5), (int)((float)genRand.Next(5, 15) * num748), (int)((float)genRand.Next(10, 15) * num748), 57, addTile: true, 1f, 0.3f);
							}
							if (genRand.Next(2) == 0)
							{
								num748 = genRand.Next(1, 3);
								TileRunner(num745, num747 - genRand.Next(2, 5), (int)((float)genRand.Next(5, 15) * num748), (int)((float)genRand.Next(10, 15) * num748), 57, addTile: true, -1f, 0.3f);
							}
						}
						TileRunner(num745 + genRand.Next(-10, 10), num747 + genRand.Next(-10, 10), genRand.Next(5, 15), genRand.Next(5, 10), -2, addTile: false, genRand.Next(-1, 3), genRand.Next(-1, 3));
						if (genRand.Next(3) == 0)
						{
							TileRunner(num745 + genRand.Next(-10, 10), num747 + genRand.Next(-10, 10), genRand.Next(10, 30), genRand.Next(10, 20), -2, addTile: false, genRand.Next(-1, 3), genRand.Next(-1, 3));
						}
						if (genRand.Next(5) == 0)
						{
							TileRunner(num745 + genRand.Next(-15, 15), num747 + genRand.Next(-15, 10), genRand.Next(15, 30), genRand.Next(5, 20), -2, addTile: false, genRand.Next(-1, 3), genRand.Next(-1, 3));
						}
					}
				}
				for (int num749 = 0; num749 < Main.maxTilesX; num749++)
				{
					TileRunner(genRand.Next(20, Main.maxTilesX - 20), genRand.Next(Main.maxTilesY - 180, Main.maxTilesY - 10), genRand.Next(2, 7), genRand.Next(2, 7), -2);
				}
				if (drunkWorldGen)
				{
					for (int num750 = 0; num750 < Main.maxTilesX * 2; num750++)
					{
						TileRunner(genRand.Next((int)((double)Main.maxTilesX * 0.35), (int)((double)Main.maxTilesX * 0.65)), genRand.Next(Main.maxTilesY - 180, Main.maxTilesY - 10), genRand.Next(5, 20), genRand.Next(5, 10), -2);
					}
				}
				for (int num751 = 0; num751 < Main.maxTilesX; num751++)
				{
					if (!Main.tile[num751, Main.maxTilesY - 145].active())
					{
						Main.tile[num751, Main.maxTilesY - 145].liquid = byte.MaxValue;
						Main.tile[num751, Main.maxTilesY - 145].lava(lava: true);
					}
					if (!Main.tile[num751, Main.maxTilesY - 144].active())
					{
						Main.tile[num751, Main.maxTilesY - 144].liquid = byte.MaxValue;
						Main.tile[num751, Main.maxTilesY - 144].lava(lava: true);
					}
				}
				for (int num752 = 0; num752 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0008); num752++)
				{
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(Main.maxTilesY - 140, Main.maxTilesY), genRand.Next(2, 7), genRand.Next(3, 7), 58);
				}
				AddHellHouses();
			});
			AddGenerationPass("Corruption", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				int num677 = Main.maxTilesX;
				int num678 = 0;
				int num679 = Main.maxTilesX;
				int num680 = 0;
				for (int num681 = 0; num681 < Main.maxTilesX; num681++)
				{
					for (int num682 = 0; (double)num682 < Main.worldSurface; num682++)
					{
						if (Main.tile[num681, num682].active())
						{
							if (Main.tile[num681, num682].type == 60)
							{
								if (num681 < num677)
								{
									num677 = num681;
								}
								if (num681 > num678)
								{
									num678 = num681;
								}
							}
							else if (Main.tile[num681, num682].type == 147 || Main.tile[num681, num682].type == 161)
							{
								if (num681 < num679)
								{
									num679 = num681;
								}
								if (num681 > num680)
								{
									num680 = num681;
								}
							}
						}
					}
				}
				int num683 = 10;
				num677 -= num683;
				num678 += num683;
				num679 -= num683;
				num680 += num683;
				int num684 = 500;
				int num685 = 100;
				bool flag45 = crimson;
				bool flag46 = true;
				double num686 = (double)Main.maxTilesX * 0.00045;
				if (drunkWorldGen)
				{
					flag45 = true;
					num686 /= 2.0;
					if (genRand.Next(2) == 0)
					{
						flag46 = false;
					}
				}
				if (flag45)
				{
					progress.Message = Lang.gen[72].Value;
					for (int num687 = 0; (double)num687 < num686; num687++)
					{
						int num688 = num679;
						int num689 = num680;
						int num690 = num677;
						int num691 = num678;
						float value15 = (float)num687 / (float)num686;
						progress.Set(value15);
						bool flag47 = false;
						int num692 = 0;
						int num693 = 0;
						int num694 = 0;
						while (!flag47)
						{
							flag47 = true;
							int num695 = Main.maxTilesX / 2;
							int num696 = 200;
							if (drunkWorldGen)
							{
								num696 = 100;
								num692 = ((!flag46) ? genRand.Next((int)((double)Main.maxTilesX * 0.5), Main.maxTilesX - num684) : genRand.Next(num684, (int)((double)Main.maxTilesX * 0.5)));
							}
							else
							{
								num692 = genRand.Next(num684, Main.maxTilesX - num684);
							}
							num693 = num692 - genRand.Next(200) - 100;
							num694 = num692 + genRand.Next(200) + 100;
							if (num693 < evilBiomeBeachAvoidance)
							{
								num693 = evilBiomeBeachAvoidance;
							}
							if (num694 > Main.maxTilesX - evilBiomeBeachAvoidance)
							{
								num694 = Main.maxTilesX - evilBiomeBeachAvoidance;
							}
							if (num692 < num693 + evilBiomeAvoidanceMidFixer)
							{
								num692 = num693 + evilBiomeAvoidanceMidFixer;
							}
							if (num692 > num694 - evilBiomeAvoidanceMidFixer)
							{
								num692 = num694 - evilBiomeAvoidanceMidFixer;
							}
							if (dungeonSide < 0 && num693 < 400)
							{
								num693 = 400;
							}
							else if (dungeonSide > 0 && num693 > Main.maxTilesX - 400)
							{
								num693 = Main.maxTilesX - 400;
							}
							if (num692 > num695 - num696 && num692 < num695 + num696)
							{
								flag47 = false;
							}
							if (num693 > num695 - num696 && num693 < num695 + num696)
							{
								flag47 = false;
							}
							if (num694 > num695 - num696 && num694 < num695 + num696)
							{
								flag47 = false;
							}
							if (num692 > UndergroundDesertLocation.X && num692 < UndergroundDesertLocation.X + UndergroundDesertLocation.Width)
							{
								flag47 = false;
							}
							if (num693 > UndergroundDesertLocation.X && num693 < UndergroundDesertLocation.X + UndergroundDesertLocation.Width)
							{
								flag47 = false;
							}
							if (num694 > UndergroundDesertLocation.X && num694 < UndergroundDesertLocation.X + UndergroundDesertLocation.Width)
							{
								flag47 = false;
							}
							if (num693 < dungeonLocation + num685 && num694 > dungeonLocation - num685)
							{
								flag47 = false;
							}
							if (num693 < num689 && num694 > num688)
							{
								num688++;
								num689--;
								flag47 = false;
							}
							if (num693 < num691 && num694 > num690)
							{
								num690++;
								num691--;
								flag47 = false;
							}
						}
						CrimStart(num692, (int)worldSurfaceLow - 10);
						for (int num697 = num693; num697 < num694; num697++)
						{
							for (int num698 = (int)worldSurfaceLow; (double)num698 < Main.worldSurface - 1.0; num698++)
							{
								if (Main.tile[num697, num698].active())
								{
									int num699 = num698 + genRand.Next(10, 14);
									for (int num700 = num698; num700 < num699; num700++)
									{
										if ((Main.tile[num697, num700].type == 59 || Main.tile[num697, num700].type == 60) && num697 >= num693 + genRand.Next(5) && num697 < num694 - genRand.Next(5))
										{
											Main.tile[num697, num700].type = 0;
										}
									}
									break;
								}
							}
						}
						double num701 = Main.worldSurface + 40.0;
						for (int num702 = num693; num702 < num694; num702++)
						{
							num701 += (double)genRand.Next(-2, 3);
							if (num701 < Main.worldSurface + 30.0)
							{
								num701 = Main.worldSurface + 30.0;
							}
							if (num701 > Main.worldSurface + 50.0)
							{
								num701 = Main.worldSurface + 50.0;
							}
							i2 = num702;
							bool flag48 = false;
							for (int num703 = (int)worldSurfaceLow; (double)num703 < num701; num703++)
							{
								if (Main.tile[i2, num703].active())
								{
									if (Main.tile[i2, num703].type == 53 && i2 >= num693 + genRand.Next(5) && i2 <= num694 - genRand.Next(5))
									{
										Main.tile[i2, num703].type = 234;
									}
									if (Main.tile[i2, num703].type == 0 && (double)num703 < Main.worldSurface - 1.0 && !flag48)
									{
										grassSpread = 0;
										SpreadGrass(i2, num703, 0, 199, repeat: true, 0);
									}
									flag48 = true;
									if (Main.tile[i2, num703].wall == 216)
									{
										Main.tile[i2, num703].wall = 218;
									}
									else if (Main.tile[i2, num703].wall == 187)
									{
										Main.tile[i2, num703].wall = 221;
									}
									if (Main.tile[i2, num703].type == 1)
									{
										if (i2 >= num693 + genRand.Next(5) && i2 <= num694 - genRand.Next(5))
										{
											Main.tile[i2, num703].type = 203;
										}
									}
									else if (Main.tile[i2, num703].type == 2)
									{
										Main.tile[i2, num703].type = 199;
									}
									else if (Main.tile[i2, num703].type == 161)
									{
										Main.tile[i2, num703].type = 200;
									}
									else if (Main.tile[i2, num703].type == 396)
									{
										Main.tile[i2, num703].type = 401;
									}
									else if (Main.tile[i2, num703].type == 397)
									{
										Main.tile[i2, num703].type = 399;
									}
								}
							}
						}
						int num704 = genRand.Next(10, 15);
						for (int num705 = 0; num705 < num704; num705++)
						{
							int num706 = 0;
							bool flag49 = false;
							int num707 = 0;
							while (!flag49)
							{
								num706++;
								int num708 = genRand.Next(num693 - num707, num694 + num707);
								int num709 = genRand.Next((int)(Main.worldSurface - (double)(num707 / 2)), (int)(Main.worldSurface + 100.0 + (double)num707));
								while (oceanDepths(num708, num709))
								{
									num708 = genRand.Next(num693 - num707, num694 + num707);
									num709 = genRand.Next((int)(Main.worldSurface - (double)(num707 / 2)), (int)(Main.worldSurface + 100.0 + (double)num707));
								}
								if (num706 > 100)
								{
									num707++;
									num706 = 0;
								}
								if (!Main.tile[num708, num709].active())
								{
									for (; !Main.tile[num708, num709].active(); num709++)
									{
									}
									num709--;
								}
								else
								{
									while (Main.tile[num708, num709].active() && (double)num709 > Main.worldSurface)
									{
										num709--;
									}
								}
								if ((num707 > 10 || (Main.tile[num708, num709 + 1].active() && Main.tile[num708, num709 + 1].type == 203)) && !IsTileNearby(num708, num709, 26, 3))
								{
									Place3x2(num708, num709, 26, 1);
									if (Main.tile[num708, num709].type == 26)
									{
										flag49 = true;
									}
								}
								if (num707 > 100)
								{
									flag49 = true;
								}
							}
						}
					}
					CrimPlaceHearts();
				}
				if (drunkWorldGen)
				{
					flag45 = false;
				}
				if (!flag45)
				{
					progress.Message = Lang.gen[20].Value;
					for (int num710 = 0; (double)num710 < num686; num710++)
					{
						int num711 = num679;
						int num712 = num680;
						int num713 = num677;
						int num714 = num678;
						float value16 = (float)num710 / (float)num686;
						progress.Set(value16);
						bool flag50 = false;
						int num715 = 0;
						int num716 = 0;
						int num717 = 0;
						while (!flag50)
						{
							flag50 = true;
							int num718 = Main.maxTilesX / 2;
							int num719 = 200;
							num715 = ((!drunkWorldGen) ? genRand.Next(num684, Main.maxTilesX - num684) : (flag46 ? genRand.Next((int)((double)Main.maxTilesX * 0.5), Main.maxTilesX - num684) : genRand.Next(num684, (int)((double)Main.maxTilesX * 0.5))));
							num716 = num715 - genRand.Next(200) - 100;
							num717 = num715 + genRand.Next(200) + 100;
							if (num716 < evilBiomeBeachAvoidance)
							{
								num716 = evilBiomeBeachAvoidance;
							}
							if (num717 > Main.maxTilesX - evilBiomeBeachAvoidance)
							{
								num717 = Main.maxTilesX - evilBiomeBeachAvoidance;
							}
							if (num715 < num716 + evilBiomeAvoidanceMidFixer)
							{
								num715 = num716 + evilBiomeAvoidanceMidFixer;
							}
							if (num715 > num717 - evilBiomeAvoidanceMidFixer)
							{
								num715 = num717 - evilBiomeAvoidanceMidFixer;
							}
							if (num715 > num718 - num719 && num715 < num718 + num719)
							{
								flag50 = false;
							}
							if (num716 > num718 - num719 && num716 < num718 + num719)
							{
								flag50 = false;
							}
							if (num717 > num718 - num719 && num717 < num718 + num719)
							{
								flag50 = false;
							}
							if (num715 > UndergroundDesertLocation.X && num715 < UndergroundDesertLocation.X + UndergroundDesertLocation.Width)
							{
								flag50 = false;
							}
							if (num716 > UndergroundDesertLocation.X && num716 < UndergroundDesertLocation.X + UndergroundDesertLocation.Width)
							{
								flag50 = false;
							}
							if (num717 > UndergroundDesertLocation.X && num717 < UndergroundDesertLocation.X + UndergroundDesertLocation.Width)
							{
								flag50 = false;
							}
							if (num716 < dungeonLocation + num685 && num717 > dungeonLocation - num685)
							{
								flag50 = false;
							}
							if (num716 < num712 && num717 > num711)
							{
								num711++;
								num712--;
								flag50 = false;
							}
							if (num716 < num714 && num717 > num713)
							{
								num713++;
								num714--;
								flag50 = false;
							}
						}
						int num720 = 0;
						for (int num721 = num716; num721 < num717; num721++)
						{
							if (num720 > 0)
							{
								num720--;
							}
							if (num721 == num715 || num720 == 0)
							{
								for (int num722 = (int)worldSurfaceLow; (double)num722 < Main.worldSurface - 1.0; num722++)
								{
									if (Main.tile[num721, num722].active() || Main.tile[num721, num722].wall > 0)
									{
										if (num721 == num715)
										{
											num720 = 20;
											ChasmRunner(num721, num722, genRand.Next(150) + 150, makeOrb: true);
										}
										else if (genRand.Next(35) == 0 && num720 == 0)
										{
											num720 = 30;
											bool makeOrb = true;
											ChasmRunner(num721, num722, genRand.Next(50) + 50, makeOrb);
										}
										break;
									}
								}
							}
							for (int num723 = (int)worldSurfaceLow; (double)num723 < Main.worldSurface - 1.0; num723++)
							{
								if (Main.tile[num721, num723].active())
								{
									int num724 = num723 + genRand.Next(10, 14);
									for (int num725 = num723; num725 < num724; num725++)
									{
										if ((Main.tile[num721, num725].type == 59 || Main.tile[num721, num725].type == 60) && num721 >= num716 + genRand.Next(5) && num721 < num717 - genRand.Next(5))
										{
											Main.tile[num721, num725].type = 0;
										}
									}
									break;
								}
							}
						}
						double num726 = Main.worldSurface + 40.0;
						for (int num727 = num716; num727 < num717; num727++)
						{
							num726 += (double)genRand.Next(-2, 3);
							if (num726 < Main.worldSurface + 30.0)
							{
								num726 = Main.worldSurface + 30.0;
							}
							if (num726 > Main.worldSurface + 50.0)
							{
								num726 = Main.worldSurface + 50.0;
							}
							i2 = num727;
							bool flag51 = false;
							for (int num728 = (int)worldSurfaceLow; (double)num728 < num726; num728++)
							{
								if (Main.tile[i2, num728].active())
								{
									if (Main.tile[i2, num728].type == 53 && i2 >= num716 + genRand.Next(5) && i2 <= num717 - genRand.Next(5))
									{
										Main.tile[i2, num728].type = 112;
									}
									if (Main.tile[i2, num728].type == 0 && (double)num728 < Main.worldSurface - 1.0 && !flag51)
									{
										grassSpread = 0;
										SpreadGrass(i2, num728, 0, 23, repeat: true, 0);
									}
									flag51 = true;
									if (Main.tile[i2, num728].type == 1 && i2 >= num716 + genRand.Next(5) && i2 <= num717 - genRand.Next(5))
									{
										Main.tile[i2, num728].type = 25;
									}
									if (Main.tile[i2, num728].wall == 216)
									{
										Main.tile[i2, num728].wall = 217;
									}
									else if (Main.tile[i2, num728].wall == 187)
									{
										Main.tile[i2, num728].wall = 220;
									}
									if (Main.tile[i2, num728].type == 2)
									{
										Main.tile[i2, num728].type = 23;
									}
									if (Main.tile[i2, num728].type == 161)
									{
										Main.tile[i2, num728].type = 163;
									}
									else if (Main.tile[i2, num728].type == 396)
									{
										Main.tile[i2, num728].type = 400;
									}
									else if (Main.tile[i2, num728].type == 397)
									{
										Main.tile[i2, num728].type = 398;
									}
								}
							}
						}
						for (int num729 = num716; num729 < num717; num729++)
						{
							for (int num730 = 0; num730 < Main.maxTilesY - 50; num730++)
							{
								if (Main.tile[num729, num730].active() && Main.tile[num729, num730].type == 31)
								{
									int num731 = num729 - 13;
									int num732 = num729 + 13;
									int num733 = num730 - 13;
									int num734 = num730 + 13;
									for (int num735 = num731; num735 < num732; num735++)
									{
										if (num735 > 10 && num735 < Main.maxTilesX - 10)
										{
											for (int num736 = num733; num736 < num734; num736++)
											{
												if (Math.Abs(num735 - num729) + Math.Abs(num736 - num730) < 9 + genRand.Next(11) && genRand.Next(3) != 0 && Main.tile[num735, num736].type != 31)
												{
													Main.tile[num735, num736].active(active: true);
													Main.tile[num735, num736].type = 25;
													if (Math.Abs(num735 - num729) <= 1 && Math.Abs(num736 - num730) <= 1)
													{
														Main.tile[num735, num736].active(active: false);
													}
												}
												if (Main.tile[num735, num736].type != 31 && Math.Abs(num735 - num729) <= 2 + genRand.Next(3) && Math.Abs(num736 - num730) <= 2 + genRand.Next(3))
												{
													Main.tile[num735, num736].active(active: false);
												}
											}
										}
									}
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Lakes", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[19].Value;
				int num658 = Main.maxTilesX / 4200;
				int num659 = genRand.Next(num658 * 3, num658 * 6);
				for (int num660 = 0; num660 < num659; num660++)
				{
					int num661 = Main.maxTilesX / 4;
					if (numLakes >= maxLakes - 1)
					{
						break;
					}
					float value14 = (float)num660 / (float)num659;
					progress.Set(value14);
					while (num661 > 0)
					{
						bool flag44 = false;
						num661--;
						int num662 = genRand.Next(lakesBeachAvoidance, Main.maxTilesX - lakesBeachAvoidance);
						while ((double)num662 > (double)Main.maxTilesX * 0.45 && (double)num662 < (double)Main.maxTilesX * 0.55)
						{
							num662 = genRand.Next(lakesBeachAvoidance, Main.maxTilesX - lakesBeachAvoidance);
						}
						for (int num663 = 0; num663 < numLakes; num663++)
						{
							if (Math.Abs(num662 - LakeX[num663]) < 150)
							{
								flag44 = true;
								break;
							}
						}
						for (int num664 = 0; num664 < numMCaves; num664++)
						{
							if (Math.Abs(num662 - mCaveX[num664]) < 100)
							{
								flag44 = true;
								break;
							}
						}
						for (int num665 = 0; num665 < numTunnels; num665++)
						{
							if (Math.Abs(num662 - tunnelX[num665]) < 100)
							{
								flag44 = true;
								break;
							}
						}
						if (!flag44)
						{
							int num666 = (int)worldSurfaceLow - 20;
							while (!Main.tile[num662, num666].active())
							{
								num666++;
								if ((double)num666 >= Main.worldSurface || Main.tile[num662, num666].wall > 0)
								{
									flag44 = true;
									break;
								}
							}
							if (Main.tile[num662, num666].type == 53)
							{
								flag44 = true;
							}
							if (!flag44)
							{
								int num667 = 50;
								for (int num668 = num662 - num667; num668 <= num662 + num667; num668++)
								{
									for (int num669 = num666 - num667; num669 <= num666 + num667; num669++)
									{
										if (Main.tile[num668, num669].type == 203 || Main.tile[num668, num669].type == 25)
										{
											flag44 = true;
											break;
										}
									}
								}
								if (!flag44)
								{
									int num670 = num666;
									num667 = 20;
									while (!SolidTile(num662 - num667, num666) || !SolidTile(num662 + num667, num666))
									{
										num666++;
										if ((double)num666 > Main.worldSurface - 50.0)
										{
											flag44 = true;
										}
									}
									if (num666 - num670 <= 10)
									{
										num667 = 60;
										for (int num671 = num662 - num667; num671 <= num662 + num667; num671++)
										{
											int num672 = num666 - 20;
											if (Main.tile[num671, num672].active() || Main.tile[num671, num672].wall > 0)
											{
												flag44 = true;
											}
										}
										if (!flag44)
										{
											int num673 = 0;
											for (int num674 = num662 - num667; num674 <= num662 + num667; num674++)
											{
												for (int num675 = num666; num675 <= num666 + num667 * 2; num675++)
												{
													if (SolidTile(num674, num675))
													{
														num673++;
													}
												}
											}
											int num676 = (num667 * 2 + 1) * (num667 * 2 + 1);
											if (!((double)num673 < (double)num676 * 0.8) && !UndergroundDesertLocation.Intersects(new Rectangle(num662 - 8, num666 - 8, 16, 16)))
											{
												SonOfLakinater(num662, num666);
												LakeX[numLakes] = num662;
												numLakes++;
												break;
											}
										}
									}
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Dungeon", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1f);
				int num653 = dungeonLocation;
				int num654 = (int)((Main.worldSurface + Main.rockLayer) / 2.0) + genRand.Next(-200, 200);
				int num655 = (int)((Main.worldSurface + Main.rockLayer) / 2.0) + 200;
				int num656 = num654;
				bool flag43 = false;
				for (int num657 = 0; num657 < 10; num657++)
				{
					if (SolidTile(num653, num656 + num657))
					{
						flag43 = true;
						break;
					}
				}
				if (!flag43)
				{
					for (; num656 < num655 && !SolidTile(num653, num656 + 10); num656++)
					{
					}
				}
				if (drunkWorldGen)
				{
					num656 = (int)Main.worldSurface + 70;
				}
				MakeDungeon(num653, num656);
			});
			AddGenerationPass("Slush", delegate
			{
				for (int num648 = snowTop; num648 < snowBottom; num648++)
				{
					for (int num649 = snowMinX[num648]; num649 < snowMaxX[num648]; num649++)
					{
						switch (Main.tile[num649, num648].type)
						{
						case 123:
							Main.tile[num649, num648].type = 224;
							break;
						case 59:
						{
							bool flag42 = true;
							int num650 = 3;
							for (int num651 = num649 - num650; num651 <= num649 + num650; num651++)
							{
								for (int num652 = num648 - num650; num652 <= num648 + num650; num652++)
								{
									if (Main.tile[num651, num652].type == 60 || Main.tile[num651, num652].type == 70 || Main.tile[num651, num652].type == 71 || Main.tile[num651, num652].type == 72)
									{
										flag42 = false;
										break;
									}
								}
							}
							if (flag42)
							{
								Main.tile[num649, num648].type = 224;
							}
							break;
						}
						case 1:
							Main.tile[num649, num648].type = 161;
							break;
						}
					}
				}
			});
			AddGenerationPass("Mountain Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[21].Value;
				for (int num647 = 0; num647 < numMCaves; num647++)
				{
					int i4 = mCaveX[num647];
					int j3 = mCaveY[num647];
					CaveOpenater(i4, j3);
					Cavinator(i4, j3, genRand.Next(40, 50));
				}
			});
			AddGenerationPass("Beaches", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[22].Value;
				bool floridaStyle = false;
				bool floridaStyle2 = false;
				if (genRand.Next(4) == 0)
				{
					if (genRand.Next(2) == 0)
					{
						floridaStyle = true;
					}
					else
					{
						floridaStyle2 = true;
					}
				}
				for (int num630 = 0; num630 < 2; num630++)
				{
					int num631 = 0;
					int num632 = 0;
					if (num630 == 0)
					{
						num631 = 0;
						num632 = genRand.Next(oceanWaterStartRandomMin, oceanWaterStartRandomMax);
						if (dungeonSide == 1)
						{
							num632 = oceanWaterForcedJungleLength;
						}
						int num633 = leftBeachEnd - minSsandBeforeWater;
						if (num632 > num633)
						{
							num632 = num633;
						}
						int num634 = 0;
						float num635 = 1f;
						int num636;
						for (num636 = 0; !Main.tile[num632 - 1, num636].active(); num636++)
						{
						}
						shellStartYLeft = num636;
						num636 += genRand.Next(1, 5);
						for (int num637 = num632 - 1; num637 >= num631; num637--)
						{
							if (num637 > 30)
							{
								num634++;
								num635 = TuneOceanDepth(num634, num635, floridaStyle);
							}
							else
							{
								num635 += 1f;
							}
							int num638 = genRand.Next(15, 20);
							for (int num639 = 0; (float)num639 < (float)num636 + num635 + (float)num638; num639++)
							{
								if ((float)num639 < (float)num636 + num635 * 0.75f - 3f)
								{
									Main.tile[num637, num639].active(active: false);
									if (num639 > num636)
									{
										Main.tile[num637, num639].liquid = byte.MaxValue;
									}
									else if (num639 == num636)
									{
										Main.tile[num637, num639].liquid = 127;
										if (shellStartXLeft == 0)
										{
											shellStartXLeft = num637;
										}
									}
								}
								else if (num639 > num636)
								{
									Main.tile[num637, num639].type = 53;
									Main.tile[num637, num639].active(active: true);
								}
								Main.tile[num637, num639].wall = 0;
							}
						}
					}
					else
					{
						num631 = Main.maxTilesX - genRand.Next(oceanWaterStartRandomMin, oceanWaterStartRandomMax);
						num632 = Main.maxTilesX;
						if (dungeonSide == -1)
						{
							num631 = Main.maxTilesX - oceanWaterForcedJungleLength;
						}
						int num640 = rightBeachStart + minSsandBeforeWater;
						if (num631 < num640)
						{
							num631 = num640;
						}
						float num641 = 1f;
						int num642 = 0;
						int num643;
						for (num643 = 0; !Main.tile[num631, num643].active(); num643++)
						{
						}
						shellStartXRight = 0;
						shellStartYRight = num643;
						num643 += genRand.Next(1, 5);
						for (int num644 = num631; num644 < num632; num644++)
						{
							if (num644 < num632 - 30)
							{
								num642++;
								num641 = TuneOceanDepth(num642, num641, floridaStyle2);
							}
							else
							{
								num641 += 1f;
							}
							int num645 = genRand.Next(15, 20);
							for (int num646 = 0; (float)num646 < (float)num643 + num641 + (float)num645; num646++)
							{
								if ((float)num646 < (float)num643 + num641 * 0.75f - 3f)
								{
									Main.tile[num644, num646].active(active: false);
									if (num646 > num643)
									{
										Main.tile[num644, num646].liquid = byte.MaxValue;
									}
									else if (num646 == num643)
									{
										Main.tile[num644, num646].liquid = 127;
										if (shellStartXRight == 0)
										{
											shellStartXRight = num644;
										}
									}
								}
								else if (num646 > num643)
								{
									Main.tile[num644, num646].type = 53;
									Main.tile[num644, num646].active(active: true);
								}
								Main.tile[num644, num646].wall = 0;
							}
						}
					}
				}
			});
			AddGenerationPass("Gems", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[23].Value;
				Main.tileSolid[484] = false;
				for (int num617 = 63; num617 <= 68; num617++)
				{
					float value13 = (float)(num617 - 63) / 6f;
					progress.Set(value13);
					float num618 = 0f;
					switch (num617)
					{
					case 67:
						num618 = (float)Main.maxTilesX * 0.5f;
						break;
					case 66:
						num618 = (float)Main.maxTilesX * 0.45f;
						break;
					case 63:
						num618 = (float)Main.maxTilesX * 0.3f;
						break;
					case 65:
						num618 = (float)Main.maxTilesX * 0.25f;
						break;
					case 64:
						num618 = (float)Main.maxTilesX * 0.1f;
						break;
					case 68:
						num618 = (float)Main.maxTilesX * 0.05f;
						break;
					}
					num618 *= 0.2f;
					for (int num619 = 0; (float)num619 < num618; num619++)
					{
						int num620 = genRand.Next(0, Main.maxTilesX);
						int num621 = genRand.Next((int)Main.worldSurface, Main.maxTilesY);
						while (Main.tile[num620, num621].type != 1)
						{
							num620 = genRand.Next(0, Main.maxTilesX);
							num621 = genRand.Next((int)Main.worldSurface, Main.maxTilesY);
						}
						TileRunner(num620, num621, genRand.Next(2, 6), genRand.Next(3, 7), num617);
					}
				}
				for (int num622 = 0; num622 < 2; num622++)
				{
					int num623 = 1;
					int num624 = 5;
					int num625 = Main.maxTilesX - 5;
					if (num622 == 1)
					{
						num623 = -1;
						num624 = Main.maxTilesX - 5;
						num625 = 5;
					}
					for (int num626 = num624; num626 != num625; num626 += num623)
					{
						if (num626 <= UndergroundDesertLocation.Left || num626 >= UndergroundDesertLocation.Right)
						{
							for (int num627 = 10; num627 < Main.maxTilesY - 10; num627++)
							{
								if (Main.tile[num626, num627].active() && Main.tile[num626, num627 + 1].active() && Main.tileSand[Main.tile[num626, num627].type] && Main.tileSand[Main.tile[num626, num627 + 1].type])
								{
									ushort type8 = Main.tile[num626, num627].type;
									int num628 = num626 + num623;
									int num629 = num627 + 1;
									if (!Main.tile[num628, num627].active() && !Main.tile[num628, num629].active())
									{
										for (; !Main.tile[num628, num629].active(); num629++)
										{
										}
										num629--;
										Main.tile[num626, num627].active(active: false);
										Main.tile[num628, num629].active(active: true);
										Main.tile[num628, num629].type = type8;
									}
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Gravitating Sand", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[24].Value;
				for (int num613 = 0; num613 < Main.maxTilesX; num613++)
				{
					float value12 = (float)num613 / (float)(Main.maxTilesX - 1);
					progress.Set(value12);
					bool flag41 = false;
					int num614 = 0;
					for (int num615 = Main.maxTilesY - 1; num615 > 0; num615--)
					{
						if (SolidOrSlopedTile(num613, num615))
						{
							ushort type7 = Main.tile[num613, num615].type;
							if (flag41 && num615 < (int)Main.worldSurface && num615 != num614 - 1 && TileID.Sets.Falling[type7])
							{
								for (int num616 = num615; num616 < num614; num616++)
								{
									Main.tile[num613, num616].ResetToType(type7);
								}
							}
							flag41 = true;
							num614 = num615;
						}
					}
				}
			});
			AddGenerationPass("Create Ocean Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				for (int num610 = 0; num610 < 2; num610++)
				{
					if (genRand.Next(4) == 0 || drunkWorldGen)
					{
						progress.Message = Lang.gen[90].Value;
						int num611 = genRand.Next(55, 95);
						if (num610 == 1)
						{
							num611 = genRand.Next(Main.maxTilesX - 95, Main.maxTilesX - 55);
						}
						int num612;
						for (num612 = 0; !Main.tile[num611, num612].active(); num612++)
						{
						}
						oceanCave(num611, num612);
					}
				}
			});
			AddGenerationPass("Clean Up Dirt", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[25].Value;
				for (int num604 = 3; num604 < Main.maxTilesX - 3; num604++)
				{
					float num605 = (float)num604 / (float)Main.maxTilesX;
					progress.Set(0.5f * num605);
					bool flag39 = true;
					for (int num606 = 0; (double)num606 < Main.worldSurface; num606++)
					{
						if (flag39)
						{
							if (Main.tile[num604, num606].wall == 2 || Main.tile[num604, num606].wall == 40 || Main.tile[num604, num606].wall == 64 || Main.tile[num604, num606].wall == 86)
							{
								Main.tile[num604, num606].wall = 0;
							}
							if (Main.tile[num604, num606].type != 53 && Main.tile[num604, num606].type != 112 && Main.tile[num604, num606].type != 234)
							{
								if (Main.tile[num604 - 1, num606].wall == 2 || Main.tile[num604 - 1, num606].wall == 40 || Main.tile[num604 - 1, num606].wall == 40)
								{
									Main.tile[num604 - 1, num606].wall = 0;
								}
								if ((Main.tile[num604 - 2, num606].wall == 2 || Main.tile[num604 - 2, num606].wall == 40 || Main.tile[num604 - 2, num606].wall == 40) && genRand.Next(2) == 0)
								{
									Main.tile[num604 - 2, num606].wall = 0;
								}
								if ((Main.tile[num604 - 3, num606].wall == 2 || Main.tile[num604 - 3, num606].wall == 40 || Main.tile[num604 - 3, num606].wall == 40) && genRand.Next(2) == 0)
								{
									Main.tile[num604 - 3, num606].wall = 0;
								}
								if (Main.tile[num604 + 1, num606].wall == 2 || Main.tile[num604 + 1, num606].wall == 40 || Main.tile[num604 + 1, num606].wall == 40)
								{
									Main.tile[num604 + 1, num606].wall = 0;
								}
								if ((Main.tile[num604 + 2, num606].wall == 2 || Main.tile[num604 + 2, num606].wall == 40 || Main.tile[num604 + 2, num606].wall == 40) && genRand.Next(2) == 0)
								{
									Main.tile[num604 + 2, num606].wall = 0;
								}
								if ((Main.tile[num604 + 3, num606].wall == 2 || Main.tile[num604 + 3, num606].wall == 40 || Main.tile[num604 + 3, num606].wall == 40) && genRand.Next(2) == 0)
								{
									Main.tile[num604 + 3, num606].wall = 0;
								}
								if (Main.tile[num604, num606].active())
								{
									flag39 = false;
								}
							}
						}
						else if (Main.tile[num604, num606].wall == 0 && Main.tile[num604, num606 + 1].wall == 0 && Main.tile[num604, num606 + 2].wall == 0 && Main.tile[num604, num606 + 3].wall == 0 && Main.tile[num604, num606 + 4].wall == 0 && Main.tile[num604 - 1, num606].wall == 0 && Main.tile[num604 + 1, num606].wall == 0 && Main.tile[num604 - 2, num606].wall == 0 && Main.tile[num604 + 2, num606].wall == 0 && !Main.tile[num604, num606].active() && !Main.tile[num604, num606 + 1].active() && !Main.tile[num604, num606 + 2].active() && !Main.tile[num604, num606 + 3].active())
						{
							flag39 = true;
						}
					}
				}
				for (int num607 = Main.maxTilesX - 5; num607 >= 5; num607--)
				{
					float num608 = (float)num607 / (float)Main.maxTilesX;
					progress.Set(1f - 0.5f * num608);
					bool flag40 = true;
					for (int num609 = 0; (double)num609 < Main.worldSurface; num609++)
					{
						if (flag40)
						{
							if (Main.tile[num607, num609].wall == 2 || Main.tile[num607, num609].wall == 40 || Main.tile[num607, num609].wall == 64)
							{
								Main.tile[num607, num609].wall = 0;
							}
							if (Main.tile[num607, num609].type != 53)
							{
								if (Main.tile[num607 - 1, num609].wall == 2 || Main.tile[num607 - 1, num609].wall == 40 || Main.tile[num607 - 1, num609].wall == 40)
								{
									Main.tile[num607 - 1, num609].wall = 0;
								}
								if ((Main.tile[num607 - 2, num609].wall == 2 || Main.tile[num607 - 2, num609].wall == 40 || Main.tile[num607 - 2, num609].wall == 40) && genRand.Next(2) == 0)
								{
									Main.tile[num607 - 2, num609].wall = 0;
								}
								if ((Main.tile[num607 - 3, num609].wall == 2 || Main.tile[num607 - 3, num609].wall == 40 || Main.tile[num607 - 3, num609].wall == 40) && genRand.Next(2) == 0)
								{
									Main.tile[num607 - 3, num609].wall = 0;
								}
								if (Main.tile[num607 + 1, num609].wall == 2 || Main.tile[num607 + 1, num609].wall == 40 || Main.tile[num607 + 1, num609].wall == 40)
								{
									Main.tile[num607 + 1, num609].wall = 0;
								}
								if ((Main.tile[num607 + 2, num609].wall == 2 || Main.tile[num607 + 2, num609].wall == 40 || Main.tile[num607 + 2, num609].wall == 40) && genRand.Next(2) == 0)
								{
									Main.tile[num607 + 2, num609].wall = 0;
								}
								if ((Main.tile[num607 + 3, num609].wall == 2 || Main.tile[num607 + 3, num609].wall == 40 || Main.tile[num607 + 3, num609].wall == 40) && genRand.Next(2) == 0)
								{
									Main.tile[num607 + 3, num609].wall = 0;
								}
								if (Main.tile[num607, num609].active())
								{
									flag40 = false;
								}
							}
						}
						else if (Main.tile[num607, num609].wall == 0 && Main.tile[num607, num609 + 1].wall == 0 && Main.tile[num607, num609 + 2].wall == 0 && Main.tile[num607, num609 + 3].wall == 0 && Main.tile[num607, num609 + 4].wall == 0 && Main.tile[num607 - 1, num609].wall == 0 && Main.tile[num607 + 1, num609].wall == 0 && Main.tile[num607 - 2, num609].wall == 0 && Main.tile[num607 + 2, num609].wall == 0 && !Main.tile[num607, num609].active() && !Main.tile[num607, num609 + 1].active() && !Main.tile[num607, num609 + 2].active() && !Main.tile[num607, num609 + 3].active())
						{
							flag40 = true;
						}
					}
				}
			});
			AddGenerationPass("Pyramids", delegate
			{
				for (int num597 = 0; num597 < numPyr; num597++)
				{
					int num598 = PyrX[num597];
					int num599 = PyrY[num597];
					if (num598 > 300 && num598 < Main.maxTilesX - 300 && (dungeonSide >= 0 || !((double)num598 < (double)dungeonX + (double)Main.maxTilesX * 0.15)) && (dungeonSide <= 0 || !((double)num598 > (double)dungeonX - (double)Main.maxTilesX * 0.15)))
					{
						for (; !Main.tile[num598, num599].active() && (double)num599 < Main.worldSurface; num599++)
						{
						}
						if ((double)num599 < Main.worldSurface && Main.tile[num598, num599].type == 53)
						{
							int num600 = Main.maxTilesX;
							for (int num601 = 0; num601 < num597; num601++)
							{
								int num602 = Math.Abs(num598 - PyrX[num601]);
								if (num602 < num600)
								{
									num600 = num602;
								}
							}
							int num603 = 220;
							if (drunkWorldGen)
							{
								num603 /= 2;
							}
							if (num600 >= num603)
							{
								num599--;
								Pyramid(num598, num599);
							}
						}
					}
				}
			});
			AddGenerationPass("Dirt Rock Wall Runner", delegate
			{
				for (int num594 = 0; num594 < Main.maxTilesX; num594++)
				{
					int num595 = genRand.Next(10, Main.maxTilesX - 10);
					int num596 = genRand.Next(10, (int)Main.worldSurface);
					if (Main.tile[num595, num596].wall == 2)
					{
						DirtyRockRunner(num595, num596);
					}
				}
			});
			AddGenerationPass("Living Trees", delegate
			{
				int num577 = 200;
				float num578 = Main.maxTilesX / 4200;
				int num579 = genRand.Next(0, (int)(2f * num578) + 1);
				if (num579 == 0 && genRand.Next(2) == 0)
				{
					num579++;
				}
				if (drunkWorldGen)
				{
					num579 += (int)(2f * num578);
				}
				for (int num580 = 0; num580 < num579; num580++)
				{
					bool flag37 = false;
					int num581 = 0;
					while (!flag37)
					{
						num581++;
						if (num581 > Main.maxTilesX / 2)
						{
							flag37 = true;
						}
						int num582 = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
						if (num582 <= Main.maxTilesX / 2 - num577 || num582 >= Main.maxTilesX / 2 + num577)
						{
							int num583;
							for (num583 = 0; !Main.tile[num582, num583].active() && (double)num583 < Main.worldSurface; num583++)
							{
							}
							if (Main.tile[num582, num583].type == 0)
							{
								num583--;
								if (num583 > 150)
								{
									bool flag38 = true;
									for (int num584 = num582 - 50; num584 < num582 + 50; num584++)
									{
										for (int num585 = num583 - 50; num585 < num583 + 50; num585++)
										{
											if (Main.tile[num584, num585].active())
											{
												switch (Main.tile[num584, num585].type)
												{
												case 41:
												case 43:
												case 44:
												case 189:
												case 196:
												case 460:
												case 481:
												case 482:
												case 483:
													flag38 = false;
													break;
												}
											}
										}
									}
									for (int num586 = 0; num586 < numMCaves; num586++)
									{
										if (num582 > mCaveX[num586] - 50 && num582 < mCaveX[num586] + 50)
										{
											flag38 = false;
											break;
										}
									}
									if (flag38)
									{
										flag37 = GrowLivingTree(num582, num583);
										if (flag37)
										{
											for (int num587 = -1; num587 <= 1; num587++)
											{
												if (num587 != 0)
												{
													int num588 = num582;
													int num589 = genRand.Next(4);
													if (drunkWorldGen)
													{
														num589 += genRand.Next(2, 5);
													}
													for (int num590 = 0; num590 < num589; num590++)
													{
														num588 += genRand.Next(13, 31) * num587;
														if (num588 <= Main.maxTilesX / 2 - num577 || num588 >= Main.maxTilesX / 2 + num577)
														{
															int num591 = num583;
															if (Main.tile[num588, num591].active())
															{
																while (Main.tile[num588, num591].active())
																{
																	num591--;
																}
															}
															else
															{
																for (; !Main.tile[num588, num591].active(); num591++)
																{
																}
																num591--;
															}
															flag38 = true;
															for (int num592 = num582 - 50; num592 < num582 + 50; num592++)
															{
																for (int num593 = num583 - 50; num593 < num583 + 50; num593++)
																{
																	if (Main.tile[num592, num593].active())
																	{
																		switch (Main.tile[num592, num593].type)
																		{
																		case 41:
																		case 43:
																		case 44:
																		case 189:
																		case 196:
																		case 460:
																		case 481:
																		case 482:
																		case 483:
																			flag38 = false;
																			break;
																		}
																	}
																}
															}
															if (flag38)
															{
																GrowLivingTree(num588, num591, patch: true);
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				Main.tileSolid[192] = false;
			});
			AddGenerationPass("Wood Tree Walls", delegate
			{
				for (int num573 = 25; num573 < Main.maxTilesX - 25; num573++)
				{
					for (int num574 = 25; (double)num574 < Main.worldSurface; num574++)
					{
						if (Main.tile[num573, num574].type == 191 || Main.tile[num573, num574 - 1].type == 191 || Main.tile[num573 - 1, num574].type == 191 || Main.tile[num573 + 1, num574].type == 191 || Main.tile[num573, num574 + 1].type == 191)
						{
							bool flag36 = true;
							for (int num575 = num573 - 1; num575 <= num573 + 1; num575++)
							{
								for (int num576 = num574 - 1; num576 <= num574 + 1; num576++)
								{
									if (num575 != num573 && num576 != num574 && Main.tile[num575, num576].type != 191 && Main.tile[num575, num576].wall != 244)
									{
										flag36 = false;
									}
								}
							}
							if (flag36)
							{
								Main.tile[num573, num574].wall = 244;
							}
						}
					}
				}
			});
			AddGenerationPass("Altars", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				Main.tileSolid[484] = false;
				progress.Message = Lang.gen[26].Value;
				int num568 = (int)((float)(Main.maxTilesX * Main.maxTilesY) * 2E-05f);
				for (int num569 = 0; num569 < num568; num569++)
				{
					progress.Set((float)num569 / (float)num568);
					for (int num570 = 0; num570 < 10000; num570++)
					{
						int num571 = genRand.Next(281, Main.maxTilesX - 3 - 280);
						while ((double)num571 > (double)Main.maxTilesX * 0.45 && (double)num571 < (double)Main.maxTilesX * 0.55)
						{
							num571 = genRand.Next(281, Main.maxTilesX - 3 - 280);
						}
						int num572 = (int)(Main.worldSurface * 2.0 + Main.rockLayer) / 3;
						while (oceanDepths(num571, num572))
						{
							num571 = genRand.Next(281, Main.maxTilesX - 3 - 280);
							while ((double)num571 > (double)Main.maxTilesX * 0.45 && (double)num571 < (double)Main.maxTilesX * 0.55)
							{
								num571 = genRand.Next(281, Main.maxTilesX - 3 - 280);
							}
							num572 = (int)(Main.worldSurface * 2.0 + Main.rockLayer) / 3;
						}
						int style2 = (crimson ? 1 : 0);
						if (!IsTileNearby(num571, num572, 26, 3))
						{
							Place3x2(num571, num572, 26, style2);
						}
						if (Main.tile[num571, num572].type == 26)
						{
							break;
						}
					}
				}
			});
			AddGenerationPass("Wet Jungle", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1f);
				for (int num566 = 0; num566 < Main.maxTilesX; num566++)
				{
					i2 = num566;
					for (int num567 = (int)worldSurfaceLow; (double)num567 < Main.worldSurface - 1.0; num567++)
					{
						if (Main.tile[i2, num567].active())
						{
							if (Main.tile[i2, num567].type == 60)
							{
								Main.tile[i2, num567 - 1].liquid = byte.MaxValue;
								Main.tile[i2, num567 - 2].liquid = byte.MaxValue;
							}
							break;
						}
					}
				}
			});
			AddGenerationPass("Jungle Temple", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				int num561 = 0;
				progress.Message = Lang.gen[70].Value;
				long num562 = 0L;
				double num563 = 0.25;
				while (true)
				{
					int num564 = genRand.Next((int)Main.rockLayer, Main.maxTilesY - 500);
					int num565 = (int)(((genRand.NextDouble() * num563 + 0.1) * (double)(-dungeonSide) + 0.5) * (double)Main.maxTilesX);
					if (Main.tile[num565, num564].active() && Main.tile[num565, num564].type == 60)
					{
						makeTemple(num565, num564);
						break;
					}
					if (num562++ > 2000000)
					{
						if (num563 == 0.35)
						{
							num561++;
							if (num561 > 10)
							{
								break;
							}
						}
						num563 = Math.Min(0.35, num563 + 0.05);
						num562 = 0L;
					}
				}
			});
			AddGenerationPass("Hives", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[71].Value;
				float num552 = Main.maxTilesX / 4200;
				float num553 = 1 + genRand.Next((int)(5f * num552), (int)(8f * num552));
				if (drunkWorldGen)
				{
					num553 *= 0.667f;
				}
				int num554 = 10000;
				HiveBiome hiveBiome = configuration.CreateBiome<HiveBiome>();
				while (num553 > 0f && num554 > 0)
				{
					num554--;
					Point origin3 = RandomWorldPoint((int)(Main.worldSurface + Main.rockLayer) >> 1, 20, 300, 20);
					if (drunkWorldGen)
					{
						RandomWorldPoint((int)Main.worldSurface, 20, 300, 20);
					}
					if (hiveBiome.Place(origin3, structures))
					{
						num553 -= 1f;
						int num555 = genRand.Next(5);
						int num556 = 0;
						int num557 = 10000;
						while (num556 < num555 && num557 > 0)
						{
							float num558 = genRand.NextFloat() * 60f + 30f;
							float num559 = genRand.NextFloat() * ((float)Math.PI * 2f);
							int num560 = (int)(Math.Cos(num559) * (double)num558) + origin3.X;
							int y12 = (int)(Math.Sin(num559) * (double)num558) + origin3.Y;
							num557--;
							if (num560 > 50 && num560 < Main.maxTilesX - 50 && hiveBiome.Place(new Point(num560, y12), structures))
							{
								num556++;
							}
						}
					}
				}
			});
			AddGenerationPass("Jungle Chests", delegate
			{
				int num526 = genRand.Next(40, Main.maxTilesX - 40);
				int num527 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 400);
				float num528 = genRand.Next(7, 12);
				num528 *= (float)(Main.maxTilesX / 4200);
				int num529 = 0;
				for (int num530 = 0; (float)num530 < num528; num530++)
				{
					bool flag34 = true;
					while (flag34)
					{
						num529++;
						num526 = genRand.Next(40, Main.maxTilesX / 2 - 40);
						if (dungeonSide < 0)
						{
							num526 += Main.maxTilesX / 2;
						}
						num527 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 400);
						if (Main.tile[num526, num527].type == 60)
						{
							int num531 = 30;
							flag34 = false;
							for (int num532 = num526 - num531; num532 < num526 + num531; num532 += 3)
							{
								for (int num533 = num527 - num531; num533 < num527 + num531; num533 += 3)
								{
									if (Main.tile[num532, num533].active() && (Main.tile[num532, num533].type == 225 || Main.tile[num532, num533].type == 229 || Main.tile[num532, num533].type == 226 || Main.tile[num532, num533].type == 119 || Main.tile[num532, num533].type == 120))
									{
										flag34 = true;
									}
									if (Main.tile[num532, num533].wall == 86 || Main.tile[num532, num533].wall == 87)
									{
										flag34 = true;
									}
								}
							}
						}
						if (!flag34)
						{
							int num534 = genRand.Next(2, 4);
							int num535 = genRand.Next(2, 4);
							ushort wall2 = 0;
							if (jungleHut == 119)
							{
								wall2 = 23;
							}
							else if (jungleHut == 120)
							{
								wall2 = 24;
							}
							else if (jungleHut == 158)
							{
								wall2 = 42;
							}
							else if (jungleHut == 175)
							{
								wall2 = 45;
							}
							else if (jungleHut == 45)
							{
								wall2 = 10;
							}
							for (int num536 = num526 - num534 - 1; num536 <= num526 + num534 + 1; num536++)
							{
								for (int num537 = num527 - num535 - 1; num537 <= num527 + num535 + 1; num537++)
								{
									Main.tile[num536, num537].active(active: true);
									Main.tile[num536, num537].type = jungleHut;
									Main.tile[num536, num537].liquid = 0;
									Main.tile[num536, num537].lava(lava: false);
								}
							}
							for (int num538 = num526 - num534; num538 <= num526 + num534; num538++)
							{
								for (int num539 = num527 - num535; num539 <= num527 + num535; num539++)
								{
									Main.tile[num538, num539].active(active: false);
									Main.tile[num538, num539].wall = wall2;
								}
							}
							bool flag35 = false;
							int num540 = 0;
							while (!flag35 && num540 < 100)
							{
								num540++;
								int num541 = genRand.Next(num526 - num534, num526 + num534 + 1);
								int num542 = genRand.Next(num527 - num535, num527 + num535 - 2);
								PlaceTile(num541, num542, 4, mute: true, forced: false, -1, 3);
								if (Main.tile[num541, num542].type == 4)
								{
									flag35 = true;
								}
							}
							for (int num543 = num526 - num534 - 1; num543 <= num526 + num534 + 1; num543++)
							{
								for (int num544 = num527 + num535 - 2; num544 <= num527 + num535; num544++)
								{
									Main.tile[num543, num544].active(active: false);
								}
							}
							for (int num545 = num526 - num534 - 1; num545 <= num526 + num534 + 1; num545++)
							{
								for (int num546 = num527 + num535 - 2; num546 <= num527 + num535 - 1; num546++)
								{
									Main.tile[num545, num546].active(active: false);
								}
							}
							for (int num547 = num526 - num534 - 1; num547 <= num526 + num534 + 1; num547++)
							{
								int num548 = 4;
								int num549 = num527 + num535 + 2;
								while (!Main.tile[num547, num549].active() && num549 < Main.maxTilesY && num548 > 0)
								{
									Main.tile[num547, num549].active(active: true);
									Main.tile[num547, num549].type = 59;
									num549++;
									num548--;
								}
							}
							num534 -= genRand.Next(1, 3);
							int num550 = num527 - num535 - 2;
							while (num534 > -1)
							{
								for (int num551 = num526 - num534 - 1; num551 <= num526 + num534 + 1; num551++)
								{
									Main.tile[num551, num550].active(active: true);
									Main.tile[num551, num550].type = jungleHut;
								}
								num534 -= genRand.Next(1, 3);
								num550--;
							}
							JChestX[numJChests] = num526;
							JChestY[numJChests] = num527;
							structures.AddProtectedStructure(new Rectangle(num526 - num534 - 1, num527 - num535 - 1, num526 + num534 + 1, num527 + num535 + 1));
							numJChests++;
							num529 = 0;
						}
						else if (num529 > Main.maxTilesX * 10)
						{
							num530++;
							num529 = 0;
							break;
						}
					}
				}
				Main.tileSolid[137] = false;
			});
			AddGenerationPass("Settle Liquids", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[27].Value;
				if (notTheBees)
				{
					NotTheBees();
				}
				Liquid.worldGenTilesIgnoreWater(ignoreSolids: true);
				Liquid.QuickWater(3);
				WaterCheck();
				int num521 = 0;
				Liquid.quickSettle = true;
				while (num521 < 10)
				{
					int num522 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
					num521++;
					float num523 = 0f;
					while (Liquid.numLiquid > 0)
					{
						float num524 = (float)(num522 - (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer)) / (float)num522;
						if (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer > num522)
						{
							num522 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
						}
						if (num524 > num523)
						{
							num523 = num524;
						}
						else
						{
							num524 = num523;
						}
						if (num521 == 1)
						{
							progress.Set(num524 / 3f + 0.33f);
						}
						int num525 = 10;
						if (num521 > num525)
						{
							num525 = num521;
						}
						Liquid.UpdateLiquid();
					}
					WaterCheck();
					progress.Set((float)num521 * 0.1f / 3f + 0.66f);
				}
				Liquid.quickSettle = false;
				Liquid.worldGenTilesIgnoreWater(ignoreSolids: false);
				Main.tileSolid[484] = false;
			});
			AddGenerationPass("Remove Water From Sand", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1f);
				for (int num518 = 400; num518 < Main.maxTilesX - 400; num518++)
				{
					i2 = num518;
					for (int num519 = 100; (double)num519 < Main.worldSurface - 1.0; num519++)
					{
						if (Main.tile[i2, num519].active())
						{
							ushort type6 = Main.tile[i2, num519].type;
							if (type6 == 53 || type6 == 396 || type6 == 397 || type6 == 404 || type6 == 407 || type6 == 151)
							{
								int num520 = num519;
								while (num520 > 100)
								{
									num520--;
									if (Main.tile[i2, num520].active())
									{
										break;
									}
									Main.tile[i2, num520].liquid = 0;
								}
							}
							break;
						}
					}
				}
				Main.tileSolid[192] = true;
			});
			AddGenerationPass("Oasis", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				if (!notTheBees)
				{
					progress.Set(1f);
					int num514 = Main.maxTilesX / 2100;
					num514 += genRand.Next(2);
					for (int num515 = 0; num515 < num514; num515++)
					{
						int num516 = beachDistance + 300;
						int num517 = Main.maxTilesX * 2;
						while (num517 > 0)
						{
							num517--;
							int x13 = genRand.Next(num516, Main.maxTilesX - num516);
							int y11 = genRand.Next(100, (int)Main.worldSurface);
							if (PlaceOasis(x13, y11))
							{
								num517 = -1;
							}
						}
					}
				}
			});
			AddGenerationPass("Shell Piles", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				if (!notTheBees)
				{
					progress.Set(1f);
					if (genRand.Next(2) == 0)
					{
						int num506 = shellStartXLeft;
						int num507 = shellStartYLeft;
						for (int num508 = num506 - 20; num508 <= num506 + 20; num508++)
						{
							for (int num509 = num507 - 10; num509 <= num507 + 10; num509++)
							{
								if (Main.tile[num508, num509].active() && Main.tile[num508, num509].type == 53 && !Main.tile[num508, num509 - 1].active() && Main.tile[num508, num509 - 1].liquid == 0 && !Main.tile[num508 - 1, num509].active() && Main.tile[num508 - 1, num509].liquid > 0)
								{
									shellStartXLeft = num508;
									shellStartYLeft = num509;
								}
							}
						}
						shellStartYLeft -= 50;
						shellStartXLeft -= genRand.Next(5);
						if (genRand.Next(2) == 0)
						{
							shellStartXLeft -= genRand.Next(10);
						}
						if (genRand.Next(3) == 0)
						{
							shellStartXLeft -= genRand.Next(15);
						}
						if (genRand.Next(4) != 0)
						{
							ShellPile(shellStartXLeft, shellStartYLeft);
						}
						int maxValue3 = genRand.Next(2, 4);
						if (genRand.Next(maxValue3) == 0)
						{
							ShellPile(shellStartXLeft - genRand.Next(10, 35), shellStartYLeft);
						}
						if (genRand.Next(maxValue3) == 0)
						{
							ShellPile(shellStartXLeft - genRand.Next(40, 65), shellStartYLeft);
						}
						if (genRand.Next(maxValue3) == 0)
						{
							ShellPile(shellStartXLeft - genRand.Next(70, 95), shellStartYLeft);
						}
						if (genRand.Next(maxValue3) == 0)
						{
							ShellPile(shellStartXLeft - genRand.Next(100, 125), shellStartYLeft);
						}
						if (genRand.Next(maxValue3) == 0)
						{
							ShellPile(shellStartXLeft + genRand.Next(10, 25), shellStartYLeft);
						}
					}
					if (genRand.Next(2) == 0)
					{
						int num510 = shellStartXRight;
						int num511 = shellStartYRight;
						for (int num512 = num510 - 20; num512 <= num510 + 20; num512++)
						{
							for (int num513 = num511 - 10; num513 <= num511 + 10; num513++)
							{
								if (Main.tile[num512, num513].active() && Main.tile[num512, num513].type == 53 && !Main.tile[num512, num513 - 1].active() && Main.tile[num512, num513 - 1].liquid == 0 && !Main.tile[num512 + 1, num513].active() && Main.tile[num512 + 1, num513].liquid > 0)
								{
									shellStartXRight = num512;
									shellStartYRight = num513;
								}
							}
						}
						shellStartYRight -= 50;
						shellStartXRight += genRand.Next(5);
						if (genRand.Next(2) == 0)
						{
							shellStartXLeft += genRand.Next(10);
						}
						if (genRand.Next(3) == 0)
						{
							shellStartXLeft += genRand.Next(15);
						}
						if (genRand.Next(4) != 0)
						{
							ShellPile(shellStartXRight, shellStartYRight);
						}
						int maxValue4 = genRand.Next(2, 4);
						if (genRand.Next(maxValue4) == 0)
						{
							ShellPile(shellStartXRight + genRand.Next(10, 35), shellStartYRight);
						}
						if (genRand.Next(maxValue4) == 0)
						{
							ShellPile(shellStartXRight + genRand.Next(40, 65), shellStartYRight);
						}
						if (genRand.Next(maxValue4) == 0)
						{
							ShellPile(shellStartXRight + genRand.Next(70, 95), shellStartYRight);
						}
						if (genRand.Next(maxValue4) == 0)
						{
							ShellPile(shellStartXRight + genRand.Next(100, 125), shellStartYRight);
						}
						if (genRand.Next(maxValue4) == 0)
						{
							ShellPile(shellStartXRight - genRand.Next(10, 25), shellStartYRight);
						}
					}
				}
			});
			AddGenerationPass("Smooth World", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[60].Value;
				Main.tileSolid[crackedType] = true;
				for (int num502 = 20; num502 < Main.maxTilesX - 20; num502++)
				{
					float value11 = (float)num502 / (float)Main.maxTilesX;
					progress.Set(value11);
					for (int num503 = 20; num503 < Main.maxTilesY - 20; num503++)
					{
						if (Main.tile[num502, num503].type != 48 && Main.tile[num502, num503].type != 137 && Main.tile[num502, num503].type != 232 && Main.tile[num502, num503].type != 191 && Main.tile[num502, num503].type != 151 && Main.tile[num502, num503].type != 274)
						{
							if (!Main.tile[num502, num503 - 1].active() && Main.tile[num502 - 1, num503].type != 136 && Main.tile[num502 + 1, num503].type != 136)
							{
								if (SolidTile(num502, num503) && TileID.Sets.CanBeClearedDuringGeneration[Main.tile[num502, num503].type])
								{
									if (!Main.tile[num502 - 1, num503].halfBrick() && !Main.tile[num502 + 1, num503].halfBrick() && Main.tile[num502 - 1, num503].slope() == 0 && Main.tile[num502 + 1, num503].slope() == 0)
									{
										if (SolidTile(num502, num503 + 1))
										{
											if (!SolidTile(num502 - 1, num503) && !Main.tile[num502 - 1, num503 + 1].halfBrick() && SolidTile(num502 - 1, num503 + 1) && SolidTile(num502 + 1, num503) && !Main.tile[num502 + 1, num503 - 1].active())
											{
												if (genRand.Next(2) == 0)
												{
													SlopeTile(num502, num503, 2);
												}
												else
												{
													PoundTile(num502, num503);
												}
											}
											else if (!SolidTile(num502 + 1, num503) && !Main.tile[num502 + 1, num503 + 1].halfBrick() && SolidTile(num502 + 1, num503 + 1) && SolidTile(num502 - 1, num503) && !Main.tile[num502 - 1, num503 - 1].active())
											{
												if (genRand.Next(2) == 0)
												{
													SlopeTile(num502, num503, 1);
												}
												else
												{
													PoundTile(num502, num503);
												}
											}
											else if (SolidTile(num502 + 1, num503 + 1) && SolidTile(num502 - 1, num503 + 1) && !Main.tile[num502 + 1, num503].active() && !Main.tile[num502 - 1, num503].active())
											{
												PoundTile(num502, num503);
											}
											if (SolidTile(num502, num503))
											{
												if (SolidTile(num502 - 1, num503) && SolidTile(num502 + 1, num503 + 2) && !Main.tile[num502 + 1, num503].active() && !Main.tile[num502 + 1, num503 + 1].active() && !Main.tile[num502 - 1, num503 - 1].active())
												{
													KillTile(num502, num503);
												}
												else if (SolidTile(num502 + 1, num503) && SolidTile(num502 - 1, num503 + 2) && !Main.tile[num502 - 1, num503].active() && !Main.tile[num502 - 1, num503 + 1].active() && !Main.tile[num502 + 1, num503 - 1].active())
												{
													KillTile(num502, num503);
												}
												else if (!Main.tile[num502 - 1, num503 + 1].active() && !Main.tile[num502 - 1, num503].active() && SolidTile(num502 + 1, num503) && SolidTile(num502, num503 + 2))
												{
													if (genRand.Next(5) == 0)
													{
														KillTile(num502, num503);
													}
													else if (genRand.Next(5) == 0)
													{
														PoundTile(num502, num503);
													}
													else
													{
														SlopeTile(num502, num503, 2);
													}
												}
												else if (!Main.tile[num502 + 1, num503 + 1].active() && !Main.tile[num502 + 1, num503].active() && SolidTile(num502 - 1, num503) && SolidTile(num502, num503 + 2))
												{
													if (genRand.Next(5) == 0)
													{
														KillTile(num502, num503);
													}
													else if (genRand.Next(5) == 0)
													{
														PoundTile(num502, num503);
													}
													else
													{
														SlopeTile(num502, num503, 1);
													}
												}
											}
										}
										if (SolidTile(num502, num503) && !Main.tile[num502 - 1, num503].active() && !Main.tile[num502 + 1, num503].active())
										{
											KillTile(num502, num503);
										}
									}
								}
								else if (!Main.tile[num502, num503].active() && Main.tile[num502, num503 + 1].type != 151 && Main.tile[num502, num503 + 1].type != 274)
								{
									if (Main.tile[num502 + 1, num503].type != 190 && Main.tile[num502 + 1, num503].type != 48 && Main.tile[num502 + 1, num503].type != 232 && SolidTile(num502 - 1, num503 + 1) && SolidTile(num502 + 1, num503) && !Main.tile[num502 - 1, num503].active() && !Main.tile[num502 + 1, num503 - 1].active())
									{
										if (Main.tile[num502 + 1, num503].type == 495)
										{
											PlaceTile(num502, num503, Main.tile[num502 + 1, num503].type);
										}
										else
										{
											PlaceTile(num502, num503, Main.tile[num502, num503 + 1].type);
										}
										if (genRand.Next(2) == 0)
										{
											SlopeTile(num502, num503, 2);
										}
										else
										{
											PoundTile(num502, num503);
										}
									}
									if (Main.tile[num502 - 1, num503].type != 190 && Main.tile[num502 - 1, num503].type != 48 && Main.tile[num502 - 1, num503].type != 232 && SolidTile(num502 + 1, num503 + 1) && SolidTile(num502 - 1, num503) && !Main.tile[num502 + 1, num503].active() && !Main.tile[num502 - 1, num503 - 1].active())
									{
										if (Main.tile[num502 - 1, num503].type == 495)
										{
											PlaceTile(num502, num503, Main.tile[num502 - 1, num503].type);
										}
										else
										{
											PlaceTile(num502, num503, Main.tile[num502, num503 + 1].type);
										}
										if (genRand.Next(2) == 0)
										{
											SlopeTile(num502, num503, 1);
										}
										else
										{
											PoundTile(num502, num503);
										}
									}
								}
							}
							else if (!Main.tile[num502, num503 + 1].active() && genRand.Next(2) == 0 && SolidTile(num502, num503) && !Main.tile[num502 - 1, num503].halfBrick() && !Main.tile[num502 + 1, num503].halfBrick() && Main.tile[num502 - 1, num503].slope() == 0 && Main.tile[num502 + 1, num503].slope() == 0 && SolidTile(num502, num503 - 1))
							{
								if (SolidTile(num502 - 1, num503) && !SolidTile(num502 + 1, num503) && SolidTile(num502 - 1, num503 - 1))
								{
									SlopeTile(num502, num503, 3);
								}
								else if (SolidTile(num502 + 1, num503) && !SolidTile(num502 - 1, num503) && SolidTile(num502 + 1, num503 - 1))
								{
									SlopeTile(num502, num503, 4);
								}
							}
							if (TileID.Sets.Conversion.Sand[Main.tile[num502, num503].type])
							{
								Tile.SmoothSlope(num502, num503, applyToNeighbors: false);
							}
						}
					}
				}
				for (int num504 = 20; num504 < Main.maxTilesX - 20; num504++)
				{
					for (int num505 = 20; num505 < Main.maxTilesY - 20; num505++)
					{
						if (genRand.Next(2) == 0 && !Main.tile[num504, num505 - 1].active() && Main.tile[num504, num505].type != 137 && Main.tile[num504, num505].type != 48 && Main.tile[num504, num505].type != 232 && Main.tile[num504, num505].type != 191 && Main.tile[num504, num505].type != 151 && Main.tile[num504, num505].type != 274 && Main.tile[num504, num505].type != 75 && Main.tile[num504, num505].type != 76 && SolidTile(num504, num505) && Main.tile[num504 - 1, num505].type != 137 && Main.tile[num504 + 1, num505].type != 137)
						{
							if (SolidTile(num504, num505 + 1) && SolidTile(num504 + 1, num505) && !Main.tile[num504 - 1, num505].active())
							{
								SlopeTile(num504, num505, 2);
							}
							if (SolidTile(num504, num505 + 1) && SolidTile(num504 - 1, num505) && !Main.tile[num504 + 1, num505].active())
							{
								SlopeTile(num504, num505, 1);
							}
						}
						if (Main.tile[num504, num505].slope() == 1 && !SolidTile(num504 - 1, num505))
						{
							SlopeTile(num504, num505);
							PoundTile(num504, num505);
						}
						if (Main.tile[num504, num505].slope() == 2 && !SolidTile(num504 + 1, num505))
						{
							SlopeTile(num504, num505);
							PoundTile(num504, num505);
						}
					}
				}
				Main.tileSolid[137] = true;
				Main.tileSolid[190] = false;
				Main.tileSolid[192] = false;
				Main.tileSolid[crackedType] = false;
			});
			AddGenerationPass("Waterfalls", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[69].Value;
				Main.tileSolid[191] = false;
				for (int num493 = 20; num493 < Main.maxTilesX - 20; num493++)
				{
					float num494 = (float)num493 / (float)Main.maxTilesX;
					progress.Set(num494 * 0.5f);
					for (int num495 = 20; num495 < Main.maxTilesY - 20; num495++)
					{
						if (SolidTile(num493, num495) && !Main.tile[num493 - 1, num495].active() && SolidTile(num493, num495 + 1) && !Main.tile[num493 + 1, num495].active() && (Main.tile[num493 - 1, num495].liquid > 0 || Main.tile[num493 + 1, num495].liquid > 0))
						{
							bool flag33 = true;
							int num496 = genRand.Next(8, 20);
							int num497 = genRand.Next(8, 20);
							num496 = num495 - num496;
							num497 += num495;
							for (int num498 = num496; num498 <= num497; num498++)
							{
								if (Main.tile[num493, num498].halfBrick())
								{
									flag33 = false;
								}
							}
							if ((Main.tile[num493, num495].type == 75 || Main.tile[num493, num495].type == 76) && genRand.Next(10) != 0)
							{
								flag33 = false;
							}
							if (flag33)
							{
								PoundTile(num493, num495);
							}
						}
					}
				}
				for (int num499 = 20; num499 < Main.maxTilesX - 20; num499++)
				{
					float num500 = (float)num499 / (float)Main.maxTilesX;
					progress.Set(num500 * 0.5f + 0.5f);
					for (int num501 = 20; num501 < Main.maxTilesY - 20; num501++)
					{
						if (Main.tile[num499, num501].type != 48 && Main.tile[num499, num501].type != 232 && SolidTile(num499, num501) && SolidTile(num499, num501 + 1))
						{
							if (!SolidTile(num499 + 1, num501) && Main.tile[num499 - 1, num501].halfBrick() && Main.tile[num499 - 2, num501].liquid > 0)
							{
								PoundTile(num499, num501);
							}
							if (!SolidTile(num499 - 1, num501) && Main.tile[num499 + 1, num501].halfBrick() && Main.tile[num499 + 2, num501].liquid > 0)
							{
								PoundTile(num499, num501);
							}
						}
					}
				}
				Main.tileSolid[191] = true;
			});
			AddGenerationPass("Ice", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				if (notTheBees)
				{
					NotTheBees();
				}
				progress.Set(1f);
				for (int num491 = 10; num491 < Main.maxTilesX - 10; num491++)
				{
					for (int num492 = (int)Main.worldSurface; num492 < Main.maxTilesY - 100; num492++)
					{
						if (Main.tile[num491, num492].liquid > 0 && !Main.tile[num491, num492].lava())
						{
							MakeWateryIceThing(num491, num492);
						}
					}
				}
				Main.tileSolid[226] = false;
				Main.tileSolid[162] = false;
			});
			AddGenerationPass("Wall Variety", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[79].Value;
				float num487 = (float)(Main.maxTilesX * Main.maxTilesY) / 5040000f;
				int num488 = (int)(300f * num487);
				int num489 = num488;
				ShapeData shapeData = new ShapeData();
				bool foundInvalidTile = default(bool);
				while (num488 > 0)
				{
					progress.Set(1f - (float)num488 / (float)num489);
					Point point2 = RandomWorldPoint((int)worldSurface, 2, 190, 2);
					Tile tile4 = Main.tile[point2.X, point2.Y];
					Tile tile5 = Main.tile[point2.X, point2.Y - 1];
					ushort num490 = 0;
					if (tile4.type == 60)
					{
						num490 = (ushort)(204 + genRand.Next(4));
					}
					else if (tile4.type == 1 && tile5.wall == 0)
					{
						num490 = (((double)point2.Y < rockLayer) ? ((ushort)(196 + genRand.Next(4))) : ((point2.Y >= lavaLine) ? ((ushort)(208 + genRand.Next(4))) : ((ushort)(212 + genRand.Next(4)))));
					}
					if (tile4.active() && num490 != 0 && !tile5.active())
					{
						foundInvalidTile = false;
						bool flag32 = ((tile4.type != 60) ? WorldUtils.Gen(new Point(point2.X, point2.Y - 1), new ShapeFloodFill(1000), Actions.Chain(new Modifiers.IsNotSolid(), new Actions.Blank().Output(shapeData), new Actions.ContinueWrapper(Actions.Chain(new Modifiers.IsTouching(true, 60, 147, 161, 396, 397, 70, 191), new Modifiers.IsTouching(true, 147, 161, 396, 397, 70, 191), new Actions.Custom(delegate
						{
							foundInvalidTile = true;
							return true;
						}))))) : WorldUtils.Gen(new Point(point2.X, point2.Y - 1), new ShapeFloodFill(1000), Actions.Chain(new Modifiers.IsNotSolid(), new Actions.Blank().Output(shapeData), new Actions.ContinueWrapper(Actions.Chain(new Modifiers.IsTouching(true, 147, 161, 396, 397, 70, 191), new Actions.Custom(delegate
						{
							foundInvalidTile = true;
							return true;
						}))))));
						if (shapeData.Count > 50 && flag32 && !foundInvalidTile)
						{
							WorldUtils.Gen(new Point(point2.X, point2.Y), new ModShapes.OuterOutline(shapeData, useDiagonals: true, useInterior: true), Actions.Chain(new Modifiers.SkipWalls(87), new Actions.PlaceWall(num490)));
							num488--;
						}
						shapeData.Clear();
					}
				}
			});
			AddGenerationPass("Life Crystals", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				if (getGoodWorldGen)
				{
					Main.tileSolid[56] = false;
				}
				if (notTheBees)
				{
					NotTheBees();
				}
				dub2 = Main.maxTilesX / 4200;
				progress.Message = Lang.gen[28].Value;
				for (int num485 = 0; num485 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2E-05); num485++)
				{
					float value10 = (float)((double)num485 / ((double)(Main.maxTilesX * Main.maxTilesY) * 2E-05));
					progress.Set(value10);
					bool flag31 = false;
					int num486 = 0;
					while (!flag31)
					{
						if (AddLifeCrystal(genRand.Next(40, Main.maxTilesX - 40), genRand.Next((int)(Main.worldSurface * 2.0 + Main.rockLayer) / 3, Main.maxTilesY - 300)))
						{
							flag31 = true;
						}
						else
						{
							num486++;
							if (num486 >= 10000)
							{
								flag31 = true;
							}
						}
					}
				}
				Main.tileSolid[225] = false;
			});
			AddGenerationPass("Statues", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[29].Value;
				int num479 = 0;
				int num480 = (int)((float)(statueList.Length * 2) * dub2);
				for (int num481 = 0; num481 < num480; num481++)
				{
					if (num479 >= statueList.Length)
					{
						num479 = 0;
					}
					int x12 = statueList[num479].X;
					int y10 = statueList[num479].Y;
					float value9 = num481 / num480;
					progress.Set(value9);
					bool flag30 = false;
					int num482 = 0;
					while (!flag30)
					{
						int num483 = genRand.Next(20, Main.maxTilesX - 20);
						int num484 = genRand.Next((int)(Main.worldSurface * 2.0 + Main.rockLayer) / 3, Main.maxTilesY - 300);
						while (oceanDepths(num483, num484))
						{
							num483 = genRand.Next(20, Main.maxTilesX - 20);
							num484 = genRand.Next((int)(Main.worldSurface * 2.0 + Main.rockLayer) / 3, Main.maxTilesY - 300);
						}
						while (!Main.tile[num483, num484].active())
						{
							num484++;
							if (num484 >= Main.maxTilesY)
							{
								break;
							}
						}
						if (num484 < Main.maxTilesY)
						{
							num484--;
							PlaceTile(num483, num484, x12, mute: true, forced: true, -1, y10);
							if (Main.tile[num483, num484].active() && Main.tile[num483, num484].type == x12)
							{
								flag30 = true;
								if (StatuesWithTraps.Contains(num479))
								{
									PlaceStatueTrap(num483, num484);
								}
								num479++;
							}
							else
							{
								num482++;
								if (num482 >= 10000)
								{
									flag30 = true;
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Buried Chests", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[30].Value;
				Main.tileSolid[226] = true;
				Main.tileSolid[162] = true;
				Main.tileSolid[225] = true;
				CaveHouseBiome caveHouseBiome = configuration.CreateBiome<CaveHouseBiome>();
				int random7 = passConfig.Get<WorldGenRange>("CaveHouseCount").GetRandom(genRand);
				int random8 = passConfig.Get<WorldGenRange>("UnderworldChestCount").GetRandom(genRand);
				int random9 = passConfig.Get<WorldGenRange>("CaveChestCount").GetRandom(genRand);
				int random10 = passConfig.Get<WorldGenRange>("AdditionalDesertHouseCount").GetRandom(genRand);
				int num468 = random7 + random8 + random9 + random10;
				int num469 = 10000;
				for (int num470 = 0; num470 < random9; num470++)
				{
					if (num469 <= 0)
					{
						break;
					}
					progress.Set((float)num470 / (float)num468);
					int num471 = genRand.Next(20, Main.maxTilesX - 20);
					int num472 = genRand.Next((int)((worldSurfaceHigh + 20.0 + Main.rockLayer) / 2.0), Main.maxTilesY - 230);
					ushort wall = Main.tile[num471, num472].wall;
					if (Main.wallDungeon[wall] || wall == 87 || oceanDepths(num471, num472) || !AddBuriedChest(num471, num472, 0, notNearOtherChests: false, -1, trySlope: false, 0))
					{
						num469--;
						num470--;
					}
				}
				num469 = 10000;
				for (int num473 = 0; num473 < random8; num473++)
				{
					if (num469 <= 0)
					{
						break;
					}
					progress.Set((float)(num473 + random9) / (float)num468);
					int num474 = genRand.Next(20, Main.maxTilesX - 20);
					int num475 = genRand.Next(Main.UnderworldLayer, Main.maxTilesY - 50);
					if (Main.wallDungeon[Main.tile[num474, num475].wall] || !AddBuriedChest(num474, num475, 0, notNearOtherChests: false, -1, trySlope: false, 0))
					{
						num469--;
						num473--;
					}
				}
				num469 = 10000;
				for (int num476 = 0; num476 < random7; num476++)
				{
					if (num469 <= 0)
					{
						break;
					}
					progress.Set((float)(num476 + random9 + random8) / (float)num468);
					int x11 = genRand.Next(80, Main.maxTilesX - 80);
					int y9 = genRand.Next((int)(worldSurfaceHigh + 20.0), Main.maxTilesY - 230);
					if (oceanDepths(x11, y9) || !caveHouseBiome.Place(new Point(x11, y9), structures))
					{
						num469--;
						num476--;
					}
				}
				num469 = 10000;
				Rectangle undergroundDesertHiveLocation = UndergroundDesertHiveLocation;
				if ((double)undergroundDesertHiveLocation.Y < Main.worldSurface + 26.0)
				{
					int num477 = (int)Main.worldSurface + 26 - undergroundDesertHiveLocation.Y;
					undergroundDesertHiveLocation.Y += num477;
					undergroundDesertHiveLocation.Height -= num477;
				}
				for (int num478 = 0; num478 < random10; num478++)
				{
					if (num469 <= 0)
					{
						break;
					}
					progress.Set((float)(num478 + random9 + random8 + random7) / (float)num468);
					if (!caveHouseBiome.Place(RandomRectanglePoint(undergroundDesertHiveLocation), structures))
					{
						num469--;
						num478--;
					}
				}
				Main.tileSolid[226] = false;
				Main.tileSolid[162] = false;
				Main.tileSolid[225] = false;
			});
			AddGenerationPass("Surface Chests", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[31].Value;
				for (int num458 = 0; num458 < (int)((double)Main.maxTilesX * 0.005); num458++)
				{
					float value8 = (float)((double)num458 / ((double)Main.maxTilesX * 0.005));
					progress.Set(value8);
					bool flag28 = false;
					int num459 = 0;
					while (!flag28)
					{
						int num460 = genRand.Next(300, Main.maxTilesX - 300);
						int num461 = genRand.Next((int)worldSurfaceLow, (int)Main.worldSurface);
						while (oceanDepths(num460, num461))
						{
							num460 = genRand.Next(300, Main.maxTilesX - 300);
							num461 = genRand.Next((int)worldSurfaceLow, (int)Main.worldSurface);
						}
						bool flag29 = false;
						if (!Main.tile[num460, num461].active())
						{
							if (Main.tile[num460, num461].wall == 2 || Main.tile[num460, num461].wall == 59 || Main.tile[num460, num461].wall == 244)
							{
								flag29 = true;
							}
						}
						else
						{
							int num462 = 50;
							int num463 = num460;
							int num464 = num461;
							int num465 = 1;
							for (int num466 = num463 - num462; num466 <= num463 + num462; num466 += 2)
							{
								for (int num467 = num464 - num462; num467 <= num464 + num462; num467 += 2)
								{
									if ((double)num467 < Main.worldSurface && !Main.tile[num466, num467].active() && Main.tile[num466, num467].wall == 244 && genRand.Next(num465) == 0)
									{
										num465++;
										flag29 = true;
										num460 = num466;
										num461 = num467;
									}
								}
							}
						}
						if (flag29 && AddBuriedChest(num460, num461, 0, notNearOtherChests: true, -1, trySlope: false, 0))
						{
							flag28 = true;
						}
						else
						{
							num459++;
							if (num459 >= 2000)
							{
								flag28 = true;
							}
						}
					}
				}
			});
			AddGenerationPass("Jungle Chests Placement", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[32].Value;
				for (int num453 = 0; num453 < numJChests; num453++)
				{
					float value7 = num453 / numJChests;
					progress.Set(value7);
					int nextJungleChestItem = GetNextJungleChestItem();
					if (!AddBuriedChest(JChestX[num453] + genRand.Next(2), JChestY[num453], nextJungleChestItem, notNearOtherChests: false, 10, trySlope: false, 0))
					{
						for (int num454 = JChestX[num453] - 1; num454 <= JChestX[num453] + 1; num454++)
						{
							for (int num455 = JChestY[num453]; num455 <= JChestY[num453] + 2; num455++)
							{
								KillTile(num454, num455);
							}
						}
						for (int num456 = JChestX[num453] - 1; num456 <= JChestX[num453] + 1; num456++)
						{
							for (int num457 = JChestY[num453]; num457 <= JChestY[num453] + 3; num457++)
							{
								if (num457 < Main.maxTilesY)
								{
									Main.tile[num456, num457].slope(0);
									Main.tile[num456, num457].halfBrick(halfBrick: false);
								}
							}
						}
						AddBuriedChest(JChestX[num453], JChestY[num453], nextJungleChestItem, notNearOtherChests: false, 10, trySlope: false, 0);
					}
				}
			});
			AddGenerationPass("Water Chests", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[33].Value;
				for (int num441 = 0; num441 < numOceanCaveTreasure; num441++)
				{
					int contain = genRand.NextFromList(new short[6]
					{
						863,
						186,
						277,
						187,
						4404,
						4425
					});
					bool flag26 = false;
					float num442 = 2f;
					while (!flag26 && num442 < 50f)
					{
						num442 += 0.1f;
						int num443 = genRand.Next(oceanCaveTreasure[num441].X - (int)num442, oceanCaveTreasure[num441].X + (int)num442 + 1);
						int num444 = genRand.Next(oceanCaveTreasure[num441].Y - (int)num442 / 2, oceanCaveTreasure[num441].Y + (int)num442 / 2 + 1);
						num443 = ((num443 >= Main.maxTilesX) ? ((int)((float)num443 + num442 / 2f)) : ((int)((float)num443 - num442 / 2f)));
						if (Main.tile[num443, num444].liquid > 250 && (Main.tile[num443, num444].liquidType() == 0 || notTheBees))
						{
							flag26 = AddBuriedChest(num443, num444, contain, notNearOtherChests: false, 17, trySlope: true, 0);
						}
					}
				}
				int num445 = 0;
				for (int num446 = 0; (float)num446 < 9f * dub2; num446++)
				{
					float value6 = (float)num446 / (9f * dub2);
					progress.Set(value6);
					int num447 = 0;
					num445++;
					if (genRand.Next(10) == 0)
					{
						num447 = 4425;
					}
					else if (genRand.Next(10) == 0)
					{
						num447 = 863;
					}
					else
					{
						switch (num445)
						{
						case 1:
							num447 = 186;
							break;
						case 2:
							num447 = 4404;
							break;
						case 3:
							num447 = 277;
							break;
						default:
							num447 = 187;
							num445 = 0;
							break;
						}
					}
					bool flag27 = false;
					int num448 = 0;
					while (!flag27)
					{
						int num449 = genRand.Next(50, Main.maxTilesX - 50);
						int num450 = genRand.Next(1, Main.UnderworldLayer);
						while (Main.tile[num449, num450].liquid < 250 || (Main.tile[num449, num450].liquidType() != 0 && !notTheBees))
						{
							num449 = genRand.Next(50, Main.maxTilesX - 50);
							num450 = genRand.Next(50, Main.UnderworldLayer);
						}
						flag27 = AddBuriedChest(num449, num450, num447, notNearOtherChests: false, 17, num449 < beachDistance || num449 > Main.maxTilesX - beachDistance, 0);
						num448++;
						if (num448 > 10000)
						{
							break;
						}
					}
					flag27 = false;
					num448 = 0;
					while (!flag27)
					{
						int num451 = genRand.Next(50, Main.maxTilesX - 50);
						int num452 = genRand.Next((int)Main.worldSurface, Main.UnderworldLayer);
						while (Main.tile[num451, num452].liquid < 250 || (Main.tile[num451, num452].liquidType() != 0 && !notTheBees))
						{
							num451 = genRand.Next(50, Main.maxTilesX - 50);
							num452 = genRand.Next((int)Main.worldSurface, Main.UnderworldLayer);
						}
						flag27 = AddBuriedChest(num451, num452, num447, notNearOtherChests: false, 17, num451 < beachDistance || num451 > Main.maxTilesX - beachDistance, 0);
						num448++;
						if (num448 > 10000)
						{
							break;
						}
					}
				}
			});
			AddGenerationPass("Spider Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[64].Value;
				maxTileCount = 3500;
				int num436 = Main.maxTilesX / 2;
				int num437 = (int)((double)Main.maxTilesX * 0.005);
				if (getGoodWorldGen)
				{
					num437 *= 3;
				}
				for (int num438 = 0; num438 < num437; num438++)
				{
					float value5 = (float)((double)num438 / ((double)Main.maxTilesX * 0.005));
					progress.Set(value5);
					int num439 = 0;
					int x10 = genRand.Next(200, Main.maxTilesX - 200);
					int y8 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 230);
					int num440 = countTiles(x10, y8, jungle: false, lavaOk: true);
					while ((num440 >= 3500 || num440 < 500) && num439 < num436)
					{
						num439++;
						x10 = genRand.Next(200, Main.maxTilesX - 200);
						y8 = genRand.Next((int)Main.rockLayer + 30, Main.maxTilesY - 230);
						num440 = countTiles(x10, y8, jungle: false, lavaOk: true);
						if (shroomCount > 1)
						{
							num440 = 0;
						}
					}
					if (num439 < num436)
					{
						Spread.Spider(x10, y8);
					}
				}
				Main.tileSolid[162] = true;
			});
			AddGenerationPass("Gem Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				if (!notTheBees)
				{
					progress.Message = Lang.gen[64].Value;
					maxTileCount = 300;
					for (int num433 = 0; num433 < (int)((double)Main.maxTilesX * 0.003); num433++)
					{
						float value4 = (float)((double)num433 / ((double)Main.maxTilesX * 0.003));
						progress.Set(value4);
						int num434 = 0;
						int x9 = genRand.Next(200, Main.maxTilesX - 200);
						int y7 = genRand.Next((int)Main.rockLayer + 30, Main.maxTilesY - 230);
						int num435 = countTiles(x9, y7);
						while ((num435 >= 300 || num435 < 50 || lavaCount > 0 || iceCount > 0 || rockCount == 0) && num434 < 1000)
						{
							num434++;
							x9 = genRand.Next(200, Main.maxTilesX - 200);
							y7 = genRand.Next((int)Main.rockLayer + 30, Main.maxTilesY - 230);
							num435 = countTiles(x9, y7);
						}
						if (num434 < 1000)
						{
							gemCave(x9, y7);
						}
					}
				}
			});
			AddGenerationPass("Moss", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				if (!notTheBees)
				{
					progress.Message = Lang.gen[61].Value;
					randMoss();
					int num405 = Main.maxTilesX / 2100;
					int num406 = 0;
					int num407 = 0;
					while (num407 < num405)
					{
						int num408 = genRand.Next(100, Main.maxTilesX - 100);
						if (getGoodWorldGen)
						{
							while ((double)num408 > (double)Main.maxTilesX * 0.42 && (double)num408 < (double)Main.maxTilesX * 0.48)
							{
								num408 = genRand.Next(100, Main.maxTilesX - 100);
							}
						}
						else if (!drunkWorldGen)
						{
							while ((double)num408 > (double)Main.maxTilesX * 0.38 && (double)num408 < (double)Main.maxTilesX * 0.62)
							{
								num408 = genRand.Next(100, Main.maxTilesX - 100);
							}
						}
						int num409 = genRand.Next((int)Main.rockLayer + 40, lavaLine - 40);
						bool flag25 = false;
						int num410 = 50;
						for (int num411 = num408 - num410; num411 <= num408 + num410; num411++)
						{
							for (int num412 = num409 - num410; num412 <= num409 + num410; num412++)
							{
								if (Main.tile[num411, num412].active())
								{
									int type5 = Main.tile[num411, num412].type;
									if (type5 == 70 || type5 == 60 || type5 == 367 || type5 == 368 || type5 == 161 || type5 == 147 || type5 == 396 || type5 == 397 || Main.tileDungeon[type5])
									{
										flag25 = true;
										num411 = num408 + num410 + 1;
										break;
									}
								}
							}
						}
						if (flag25)
						{
							num406++;
							if (num406 > Main.maxTilesX)
							{
								num407++;
							}
						}
						else
						{
							num406 = 0;
							num407++;
							neonMossBiome(num408, num409, lavaLine);
						}
					}
					maxTileCount = 2500;
					for (int num413 = 0; num413 < (int)((double)Main.maxTilesX * 0.01); num413++)
					{
						float value3 = (float)((double)num413 / ((double)Main.maxTilesX * 0.01));
						progress.Set(value3);
						int num414 = 0;
						int x8 = genRand.Next(200, Main.maxTilesX - 200);
						int y6 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, waterLine);
						int num415 = countTiles(x8, y6);
						while ((num415 >= 2500 || num415 < 10 || lavaCount > 0 || iceCount > 0 || rockCount == 0 || shroomCount > 0) && num414 < 1000)
						{
							num414++;
							x8 = genRand.Next(200, Main.maxTilesX - 200);
							y6 = genRand.Next((int)Main.rockLayer + 30, Main.maxTilesY - 230);
							num415 = countTiles(x8, y6);
						}
						if (num414 < 1000)
						{
							setMoss(x8, y6);
							Spread.Moss(x8, y6);
						}
					}
					for (int num416 = 0; num416 < Main.maxTilesX; num416++)
					{
						int num417 = genRand.Next(50, Main.maxTilesX - 50);
						int num418 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, lavaLine);
						if (Main.tile[num417, num418].type == 1)
						{
							setMoss(num417, num418);
							Main.tile[num417, num418].type = mossTile;
						}
					}
					float num419 = (float)Main.maxTilesX * 0.05f;
					while (num419 > 0f)
					{
						int num420 = genRand.Next(50, Main.maxTilesX - 50);
						int num421 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, lavaLine);
						if (Main.tile[num420, num421].type == 1 && (!Main.tile[num420 - 1, num421].active() || !Main.tile[num420 + 1, num421].active() || !Main.tile[num420, num421 - 1].active() || !Main.tile[num420, num421 + 1].active()))
						{
							setMoss(num420, num421);
							Main.tile[num420, num421].type = mossTile;
							num419 -= 1f;
						}
					}
					num419 = (float)Main.maxTilesX * 0.065f;
					while (num419 > 0f)
					{
						int num422 = genRand.Next(50, Main.maxTilesX - 50);
						int num423 = genRand.Next(waterLine, Main.UnderworldLayer);
						if (Main.tile[num422, num423].type == 1 && (!Main.tile[num422 - 1, num423].active() || !Main.tile[num422 + 1, num423].active() || !Main.tile[num422, num423 - 1].active() || !Main.tile[num422, num423 + 1].active()))
						{
							int num424 = 25;
							int num425 = 0;
							for (int num426 = num422 - num424; num426 < num422 + num424; num426++)
							{
								for (int num427 = num423 - num424; num427 < num423 + num424; num427++)
								{
									if (Main.tile[num426, num427].liquid > 0 && Main.tile[num426, num427].lava())
									{
										num425++;
									}
								}
							}
							if (num425 > 20)
							{
								Main.tile[num422, num423].type = 381;
								num419 -= 1f;
							}
							else
							{
								num419 -= 0.002f;
							}
						}
					}
					for (int num428 = 0; num428 < Main.maxTilesX; num428++)
					{
						for (int num429 = 0; num429 < Main.maxTilesY; num429++)
						{
							if (Main.tile[num428, num429].active() && Main.tileMoss[Main.tile[num428, num429].type])
							{
								for (int num430 = 0; num430 < 4; num430++)
								{
									int num431 = num428;
									int num432 = num429;
									if (num430 == 0)
									{
										num431--;
									}
									if (num430 == 1)
									{
										num431++;
									}
									if (num430 == 2)
									{
										num432--;
									}
									if (num430 == 3)
									{
										num432++;
									}
									try
									{
										grassSpread = 0;
										SpreadGrass(num431, num432, 1, Main.tile[num428, num429].type, repeat: true, 0);
									}
									catch
									{
										grassSpread = 0;
										SpreadGrass(num431, num432, 1, Main.tile[num428, num429].type, repeat: false, 0);
									}
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Temple", delegate
			{
				Main.tileSolid[162] = false;
				Main.tileSolid[226] = true;
				templePart2();
				Main.tileSolid[232] = false;
			});
			AddGenerationPass("Cave Walls", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[63].Value;
				maxTileCount = 1500;
				for (int num393 = 0; num393 < (int)((double)Main.maxTilesX * 0.04); num393++)
				{
					float num394 = (float)((double)num393 / ((double)Main.maxTilesX * 0.04));
					progress.Set(num394 * 0.66f);
					int num395 = 0;
					int x7 = genRand.Next(200, Main.maxTilesX - 200);
					int y5 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 220);
					int num396 = countTiles(x7, y5, jungle: false, lavaOk: true);
					while ((num396 >= maxTileCount || num396 < 10) && num395 < 500)
					{
						num395++;
						x7 = genRand.Next(200, Main.maxTilesX - 200);
						y5 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 220);
						num396 = countTiles(x7, y5, jungle: false, lavaOk: true);
					}
					if (num395 < 500)
					{
						int num397 = genRand.Next(2);
						if ((double)shroomCount > (double)rockCount * 0.75)
						{
							num397 = 80;
						}
						else if (iceCount > 0)
						{
							switch (num397)
							{
							case 0:
								num397 = 40;
								break;
							case 1:
								num397 = 71;
								break;
							}
						}
						else if (lavaCount > 0)
						{
							num397 = 79;
						}
						else
						{
							num397 = genRand.Next(4);
							switch (num397)
							{
							case 0:
								num397 = 59;
								break;
							case 1:
								num397 = 61;
								break;
							case 2:
								num397 = 170;
								break;
							case 3:
								num397 = 171;
								break;
							}
						}
						Spread.Wall(x7, y5, num397);
					}
				}
				maxTileCount = 1500;
				float num398 = (float)Main.maxTilesX * 0.02f;
				for (int num399 = 0; (float)num399 < num398; num399++)
				{
					float num400 = (float)num399 / ((float)Main.maxTilesX * 0.02f);
					progress.Set(num400 * 0.33f + 0.66f);
					int num401 = 0;
					int num402 = genRand.Next(200, Main.maxTilesX - 200);
					int num403 = genRand.Next((int)Main.worldSurface, lavaLine);
					int num404 = 0;
					if (Main.tile[num402, num403].wall == 64)
					{
						num404 = countTiles(num402, num403, jungle: true);
					}
					while ((num404 >= maxTileCount || num404 < 10) && num401 < 1000)
					{
						num401++;
						num402 = genRand.Next(200, Main.maxTilesX - 200);
						num403 = genRand.Next((int)Main.worldSurface, lavaLine);
						if (!Main.wallHouse[Main.tile[num402, num403].wall] && Main.tile[num402, num403].wall != 244)
						{
							num404 = ((Main.tile[num402, num403].wall == 64) ? countTiles(num402, num403, jungle: true) : 0);
						}
					}
					if (num401 < 1000)
					{
						Spread.Wall2(num402, num403, 15);
					}
				}
			});
			AddGenerationPass("Jungle Trees", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[83].Value;
				for (int num391 = 0; num391 < Main.maxTilesX; num391++)
				{
					progress.Set((float)num391 / (float)Main.maxTilesX);
					for (int num392 = (int)Main.worldSurface - 1; num392 < Main.maxTilesY - 350; num392++)
					{
						if (genRand.Next(10) == 0 || drunkWorldGen)
						{
							GrowUndergroundTree(num391, num392);
						}
					}
				}
			});
			AddGenerationPass("Floating Island Houses", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1f);
				for (int num390 = 0; num390 < numIslandHouses; num390++)
				{
					if (!skyLake[num390])
					{
						IslandHouse(floatingIslandHouseX[num390], floatingIslandHouseY[num390], floatingIslandStyle[num390]);
					}
				}
			});
			AddGenerationPass("Quick Cleanup", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1f);
				if (notTheBees)
				{
					NotTheBees();
				}
				Main.tileSolid[137] = false;
				Main.tileSolid[130] = false;
				for (int num383 = 20; num383 < Main.maxTilesX - 20; num383++)
				{
					for (int num384 = 20; num384 < Main.maxTilesY - 20; num384++)
					{
						if ((double)num384 < Main.worldSurface && oceanDepths(num383, num384) && Main.tile[num383, num384].type == 53 && Main.tile[num383, num384].active())
						{
							if (Main.tile[num383, num384].bottomSlope())
							{
								Main.tile[num383, num384].slope(0);
							}
							for (int num385 = num384 + 1; num385 < num384 + genRand.Next(4, 7) && (!Main.tile[num383, num385].active() || (Main.tile[num383, num385].type != 397 && Main.tile[num383, num385].type != 53)) && (!Main.tile[num383, num385 + 1].active() || (Main.tile[num383, num385 + 1].type != 397 && Main.tile[num383, num385 + 1].type != 53 && Main.tile[num383, num385 + 1].type != 495)) && (!Main.tile[num383, num385 + 2].active() || (Main.tile[num383, num385 + 2].type != 397 && Main.tile[num383, num385 + 2].type != 53 && Main.tile[num383, num385 + 2].type != 495)); num385++)
							{
								Main.tile[num383, num385].type = 0;
								Main.tile[num383, num385].active(active: true);
								Main.tile[num383, num385].halfBrick(halfBrick: false);
								Main.tile[num383, num385].slope(0);
							}
						}
						if (Main.tile[num383, num384].wall == 187 || Main.tile[num383, num384].wall == 216)
						{
							if (Main.tile[num383, num384].type == 59 || Main.tile[num383, num384].type == 123 || Main.tile[num383, num384].type == 224)
							{
								Main.tile[num383, num384].type = 397;
							}
							if (Main.tile[num383, num384].type == 368 || Main.tile[num383, num384].type == 367)
							{
								Main.tile[num383, num384].type = 397;
							}
							if ((double)num384 <= Main.rockLayer)
							{
								Main.tile[num383, num384].liquid = 0;
							}
							else if (Main.tile[num383, num384].liquid > 0)
							{
								Main.tile[num383, num384].liquid = byte.MaxValue;
								Main.tile[num383, num384].lava(lava: true);
							}
						}
						if ((double)num384 < Main.worldSurface && Main.tile[num383, num384].active() && Main.tile[num383, num384].type == 53 && Main.tile[num383, num384 + 1].wall == 0 && !SolidTile(num383, num384 + 1))
						{
							ushort num386 = 0;
							int num387 = 3;
							for (int num388 = num383 - num387; num388 <= num383 + num387; num388++)
							{
								for (int num389 = num384 - num387; num389 <= num384 + num387; num389++)
								{
									if (Main.tile[num388, num389].wall > 0)
									{
										num386 = Main.tile[num388, num389].wall;
										break;
									}
								}
							}
							if (num386 > 0)
							{
								Main.tile[num383, num384 + 1].wall = num386;
								if (Main.tile[num383, num384].wall == 0)
								{
									Main.tile[num383, num384].wall = num386;
								}
							}
						}
						if (Main.tile[num383, num384].type != 19 && TileID.Sets.CanBeClearedDuringGeneration[Main.tile[num383, num384].type])
						{
							if (Main.tile[num383, num384].topSlope() || Main.tile[num383, num384].halfBrick())
							{
								if (Main.tile[num383, num384].type != 225 || !Main.tile[num383, num384].halfBrick())
								{
									if (!SolidTile(num383, num384 + 1))
									{
										Main.tile[num383, num384].active(active: false);
									}
									if (Main.tile[num383 + 1, num384].type == 137 || Main.tile[num383 - 1, num384].type == 137)
									{
										Main.tile[num383, num384].active(active: false);
									}
								}
							}
							else if (Main.tile[num383, num384].bottomSlope())
							{
								if (!SolidTile(num383, num384 - 1))
								{
									Main.tile[num383, num384].active(active: false);
								}
								if (Main.tile[num383 + 1, num384].type == 137 || Main.tile[num383 - 1, num384].type == 137)
								{
									Main.tile[num383, num384].active(active: false);
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Pots", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				Main.tileSolid[137] = true;
				Main.tileSolid[130] = true;
				progress.Message = Lang.gen[35].Value;
				for (int num375 = 0; num375 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0008); num375++)
				{
					float num376 = (float)((double)num375 / ((double)(Main.maxTilesX * Main.maxTilesY) * 0.0008));
					progress.Set(num376);
					bool flag23 = false;
					int num377 = 0;
					while (!flag23)
					{
						int num378 = genRand.Next((int)worldSurfaceHigh, Main.maxTilesY - 10);
						if ((double)num376 > 0.93)
						{
							num378 = Main.maxTilesY - 150;
						}
						else if ((double)num376 > 0.75)
						{
							num378 = (int)worldSurfaceLow;
						}
						int num379 = genRand.Next(1, Main.maxTilesX);
						bool flag24 = false;
						for (int num380 = num378; num380 < Main.maxTilesY; num380++)
						{
							if (!flag24)
							{
								if (Main.tile[num379, num380].active() && Main.tileSolid[Main.tile[num379, num380].type] && !Main.tile[num379, num380 - 1].lava())
								{
									flag24 = true;
								}
							}
							else if (!((double)num380 < Main.worldSurface) || Main.tile[num379, num380].wall != 0)
							{
								int style = genRand.Next(0, 4);
								int num381 = 0;
								int num382 = 0;
								if (num380 < Main.maxTilesY - 5)
								{
									num381 = Main.tile[num379, num380 + 1].type;
									num382 = Main.tile[num379, num380].wall;
								}
								if (num381 == 147 || num381 == 161 || num381 == 162)
								{
									style = genRand.Next(4, 7);
								}
								if (num381 == 60)
								{
									style = genRand.Next(7, 10);
								}
								if (Main.wallDungeon[Main.tile[num379, num380].wall])
								{
									style = genRand.Next(10, 13);
								}
								if (num381 == 41 || num381 == 43 || num381 == 44 || num381 == 481 || num381 == 482 || num381 == 483)
								{
									style = genRand.Next(10, 13);
								}
								if (num381 == 22 || num381 == 23 || num381 == 25)
								{
									style = genRand.Next(16, 19);
								}
								if (num381 == 199 || num381 == 203 || num381 == 204 || num381 == 200)
								{
									style = genRand.Next(22, 25);
								}
								if (num381 == 367)
								{
									style = genRand.Next(31, 34);
								}
								if (num381 == 226)
								{
									style = genRand.Next(28, 31);
								}
								if (num382 == 187 || num382 == 216)
								{
									style = genRand.Next(34, 37);
								}
								if (num380 > Main.UnderworldLayer)
								{
									style = genRand.Next(13, 16);
								}
								if (!oceanDepths(num379, num380) && PlacePot(num379, num380, 28, style))
								{
									flag23 = true;
									break;
								}
								num377++;
								if (num377 >= 10000)
								{
									flag23 = true;
									break;
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Hellforge", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[36].Value;
				for (int num371 = 0; num371 < Main.maxTilesX / 200; num371++)
				{
					float value2 = num371 / (Main.maxTilesX / 200);
					progress.Set(value2);
					bool flag22 = false;
					int num372 = 0;
					while (!flag22)
					{
						int num373 = genRand.Next(1, Main.maxTilesX);
						int num374 = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 30);
						try
						{
							if (Main.tile[num373, num374].wall == 13 || Main.tile[num373, num374].wall == 14)
							{
								for (; !Main.tile[num373, num374].active() && num374 < Main.maxTilesY - 20; num374++)
								{
								}
								num374--;
								PlaceTile(num373, num374, 77);
								if (Main.tile[num373, num374].type == 77)
								{
									flag22 = true;
								}
								else
								{
									num372++;
									if (num372 >= 10000)
									{
										flag22 = true;
									}
								}
							}
						}
						catch
						{
						}
					}
				}
			});
			AddGenerationPass("Spreading Grass", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				if (!notTheBees)
				{
					progress.Message = Lang.gen[37].Value;
					for (int num361 = 50; num361 < Main.maxTilesX - 50; num361++)
					{
						for (int num362 = 50; (double)num362 <= Main.worldSurface; num362++)
						{
							if (Main.tile[num361, num362].active())
							{
								int type4 = Main.tile[num361, num362].type;
								if (Main.tile[num361, num362].active() && type4 == 60)
								{
									for (int num363 = num361 - 1; num363 <= num361 + 1; num363++)
									{
										for (int num364 = num362 - 1; num364 <= num362 + 1; num364++)
										{
											if (Main.tile[num363, num364].active() && Main.tile[num363, num364].type == 0)
											{
												if (!Main.tile[num363, num364 - 1].active())
												{
													Main.tile[num363, num364].type = 60;
												}
												else
												{
													Main.tile[num363, num364].type = 59;
												}
											}
										}
									}
								}
								else if (type4 == 1 || type4 == 40 || TileID.Sets.Ore[type4])
								{
									int num365 = 3;
									bool flag20 = false;
									ushort num366 = 0;
									for (int num367 = num361 - num365; num367 <= num361 + num365; num367++)
									{
										for (int num368 = num362 - num365; num368 <= num362 + num365; num368++)
										{
											if (Main.tile[num367, num368].active())
											{
												if (Main.tile[num367, num368].type == 53 || num366 == 53)
												{
													num366 = 53;
												}
												else if (Main.tile[num367, num368].type == 59 || Main.tile[num367, num368].type == 60 || Main.tile[num367, num368].type == 147 || Main.tile[num367, num368].type == 161 || Main.tile[num367, num368].type == 199 || Main.tile[num367, num368].type == 23)
												{
													num366 = Main.tile[num367, num368].type;
												}
											}
											else if (num368 < num362 && Main.tile[num367, num368].wall == 0)
											{
												flag20 = true;
											}
										}
									}
									if (flag20)
									{
										switch (num366)
										{
										case 23:
										case 199:
											if (Main.tile[num361, num362 - 1].active())
											{
												num366 = 0;
											}
											break;
										case 59:
										case 60:
											if (num361 >= jungleMinX && num361 <= jungleMaxX)
											{
												num366 = (ushort)(Main.tile[num361, num362 - 1].active() ? 59 : 60);
											}
											break;
										}
										Main.tile[num361, num362].type = num366;
									}
								}
							}
						}
					}
					for (int num369 = 10; num369 < Main.maxTilesX - 10; num369++)
					{
						i2 = num369;
						bool flag21 = true;
						for (int num370 = 0; (double)num370 < Main.worldSurface - 1.0; num370++)
						{
							if (Main.tile[i2, num370].active())
							{
								if (flag21 && Main.tile[i2, num370].type == 0)
								{
									try
									{
										grassSpread = 0;
										SpreadGrass(i2, num370, 0, 2, repeat: true, 0);
									}
									catch
									{
										grassSpread = 0;
										SpreadGrass(i2, num370, 0, 2, repeat: false, 0);
									}
								}
								if ((double)num370 > worldSurfaceHigh)
								{
									break;
								}
								flag21 = false;
							}
							else if (Main.tile[i2, num370].wall == 0)
							{
								flag21 = true;
							}
						}
					}
				}
			});
			AddGenerationPass("Surface Ore and Stone", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1f);
				int num352 = genRand.Next(Main.maxTilesX / 4200 * 5, Main.maxTilesX / 4200 * 10);
				for (int num353 = 0; num353 < num352; num353++)
				{
					int num354 = Main.maxTilesX / 420;
					while (num354 > 0)
					{
						num354--;
						int num355 = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
						while ((double)num355 >= (double)Main.maxTilesX * 0.48 && (double)num355 <= (double)Main.maxTilesX * 0.52)
						{
							num355 = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
						}
						int y3 = genRand.Next((int)worldSurfaceLow, (int)worldSurface);
						bool flag18 = false;
						for (int num356 = 0; num356 < numOrePatch; num356++)
						{
							if (Math.Abs(num355 - orePatchX[num356]) < 200)
							{
								flag18 = true;
							}
						}
						if (!flag18 && OrePatch(num355, y3))
						{
							if (numOrePatch < maxOrePatch - 1)
							{
								orePatchX[numOrePatch] = num355;
								numOrePatch++;
							}
							break;
						}
					}
				}
				num352 = genRand.Next(1, Main.maxTilesX / 4200 * 7);
				for (int num357 = 0; num357 < num352; num357++)
				{
					int num358 = Main.maxTilesX / 420;
					while (num358 > 0)
					{
						num358--;
						int num359 = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
						while ((double)num359 >= (double)Main.maxTilesX * 0.47 && (double)num359 <= (double)Main.maxTilesX * 0.53)
						{
							num359 = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
						}
						int y4 = genRand.Next((int)worldSurfaceLow, (int)worldSurface);
						bool flag19 = false;
						for (int num360 = 0; num360 < numOrePatch; num360++)
						{
							if (Math.Abs(num359 - orePatchX[num360]) < 100)
							{
								flag19 = true;
							}
						}
						if (!flag19 && StonePatch(num359, y4))
						{
							break;
						}
					}
				}
			});
			AddGenerationPass("Place Fallen Log", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[85].Value;
				int num338 = Main.maxTilesX / 2100;
				num338 += genRand.Next(-1, 2);
				for (int num339 = 0; num339 < num338; num339++)
				{
					progress.Set((float)num339 / (float)num338);
					int num340 = beachDistance + 20;
					int num341 = 50000;
					int num342 = 5000;
					while (num341 > 0)
					{
						num341--;
						int num343 = genRand.Next(num340, Main.maxTilesX - num340);
						int num344 = genRand.Next(10, (int)Main.worldSurface);
						bool flag16 = false;
						if (num341 < num342)
						{
							flag16 = true;
						}
						if (num341 > num342 / 2)
						{
							while ((double)num343 > (double)Main.maxTilesX * 0.4 && (double)num343 < (double)Main.maxTilesX * 0.6)
							{
								num343 = genRand.Next(num340, Main.maxTilesX - num340);
							}
						}
						if (!Main.tile[num343, num344].active() && Main.tile[num343, num344].wall == 0)
						{
							for (; !Main.tile[num343, num344].active() && Main.tile[num343, num344].wall == 0 && (double)num344 <= Main.worldSurface; num344++)
							{
							}
							bool flag17 = true;
							if ((double)num344 > Main.worldSurface - 10.0)
							{
								flag17 = false;
							}
							else if (!flag16)
							{
								int num345 = 50;
								for (int num346 = num343 - num345; num346 < num343 + num345; num346++)
								{
									if (num346 > 10 && num346 < Main.maxTilesX - 10)
									{
										for (int num347 = num344 - num345; num347 < num344 + num345; num347++)
										{
											if (num347 > 10 && num347 < Main.maxTilesY - 10)
											{
												int type3 = Main.tile[num346, num347].type;
												switch (type3)
												{
												case 189:
													flag17 = false;
													break;
												case 53:
													flag17 = false;
													break;
												default:
													if (Main.tileDungeon[type3])
													{
														flag17 = false;
													}
													else if (TileID.Sets.Crimson[type3])
													{
														flag17 = false;
													}
													else if (TileID.Sets.Corrupt[type3])
													{
														flag17 = false;
													}
													break;
												}
											}
										}
									}
								}
								if (flag17)
								{
									int num348 = 10;
									int num349 = 10;
									for (int num350 = num343 - num348; num350 < num343 + num348; num350++)
									{
										for (int num351 = num344 - num349; num351 < num344 - 1; num351++)
										{
											if (Main.tile[num350, num351].active() && Main.tileSolid[Main.tile[num350, num351].type])
											{
												flag17 = false;
											}
											if (Main.tile[num350, num351].wall != 0)
											{
												flag17 = false;
											}
										}
									}
								}
							}
							if (flag17 && (Main.tile[num343, num344 - 1].liquid == 0 || num341 < num342 / 5) && (Main.tile[num343, num344].type == 2 || (notTheBees && Main.tile[num343, num344].type == 60)) && (Main.tile[num343 - 1, num344].type == 2 || (notTheBees && Main.tile[num343 - 1, num344].type == 60)) && (Main.tile[num343 + 1, num344].type == 2 || (notTheBees && Main.tile[num343 + 1, num344].type == 60)))
							{
								num344--;
								PlaceTile(num343, num344, 488);
								if (Main.tile[num343, num344].active() && Main.tile[num343, num344].type == 488)
								{
									if (genRand.Next(2) == 0)
									{
										logX = num343;
										logY = num344;
									}
									num341 = -1;
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Traps", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				if (!notTheBees)
				{
					placingTraps = true;
					progress.Message = Lang.gen[34].Value;
					float num327 = (float)Main.maxTilesX * 0.05f;
					if (getGoodWorldGen)
					{
						num327 *= 1.5f;
					}
					for (int num328 = 0; (float)num328 < num327; num328++)
					{
						progress.Set((float)num328 / num327 / 2f);
						for (int num329 = 0; num329 < 1150; num329++)
						{
							int num330 = genRand.Next(200, Main.maxTilesX - 200);
							int num331 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 210);
							while (oceanDepths(num330, num331))
							{
								num330 = genRand.Next(200, Main.maxTilesX - 200);
								num331 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 210);
							}
							if (Main.tile[num330, num331].wall == 0 && placeTrap(num330, num331))
							{
								break;
							}
						}
					}
					num327 = (float)Main.maxTilesX * 0.003f;
					if (getGoodWorldGen)
					{
						num327 *= 1.5f;
					}
					for (int num332 = 0; (float)num332 < num327; num332++)
					{
						progress.Set((float)num332 / num327 / 2f + 0.5f);
						for (int num333 = 0; num333 < 20000; num333++)
						{
							int num334 = genRand.Next((int)((double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.85));
							int num335 = genRand.Next((int)Main.worldSurface + 20, Main.maxTilesY - 210);
							if (Main.tile[num334, num335].wall == 187 && PlaceSandTrap(num334, num335))
							{
								break;
							}
						}
					}
					if (drunkWorldGen)
					{
						for (int num336 = 0; num336 < 8; num336++)
						{
							progress.Message = Lang.gen[34].Value;
							num327 = 100f;
							for (int num337 = 0; (float)num337 < num327; num337++)
							{
								progress.Set((float)num337 / num327);
								Thread.Sleep(10);
							}
						}
					}
					placingTraps = false;
				}
			});
			AddGenerationPass("Piles", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[89].Value;
				Main.tileSolid[229] = false;
				Main.tileSolid[190] = false;
				Main.tileSolid[196] = false;
				Main.tileSolid[189] = false;
				Main.tileSolid[202] = false;
				Main.tileSolid[460] = false;
				for (int num269 = 0; (double)num269 < (double)Main.maxTilesX * 0.06; num269++)
				{
					int num270 = Main.maxTilesX / 2;
					bool flag9 = false;
					while (!flag9 && num270 > 0)
					{
						num270--;
						int num271 = genRand.Next(25, Main.maxTilesX - 25);
						int num272 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 300);
						while (oceanDepths(num271, num272))
						{
							num271 = genRand.Next(25, Main.maxTilesX - 25);
							num272 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 300);
						}
						if (!Main.tile[num271, num272].active())
						{
							int num273 = 186;
							for (; !Main.tile[num271, num272 + 1].active() && num272 < Main.maxTilesY - 5; num272++)
							{
							}
							int num274 = genRand.Next(22);
							if (num274 >= 16 && num274 <= 22)
							{
								num274 = genRand.Next(22);
							}
							if ((Main.tile[num271, num272 + 1].type == 0 || Main.tile[num271, num272 + 1].type == 1 || Main.tileMoss[Main.tile[num271, num272 + 1].type]) && genRand.Next(5) == 0)
							{
								num274 = genRand.Next(23, 29);
								num273 = 187;
							}
							if (num272 > Main.maxTilesY - 300 || Main.wallDungeon[Main.tile[num271, num272].wall] || Main.tile[num271, num272 + 1].type == 30 || Main.tile[num271, num272 + 1].type == 19 || Main.tile[num271, num272 + 1].type == 25 || Main.tile[num271, num272 + 1].type == 203)
							{
								num274 = genRand.Next(7);
								num273 = 186;
							}
							if (Main.tile[num271, num272 + 1].type == 147 || Main.tile[num271, num272 + 1].type == 161 || Main.tile[num271, num272 + 1].type == 162)
							{
								num274 = genRand.Next(26, 32);
								num273 = 186;
							}
							if (Main.tile[num271, num272 + 1].type == 60)
							{
								num273 = 187;
								num274 = genRand.Next(6);
							}
							if ((Main.tile[num271, num272 + 1].type == 57 || Main.tile[num271, num272 + 1].type == 58) && genRand.Next(3) < 2)
							{
								num273 = 187;
								num274 = genRand.Next(6, 9);
							}
							if (Main.tile[num271, num272 + 1].type == 226)
							{
								num273 = 187;
								num274 = genRand.Next(18, 23);
							}
							if (Main.tile[num271, num272 + 1].type == 70)
							{
								num274 = genRand.Next(32, 35);
								num273 = 186;
							}
							if (Main.tile[num271, num272 + 1].type == 396 || Main.tile[num271, num272 + 1].type == 397 || Main.tile[num271, num272 + 1].type == 404)
							{
								num274 = genRand.Next(29, 35);
								num273 = 187;
							}
							if (Main.tile[num271, num272 + 1].type == 368)
							{
								num274 = genRand.Next(35, 41);
								num273 = 187;
							}
							if (Main.tile[num271, num272 + 1].type == 367)
							{
								num274 = genRand.Next(41, 47);
								num273 = 187;
							}
							if (num273 == 186 && num274 >= 7 && num274 <= 15 && genRand.Next(75) == 0)
							{
								num273 = 187;
								num274 = 17;
							}
							if (Main.wallDungeon[Main.tile[num271, num272].wall] && genRand.Next(3) != 0)
							{
								flag9 = true;
							}
							else
							{
								PlaceTile(num271, num272, num273, mute: true, forced: false, -1, num274);
								if (Main.tile[num271, num272].type == 186 || Main.tile[num271, num272].type == 187)
								{
									flag9 = true;
								}
								if (flag9 && num273 == 186 && num274 <= 7)
								{
									int num275 = genRand.Next(1, 5);
									for (int num276 = 0; num276 < num275; num276++)
									{
										int num277 = num271 + genRand.Next(-10, 11);
										int num278 = num272 - genRand.Next(5);
										if (!Main.tile[num277, num278].active())
										{
											for (; !Main.tile[num277, num278 + 1].active() && num278 < Main.maxTilesY - 5; num278++)
											{
											}
											int x3 = genRand.Next(12, 36);
											PlaceSmallPile(num277, num278, x3, 0, 185);
										}
									}
								}
							}
						}
					}
				}
				for (int num279 = 0; (double)num279 < (double)Main.maxTilesX * 0.01; num279++)
				{
					int num280 = Main.maxTilesX / 2;
					bool flag10 = false;
					while (!flag10 && num280 > 0)
					{
						num280--;
						int num281 = genRand.Next(25, Main.maxTilesX - 25);
						int num282 = genRand.Next(Main.maxTilesY - 300, Main.maxTilesY - 10);
						if (!Main.tile[num281, num282].active())
						{
							int num283 = 186;
							for (; !Main.tile[num281, num282 + 1].active() && num282 < Main.maxTilesY - 5; num282++)
							{
							}
							int num284 = genRand.Next(22);
							if (num284 >= 16 && num284 <= 22)
							{
								num284 = genRand.Next(22);
							}
							if (num282 > Main.maxTilesY - 300 || Main.wallDungeon[Main.tile[num281, num282].wall] || Main.tile[num281, num282 + 1].type == 30 || Main.tile[num281, num282 + 1].type == 19)
							{
								num284 = genRand.Next(7);
							}
							if ((Main.tile[num281, num282 + 1].type == 57 || Main.tile[num281, num282 + 1].type == 58) && genRand.Next(3) < 2)
							{
								num283 = 187;
								num284 = genRand.Next(6, 9);
							}
							if (Main.tile[num281, num282 + 1].type == 147 || Main.tile[num281, num282 + 1].type == 161 || Main.tile[num281, num282 + 1].type == 162)
							{
								num284 = genRand.Next(26, 32);
							}
							PlaceTile(num281, num282, num283, mute: true, forced: false, -1, num284);
							if (Main.tile[num281, num282].type == 186 || Main.tile[num281, num282].type == 187)
							{
								flag10 = true;
							}
							if (flag10 && num283 == 186 && num284 <= 7)
							{
								int num285 = genRand.Next(1, 5);
								for (int num286 = 0; num286 < num285; num286++)
								{
									int num287 = num281 + genRand.Next(-10, 11);
									int num288 = num282 - genRand.Next(5);
									if (!Main.tile[num287, num288].active())
									{
										for (; !Main.tile[num287, num288 + 1].active() && num288 < Main.maxTilesY - 5; num288++)
										{
										}
										int x4 = genRand.Next(12, 36);
										PlaceSmallPile(num287, num288, x4, 0, 185);
									}
								}
							}
						}
					}
				}
				for (int num289 = 0; (double)num289 < (double)Main.maxTilesX * 0.003; num289++)
				{
					int num290 = Main.maxTilesX / 2;
					bool flag11 = false;
					while (!flag11 && num290 > 0)
					{
						num290--;
						int num291 = 186;
						int num292 = genRand.Next(25, Main.maxTilesX - 25);
						int num293 = genRand.Next(10, (int)Main.worldSurface);
						while (oceanDepths(num292, num293))
						{
							num292 = genRand.Next(25, Main.maxTilesX - 25);
							num293 = genRand.Next(10, (int)Main.worldSurface);
						}
						if (!Main.tile[num292, num293].active())
						{
							for (; !Main.tile[num292, num293 + 1].active() && num293 < Main.maxTilesY - 5; num293++)
							{
							}
							int num294 = genRand.Next(7, 13);
							if (num293 > Main.maxTilesY - 300 || Main.wallDungeon[Main.tile[num292, num293].wall] || Main.tile[num292, num293 + 1].type == 30 || Main.tile[num292, num293 + 1].type == 19 || Main.tile[num292, num293 + 1].type == 25 || Main.tile[num292, num293 + 1].type == 203 || Main.tile[num292, num293 + 1].type == 234 || Main.tile[num292, num293 + 1].type == 112)
							{
								num294 = -1;
							}
							if (Main.tile[num292, num293 + 1].type == 147 || Main.tile[num292, num293 + 1].type == 161 || Main.tile[num292, num293 + 1].type == 162)
							{
								num294 = genRand.Next(26, 32);
							}
							if (Main.tile[num292, num293 + 1].type == 53)
							{
								num291 = 187;
								num294 = genRand.Next(52, 55);
							}
							if (Main.tile[num292, num293 + 1].type == 2 || Main.tile[num292 - 1, num293 + 1].type == 2 || Main.tile[num292 + 1, num293 + 1].type == 2)
							{
								num291 = 187;
								num294 = genRand.Next(14, 17);
							}
							if (Main.tile[num292, num293 + 1].type == 151 || Main.tile[num292, num293 + 1].type == 274)
							{
								num291 = 186;
								num294 = genRand.Next(7);
							}
							if (num294 >= 0)
							{
								PlaceTile(num292, num293, num291, mute: true, forced: false, -1, num294);
							}
							if (Main.tile[num292, num293].type == num291)
							{
								flag11 = true;
							}
						}
					}
				}
				for (int num295 = 0; (double)num295 < (double)Main.maxTilesX * 0.0035; num295++)
				{
					int num296 = Main.maxTilesX / 2;
					bool flag12 = false;
					while (!flag12 && num296 > 0)
					{
						num296--;
						int num297 = genRand.Next(25, Main.maxTilesX - 25);
						int num298 = genRand.Next(10, (int)Main.worldSurface);
						if (!Main.tile[num297, num298].active() && Main.tile[num297, num298].wall > 0)
						{
							int num299 = 186;
							for (; !Main.tile[num297, num298 + 1].active() && num298 < Main.maxTilesY - 5; num298++)
							{
							}
							int num300 = genRand.Next(7, 13);
							if (num298 > Main.maxTilesY - 300 || Main.wallDungeon[Main.tile[num297, num298].wall] || Main.tile[num297, num298 + 1].type == 30 || Main.tile[num297, num298 + 1].type == 19)
							{
								num300 = -1;
							}
							if (Main.tile[num297, num298 + 1].type == 25)
							{
								num300 = genRand.Next(7);
							}
							if (Main.tile[num297, num298 + 1].type == 147 || Main.tile[num297, num298 + 1].type == 161 || Main.tile[num297, num298 + 1].type == 162)
							{
								num300 = genRand.Next(26, 32);
							}
							if (Main.tile[num297, num298 + 1].type == 2 || Main.tile[num297 - 1, num298 + 1].type == 2 || Main.tile[num297 + 1, num298 + 1].type == 2)
							{
								num299 = 187;
								num300 = genRand.Next(14, 17);
							}
							if (Main.tile[num297, num298 + 1].type == 151 || Main.tile[num297, num298 + 1].type == 274)
							{
								num299 = 186;
								num300 = genRand.Next(7);
							}
							if (num300 >= 0)
							{
								PlaceTile(num297, num298, num299, mute: true, forced: false, -1, num300);
							}
							if (Main.tile[num297, num298].type == num299)
							{
								flag12 = true;
							}
							if (flag12 && num300 <= 7)
							{
								int num301 = genRand.Next(1, 5);
								for (int num302 = 0; num302 < num301; num302++)
								{
									int num303 = num297 + genRand.Next(-10, 11);
									int num304 = num298 - genRand.Next(5);
									if (!Main.tile[num303, num304].active())
									{
										for (; !Main.tile[num303, num304 + 1].active() && num304 < Main.maxTilesY - 5; num304++)
										{
										}
										int x5 = genRand.Next(12, 36);
										PlaceSmallPile(num303, num304, x5, 0, 185);
									}
								}
							}
						}
					}
				}
				for (int num305 = 0; (double)num305 < (double)Main.maxTilesX * 0.6; num305++)
				{
					int num306 = Main.maxTilesX / 2;
					bool flag13 = false;
					while (!flag13 && num306 > 0)
					{
						num306--;
						int num307 = genRand.Next(25, Main.maxTilesX - 25);
						int num308 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 20);
						if (Main.tile[num307, num308].wall == 87 && genRand.Next(2) == 0)
						{
							num307 = genRand.Next(25, Main.maxTilesX - 25);
							num308 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 20);
						}
						while (oceanDepths(num307, num308))
						{
							num307 = genRand.Next(25, Main.maxTilesX - 25);
							num308 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 20);
						}
						if (!Main.tile[num307, num308].active())
						{
							for (; !Main.tile[num307, num308 + 1].active() && num308 < Main.maxTilesY - 5; num308++)
							{
							}
							int num309 = genRand.Next(2);
							int num310 = genRand.Next(36);
							if (num310 >= 28 && num310 <= 35)
							{
								num310 = genRand.Next(36);
							}
							if (num309 == 1)
							{
								num310 = genRand.Next(25);
								if (num310 >= 16 && num310 <= 24)
								{
									num310 = genRand.Next(25);
								}
							}
							if (num308 > Main.maxTilesY - 300)
							{
								if (num309 == 0)
								{
									num310 = genRand.Next(12, 28);
								}
								if (num309 == 1)
								{
									num310 = genRand.Next(6, 16);
								}
							}
							if (Main.wallDungeon[Main.tile[num307, num308].wall] || Main.tile[num307, num308 + 1].type == 30 || Main.tile[num307, num308 + 1].type == 19 || Main.tile[num307, num308 + 1].type == 25 || Main.tile[num307, num308 + 1].type == 203 || Main.tile[num307, num308].wall == 87)
							{
								if (num309 == 0 && num310 < 12)
								{
									num310 += 12;
								}
								if (num309 == 1 && num310 < 6)
								{
									num310 += 6;
								}
								if (num309 == 1 && num310 >= 17)
								{
									num310 -= 10;
								}
							}
							if (Main.tile[num307, num308 + 1].type == 147 || Main.tile[num307, num308 + 1].type == 161 || Main.tile[num307, num308 + 1].type == 162)
							{
								if (num309 == 0 && num310 < 12)
								{
									num310 += 36;
								}
								if (num309 == 1 && num310 >= 20)
								{
									num310 += 6;
								}
								if (num309 == 1 && num310 < 6)
								{
									num310 += 25;
								}
							}
							if (Main.tile[num307, num308 + 1].type == 151 || Main.tile[num307, num308 + 1].type == 274)
							{
								if (num309 == 0)
								{
									num310 = genRand.Next(12, 28);
								}
								if (num309 == 1)
								{
									num310 = genRand.Next(12, 19);
								}
							}
							if (Main.tile[num307, num308 + 1].type == 368)
							{
								if (num309 == 0)
								{
									num310 = genRand.Next(60, 66);
								}
								if (num309 == 1)
								{
									num310 = genRand.Next(47, 53);
								}
							}
							if (Main.tile[num307, num308 + 1].type == 367)
							{
								if (num309 == 0)
								{
									num310 = genRand.Next(66, 72);
								}
								if (num309 == 1)
								{
									num310 = genRand.Next(53, 59);
								}
							}
							flag13 = (Main.wallDungeon[Main.tile[num307, num308].wall] && genRand.Next(3) != 0) || PlaceSmallPile(num307, num308, num310, num309, 185);
							if (flag13 && num309 == 1 && num310 >= 6 && num310 <= 15)
							{
								int num311 = genRand.Next(1, 5);
								for (int num312 = 0; num312 < num311; num312++)
								{
									int num313 = num307 + genRand.Next(-10, 11);
									int num314 = num308 - genRand.Next(5);
									if (!Main.tile[num313, num314].active())
									{
										for (; !Main.tile[num313, num314 + 1].active() && num314 < Main.maxTilesY - 5; num314++)
										{
										}
										int x6 = genRand.Next(12, 36);
										PlaceSmallPile(num313, num314, x6, 0, 185);
									}
								}
							}
						}
					}
				}
				for (int num315 = 0; (float)num315 < (float)Main.maxTilesX * 0.02f; num315++)
				{
					int num316 = Main.maxTilesX / 2;
					bool flag14 = false;
					while (!flag14 && num316 > 0)
					{
						num316--;
						int num317 = genRand.Next(25, Main.maxTilesX - 25);
						int num318 = genRand.Next(15, (int)Main.worldSurface);
						while (oceanDepths(num317, num318))
						{
							num317 = genRand.Next(25, Main.maxTilesX - 25);
							num318 = genRand.Next(15, (int)Main.worldSurface);
						}
						if (!Main.tile[num317, num318].active())
						{
							for (; !Main.tile[num317, num318 + 1].active() && num318 < Main.maxTilesY - 5; num318++)
							{
							}
							int num319 = genRand.Next(2);
							int num320 = genRand.Next(11);
							if (num319 == 1)
							{
								num320 = genRand.Next(5);
							}
							if (Main.tile[num317, num318 + 1].type == 147 || Main.tile[num317, num318 + 1].type == 161 || Main.tile[num317, num318 + 1].type == 162)
							{
								if (num319 == 0 && num320 < 12)
								{
									num320 += 36;
								}
								if (num319 == 1 && num320 >= 20)
								{
									num320 += 6;
								}
								if (num319 == 1 && num320 < 6)
								{
									num320 += 25;
								}
							}
							if (Main.tile[num317, num318 + 1].type == 2 && num319 == 1)
							{
								num320 = genRand.Next(38, 41);
							}
							if (Main.tile[num317, num318 + 1].type == 151 || Main.tile[num317, num318 + 1].type == 274)
							{
								if (num319 == 0)
								{
									num320 = genRand.Next(12, 28);
								}
								if (num319 == 1)
								{
									num320 = genRand.Next(12, 19);
								}
							}
							if (!Main.wallDungeon[Main.tile[num317, num318].wall] && Main.tile[num317, num318 + 1].type != 30 && Main.tile[num317, num318 + 1].type != 19 && Main.tile[num317, num318 + 1].type != 41 && Main.tile[num317, num318 + 1].type != 43 && Main.tile[num317, num318 + 1].type != 44 && Main.tile[num317, num318 + 1].type != 481 && Main.tile[num317, num318 + 1].type != 482 && Main.tile[num317, num318 + 1].type != 483 && Main.tile[num317, num318 + 1].type != 45 && Main.tile[num317, num318 + 1].type != 46 && Main.tile[num317, num318 + 1].type != 47 && Main.tile[num317, num318 + 1].type != 175 && Main.tile[num317, num318 + 1].type != 176 && Main.tile[num317, num318 + 1].type != 177 && Main.tile[num317, num318 + 1].type != 53 && Main.tile[num317, num318 + 1].type != 25 && Main.tile[num317, num318 + 1].type != 203)
							{
								flag14 = PlaceSmallPile(num317, num318, num320, num319, 185);
							}
						}
					}
				}
				for (int num321 = 0; (float)num321 < (float)Main.maxTilesX * 0.15f; num321++)
				{
					int num322 = Main.maxTilesX / 2;
					bool flag15 = false;
					while (!flag15 && num322 > 0)
					{
						num322--;
						int num323 = genRand.Next(25, Main.maxTilesX - 25);
						int num324 = genRand.Next(15, (int)Main.worldSurface);
						if (!Main.tile[num323, num324].active() && (Main.tile[num323, num324].wall == 2 || Main.tile[num323, num324].wall == 40))
						{
							for (; !Main.tile[num323, num324 + 1].active() && num324 < Main.maxTilesY - 5; num324++)
							{
							}
							int num325 = genRand.Next(2);
							int num326 = genRand.Next(11);
							if (num325 == 1)
							{
								num326 = genRand.Next(5);
							}
							if (Main.tile[num323, num324 + 1].type == 147 || Main.tile[num323, num324 + 1].type == 161 || Main.tile[num323, num324 + 1].type == 162)
							{
								if (num325 == 0 && num326 < 12)
								{
									num326 += 36;
								}
								if (num325 == 1 && num326 >= 20)
								{
									num326 += 6;
								}
								if (num325 == 1 && num326 < 6)
								{
									num326 += 25;
								}
							}
							if (Main.tile[num323, num324 + 1].type == 2 && num325 == 1)
							{
								num326 = genRand.Next(38, 41);
							}
							if (Main.tile[num323, num324 + 1].type == 151 || Main.tile[num323, num324 + 1].type == 274)
							{
								if (num325 == 0)
								{
									num326 = genRand.Next(12, 28);
								}
								if (num325 == 1)
								{
									num326 = genRand.Next(12, 19);
								}
							}
							if ((Main.tile[num323, num324].liquid != byte.MaxValue || Main.tile[num323, num324 + 1].type != 53 || Main.tile[num323, num324].wall != 0) && !Main.wallDungeon[Main.tile[num323, num324].wall] && Main.tile[num323, num324 + 1].type != 30 && Main.tile[num323, num324 + 1].type != 19 && Main.tile[num323, num324 + 1].type != 41 && Main.tile[num323, num324 + 1].type != 43 && Main.tile[num323, num324 + 1].type != 44 && Main.tile[num323, num324 + 1].type != 481 && Main.tile[num323, num324 + 1].type != 482 && Main.tile[num323, num324 + 1].type != 483 && Main.tile[num323, num324 + 1].type != 45 && Main.tile[num323, num324 + 1].type != 46 && Main.tile[num323, num324 + 1].type != 47 && Main.tile[num323, num324 + 1].type != 175 && Main.tile[num323, num324 + 1].type != 176 && Main.tile[num323, num324 + 1].type != 177 && Main.tile[num323, num324 + 1].type != 25 && Main.tile[num323, num324 + 1].type != 203)
							{
								flag15 = PlaceSmallPile(num323, num324, num326, num325, 185);
							}
						}
					}
				}
				Main.tileSolid[190] = true;
				Main.tileSolid[192] = true;
				Main.tileSolid[196] = true;
				Main.tileSolid[189] = true;
				Main.tileSolid[202] = true;
				Main.tileSolid[225] = true;
				Main.tileSolid[460] = true;
			});
			AddGenerationPass("Spawn Point", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1f);
				int num263 = 5;
				bool flag8 = true;
				while (flag8)
				{
					int num264 = Main.maxTilesX / 2 + genRand.Next(-num263, num263 + 1);
					for (int num265 = 0; num265 < Main.maxTilesY; num265++)
					{
						if (Main.tile[num264, num265].active())
						{
							Main.spawnTileX = num264;
							Main.spawnTileY = num265;
							break;
						}
					}
					flag8 = false;
					num263++;
					if ((double)Main.spawnTileY > Main.worldSurface)
					{
						flag8 = true;
					}
					if (Main.tile[Main.spawnTileX, Main.spawnTileY - 1].liquid > 0)
					{
						flag8 = true;
					}
				}
				int num266 = 10;
				while ((double)Main.spawnTileY > Main.worldSurface)
				{
					int num267 = genRand.Next(Main.maxTilesX / 2 - num266, Main.maxTilesX / 2 + num266);
					for (int num268 = 0; num268 < Main.maxTilesY; num268++)
					{
						if (Main.tile[num267, num268].active())
						{
							Main.spawnTileX = num267;
							Main.spawnTileY = num268;
							break;
						}
					}
					num266++;
				}
			});
			AddGenerationPass("Grass Wall", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				maxTileCount = 3500;
				progress.Set(1f);
				for (int num251 = 50; num251 < Main.maxTilesX - 50; num251++)
				{
					for (int num252 = 0; (double)num252 < Main.worldSurface - 10.0; num252++)
					{
						if (genRand.Next(4) == 0)
						{
							bool flag6 = false;
							int num253 = -1;
							int num254 = -1;
							if (Main.tile[num251, num252].active() && Main.tile[num251, num252].type == 2 && (Main.tile[num251, num252].wall == 2 || Main.tile[num251, num252].wall == 63))
							{
								for (int num255 = num251 - 1; num255 <= num251 + 1; num255++)
								{
									for (int num256 = num252 - 1; num256 <= num252 + 1; num256++)
									{
										if (Main.tile[num255, num256].wall == 0 && !SolidTile(num255, num256))
										{
											flag6 = true;
										}
									}
								}
								if (flag6)
								{
									for (int num257 = num251 - 1; num257 <= num251 + 1; num257++)
									{
										for (int num258 = num252 - 1; num258 <= num252 + 1; num258++)
										{
											if ((Main.tile[num257, num258].wall == 2 || Main.tile[num257, num258].wall == 15) && !SolidTile(num257, num258))
											{
												num253 = num257;
												num254 = num258;
											}
										}
									}
								}
							}
							if (flag6 && num253 > -1 && num254 > -1 && countDirtTiles(num253, num254) < maxTileCount)
							{
								try
								{
									Spread.Wall2(num253, num254, 63);
								}
								catch
								{
								}
							}
						}
					}
				}
				for (int num259 = 5; num259 < Main.maxTilesX - 5; num259++)
				{
					for (int num260 = 10; (double)num260 < Main.worldSurface - 1.0; num260++)
					{
						if (Main.tile[num259, num260].wall == 63 && genRand.Next(10) == 0)
						{
							Main.tile[num259, num260].wall = 65;
						}
						if (Main.tile[num259, num260].active() && Main.tile[num259, num260].type == 0)
						{
							bool flag7 = false;
							for (int num261 = num259 - 1; num261 <= num259 + 1; num261++)
							{
								for (int num262 = num260 - 1; num262 <= num260 + 1; num262++)
								{
									if (Main.tile[num261, num262].wall == 63 || Main.tile[num261, num262].wall == 65)
									{
										flag7 = true;
										break;
									}
								}
							}
							if (flag7)
							{
								SpreadGrass(num259, num260, 0, 2, repeat: true, 0);
							}
						}
					}
				}
			});
			AddGenerationPass("Guide", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1f);
				if (getGoodWorldGen)
				{
					int num247 = NPC.NewNPC(Main.spawnTileX * 16, Main.spawnTileY * 16, 38);
					Main.npc[num247].homeTileX = Main.spawnTileX;
					Main.npc[num247].homeTileY = Main.spawnTileY;
					Main.npc[num247].direction = 1;
					Main.npc[num247].homeless = true;
				}
				else if (drunkWorldGen)
				{
					int num248 = NPC.NewNPC(Main.spawnTileX * 16, Main.spawnTileY * 16, 208);
					Main.npc[num248].homeTileX = Main.spawnTileX;
					Main.npc[num248].homeTileY = Main.spawnTileY;
					Main.npc[num248].direction = 1;
					Main.npc[num248].homeless = true;
				}
				else if (notTheBees)
				{
					int num249 = NPC.NewNPC(Main.spawnTileX * 16, Main.spawnTileY * 16, 17);
					Main.npc[num249].homeTileX = Main.spawnTileX;
					Main.npc[num249].homeTileY = Main.spawnTileY;
					Main.npc[num249].direction = 1;
					Main.npc[num249].homeless = true;
				}
				else
				{
					int num250 = NPC.NewNPC(Main.spawnTileX * 16, Main.spawnTileY * 16, 22);
					Main.npc[num250].homeTileX = Main.spawnTileX;
					Main.npc[num250].homeTileY = Main.spawnTileY;
					Main.npc[num250].direction = 1;
					Main.npc[num250].homeless = true;
				}
			});
			AddGenerationPass("Sunflowers", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[39].Value;
				for (int num241 = 0; (double)num241 < (double)Main.maxTilesX * 0.002; num241++)
				{
					progress.Set((float)num241 / (float)Main.maxTilesX * 0.002f);
					int num242 = 0;
					int num243 = 0;
					_ = Main.maxTilesX / 2;
					int num244 = genRand.Next(Main.maxTilesX);
					num242 = num244 - genRand.Next(10) - 7;
					num243 = num244 + genRand.Next(10) + 7;
					if (num242 < 0)
					{
						num242 = 0;
					}
					if (num243 > Main.maxTilesX - 1)
					{
						num243 = Main.maxTilesX - 1;
					}
					for (int num245 = num242; num245 < num243; num245++)
					{
						for (int num246 = 1; (double)num246 < Main.worldSurface - 1.0; num246++)
						{
							if (Main.tile[num245, num246].type == 2 && Main.tile[num245, num246].active() && !Main.tile[num245, num246 - 1].active())
							{
								PlaceTile(num245, num246 - 1, 27, mute: true);
							}
							if (Main.tile[num245, num246].active())
							{
								break;
							}
						}
					}
				}
			});
			AddGenerationPass("Planting Trees", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[40].Value;
				if (!drunkWorldGen)
				{
					for (int num236 = 0; (double)num236 < (double)Main.maxTilesX * 0.003; num236++)
					{
						progress.Set((float)num236 / (float)Main.maxTilesX * 0.003f);
						int num237 = genRand.Next(50, Main.maxTilesX - 50);
						int num238 = genRand.Next(25, 50);
						for (int num239 = num237 - num238; num239 < num237 + num238; num239++)
						{
							for (int num240 = 20; (double)num240 < Main.worldSurface; num240++)
							{
								GrowEpicTree(num239, num240);
							}
						}
					}
				}
				AddTrees();
			});
			AddGenerationPass("Herbs", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[41].Value;
				for (int num235 = 0; (double)num235 < (double)Main.maxTilesX * 1.7; num235++)
				{
					progress.Set((float)num235 / (float)Main.maxTilesX * 1.7f);
					PlantAlch();
				}
			});
			AddGenerationPass("Dye Plants", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1f);
				for (int num234 = 0; num234 < Main.maxTilesX; num234++)
				{
					plantDye(genRand.Next(100, Main.maxTilesX - 100), genRand.Next(100, Main.UnderworldLayer));
				}
				MatureTheHerbPlants();
			});
			AddGenerationPass("Webs And Honey", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1f);
				for (int num225 = 100; num225 < Main.maxTilesX - 100; num225++)
				{
					for (int num226 = (int)Main.worldSurface; num226 < Main.maxTilesY - 100; num226++)
					{
						if (Main.tile[num225, num226].wall == 86)
						{
							if (Main.tile[num225, num226].liquid > 0)
							{
								Main.tile[num225, num226].honey(honey: true);
							}
							if (genRand.Next(3) == 0)
							{
								PlaceTight(num225, num226);
							}
						}
						if (Main.tile[num225, num226].wall == 62)
						{
							Main.tile[num225, num226].liquid = 0;
							Main.tile[num225, num226].lava(lava: false);
						}
						if (Main.tile[num225, num226].wall == 62 && !Main.tile[num225, num226].active() && genRand.Next(10) != 0)
						{
							int num227 = genRand.Next(2, 5);
							int num228 = num225 - num227;
							int num229 = num225 + num227;
							int num230 = num226 - num227;
							int num231 = num226 + num227;
							bool flag5 = false;
							for (int num232 = num228; num232 <= num229; num232++)
							{
								for (int num233 = num230; num233 <= num231; num233++)
								{
									if (SolidTile(num232, num233))
									{
										flag5 = true;
										break;
									}
								}
							}
							if (flag5)
							{
								PlaceTile(num225, num226, 51, mute: true);
								TileFrame(num225, num226);
							}
						}
					}
				}
			});
			AddGenerationPass("Weeds", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[42].Value;
				if (Main.halloween)
				{
					for (int num219 = 40; num219 < Main.maxTilesX - 40; num219++)
					{
						for (int num220 = 50; (double)num220 < Main.worldSurface; num220++)
						{
							if (Main.tile[num219, num220].active() && Main.tile[num219, num220].type == 2 && genRand.Next(15) == 0)
							{
								PlacePumpkin(num219, num220 - 1);
								int num221 = genRand.Next(5);
								for (int num222 = 0; num222 < num221; num222++)
								{
									GrowPumpkin(num219, num220 - 1, 254);
								}
							}
						}
					}
				}
				for (int num223 = 0; num223 < Main.maxTilesX; num223++)
				{
					progress.Set((float)num223 / (float)Main.maxTilesX);
					for (int num224 = 1; num224 < Main.maxTilesY; num224++)
					{
						if (Main.tile[num223, num224].type == 2 && Main.tile[num223, num224].nactive())
						{
							if (!Main.tile[num223, num224 - 1].active())
							{
								PlaceTile(num223, num224 - 1, 3, mute: true);
							}
						}
						else if (Main.tile[num223, num224].type == 23 && Main.tile[num223, num224].nactive())
						{
							if (!Main.tile[num223, num224 - 1].active())
							{
								PlaceTile(num223, num224 - 1, 24, mute: true);
							}
						}
						else if (Main.tile[num223, num224].type == 199 && Main.tile[num223, num224].nactive() && !Main.tile[num223, num224 - 1].active())
						{
							PlaceTile(num223, num224 - 1, 201, mute: true);
						}
					}
				}
			});
			AddGenerationPass("Glowing Mushrooms and Jungle Plants", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1f);
				for (int num217 = 0; num217 < Main.maxTilesX; num217++)
				{
					for (int num218 = 0; num218 < Main.maxTilesY; num218++)
					{
						if (Main.tile[num217, num218].active())
						{
							if (num218 >= (int)Main.worldSurface && Main.tile[num217, num218].type == 70 && !Main.tile[num217, num218 - 1].active())
							{
								GrowTree(num217, num218);
								if (!Main.tile[num217, num218 - 1].active())
								{
									GrowTree(num217, num218);
									if (!Main.tile[num217, num218 - 1].active())
									{
										GrowShroom(num217, num218);
										if (!Main.tile[num217, num218 - 1].active())
										{
											PlaceTile(num217, num218 - 1, 71, mute: true);
										}
									}
								}
							}
							if (Main.tile[num217, num218].type == 60 && !Main.tile[num217, num218 - 1].active())
							{
								PlaceTile(num217, num218 - 1, 61, mute: true);
							}
						}
					}
				}
			});
			AddGenerationPass("Jungle Plants", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1f);
				for (int num214 = 0; num214 < Main.maxTilesX * 100; num214++)
				{
					int num215 = genRand.Next(40, Main.maxTilesX / 2 - 40);
					if (dungeonSide < 0)
					{
						num215 += Main.maxTilesX / 2;
					}
					int num216;
					for (num216 = genRand.Next(Main.maxTilesY - 300); !Main.tile[num215, num216].active() && num216 < Main.maxTilesY - 300; num216++)
					{
					}
					if (Main.tile[num215, num216].active() && Main.tile[num215, num216].type == 60)
					{
						num216--;
						PlaceJunglePlant(num215, num216, 233, genRand.Next(8), 0);
						if (Main.tile[num215, num216].type != 233)
						{
							PlaceJunglePlant(num215, num216, 233, genRand.Next(12), 1);
						}
					}
				}
			});
			AddGenerationPass("Vines", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[43].Value;
				for (int num196 = 5; num196 < Main.maxTilesX - 5; num196++)
				{
					progress.Set((float)num196 / (float)Main.maxTilesX);
					int num197 = 0;
					ushort type2 = 52;
					for (int num198 = 0; (double)num198 < Main.worldSurface; num198++)
					{
						if (num197 > 0 && !Main.tile[num196, num198].active())
						{
							Main.tile[num196, num198].active(active: true);
							Main.tile[num196, num198].type = type2;
							Main.tile[num196, num198].color(Main.tile[num196, num198 - 1].color());
							num197--;
						}
						else
						{
							num197 = 0;
						}
						if (Main.tile[num196, num198].active() && !Main.tile[num196, num198].bottomSlope() && (Main.tile[num196, num198].type == 2 || (Main.tile[num196, num198].type == 192 && genRand.Next(4) == 0)) && GrowMoreVines(num196, num198))
						{
							type2 = 52;
							if (Main.tile[num196, num198].wall == 68 || Main.tile[num196, num198].wall == 65 || Main.tile[num196, num198].wall == 66 || Main.tile[num196, num198].wall == 63)
							{
								type2 = 382;
							}
							else if (Main.tile[num196, num198 + 1].wall == 68 || Main.tile[num196, num198 + 1].wall == 65 || Main.tile[num196, num198 + 1].wall == 66 || Main.tile[num196, num198 + 1].wall == 63)
							{
								type2 = 382;
							}
							if (genRand.Next(5) < 3)
							{
								num197 = genRand.Next(1, 10);
							}
						}
					}
					num197 = 0;
					for (int num199 = 5; num199 < Main.maxTilesY - 5; num199++)
					{
						if (num197 > 0 && !Main.tile[num196, num199].active())
						{
							Main.tile[num196, num199].active(active: true);
							Main.tile[num196, num199].type = 62;
							num197--;
						}
						else
						{
							num197 = 0;
						}
						if (Main.tile[num196, num199].active() && Main.tile[num196, num199].type == 60 && !Main.tile[num196, num199].bottomSlope() && GrowMoreVines(num196, num199))
						{
							if (notTheBees && num199 < Main.maxTilesY - 10 && Main.tile[num196, num199 - 1].active() && !Main.tile[num196, num199 - 1].bottomSlope() && Main.tile[num196 + 1, num199 - 1].active() && !Main.tile[num196 + 1, num199 - 1].bottomSlope() && (Main.tile[num196, num199 - 1].type == 60 || Main.tile[num196, num199 - 1].type == 444 || Main.tile[num196, num199 - 1].type == 230))
							{
								bool flag3 = true;
								for (int num200 = num196; num200 < num196 + 2; num200++)
								{
									for (int num201 = num199 + 1; num201 < num199 + 3; num201++)
									{
										if (Main.tile[num200, num201].active() && (!Main.tileCut[Main.tile[num200, num201].type] || Main.tile[num200, num201].type == 444))
										{
											flag3 = false;
											break;
										}
										if (Main.tile[num200, num201].liquid > 0 || Main.wallHouse[Main.tile[num200, num201].wall])
										{
											flag3 = false;
											break;
										}
									}
									if (!flag3)
									{
										break;
									}
								}
								if (flag3 && CountNearBlocksTypes(num196, num199, genRand.Next(3, 10), 1, 444) > 0)
								{
									flag3 = false;
								}
								if (flag3)
								{
									for (int num202 = num196; num202 < num196 + 2; num202++)
									{
										for (int num203 = num199 + 1; num203 < num199 + 3; num203++)
										{
											KillTile(num202, num203);
										}
									}
									for (int num204 = num196; num204 < num196 + 2; num204++)
									{
										for (int num205 = num199 + 1; num205 < num199 + 3; num205++)
										{
											Main.tile[num204, num205].active(active: true);
											Main.tile[num204, num205].type = 444;
											Main.tile[num204, num205].frameX = (short)((num204 - num196) * 18);
											Main.tile[num204, num205].frameY = (short)((num205 - num199 - 1) * 18);
										}
									}
									continue;
								}
							}
							else if (num196 < Main.maxTilesX - 1 && num199 < Main.maxTilesY - 2 && Main.tile[num196 + 1, num199].active() && Main.tile[num196 + 1, num199].type == 60 && !Main.tile[num196 + 1, num199].bottomSlope() && genRand.Next(40) == 0)
							{
								bool flag4 = true;
								for (int num206 = num196; num206 < num196 + 2; num206++)
								{
									for (int num207 = num199 + 1; num207 < num199 + 3; num207++)
									{
										if (Main.tile[num206, num207].active() && (!Main.tileCut[Main.tile[num206, num207].type] || Main.tile[num206, num207].type == 444))
										{
											flag4 = false;
											break;
										}
										if (Main.tile[num206, num207].liquid > 0 || Main.wallHouse[Main.tile[num206, num207].wall])
										{
											flag4 = false;
											break;
										}
									}
									if (!flag4)
									{
										break;
									}
								}
								if (flag4 && CountNearBlocksTypes(num196, num199, 20, 1, 444) > 0)
								{
									flag4 = false;
								}
								if (flag4)
								{
									for (int num208 = num196; num208 < num196 + 2; num208++)
									{
										for (int num209 = num199 + 1; num209 < num199 + 3; num209++)
										{
											KillTile(num208, num209);
										}
									}
									for (int num210 = num196; num210 < num196 + 2; num210++)
									{
										for (int num211 = num199 + 1; num211 < num199 + 3; num211++)
										{
											Main.tile[num210, num211].active(active: true);
											Main.tile[num210, num211].type = 444;
											Main.tile[num210, num211].frameX = (short)((num210 - num196) * 18);
											Main.tile[num210, num211].frameY = (short)((num211 - num199 - 1) * 18);
										}
									}
									continue;
								}
							}
							if (genRand.Next(5) < 3)
							{
								num197 = genRand.Next(1, 10);
							}
						}
					}
					num197 = 0;
					for (int num212 = 0; num212 < Main.maxTilesY; num212++)
					{
						if (num197 > 0 && !Main.tile[num196, num212].active())
						{
							Main.tile[num196, num212].active(active: true);
							Main.tile[num196, num212].type = 528;
							num197--;
						}
						else
						{
							num197 = 0;
						}
						if (Main.tile[num196, num212].active() && Main.tile[num196, num212].type == 70 && genRand.Next(5) == 0 && !Main.tile[num196, num212].bottomSlope() && GrowMoreVines(num196, num212) && genRand.Next(5) < 3)
						{
							num197 = genRand.Next(1, 10);
						}
					}
					num197 = 0;
					for (int num213 = 0; num213 < Main.maxTilesY; num213++)
					{
						if (num197 > 0 && !Main.tile[num196, num213].active())
						{
							Main.tile[num196, num213].active(active: true);
							Main.tile[num196, num213].type = 205;
							num197--;
						}
						else
						{
							num197 = 0;
						}
						if (Main.tile[num196, num213].active() && !Main.tile[num196, num213].bottomSlope() && Main.tile[num196, num213].type == 199 && GrowMoreVines(num196, num213) && genRand.Next(5) < 3)
						{
							num197 = genRand.Next(1, 10);
						}
					}
				}
			});
			AddGenerationPass("Flowers", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[44].Value;
				for (int num188 = 0; (double)num188 < (double)Main.maxTilesX * 0.004; num188++)
				{
					progress.Set((float)num188 / (float)Main.maxTilesX * 0.004f);
					int num189 = genRand.Next(32, Main.maxTilesX - 32);
					int num190 = genRand.Next(15, 30);
					int num191 = genRand.Next(15, 30);
					for (int num192 = num191; (double)num192 < Main.worldSurface - (double)num191 - 1.0; num192++)
					{
						if (Main.tile[num189, num192].active())
						{
							if (logX >= 0)
							{
								num189 = logX;
								num192 = logY;
								logX = -1;
							}
							int num193 = genRand.NextFromList<int>(21, 24, 27, 30, 33, 36, 39, 42);
							for (int num194 = num189 - num190; num194 < num189 + num190; num194++)
							{
								for (int num195 = num192 - num191; num195 < num192 + num191; num195++)
								{
									if (Main.tile[num194, num195].type != 488 && !Main.tileSolid[Main.tile[num194, num195].type])
									{
										if (Main.tile[num194, num195].type == 3)
										{
											Main.tile[num194, num195].frameX = (short)((num193 + genRand.Next(3)) * 18);
											if (genRand.Next(3) != 0)
											{
												Main.tile[num194, num195].type = 73;
											}
										}
										else if (Main.tile[num194, num195 + 1].wall == 0 && (Main.tile[num194, num195 + 1].type == 2 || ((Main.tile[num194, num195 + 1].type == 40 || Main.tile[num194, num195 + 1].type == 1 || TileID.Sets.Ore[Main.tile[num194, num195 + 1].type]) && !Main.tile[num194, num195].active())) && (!Main.tile[num194, num195].active() || Main.tile[num194, num195].type == 185 || Main.tile[num194, num195].type == 186 || Main.tile[num194, num195].type == 187 || (Main.tile[num194, num195].type == 5 && (double)num194 < (double)Main.maxTilesX * 0.48) || (double)num194 > (double)Main.maxTilesX * 0.52))
										{
											if (Main.tile[num194, num195 + 1].type == 40 || Main.tile[num194, num195 + 1].type == 1 || TileID.Sets.Ore[Main.tile[num194, num195 + 1].type])
											{
												Main.tile[num194, num195 + 1].type = 2;
												if (Main.tile[num194, num195 + 2].type == 40 || Main.tile[num194, num195 + 2].type == 1 || TileID.Sets.Ore[Main.tile[num194, num195 + 2].type])
												{
													Main.tile[num194, num195 + 2].type = 2;
												}
											}
											KillTile(num194, num195);
											if (genRand.Next(2) == 0)
											{
												Main.tile[num194, num195 + 1].slope(0);
												Main.tile[num194, num195 + 1].halfBrick(halfBrick: false);
											}
											PlaceTile(num194, num195, 3);
											if (Main.tile[num194, num195].active() && Main.tile[num194, num195].type == 3)
											{
												Main.tile[num194, num195].frameX = (short)((num193 + genRand.Next(3)) * 18);
												if (genRand.Next(3) != 0)
												{
													Main.tile[num194, num195].type = 73;
												}
											}
											if (Main.tile[num194, num195 + 2].type == 40 || Main.tile[num194, num195 + 2].type == 1 || TileID.Sets.Ore[Main.tile[num194, num195 + 2].type])
											{
												Main.tile[num194, num195 + 2].type = 0;
											}
										}
									}
								}
							}
							break;
						}
					}
				}
			});
			AddGenerationPass("Mushrooms", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[45].Value;
				for (int num181 = 0; (double)num181 < (double)Main.maxTilesX * 0.002; num181++)
				{
					progress.Set((float)num181 / (float)Main.maxTilesX * 0.002f);
					int num182 = genRand.Next(20, Main.maxTilesX - 20);
					int num183 = genRand.Next(4, 10);
					int num184 = genRand.Next(15, 30);
					for (int num185 = 1; (double)num185 < Main.worldSurface - 1.0; num185++)
					{
						if (Main.tile[num182, num185].active())
						{
							for (int num186 = num182 - num183; num186 < num182 + num183; num186++)
							{
								for (int num187 = num185 - num184; num187 < num185 + num184; num187++)
								{
									if (num186 < 10)
									{
										break;
									}
									if (num187 < 0)
									{
										break;
									}
									if (num186 > Main.maxTilesX - 10)
									{
										break;
									}
									if (num187 > Main.maxTilesY - 10)
									{
										break;
									}
									if (Main.tile[num186, num187].type == 3 || Main.tile[num186, num187].type == 24)
									{
										Main.tile[num186, num187].frameX = 144;
									}
									else if (Main.tile[num186, num187].type == 201)
									{
										Main.tile[num186, num187].frameX = 270;
									}
								}
							}
							break;
						}
					}
				}
			});
			AddGenerationPass("Gems In Ice Biome", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1f);
				for (int num170 = 0; (double)num170 < (double)Main.maxTilesX * 0.25; num170++)
				{
					int num171 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, lavaLine);
					int num172 = genRand.Next(snowMinX[num171], snowMaxX[num171]);
					if (Main.tile[num172, num171].active() && (Main.tile[num172, num171].type == 147 || Main.tile[num172, num171].type == 161 || Main.tile[num172, num171].type == 162 || Main.tile[num172, num171].type == 224))
					{
						int num173 = genRand.Next(1, 4);
						int num174 = genRand.Next(1, 4);
						int num175 = genRand.Next(1, 4);
						int num176 = genRand.Next(1, 4);
						int num177 = genRand.Next(12);
						int num178 = 0;
						num178 = ((num177 >= 3) ? ((num177 < 6) ? 1 : ((num177 < 8) ? 2 : ((num177 < 10) ? 3 : ((num177 >= 11) ? 5 : 4)))) : 0);
						for (int num179 = num172 - num173; num179 < num172 + num174; num179++)
						{
							for (int num180 = num171 - num175; num180 < num171 + num176; num180++)
							{
								if (!Main.tile[num179, num180].active())
								{
									PlaceTile(num179, num180, 178, mute: true, forced: false, -1, num178);
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Random Gems", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1f);
				for (int num156 = 0; num156 < Main.maxTilesX; num156++)
				{
					int num157 = genRand.Next(20, Main.maxTilesX - 20);
					int num158 = genRand.Next((int)Main.rockLayer, Main.maxTilesY - 300);
					if (!Main.tile[num157, num158].active() && !Main.tile[num157, num158].lava() && !Main.wallDungeon[Main.tile[num157, num158].wall] && Main.tile[num157, num158].wall != 27)
					{
						int num159 = genRand.Next(12);
						int num160 = 0;
						num160 = ((num159 >= 3) ? ((num159 < 6) ? 1 : ((num159 < 8) ? 2 : ((num159 < 10) ? 3 : ((num159 >= 11) ? 5 : 4)))) : 0);
						PlaceTile(num157, num158, 178, mute: true, forced: false, -1, num160);
					}
				}
				for (int num161 = 0; num161 < Main.maxTilesX; num161++)
				{
					int num162 = genRand.Next(20, Main.maxTilesX - 20);
					int num163 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 300);
					if (!Main.tile[num162, num163].active() && !Main.tile[num162, num163].lava() && (Main.tile[num162, num163].wall == 216 || Main.tile[num162, num163].wall == 187))
					{
						int num164 = genRand.Next(1, 4);
						int num165 = genRand.Next(1, 4);
						int num166 = genRand.Next(1, 4);
						int num167 = genRand.Next(1, 4);
						for (int num168 = num162 - num164; num168 < num162 + num165; num168++)
						{
							for (int num169 = num163 - num166; num169 < num163 + num167; num169++)
							{
								if (!Main.tile[num168, num169].active())
								{
									PlaceTile(num168, num169, 178, mute: true, forced: false, -1, 6);
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Moss Grass", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1f);
				for (int num151 = 5; num151 < Main.maxTilesX - 5; num151++)
				{
					for (int num152 = 5; num152 < Main.maxTilesY - 5; num152++)
					{
						if (Main.tile[num151, num152].active() && Main.tileMoss[Main.tile[num151, num152].type])
						{
							for (int num153 = 0; num153 < 4; num153++)
							{
								int num154 = num151;
								int num155 = num152;
								if (num153 == 0)
								{
									num154--;
								}
								if (num153 == 1)
								{
									num154++;
								}
								if (num153 == 2)
								{
									num155--;
								}
								if (num153 == 3)
								{
									num155++;
								}
								if (!Main.tile[num154, num155].active())
								{
									PlaceTile(num154, num155, 184, mute: true);
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Muds Walls In Jungle", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1f);
				int num143 = 0;
				int num144 = 0;
				bool flag2 = false;
				for (int num145 = 5; num145 < Main.maxTilesX - 5; num145++)
				{
					for (int num146 = 0; (double)num146 < Main.worldSurface + 20.0; num146++)
					{
						if (Main.tile[num145, num146].active() && Main.tile[num145, num146].type == 60)
						{
							num143 = num145;
							flag2 = true;
							break;
						}
					}
					if (flag2)
					{
						break;
					}
				}
				flag2 = false;
				for (int num147 = Main.maxTilesX - 5; num147 > 5; num147--)
				{
					for (int num148 = 0; (double)num148 < Main.worldSurface + 20.0; num148++)
					{
						if (Main.tile[num147, num148].active() && Main.tile[num147, num148].type == 60)
						{
							num144 = num147;
							flag2 = true;
							break;
						}
					}
					if (flag2)
					{
						break;
					}
				}
				jungleMinX = num143;
				jungleMaxX = num144;
				for (int num149 = num143; num149 <= num144; num149++)
				{
					for (int num150 = 0; (double)num150 < Main.worldSurface + 20.0; num150++)
					{
						if (((num149 >= num143 + 2 && num149 <= num144 - 2) || genRand.Next(2) != 0) && ((num149 >= num143 + 3 && num149 <= num144 - 3) || genRand.Next(3) != 0) && (Main.tile[num149, num150].wall == 2 || Main.tile[num149, num150].wall == 59))
						{
							Main.tile[num149, num150].wall = 15;
						}
					}
				}
			});
			AddGenerationPass("Larva", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				Main.tileSolid[229] = true;
				progress.Set(1f);
				for (int num138 = 0; num138 < numLarva; num138++)
				{
					int num139 = larvaX[num138];
					int num140 = larvaY[num138];
					for (int num141 = num139 - 1; num141 <= num139 + 1; num141++)
					{
						for (int num142 = num140 - 2; num142 <= num140 + 1; num142++)
						{
							if (num142 != num140 + 1)
							{
								Main.tile[num141, num142].active(active: false);
							}
							else
							{
								Main.tile[num141, num142].active(active: true);
								Main.tile[num141, num142].type = 225;
								Main.tile[num141, num142].slope(0);
								Main.tile[num141, num142].halfBrick(halfBrick: false);
							}
						}
					}
					PlaceTile(num139, num140, 231, mute: true);
				}
				Main.tileSolid[232] = true;
				Main.tileSolid[162] = true;
			});
			AddGenerationPass("Settle Liquids Again", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				if (getGoodWorldGen)
				{
					Main.tileSolid[56] = true;
				}
				progress.Message = Lang.gen[27].Value;
				if (notTheBees)
				{
					NotTheBees();
				}
				Liquid.worldGenTilesIgnoreWater(ignoreSolids: true);
				Liquid.QuickWater(3);
				WaterCheck();
				int num133 = 0;
				Liquid.quickSettle = true;
				int num134 = 10;
				while (num133 < num134)
				{
					int num135 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
					num133++;
					float num136 = 0f;
					while (Liquid.numLiquid > 0)
					{
						float num137 = (float)(num135 - (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer)) / (float)num135;
						if (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer > num135)
						{
							num135 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
						}
						if (num137 > num136)
						{
							num136 = num137;
						}
						else
						{
							num137 = num136;
						}
						if (num133 == 1)
						{
							progress.Set(num137 / 3f + 0.33f);
						}
						Liquid.UpdateLiquid();
					}
					WaterCheck();
					progress.Set((float)(num133 / num134) / 3f + 0.66f);
				}
				Liquid.quickSettle = false;
				Liquid.worldGenTilesIgnoreWater(ignoreSolids: false);
				Main.tileSolid[484] = false;
			});
			AddGenerationPass("Cactus, Palm Trees, & Coral", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[38].Value;
				int num109 = 8;
				int num110 = 400;
				int num111 = genRand.Next(3, 13);
				int num112 = genRand.Next(3, 13);
				int num113 = genRand.Next(2, 6);
				int num114 = genRand.Next(2, 6);
				int num115 = 380;
				for (int num116 = 0; num116 < numOasis; num116++)
				{
					int num117 = (int)((double)oasisWidth[num116] * 1.5);
					for (int num118 = (int)oasisPosition[num116].X - num117; num118 <= (int)oasisPosition[num116].X + num117; num118++)
					{
						for (int num119 = (int)oasisPosition[num116].Y - oasisHeight; num119 <= (int)oasisPosition[num116].Y + oasisHeight; num119++)
						{
							float num120 = 1f;
							int num121 = 8;
							for (int num122 = num118 - num121; num122 <= num118 + num121; num122++)
							{
								for (int num123 = num119 - num121; num123 <= num119 + num121; num123++)
								{
									if (InWorld(num122, num123) && Main.tile[num122, num123] != null && Main.tile[num122, num123].active() && Main.tile[num122, num123].type == 323)
									{
										num120 = 0.13f;
									}
								}
							}
							if (genRand.NextFloat() < num120)
							{
								GrowPalmTree(num118, num119);
							}
							if (PlantSeaOat(num118, num119))
							{
								if (genRand.Next(2) == 0)
								{
									GrowSeaOat(num118, num119);
								}
								if (genRand.Next(2) == 0)
								{
									GrowSeaOat(num118, num119);
								}
							}
							PlaceOasisPlant(num118, num119, 530);
						}
					}
				}
				for (int num124 = 0; num124 < 3; num124++)
				{
					progress.Set((float)num124 / 3f);
					int num125;
					int num126;
					bool flag;
					int maxValue2;
					switch (num124)
					{
					default:
						num125 = 5;
						num126 = num115;
						flag = false;
						maxValue2 = num111;
						break;
					case 1:
						num125 = num110;
						num126 = Main.maxTilesX - num110;
						flag = true;
						maxValue2 = num109;
						break;
					case 2:
						num125 = Main.maxTilesX - num115;
						num126 = Main.maxTilesX - 5;
						flag = false;
						maxValue2 = num112;
						break;
					}
					for (int num127 = num125; num127 < num126; num127++)
					{
						if (genRand.Next(maxValue2) == 0)
						{
							for (int num128 = 0; (double)num128 < Main.worldSurface - 1.0; num128++)
							{
								Tile tile2 = Main.tile[num127, num128];
								if (tile2.active() && (tile2.type == 53 || tile2.type == 112 || tile2.type == 234))
								{
									Tile tile3 = Main.tile[num127, num128 - 1];
									if (!tile3.active() && tile3.wall == 0)
									{
										if (flag)
										{
											int num129 = 0;
											for (int num130 = num127 - cactusWaterWidth; num130 < num127 + cactusWaterWidth; num130++)
											{
												for (int num131 = num128 - cactusWaterHeight; num131 < num128 + cactusWaterHeight; num131++)
												{
													num129 += Main.tile[num130, num131].liquid;
												}
											}
											if (num129 / 255 > cactusWaterLimit)
											{
												if (genRand.Next(4) == 0)
												{
													GrowPalmTree(num127, num128);
												}
											}
											else
											{
												PlantCactus(num127, num128);
											}
											break;
										}
										if (Main.tile[num127, num128 - 2].liquid == byte.MaxValue && Main.tile[num127, num128 - 3].liquid == byte.MaxValue && Main.tile[num127, num128 - 4].liquid == byte.MaxValue)
										{
											if (genRand.Next(2) == 0)
											{
												PlaceTile(num127, num128 - 1, 81, mute: true);
											}
											else
											{
												PlaceTile(num127, num128 - 1, 324, mute: true, forced: false, -1, RollRandomSeaShellStyle());
											}
											break;
										}
										if (Main.tile[num127, num128 - 2].liquid == 0 && (double)num128 < Main.worldSurface)
										{
											PlaceTile(num127, num128 - 1, 324, mute: true, forced: false, -1, RollRandomSeaShellStyle());
											break;
										}
									}
								}
							}
						}
						else
						{
							for (int num132 = 0; (double)num132 < Main.worldSurface - 1.0; num132++)
							{
								if (PlantSeaOat(num127, num132))
								{
									if (genRand.Next(2) == 0)
									{
										GrowSeaOat(num127, num132);
									}
									if (genRand.Next(2) == 0)
									{
										GrowSeaOat(num127, num132);
									}
								}
								PlaceOasisPlant(num127, num132, 530);
							}
						}
					}
				}
			});
			AddGenerationPass("Tile Cleanup", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[84].Value;
				for (int num52 = 40; num52 < Main.maxTilesX - 40; num52++)
				{
					progress.Set((float)(num52 - 40) / (float)(Main.maxTilesX - 80));
					for (int num53 = 40; num53 < Main.maxTilesY - 40; num53++)
					{
						if (Main.tile[num52, num53].active() && Main.tile[num52, num53].topSlope() && ((Main.tile[num52, num53].leftSlope() && Main.tile[num52 + 1, num53].halfBrick()) || (Main.tile[num52, num53].rightSlope() && Main.tile[num52 - 1, num53].halfBrick())))
						{
							Main.tile[num52, num53].slope(0);
							Main.tile[num52, num53].halfBrick(halfBrick: true);
						}
						if (Main.tile[num52, num53].active() && Main.tile[num52, num53].liquid > 0 && TileID.Sets.SlowlyDiesInWater[Main.tile[num52, num53].type])
						{
							KillTile(num52, num53);
						}
						if (!Main.tile[num52, num53].active() && Main.tile[num52, num53].liquid == 0 && genRand.Next(3) != 0 && SolidTile(num52, num53 - 1))
						{
							int num54 = genRand.Next(15, 21);
							for (int num55 = num53 - 2; num55 >= num53 - num54; num55--)
							{
								if (Main.tile[num52, num55].liquid >= 128)
								{
									int num56 = 373;
									if (Main.tile[num52, num55].lava())
									{
										num56 = 374;
									}
									else if (Main.tile[num52, num55].honey())
									{
										num56 = 375;
									}
									int maxValue = num53 - num55;
									if (genRand.Next(maxValue) <= 1)
									{
										if (Main.tile[num52, num53].wall == 86)
										{
											num56 = 375;
										}
										Main.tile[num52, num53].type = (ushort)num56;
										Main.tile[num52, num53].frameX = 0;
										Main.tile[num52, num53].frameY = 0;
										Main.tile[num52, num53].active(active: true);
										break;
									}
								}
							}
							if (!Main.tile[num52, num53].active())
							{
								num54 = genRand.Next(3, 11);
								for (int num57 = num53 + 1; num57 <= num53 + num54; num57++)
								{
									if (Main.tile[num52, num57].liquid >= 200)
									{
										int num58 = 373;
										if (Main.tile[num52, num57].lava())
										{
											num58 = 374;
										}
										else if (Main.tile[num52, num57].honey())
										{
											num58 = 375;
										}
										int num59 = num57 - num53;
										if (genRand.Next(num59 * 3) <= 1)
										{
											Main.tile[num52, num53].type = (ushort)num58;
											Main.tile[num52, num53].frameX = 0;
											Main.tile[num52, num53].frameY = 0;
											Main.tile[num52, num53].active(active: true);
											break;
										}
									}
								}
							}
							if (!Main.tile[num52, num53].active() && genRand.Next(4) == 0)
							{
								Tile tile = Main.tile[num52, num53 - 1];
								if (TileID.Sets.Conversion.Sandstone[tile.type] || TileID.Sets.Conversion.HardenedSand[tile.type])
								{
									Main.tile[num52, num53].type = 461;
									Main.tile[num52, num53].frameX = 0;
									Main.tile[num52, num53].frameY = 0;
									Main.tile[num52, num53].active(active: true);
								}
							}
						}
						if (Main.tile[num52, num53].type == 137)
						{
							if (Main.tile[num52, num53].frameY <= 52)
							{
								int num60 = -1;
								if (Main.tile[num52, num53].frameX >= 18)
								{
									num60 = 1;
								}
								if (Main.tile[num52 + num60, num53].halfBrick() || Main.tile[num52 + num60, num53].slope() != 0)
								{
									Main.tile[num52 + num60, num53].active(active: false);
								}
							}
						}
						else if (Main.tile[num52, num53].type == 162 && Main.tile[num52, num53 + 1].liquid == 0 && CanKillTile(num52, num53))
						{
							Main.tile[num52, num53].active(active: false);
						}
						if (Main.tile[num52, num53].wall == 13 || Main.tile[num52, num53].wall == 14)
						{
							Main.tile[num52, num53].liquid = 0;
						}
						if (Main.tile[num52, num53].type == 31)
						{
							int num61 = Main.tile[num52, num53].frameX / 18;
							int num62 = 0;
							int num63 = num52;
							num62 += num61 / 2;
							num62 = ((!drunkWorldGen) ? (crimson ? 1 : 0) : ((Main.tile[num52, num53].wall == 83) ? 1 : 0));
							num61 %= 2;
							num63 -= num61;
							int num64 = Main.tile[num52, num53].frameY / 18;
							int num65 = 0;
							int num66 = num53;
							num65 += num64 / 2;
							num64 %= 2;
							num66 -= num64;
							for (int num67 = 0; num67 < 2; num67++)
							{
								for (int num68 = 0; num68 < 2; num68++)
								{
									int num69 = num63 + num67;
									int num70 = num66 + num68;
									Main.tile[num69, num70].active(active: true);
									Main.tile[num69, num70].slope(0);
									Main.tile[num69, num70].halfBrick(halfBrick: false);
									Main.tile[num69, num70].type = 31;
									Main.tile[num69, num70].frameX = (short)(num67 * 18 + 36 * num62);
									Main.tile[num69, num70].frameY = (short)(num68 * 18 + 36 * num65);
								}
							}
						}
						if (Main.tile[num52, num53].type == 12)
						{
							int num71 = Main.tile[num52, num53].frameX / 18;
							int num72 = 0;
							int num73 = num52;
							num72 += num71 / 2;
							num71 %= 2;
							num73 -= num71;
							int num74 = Main.tile[num52, num53].frameY / 18;
							int num75 = 0;
							int num76 = num53;
							num75 += num74 / 2;
							num74 %= 2;
							num76 -= num74;
							for (int num77 = 0; num77 < 2; num77++)
							{
								for (int num78 = 0; num78 < 2; num78++)
								{
									int num79 = num73 + num77;
									int num80 = num76 + num78;
									Main.tile[num79, num80].active(active: true);
									Main.tile[num79, num80].slope(0);
									Main.tile[num79, num80].halfBrick(halfBrick: false);
									Main.tile[num79, num80].type = 12;
									Main.tile[num79, num80].frameX = (short)(num77 * 18 + 36 * num72);
									Main.tile[num79, num80].frameY = (short)(num78 * 18 + 36 * num75);
								}
								if (!Main.tile[num77, num53 + 2].active())
								{
									Main.tile[num77, num53 + 2].active(active: true);
									if (!Main.tileSolid[Main.tile[num77, num53 + 2].type] || Main.tileSolidTop[Main.tile[num77, num53 + 2].type])
									{
										Main.tile[num77, num53 + 2].type = 0;
									}
								}
								Main.tile[num77, num53 + 2].slope(0);
								Main.tile[num77, num53 + 2].halfBrick(halfBrick: false);
							}
						}
						if (TileID.Sets.BasicChest[Main.tile[num52, num53].type])
						{
							int num81 = Main.tile[num52, num53].frameX / 18;
							int num82 = 0;
							ushort type = 21;
							int num83 = num52;
							int num84 = num53 - Main.tile[num52, num53].frameY / 18;
							if (Main.tile[num52, num53].type == 467)
							{
								type = 467;
							}
							while (num81 >= 2)
							{
								num82++;
								num81 -= 2;
							}
							num83 -= num81;
							int num85 = Chest.FindChest(num83, num84);
							if (num85 != -1)
							{
								switch (Main.chest[num85].item[0].type)
								{
								case 1156:
									num82 = 23;
									break;
								case 1571:
									num82 = 24;
									break;
								case 1569:
									num82 = 25;
									break;
								case 1260:
									num82 = 26;
									break;
								case 1572:
									num82 = 27;
									break;
								}
							}
							for (int num86 = 0; num86 < 2; num86++)
							{
								for (int num87 = 0; num87 < 2; num87++)
								{
									int num88 = num83 + num86;
									int num89 = num84 + num87;
									Main.tile[num88, num89].active(active: true);
									Main.tile[num88, num89].slope(0);
									Main.tile[num88, num89].halfBrick(halfBrick: false);
									Main.tile[num88, num89].type = type;
									Main.tile[num88, num89].frameX = (short)(num86 * 18 + 36 * num82);
									Main.tile[num88, num89].frameY = (short)(num87 * 18);
								}
								if (!Main.tile[num86, num53 + 2].active())
								{
									Main.tile[num86, num53 + 2].active(active: true);
									if (!Main.tileSolid[Main.tile[num86, num53 + 2].type] || Main.tileSolidTop[Main.tile[num86, num53 + 2].type])
									{
										Main.tile[num86, num53 + 2].type = 0;
									}
								}
								Main.tile[num86, num53 + 2].slope(0);
								Main.tile[num86, num53 + 2].halfBrick(halfBrick: false);
							}
						}
						if (Main.tile[num52, num53].type == 28)
						{
							int num90 = Main.tile[num52, num53].frameX / 18;
							int num91 = 0;
							int num92 = num52;
							while (num90 >= 2)
							{
								num91++;
								num90 -= 2;
							}
							num92 -= num90;
							int num93 = Main.tile[num52, num53].frameY / 18;
							int num94 = 0;
							int num95 = num53;
							while (num93 >= 2)
							{
								num94++;
								num93 -= 2;
							}
							num95 -= num93;
							for (int num96 = 0; num96 < 2; num96++)
							{
								for (int num97 = 0; num97 < 2; num97++)
								{
									int num98 = num92 + num96;
									int num99 = num95 + num97;
									Main.tile[num98, num99].active(active: true);
									Main.tile[num98, num99].slope(0);
									Main.tile[num98, num99].halfBrick(halfBrick: false);
									Main.tile[num98, num99].type = 28;
									Main.tile[num98, num99].frameX = (short)(num96 * 18 + 36 * num91);
									Main.tile[num98, num99].frameY = (short)(num97 * 18 + 36 * num94);
								}
								if (!Main.tile[num96, num53 + 2].active())
								{
									Main.tile[num96, num53 + 2].active(active: true);
									if (!Main.tileSolid[Main.tile[num96, num53 + 2].type] || Main.tileSolidTop[Main.tile[num96, num53 + 2].type])
									{
										Main.tile[num96, num53 + 2].type = 0;
									}
								}
								Main.tile[num96, num53 + 2].slope(0);
								Main.tile[num96, num53 + 2].halfBrick(halfBrick: false);
							}
						}
						if (Main.tile[num52, num53].type == 26)
						{
							int num100 = Main.tile[num52, num53].frameX / 18;
							int num101 = 0;
							int num102 = num52;
							int num103 = num53 - Main.tile[num52, num53].frameY / 18;
							while (num100 >= 3)
							{
								num101++;
								num100 -= 3;
							}
							num102 -= num100;
							num101 = (drunkWorldGen ? ((Main.tile[num52, num53].wall == 83) ? 1 : 0) : (crimson ? 1 : 0));
							for (int num104 = 0; num104 < 3; num104++)
							{
								for (int num105 = 0; num105 < 2; num105++)
								{
									int num106 = num102 + num104;
									int num107 = num103 + num105;
									Main.tile[num106, num107].active(active: true);
									Main.tile[num106, num107].slope(0);
									Main.tile[num106, num107].halfBrick(halfBrick: false);
									Main.tile[num106, num107].type = 26;
									Main.tile[num106, num107].frameX = (short)(num104 * 18 + 54 * num101);
									Main.tile[num106, num107].frameY = (short)(num105 * 18);
								}
								if (!Main.tile[num102 + num104, num103 + 2].active() || !Main.tileSolid[Main.tile[num102 + num104, num103 + 2].type] || Main.tileSolidTop[Main.tile[num102 + num104, num103 + 2].type])
								{
									Main.tile[num102 + num104, num103 + 2].active(active: true);
									if (!TileID.Sets.Platforms[Main.tile[num102 + num104, num103 + 2].type] && (!Main.tileSolid[Main.tile[num102 + num104, num103 + 2].type] || Main.tileSolidTop[Main.tile[num102 + num104, num103 + 2].type]))
									{
										Main.tile[num102 + num104, num103 + 2].type = 0;
									}
								}
								Main.tile[num102 + num104, num103 + 2].slope(0);
								Main.tile[num102 + num104, num103 + 2].halfBrick(halfBrick: false);
								if (Main.tile[num102 + num104, num103 + 3].type == 28 && Main.tile[num102 + num104, num103 + 3].frameY % 36 >= 18)
								{
									Main.tile[num102 + num104, num103 + 3].type = 0;
									Main.tile[num102 + num104, num103 + 3].active(active: false);
								}
							}
							for (int num108 = 0; num108 < 3; num108++)
							{
								if ((Main.tile[num102 - 1, num103 + num108].type == 28 || Main.tile[num102 - 1, num103 + num108].type == 12) && Main.tile[num102 - 1, num103 + num108].frameX % 36 < 18)
								{
									Main.tile[num102 - 1, num103 + num108].type = 0;
									Main.tile[num102 - 1, num103 + num108].active(active: false);
								}
								if ((Main.tile[num102 + 3, num103 + num108].type == 28 || Main.tile[num102 + 3, num103 + num108].type == 12) && Main.tile[num102 + 3, num103 + num108].frameX % 36 >= 18)
								{
									Main.tile[num102 + 3, num103 + num108].type = 0;
									Main.tile[num102 + 3, num103 + num108].active(active: false);
								}
							}
						}
						if (Main.tile[num52, num53].type == 237 && Main.tile[num52, num53 + 1].type == 232)
						{
							Main.tile[num52, num53 + 1].type = 226;
						}
						if (Main.tile[num52, num53].wall == 87)
						{
							Main.tile[num52, num53].liquid = 0;
						}
					}
				}
			});
			AddGenerationPass("Lihzahrd Altars", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1f);
				for (int num46 = 0; num46 < 3; num46++)
				{
					for (int num47 = 0; num47 < 2; num47++)
					{
						int num48 = lAltarX + num46;
						int num49 = lAltarY + num47;
						Main.tile[num48, num49].active(active: true);
						Main.tile[num48, num49].type = 237;
						Main.tile[num48, num49].frameX = (short)(num46 * 18);
						Main.tile[num48, num49].frameY = (short)(num47 * 18);
					}
					Main.tile[lAltarX + num46, lAltarY + 2].active(active: true);
					Main.tile[lAltarX + num46, lAltarY + 2].slope(0);
					Main.tile[lAltarX + num46, lAltarY + 2].halfBrick(halfBrick: false);
					Main.tile[lAltarX + num46, lAltarY + 2].type = 226;
				}
				for (int num50 = 0; num50 < 3; num50++)
				{
					for (int num51 = 0; num51 < 2; num51++)
					{
						int i3 = lAltarX + num50;
						int j2 = lAltarY + num51;
						SquareTileFrame(i3, j2);
					}
				}
			});
			AddGenerationPass("Micro Biomes", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[76].Value;
				_ = (float)(Main.maxTilesX * Main.maxTilesY) / 5040000f;
				float num27 = 10f;
				if (getGoodWorldGen)
				{
					num27 *= 10f;
				}
				DeadMansChestBiome deadMansChestBiome = configuration.CreateBiome<DeadMansChestBiome>();
				List<int> possibleChestsToTrapify = deadMansChestBiome.GetPossibleChestsToTrapify(structures);
				int random = passConfig.Get<WorldGenRange>("DeadManChests").GetRandom(genRand);
				int num28 = 0;
				while (num28 < random && possibleChestsToTrapify.Count > 0)
				{
					int num29 = possibleChestsToTrapify[genRand.Next(possibleChestsToTrapify.Count)];
					Point origin = new Point(Main.chest[num29].x, Main.chest[num29].y);
					deadMansChestBiome.Place(origin, structures);
					num28++;
					possibleChestsToTrapify.Remove(num29);
				}
				progress.Set(1f / num27);
				if (!notTheBees)
				{
					ThinIceBiome thinIceBiome = configuration.CreateBiome<ThinIceBiome>();
					int random2 = passConfig.Get<WorldGenRange>("ThinIcePatchCount").GetRandom(genRand);
					int num30 = 0;
					while (num30 < random2)
					{
						if (thinIceBiome.Place(RandomWorldPoint((int)Main.worldSurface + 20, 50, 200, 50), structures))
						{
							num30++;
						}
					}
				}
				progress.Set(0.1f);
				progress.Set(2f / num27);
				EnchantedSwordBiome enchantedSwordBiome = configuration.CreateBiome<EnchantedSwordBiome>();
				int random3 = passConfig.Get<WorldGenRange>("SwordShrineAttempts").GetRandom(genRand);
				float num31 = passConfig.Get<float>("SwordShrinePlacementChance");
				Point origin2 = default(Point);
				for (int num32 = 0; num32 < random3; num32++)
				{
					if (!(genRand.NextFloat() > num31))
					{
						int num33 = 0;
						while (num33++ <= Main.maxTilesX)
						{
							origin2.Y = (int)worldSurface + genRand.Next(50, 100);
							if (genRand.Next(2) == 0)
							{
								origin2.X = genRand.Next(50, (int)((float)Main.maxTilesX * 0.3f));
							}
							else
							{
								origin2.X = genRand.Next((int)((float)Main.maxTilesX * 0.7f), Main.maxTilesX - 50);
							}
							if (enchantedSwordBiome.Place(origin2, structures))
							{
								break;
							}
						}
					}
				}
				progress.Set(0.2f);
				progress.Set(3f / num27);
				if (!notTheBees)
				{
					CampsiteBiome campsiteBiome = configuration.CreateBiome<CampsiteBiome>();
					int random4 = passConfig.Get<WorldGenRange>("CampsiteCount").GetRandom(genRand);
					int num34 = 0;
					while (num34 < random4)
					{
						if (campsiteBiome.Place(RandomWorldPoint((int)Main.worldSurface, beachDistance, 200, beachDistance), structures))
						{
							num34++;
						}
					}
				}
				progress.Set(4f / num27);
				if (!notTheBees)
				{
					MiningExplosivesBiome miningExplosivesBiome = configuration.CreateBiome<MiningExplosivesBiome>();
					int num35 = passConfig.Get<WorldGenRange>("ExplosiveTrapCount").GetRandom(genRand);
					if (getGoodWorldGen)
					{
						num35 = (int)((double)num35 * 1.5);
					}
					int num36 = 0;
					while (num36 < num35)
					{
						if (miningExplosivesBiome.Place(RandomWorldPoint((int)rockLayer, beachDistance, 200, beachDistance), structures))
						{
							num36++;
						}
					}
				}
				progress.Set(0.3f);
				progress.Set(5f / num27);
				MahoganyTreeBiome mahoganyTreeBiome = configuration.CreateBiome<MahoganyTreeBiome>();
				int random5 = passConfig.Get<WorldGenRange>("LivingTreeCount").GetRandom(genRand);
				int num37 = 0;
				int num38 = 0;
				while (num37 < random5 && num38 < 20000)
				{
					if (mahoganyTreeBiome.Place(RandomWorldPoint((int)Main.worldSurface + 50, 50, 500, 50), structures))
					{
						num37++;
					}
					num38++;
				}
				progress.Set(0.4f);
				progress.Set(6f / num27);
				progress.Set(7f / num27);
				TrackGenerator trackGenerator = new TrackGenerator();
				int random6 = passConfig.Get<WorldGenRange>("LongTrackCount").GetRandom(genRand);
				WorldGenRange worldGenRange = passConfig.Get<WorldGenRange>("LongTrackLength");
				int num39 = Main.maxTilesX * 10;
				int num40 = 0;
				int num41 = 0;
				while (num41 < random6)
				{
					if (trackGenerator.Place(RandomWorldPoint((int)Main.worldSurface, 10, 200, 10), worldGenRange.ScaledMinimum, worldGenRange.ScaledMaximum))
					{
						num41++;
						num40 = 0;
					}
					else
					{
						num40++;
						if (num40 > num39)
						{
							num41++;
							num40 = 0;
						}
					}
				}
				progress.Set(8f / num27);
				random6 = passConfig.Get<WorldGenRange>("StandardTrackCount").GetRandom(genRand);
				worldGenRange = passConfig.Get<WorldGenRange>("StandardTrackLength");
				int num42 = 0;
				while (num42 < random6)
				{
					if (trackGenerator.Place(RandomWorldPoint((int)Main.worldSurface, 10, 200, 10), worldGenRange.ScaledMinimum, worldGenRange.ScaledMaximum))
					{
						num42++;
					}
				}
				progress.Set(9f / num27);
				if (!notTheBees)
				{
					double num43 = (double)Main.maxTilesX * 0.02;
					if (getGoodWorldGen)
					{
						num27 *= 2f;
					}
					for (int num44 = 0; (double)num44 < num43; num44++)
					{
						for (int num45 = 0; num45 < 10150; num45++)
						{
							int x2 = genRand.Next(200, Main.maxTilesX - 200);
							int y2 = genRand.Next(lavaLine - 100, Main.maxTilesY - 210);
							if (placeLavaTrap(x2, y2))
							{
								break;
							}
						}
					}
				}
				progress.Set(1f);
			});
			AddGenerationPass("Water Plants", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[88].Value;
				for (int num20 = 20; num20 < Main.maxTilesX - 20; num20++)
				{
					progress.Set((float)num20 / (float)Main.maxTilesX);
					for (int num21 = 1; (double)num21 < Main.worldSurface; num21++)
					{
						if (genRand.Next(5) == 0 && Main.tile[num20, num21].liquid > 0)
						{
							if (!Main.tile[num20, num21].active())
							{
								if (genRand.Next(2) == 0)
								{
									PlaceLilyPad(num20, num21);
								}
								else
								{
									Point point = PlaceCatTail(num20, num21);
									if (InWorld(point.X, point.Y))
									{
										int num22 = genRand.Next(14);
										for (int num23 = 0; num23 < num22; num23++)
										{
											GrowCatTail(point.X, point.Y);
										}
										SquareTileFrame(point.X, point.Y);
									}
								}
							}
							if ((!Main.tile[num20, num21].active() || Main.tile[num20, num21].type == 61 || Main.tile[num20, num21].type == 74) && PlaceBamboo(num20, num21))
							{
								int num24 = genRand.Next(10, 20);
								for (int num25 = 0; num25 < num24 && PlaceBamboo(num20, num21 - num25); num25++)
								{
								}
							}
						}
					}
					int num26 = Main.UnderworldLayer;
					while ((double)num26 > Main.worldSurface)
					{
						if (Main.tile[num20, num26].type == 53 && genRand.Next(3) != 0)
						{
							GrowCheckSeaweed(num20, num26);
						}
						else if (Main.tile[num20, num26].type == 549)
						{
							GrowCheckSeaweed(num20, num26);
						}
						num26--;
					}
				}
			});
			AddGenerationPass("Stalac", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1f);
				for (int num16 = 20; num16 < Main.maxTilesX - 20; num16++)
				{
					for (int num17 = (int)Main.worldSurface; num17 < Main.maxTilesY - 20; num17++)
					{
						if ((drunkWorldGen || genRand.Next(5) == 0) && Main.tile[num16, num17 - 1].liquid == 0)
						{
							int num18 = genRand.Next(7);
							int treeTileType = 0;
							switch (num18)
							{
							case 0:
								treeTileType = 583;
								break;
							case 1:
								treeTileType = 584;
								break;
							case 2:
								treeTileType = 585;
								break;
							case 3:
								treeTileType = 586;
								break;
							case 4:
								treeTileType = 587;
								break;
							case 5:
								treeTileType = 588;
								break;
							case 6:
								treeTileType = 589;
								break;
							}
							TryGrowingTreeByType(treeTileType, num16, num17);
						}
						if (!oceanDepths(num16, num17) && !Main.tile[num16, num17].active() && genRand.Next(5) == 0)
						{
							if ((Main.tile[num16, num17 - 1].type == 1 || Main.tile[num16, num17 - 1].type == 147 || Main.tile[num16, num17 - 1].type == 161 || Main.tile[num16, num17 - 1].type == 25 || Main.tile[num16, num17 - 1].type == 203 || Main.tileStone[Main.tile[num16, num17 - 1].type] || Main.tileMoss[Main.tile[num16, num17 - 1].type]) && !Main.tile[num16, num17].active() && !Main.tile[num16, num17 + 1].active())
							{
								Main.tile[num16, num17 - 1].slope(0);
							}
							if ((Main.tile[num16, num17 + 1].type == 1 || Main.tile[num16, num17 + 1].type == 147 || Main.tile[num16, num17 + 1].type == 161 || Main.tile[num16, num17 + 1].type == 25 || Main.tile[num16, num17 + 1].type == 203 || Main.tileStone[Main.tile[num16, num17 + 1].type] || Main.tileMoss[Main.tile[num16, num17 + 1].type]) && !Main.tile[num16, num17].active() && !Main.tile[num16, num17 - 1].active())
							{
								Main.tile[num16, num17 + 1].slope(0);
							}
							PlaceTight(num16, num17);
						}
					}
					for (int num19 = 5; num19 < (int)Main.worldSurface; num19++)
					{
						if ((Main.tile[num16, num19 - 1].type == 147 || Main.tile[num16, num19 - 1].type == 161) && genRand.Next(5) == 0)
						{
							if (!Main.tile[num16, num19].active() && !Main.tile[num16, num19 + 1].active())
							{
								Main.tile[num16, num19 - 1].slope(0);
							}
							PlaceTight(num16, num19);
						}
						if ((Main.tile[num16, num19 - 1].type == 25 || Main.tile[num16, num19 - 1].type == 203) && genRand.Next(5) == 0)
						{
							if (!Main.tile[num16, num19].active() && !Main.tile[num16, num19 + 1].active())
							{
								Main.tile[num16, num19 - 1].slope(0);
							}
							PlaceTight(num16, num19);
						}
						if ((Main.tile[num16, num19 + 1].type == 25 || Main.tile[num16, num19 + 1].type == 203) && genRand.Next(5) == 0)
						{
							if (!Main.tile[num16, num19].active() && !Main.tile[num16, num19 - 1].active())
							{
								Main.tile[num16, num19 + 1].slope(0);
							}
							PlaceTight(num16, num19);
						}
					}
				}
			});
			AddGenerationPass("Remove Broken Traps", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[82].Value;
				List<Point> list = new List<Point>();
				int num13 = 50;
				for (int num14 = num13; num14 < Main.maxTilesX - num13; num14++)
				{
					float value = (float)(num14 - num13) / (float)(Main.maxTilesX - num13 * 2);
					progress.Set(value);
					for (int num15 = 50; num15 < Main.maxTilesY - 50; num15++)
					{
						if (Main.tile[num14, num15].wire() && !list.Contains(new Point(num14, num15)))
						{
							ClearBrokenTraps(new Point(num14, num15), list);
						}
					}
				}
			});
			AddGenerationPass("Final Cleanup", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				FillWallHolesInArea(new Rectangle(0, 0, Main.maxTilesX, (int)Main.worldSurface));
				progress.Message = Lang.gen[86].Value;
				for (int j = 0; j < Main.maxTilesX; j++)
				{
					progress.Set((float)j / (float)Main.maxTilesX);
					for (int k = 0; k < Main.maxTilesY; k++)
					{
						if (Main.tile[j, k].active() && !SolidTile(j, k + 1) && (Main.tile[j, k].type == 53 || Main.tile[j, k].type == 112 || Main.tile[j, k].type == 234 || Main.tile[j, k].type == 224 || Main.tile[j, k].type == 123))
						{
							if ((double)k < Main.worldSurface + 10.0 && !Main.tile[j, k + 1].active() && Main.tile[j, k + 1].wall != 191 && !oceanDepths(j, k))
							{
								int num2 = 10;
								int num3 = k + 1;
								for (int l = num3; l < num3 + 10; l++)
								{
									if (Main.tile[j, l].active() && Main.tile[j, l].type == 314)
									{
										num2 = 0;
										break;
									}
								}
								while (!Main.tile[j, num3].active() && num2 > 0 && num3 < Main.maxTilesY - 50)
								{
									Main.tile[j, num3 - 1].slope(0);
									Main.tile[j, num3 - 1].halfBrick(halfBrick: false);
									Main.tile[j, num3].active(active: true);
									Main.tile[j, num3].type = Main.tile[j, k].type;
									Main.tile[j, num3].slope(0);
									Main.tile[j, num3].halfBrick(halfBrick: false);
									num3++;
									num2--;
								}
								if (num2 == 0 && !Main.tile[j, num3].active())
								{
									switch (Main.tile[j, k].type)
									{
									case 53:
										Main.tile[j, num3].type = 397;
										Main.tile[j, num3].active(active: true);
										break;
									case 112:
										Main.tile[j, num3].type = 398;
										Main.tile[j, num3].active(active: true);
										break;
									case 234:
										Main.tile[j, num3].type = 399;
										Main.tile[j, num3].active(active: true);
										break;
									case 224:
										Main.tile[j, num3].type = 147;
										Main.tile[j, num3].active(active: true);
										break;
									case 123:
										Main.tile[j, num3].type = 1;
										Main.tile[j, num3].active(active: true);
										break;
									}
								}
								else if (Main.tile[j, num3].active() && Main.tileSolid[Main.tile[j, num3].type] && !Main.tileSolidTop[Main.tile[j, num3].type])
								{
									Main.tile[j, num3].slope(0);
									Main.tile[j, num3].halfBrick(halfBrick: false);
								}
							}
							else if (Main.tileSolid[Main.tile[j, k + 1].type] && !Main.tileSolidTop[Main.tile[j, k + 1].type] && (Main.tile[j, k + 1].topSlope() || Main.tile[j, k + 1].halfBrick()))
							{
								Main.tile[j, k + 1].slope(0);
								Main.tile[j, k + 1].halfBrick(halfBrick: false);
							}
							else
							{
								switch (Main.tile[j, k].type)
								{
								case 53:
									Main.tile[j, k].type = 397;
									break;
								case 112:
									Main.tile[j, k].type = 398;
									break;
								case 234:
									Main.tile[j, k].type = 399;
									break;
								case 224:
									Main.tile[j, k].type = 147;
									break;
								case 123:
									Main.tile[j, k].type = 1;
									break;
								}
							}
						}
						if ((Main.tile[j, k].wall == 187 || Main.tile[j, k].wall == 216) && Main.tile[j, k].liquid > 0)
						{
							Main.tile[j, k].liquid = byte.MaxValue;
							Main.tile[j, k].lava(lava: true);
						}
						if (Main.tile[j, k].type == 485 || Main.tile[j, k].type == 187 || Main.tile[j, k].type == 165)
						{
							TileFrame(j, k);
						}
						if (Main.tile[j, k].type == 28)
						{
							TileFrame(j, k);
						}
						if (Main.tile[j, k].type == 137)
						{
							Main.tile[j, k].slope(0);
							Main.tile[j, k].halfBrick(halfBrick: false);
						}
						if (Main.tile[j, k].active() && TileID.Sets.Boulders[Main.tile[j, k].type])
						{
							int num4 = Main.tile[j, k].frameX / 18;
							int num5 = j;
							num5 -= num4;
							int num6 = Main.tile[j, k].frameY / 18;
							int num7 = k;
							num7 -= num6;
							for (int m = 0; m < 2; m++)
							{
								for (int n = 0; n < 2; n++)
								{
									int num8 = num5 + m;
									int num9 = num7 + n;
									Main.tile[num8, num9].active(active: true);
									Main.tile[num8, num9].slope(0);
									Main.tile[num8, num9].halfBrick(halfBrick: false);
									Main.tile[num8, num9].type = Main.tile[j, k].type;
									Main.tile[num8, num9].frameX = (short)(m * 18);
									Main.tile[num8, num9].frameY = (short)(n * 18);
								}
							}
						}
						if (Main.tile[j, k].type == 323 && Main.tile[j, k].liquid > 0)
						{
							KillTile(j, k);
						}
						if (Main.wallDungeon[Main.tile[j, k].wall])
						{
							Main.tile[j, k].lava(lava: false);
							if (Main.tile[j, k].active() && Main.tile[j, k].type == 56)
							{
								KillTile(j, k);
								Main.tile[j, k].lava(lava: false);
								Main.tile[j, k].liquid = byte.MaxValue;
							}
						}
						if (Main.tile[j, k].active() && Main.tile[j, k].type == 314)
						{
							int num10 = 15;
							int num11 = 1;
							int num12 = k;
							while (k - num12 < num10)
							{
								Main.tile[j, num12].liquid = 0;
								num12--;
							}
							for (num12 = k; num12 - k < num11; num12++)
							{
								Main.tile[j, num12].liquid = 0;
							}
						}
						if (Main.tile[j, k].active() && Main.tile[j, k].type == 332 && !Main.tile[j, k + 1].active())
						{
							Main.tile[j, k + 1].ClearEverything();
							Main.tile[j, k + 1].active(active: true);
							Main.tile[j, k + 1].type = 332;
						}
						if (j > beachDistance && j < Main.maxTilesX - beachDistance && (double)k < Main.worldSurface && Main.tile[j, k].liquid > 0 && Main.tile[j, k].liquid < byte.MaxValue && Main.tile[j - 1, k].liquid < byte.MaxValue && Main.tile[j + 1, k].liquid < byte.MaxValue && Main.tile[j, k + 1].liquid < byte.MaxValue && !TileID.Sets.Clouds[Main.tile[j - 1, k].type] && !TileID.Sets.Clouds[Main.tile[j + 1, k].type] && !TileID.Sets.Clouds[Main.tile[j, k + 1].type])
						{
							Main.tile[j, k].liquid = 0;
						}
					}
				}
				if (drunkWorldGen)
				{
					FinishDrunkGen();
				}
				if (notTheBees)
				{
					NotTheBees();
					FinishNotTheBees();
					notTheBees = false;
				}
				if (getGoodWorldGen)
				{
					FinishGetGoodWorld();
					getGoodWorldGen = false;
				}
				noTileActions = false;
				Main.tileSolid[crackedType] = true;
				Main.tileSolid[484] = true;
				gen = false;
				Main.AnglerQuestSwap();
				skipFramingDuringGen = false;
				progress.Message = Lang.gen[87].Value;
			});
			_generator.GenerateWorld(customProgressObject);
			ConsumePostGenActions(structures);
			Main.WorldFileMetadata = FileMetadata.FromCurrentSettings(FileType.World);
			Main.NotifyOfEvent(GameNotificationType.WorldGen);
			drunkWorldGenText = false;
		}

		private static void NotTheBees()
		{
			if (!notTheBees)
			{
				return;
			}
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				for (int j = 0; j < Main.maxTilesY - 180; j++)
				{
					if (Main.tile[i, j].type == 52)
					{
						Main.tile[i, j].type = 62;
					}
					if ((SolidOrSlopedTile(i, j) || TileID.Sets.CrackedBricks[Main.tile[i, j].type]) && !TileID.Sets.Ore[Main.tile[i, j].type] && Main.tile[i, j].type != 123 && Main.tile[i, j].type != 40)
					{
						if (Main.tile[i, j].type == 191 || Main.tile[i, j].type == 383)
						{
							Main.tile[i, j].type = 383;
						}
						else if (Main.tile[i, j].type == 192 || Main.tile[i, j].type == 384)
						{
							Main.tile[i, j].type = 384;
						}
						else if (Main.tile[i, j].type != 151 && Main.tile[i, j].type != 189 && Main.tile[i, j].type != 196 && Main.tile[i, j].type != 120 && Main.tile[i, j].type != 158 && Main.tile[i, j].type != 175 && Main.tile[i, j].type != 45 && Main.tile[i, j].type != 119)
						{
							if (Main.tile[i, j].type >= 63 && Main.tile[i, j].type <= 68)
							{
								Main.tile[i, j].type = 230;
							}
							else if (Main.tile[i, j].type != 57 && Main.tile[i, j].type != 76 && Main.tile[i, j].type != 75 && Main.tile[i, j].type != 229 && Main.tile[i, j].type != 230 && Main.tile[i, j].type != 407 && Main.tile[i, j].type != 404)
							{
								if (Main.tile[i, j].type == 224)
								{
									Main.tile[i, j].type = 229;
								}
								else if (Main.tile[i, j].type == 53)
								{
									if (i < beachDistance + genRand.Next(3) || i > Main.maxTilesX - beachDistance - genRand.Next(3))
									{
										Main.tile[i, j].type = 229;
									}
								}
								else if ((i <= beachDistance - genRand.Next(3) || i >= Main.maxTilesX - beachDistance + genRand.Next(3) || (Main.tile[i, j].type != 397 && Main.tile[i, j].type != 396)) && Main.tile[i, j].type != 10 && Main.tile[i, j].type != 203 && Main.tile[i, j].type != 25 && Main.tile[i, j].type != 137 && Main.tile[i, j].type != 138 && Main.tile[i, j].type != 141)
								{
									if (Main.tileDungeon[Main.tile[i, j].type] || TileID.Sets.CrackedBricks[Main.tile[i, j].type])
									{
										Main.tile[i, j].color(14);
									}
									else if (Main.tile[i, j].type == 226)
									{
										Main.tile[i, j].color(15);
									}
									else if (Main.tile[i, j].type != 202 && Main.tile[i, j].type != 70 && Main.tile[i, j].type != 48 && Main.tile[i, j].type != 232)
									{
										if (TileID.Sets.Conversion.Grass[Main.tile[i, j].type])
										{
											if (j > lavaLine + genRand.Next(-2, 3) + 2)
											{
												Main.tile[i, j].type = 70;
											}
											else
											{
												Main.tile[i, j].type = 60;
											}
										}
										else if (Main.tile[i, j].type == 0 || Main.tile[i, j].type == 59)
										{
											Main.tile[i, j].type = 59;
										}
										else if (j > lavaLine + genRand.Next(-2, 3) + 2)
										{
											Main.tile[i, j].type = 230;
										}
										else
										{
											Main.tile[i, j].type = 225;
										}
									}
								}
							}
						}
					}
					if (Main.tile[i, j].wall != 15 && Main.tile[i, j].wall != 64 && Main.tile[i, j].wall != 204 && Main.tile[i, j].wall != 205 && Main.tile[i, j].wall != 206 && Main.tile[i, j].wall != 207 && Main.tile[i, j].wall != 23 && Main.tile[i, j].wall != 24 && Main.tile[i, j].wall != 42 && Main.tile[i, j].wall != 10 && Main.tile[i, j].wall != 21 && Main.tile[i, j].wall != 82 && Main.tile[i, j].wall != 187 && Main.tile[i, j].wall != 216 && Main.tile[i, j].wall != 34 && Main.tile[i, j].wall != 244)
					{
						if (Main.tile[i, j].wall == 87)
						{
							Main.tile[i, j].wallColor(15);
						}
						else if (Main.wallDungeon[Main.tile[i, j].wall])
						{
							Main.tile[i, j].wallColor(14);
						}
						else if (Main.tile[i, j].wall == 2)
						{
							Main.tile[i, j].wall = 2;
						}
						else if (Main.tile[i, j].wall == 196)
						{
							Main.tile[i, j].wall = 196;
						}
						else if (Main.tile[i, j].wall == 197)
						{
							Main.tile[i, j].wall = 197;
						}
						else if (Main.tile[i, j].wall == 198)
						{
							Main.tile[i, j].wall = 198;
						}
						else if (Main.tile[i, j].wall == 199)
						{
							Main.tile[i, j].wall = 199;
						}
						else if (Main.tile[i, j].wall == 63)
						{
							Main.tile[i, j].wall = 64;
						}
						else if (Main.tile[i, j].wall != 3 && Main.tile[i, j].wall != 83 && Main.tile[i, j].wall != 73 && Main.tile[i, j].wall != 13 && Main.tile[i, j].wall != 14 && Main.tile[i, j].wall > 0)
						{
							Main.tile[i, j].wall = 86;
						}
					}
					if (Main.tile[i, j].liquid > 0 && j <= lavaLine + 2)
					{
						if ((double)j > Main.rockLayer && (i < beachDistance + 200 || i > Main.maxTilesX - beachDistance - 200))
						{
							Main.tile[i, j].honey(honey: false);
						}
						else if (Main.wallDungeon[Main.tile[i, j].wall])
						{
							Main.tile[i, j].honey(honey: false);
						}
						else
						{
							Main.tile[i, j].honey(honey: true);
						}
					}
				}
			}
		}

		private static void FinishNotTheBees()
		{
			if (!notTheBees)
			{
				return;
			}
			int num = 0;
			for (int i = 20; (double)i < Main.worldSurface; i++)
			{
				for (int j = 20; j < Main.maxTilesX - 20; j++)
				{
					if (Main.tile[j, i].active() && TileID.Sets.Clouds[Main.tile[j, i].type])
					{
						num = i;
						break;
					}
				}
			}
			for (int k = 20; k < Main.maxTilesX - 20; k++)
			{
				for (int l = 20; l < Main.maxTilesY - 20; l++)
				{
					int num2 = 20;
					if (Main.tile[k, l].type == 25)
					{
						for (int m = k - num2; m <= k + num2; m++)
						{
							for (int n = l - num2; n <= l + num2; n++)
							{
								if (Main.tile[m, n].type == 60)
								{
									if (Main.tile[m, n + 1].type == 444)
									{
										KillTile(m, n + 1);
									}
									Main.tile[m, n].type = 23;
									if (Main.tile[m, n - 1].type == 61 || Main.tile[m, n - 1].type == 74)
									{
										Main.tile[m, n - 1].active(active: false);
										PlaceTile(m, n - 1, 24);
									}
								}
								else if (Main.tile[m, n - 1].type == 233 || Main.tile[m, n - 1].type == 82)
								{
									KillTile(m, n - 1);
								}
								if (Main.tile[m, n].type == 59)
								{
									Main.tile[m, n].type = 0;
								}
							}
						}
					}
					else if (Main.tile[k, l].type == 203)
					{
						for (int num3 = k - num2; num3 <= k + num2; num3++)
						{
							for (int num4 = l - num2; num4 <= l + num2; num4++)
							{
								if (Main.tile[num3, num4].type == 60)
								{
									if (Main.tile[num3, num4 + 1].type == 444)
									{
										KillTile(num3, num4 + 1);
									}
									Main.tile[num3, num4].type = 199;
									if (Main.tile[num3, num4 - 1].type == 61 || Main.tile[num3, num4 - 1].type == 74)
									{
										Main.tile[num3, num4 - 1].active(active: false);
										PlaceTile(num3, num4 - 1, 201);
									}
									else if (Main.tile[num3, num4 - 1].type == 233 || Main.tile[num3, num4 - 1].type == 82)
									{
										KillTile(num3, num4 - 1);
									}
								}
								if (Main.tile[num3, num4].type == 59)
								{
									Main.tile[num3, num4].type = 0;
								}
							}
						}
					}
					if (Main.tile[k, l].type == 382 || Main.tile[k, l].type == 52)
					{
						Main.tile[k, l].type = 62;
					}
					if (l > lavaLine + genRand.Next(-2, 3) + 2)
					{
						SpreadGrass(k, l, 59, 70, repeat: true, 0);
					}
					else
					{
						SpreadGrass(k, l, 59, 60, repeat: true, 0);
					}
					if ((double)l > Main.rockLayer + 20.0 + (double)genRand.Next(-2, 3) && l <= lavaLine + 2 - 20 - genRand.Next(-2, 3) && (k < beachDistance + 200 - 20 - genRand.Next(-2, 3) || k > Main.maxTilesX - beachDistance - 200 + 20 + genRand.Next(-2, 3)))
					{
						if (Main.tile[k, l].liquid > 0)
						{
							Main.tile[k, l].honey(honey: false);
							Main.tile[k, l].lava(lava: false);
						}
						if (Main.tile[k, l].type == 59)
						{
							bool flag = false;
							for (int num5 = k - 1; num5 <= k + 1; num5++)
							{
								for (int num6 = l - 1; num6 <= l + 1; num6++)
								{
									if (Main.tile[num5, num6].type == 60)
									{
										flag = true;
									}
								}
							}
							if (!flag)
							{
								if ((double)l < (Main.rockLayer + (double)lavaLine) / 2.0)
								{
									Main.tile[k, l].type = 161;
								}
								else
								{
									Main.tile[k, l].type = 147;
								}
							}
						}
					}
					if (Main.tile[k, l].type == 7 || Main.tile[k, l].type == 166 || Main.tile[k, l].type == 6 || Main.tile[k, l].type == 167)
					{
						if ((double)l > ((double)lavaLine + Main.rockLayer * 2.0) / 3.0 + (double)genRand.Next(-2, 3) + 2.0)
						{
							Main.tile[k, l].type = 0;
						}
					}
					else if ((Main.tile[k, l].type == 123 || Main.tile[k, l].type == 40) && (double)l > ((double)lavaLine + Main.rockLayer) / 2.0 + (double)genRand.Next(-2, 3) + 2.0)
					{
						Main.tile[k, l].type = 1;
					}
					if (l > num && (Main.tile[k, l].liquid == 0 || !Main.tile[k, l].lava()) && genRand.Next(25) == 0)
					{
						PlaceTile(k, l, 231, mute: true);
					}
				}
			}
			for (int num7 = 20; num7 < num; num7++)
			{
				for (int num8 = 20; num8 <= Main.maxTilesX - 20; num8++)
				{
					Main.tile[num8, num7].honey(honey: false);
					if (Main.tile[num8, num7].type == 375)
					{
						Main.tile[num8, num7].type = 373;
					}
					if (Main.tile[num8, num7].type == 60)
					{
						Main.tile[num8, num7].type = 2;
						if (genRand.Next(2) == 0)
						{
							GrowTreeWithSettings(num8, num7, GrowTreeSettings.Profiles.VanityTree_Willow);
						}
						else
						{
							GrowTreeWithSettings(num8, num7, GrowTreeSettings.Profiles.VanityTree_Sakura);
						}
						if (!Main.tile[num8, num7 - 1].active())
						{
							PlaceTile(num8, num7 - 1, 3);
						}
					}
					if (Main.tile[num8, num7].type == 59)
					{
						Main.tile[num8, num7].type = 0;
					}
				}
			}
		}

		private static void FinishGetGoodWorld()
		{
			int num = 0;
			for (int i = 20; (double)i < Main.worldSurface; i++)
			{
				for (int j = 20; j < Main.maxTilesX - 20; j++)
				{
					if (Main.tile[j, i].active() && TileID.Sets.Clouds[Main.tile[j, i].type])
					{
						num = i;
						break;
					}
				}
			}
			byte b = (byte)genRand.Next(13, 25);
			for (int k = 0; k < Main.maxTilesX; k++)
			{
				bool flag = false;
				for (int l = 0; l < Main.maxTilesY; l++)
				{
					if (!Main.tile[k, l].active() || !Main.tileDungeon[Main.tile[k, l].type])
					{
						continue;
					}
					if (Main.tile[k, l].type == 44)
					{
						b = (byte)genRand.Next(13, 15);
						if (genRand.Next(2) == 0)
						{
							b = (byte)genRand.Next(23, 25);
						}
					}
					if (Main.tile[k, l].type == 43)
					{
						b = (byte)genRand.Next(15, 19);
					}
					if (Main.tile[k, l].type == 41)
					{
						b = (byte)genRand.Next(19, 23);
					}
				}
				if (flag)
				{
					break;
				}
			}
			for (int m = 0; m < Main.maxTilesX; m++)
			{
				for (int n = 5; n < Main.maxTilesY - 5; n++)
				{
					if (Main.tile[m, n].active() && (Main.tileDungeon[Main.tile[m, n].type] || TileID.Sets.CrackedBricks[Main.tile[m, n].type]))
					{
						Main.tile[m, n].color(b);
					}
					if (Main.wallDungeon[Main.tile[m, n].wall])
					{
						Main.tile[m, n].wallColor(b);
					}
					if (Main.tile[m, n].active() && (Main.tile[m, n].type == 226 || (Main.tile[m, n].type == 137 && Main.tile[m, n].frameY > 0)))
					{
						Main.tile[m, n].color(17);
					}
					if (Main.tile[m, n].wall == 87)
					{
						Main.tile[m, n].wallColor(25);
					}
					if (!Main.tile[m, n].active())
					{
						continue;
					}
					if (Main.tile[m, n].type == 57 && genRand.Next(15) == 0)
					{
						if (Main.tile[m, n - 1].type == 57)
						{
							Main.tile[m, n].active(active: false);
						}
						Main.tile[m, n].liquid = byte.MaxValue;
						Main.tile[m, n].lava(lava: true);
					}
					if (n < num && Main.tile[m, n].type == 2)
					{
						if (crimson)
						{
							Main.tile[m, n].type = 199;
						}
						else
						{
							Main.tile[m, n].type = 23;
						}
						if (Main.tile[m, n - 1].type == 3)
						{
							Main.tile[m, n - 1].active(active: false);
						}
						if (Main.tile[m, n - 1].type == 73)
						{
							Main.tile[m, n - 1].active(active: false);
						}
						if (Main.tile[m, n - 1].type == 27)
						{
							KillTile(m, n - 1);
						}
						if (Main.tile[m, n - 1].type == 596)
						{
							KillTile(m, n - 1);
						}
						if (Main.tile[m, n - 1].type == 616)
						{
							KillTile(m, n - 1);
						}
						if (Main.tile[m, n - 1].type == 82)
						{
							KillTile(m, n - 1);
						}
						if (Main.tile[m, n - 1].type == 83)
						{
							KillTile(m, n - 1);
						}
						if (Main.tile[m, n - 1].type == 186)
						{
							KillTile(m, n - 1);
						}
						if (Main.tile[m, n - 1].type == 187)
						{
							KillTile(m, n - 1);
						}
						if (Main.tile[m, n - 1].type == 185)
						{
							KillTile(m, n - 1);
						}
						if (Main.tile[m, n - 1].type == 227)
						{
							KillTile(m, n - 1);
						}
					}
				}
			}
			for (int num2 = 0; num2 < 8000 && Main.chest[num2] != null; num2++)
			{
				if (genRand.Next(10) != 0 || Main.chest[num2].item[1].stack == 0)
				{
					continue;
				}
				for (int num3 = 1; num3 < 40; num3++)
				{
					if (Main.chest[num2].item[num3].stack == 0)
					{
						Main.chest[num2].item[num3].SetDefaults(678);
						break;
					}
				}
			}
		}

		private static void FinishDrunkGen()
		{
			byte color = (byte)genRand.Next(13, 25);
			byte b = 16;
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				bool flag = false;
				for (int j = 0; j < Main.maxTilesY; j++)
				{
					if (!Main.tile[i, j].active() || !Main.tileDungeon[Main.tile[i, j].type])
					{
						continue;
					}
					if (Main.tile[i, j].type == 44)
					{
						color = (byte)genRand.Next(13, 15);
						if (genRand.Next(2) == 0)
						{
							color = (byte)genRand.Next(23, 25);
						}
					}
					if (Main.tile[i, j].type == 43)
					{
						color = (byte)genRand.Next(15, 19);
					}
					if (Main.tile[i, j].type == 41)
					{
						color = (byte)genRand.Next(19, 23);
					}
				}
				if (flag)
				{
					break;
				}
			}
			for (int k = 0; k < Main.maxTilesX; k++)
			{
				for (int l = 0; l < Main.maxTilesY; l++)
				{
					if (Main.tile[k, l].active() && (Main.tileDungeon[Main.tile[k, l].type] || TileID.Sets.CrackedBricks[Main.tile[k, l].type]))
					{
						Main.tile[k, l].color(color);
					}
					if (Main.wallDungeon[Main.tile[k, l].wall])
					{
						Main.tile[k, l].wallColor(25);
					}
					if (Main.tile[k, l].active() && (Main.tile[k, l].type == 226 || (Main.tile[k, l].type == 137 && Main.tile[k, l].frameY > 0)))
					{
						Main.tile[k, l].color(b);
					}
					if (Main.tile[k, l].wall == 87)
					{
						Main.tile[k, l].wallColor(b);
					}
				}
			}
			for (int m = 0; m < 8000 && Main.chest[m] != null; m++)
			{
				if (genRand.Next(15) == 0 && Main.chest[m].item[1].stack != 0)
				{
					for (int n = 1; n < 40; n++)
					{
						if (Main.chest[m].item[n].stack == 0)
						{
							Main.chest[m].item[n].SetDefaults(5001);
							break;
						}
					}
				}
				if (genRand.Next(30) != 0 || Main.chest[m].item[1].stack == 0)
				{
					continue;
				}
				for (int num = 1; num < 40; num++)
				{
					if (Main.chest[m].item[num].stack == 0)
					{
						Main.chest[m].item[num].SetDefaults(678);
						break;
					}
				}
			}
		}

		public static bool IsItATrap(Tile tile)
		{
			if (tile.actuator())
			{
				return true;
			}
			if (tile.active() && TileID.Sets.IsAMechanism[tile.type])
			{
				return true;
			}
			return false;
		}

		public static bool IsItATrigger(Tile tile)
		{
			if (tile.active())
			{
				if (TileID.Sets.IsATrigger[tile.type])
				{
					return true;
				}
				if (tile.type == 467 && tile.frameX / 36 == 4)
				{
					return true;
				}
				if (tile.type == 314 && Minecart.IsPressurePlate(tile))
				{
					return true;
				}
			}
			return false;
		}

		public static void ClearAllBrokenTraps()
		{
			List<Point> list = new List<Point>();
			for (int i = 50; i < Main.maxTilesX - 50; i++)
			{
				for (int j = 50; j < Main.maxTilesY - 50; j++)
				{
					if (Main.tile[i, j].wire() && !list.Contains(new Point(i, j)))
					{
						ClearBrokenTraps(new Point(i, j), list);
					}
				}
			}
		}

		public static void ClearBrokenTraps(Point startTileCoords, List<Point> pointsWeAlreadyWentOver)
		{
			List<Point> t = new List<Point>();
			List<Point> t2 = new List<Point>();
			List<Point> list = new List<Point>();
			bool flag = false;
			bool flag2 = false;
			t2.Add(startTileCoords);
			while (t2.Count > 0)
			{
				Utils.Swap(t, t2);
				while (t.Count > 0)
				{
					Point item = t[0];
					t.RemoveAt(0);
					if (!InWorld(item.X, item.Y, 5))
					{
						continue;
					}
					Tile tile = Main.tile[item.X, item.Y];
					if (tile.wire())
					{
						pointsWeAlreadyWentOver.Add(item);
						list.Add(item);
						if (IsItATrap(tile))
						{
							flag = true;
						}
						if (IsItATrigger(tile))
						{
							flag2 = true;
						}
						if (flag2 && flag)
						{
							break;
						}
						Point item2 = new Point(item.X - 1, item.Y);
						if (!list.Contains(item2))
						{
							t2.Add(item2);
						}
						item2 = new Point(item.X + 1, item.Y);
						if (!list.Contains(item2))
						{
							t2.Add(item2);
						}
						item2 = new Point(item.X, item.Y - 1);
						if (!list.Contains(item2))
						{
							t2.Add(item2);
						}
						item2 = new Point(item.X, item.Y + 1);
						if (!list.Contains(item2))
						{
							t2.Add(item2);
						}
					}
				}
				if (flag2 && flag)
				{
					break;
				}
			}
			if (flag2 && flag)
			{
				return;
			}
			foreach (Point item3 in list)
			{
				Tile tile2 = Main.tile[item3.X, item3.Y];
				tile2.wire(wire: false);
				if (IsItATrap(tile2))
				{
					if (tile2.actuator())
					{
						Main.tile[item3.X, item3.Y].actuator(actuator: false);
					}
					else if (tile2.type != 105)
					{
						KillTile(item3.X, item3.Y);
					}
				}
				else if (IsItATrigger(tile2))
				{
					if (tile2.type == 314)
					{
						tile2.frameX = 1;
					}
					else
					{
						KillTile(item3.X, item3.Y);
					}
				}
			}
		}

		private static float TuneOceanDepth(int count, float depth, bool floridaStyle = false)
		{
			if (!floridaStyle)
			{
				if (count < 3)
				{
					depth += (float)genRand.Next(10, 20) * 0.2f;
				}
				else if (count < 6)
				{
					depth += (float)genRand.Next(10, 20) * 0.15f;
				}
				else if (count < 9)
				{
					depth += (float)genRand.Next(10, 20) * 0.1f;
				}
				else if (count < 15)
				{
					depth += (float)genRand.Next(10, 20) * 0.07f;
				}
				else if (count < 50)
				{
					depth += (float)genRand.Next(10, 20) * 0.05f;
				}
				else if (count < 75)
				{
					depth += (float)genRand.Next(10, 20) * 0.04f;
				}
				else if (count < 100)
				{
					depth += (float)genRand.Next(10, 20) * 0.03f;
				}
				else if (count < 125)
				{
					depth += (float)genRand.Next(10, 20) * 0.02f;
				}
				else if (count < 150)
				{
					depth += (float)genRand.Next(10, 20) * 0.01f;
				}
				else if (count < 175)
				{
					depth += (float)genRand.Next(10, 20) * 0.005f;
				}
				else if (count < 200)
				{
					depth += (float)genRand.Next(10, 20) * 0.001f;
				}
				else if (count < 230)
				{
					depth += (float)genRand.Next(10, 20) * 0.01f;
				}
				else if (count < 235)
				{
					depth += (float)genRand.Next(10, 20) * 0.05f;
				}
				else if (count < 240)
				{
					depth += (float)genRand.Next(10, 20) * 0.1f;
				}
				else if (count < 245)
				{
					depth += (float)genRand.Next(10, 20) * 0.05f;
				}
				else if (count < 255)
				{
					depth += (float)genRand.Next(10, 20) * 0.01f;
				}
			}
			else if (count < 3)
			{
				depth += (float)genRand.Next(10, 20) * 0.001f;
			}
			else if (count < 6)
			{
				depth += (float)genRand.Next(10, 20) * 0.002f;
			}
			else if (count < 9)
			{
				depth += (float)genRand.Next(10, 20) * 0.004f;
			}
			else if (count < 15)
			{
				depth += (float)genRand.Next(10, 20) * 0.007f;
			}
			else if (count < 50)
			{
				depth += (float)genRand.Next(10, 20) * 0.01f;
			}
			else if (count < 75)
			{
				depth += (float)genRand.Next(10, 20) * 0.014f;
			}
			else if (count < 100)
			{
				depth += (float)genRand.Next(10, 20) * 0.019f;
			}
			else if (count < 125)
			{
				depth += (float)genRand.Next(10, 20) * 0.027f;
			}
			else if (count < 150)
			{
				depth += (float)genRand.Next(10, 20) * 0.038f;
			}
			else if (count < 175)
			{
				depth += (float)genRand.Next(10, 20) * 0.052f;
			}
			else if (count < 200)
			{
				depth += (float)genRand.Next(10, 20) * 0.08f;
			}
			else if (count < 230)
			{
				depth += (float)genRand.Next(10, 20) * 0.12f;
			}
			else if (count < 235)
			{
				depth += (float)genRand.Next(10, 20) * 0.16f;
			}
			else if (count < 240)
			{
				depth += (float)genRand.Next(10, 20) * 0.27f;
			}
			else if (count < 245)
			{
				depth += (float)genRand.Next(10, 20) * 0.43f;
			}
			else if (count < 255)
			{
				depth += (float)genRand.Next(10, 20) * 0.6f;
			}
			return depth;
		}

		public static void QueuePostGenAction(Action<StructureMap> action)
		{
			_postGenActions.Enqueue(action);
		}

		public static void ConsumePostGenActions(StructureMap structures)
		{
			while (_postGenActions.Count > 0)
			{
				_postGenActions.Dequeue()(structures);
			}
		}

		public static Point RandomRectanglePoint(Rectangle rectangle)
		{
			return new Point(genRand.Next(rectangle.X, rectangle.X + rectangle.Width), genRand.Next(rectangle.Y, rectangle.Y + rectangle.Height));
		}

		public static Point RandomRectanglePoint(int x, int y, int width, int height)
		{
			return new Point(genRand.Next(x, x + width), genRand.Next(y, y + height));
		}

		public static Point RandomWorldPoint(int padding)
		{
			return RandomWorldPoint(padding, padding, padding, padding);
		}

		public static Point RandomWorldPoint(int top = 0, int right = 0, int bottom = 0, int left = 0)
		{
			return new Point(genRand.Next(left, Main.maxTilesX - right), genRand.Next(top, Main.maxTilesY - bottom));
		}

		public static bool GrowPalmTree(int i, int y)
		{
			int num = y;
			if (!InWorld(i, y))
			{
				return false;
			}
			while (Main.tile[i, num].type == 20)
			{
				num++;
				if (Main.tile[i, num] == null)
				{
					return false;
				}
			}
			Tile tile = Main.tile[i, num];
			Tile tile2 = Main.tile[i, num - 1];
			tile.slope();
			tile.halfBrick();
			if (!tile.active() || tile.halfBrick() || tile.slope() != 0)
			{
				return false;
			}
			if (tile2.wall != 0 || tile2.liquid != 0)
			{
				return false;
			}
			if (tile.type != 53 && tile.type != 234 && tile.type != 116 && tile.type != 112)
			{
				return false;
			}
			if (!EmptyTileCheck(i, i, num - 2, num - 1, 20))
			{
				return false;
			}
			if (!EmptyTileCheck(i - 1, i + 1, num - 30, num - 3, 20))
			{
				return false;
			}
			int num2 = genRand.Next(10, 21);
			int num3 = genRand.Next(-8, 9);
			num3 *= 2;
			short num4 = 0;
			for (int j = 0; j < num2; j++)
			{
				tile = Main.tile[i, num - 1 - j];
				if (j == 0)
				{
					tile.active(active: true);
					tile.type = 323;
					tile.frameX = 66;
					tile.frameY = 0;
					continue;
				}
				if (j == num2 - 1)
				{
					tile.active(active: true);
					tile.type = 323;
					tile.frameX = (short)(22 * genRand.Next(4, 7));
					tile.frameY = num4;
					continue;
				}
				if (num4 != num3)
				{
					float num5 = (float)j / (float)num2;
					bool flag = false;
					if (!(num5 < 0.25f) && ((num5 < 0.5f && genRand.Next(13) == 0) || (num5 < 0.7f && genRand.Next(9) == 0) || !(num5 < 0.95f) || genRand.Next(5) != 0 || true))
					{
						short num6 = (short)Math.Sign(num3);
						num4 = (short)(num4 + (short)(num6 * 2));
					}
				}
				tile.active(active: true);
				tile.type = 323;
				tile.frameX = (short)(22 * genRand.Next(0, 3));
				tile.frameY = num4;
			}
			RangeFrame(i - 2, num - num2 - 1, i + 2, num + 1);
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, i, (int)((double)num - (double)num2 * 0.5), num2 + 1);
			}
			return true;
		}

		public static bool IsPalmOasisTree(int x)
		{
			if (x >= beachDistance)
			{
				return x <= Main.maxTilesX - beachDistance;
			}
			return false;
		}

		public static bool GrowEpicTree(int i, int y)
		{
			int j;
			for (j = y; Main.tile[i, j].type == 20; j++)
			{
			}
			if (Main.tile[i, j].active() && !Main.tile[i, j].halfBrick() && Main.tile[i, j].slope() == 0 && Main.tile[i, j].type == 2 && Main.tile[i, j - 1].wall == 0 && Main.tile[i, j - 1].liquid == 0 && ((Main.tile[i - 1, j].active() && (Main.tile[i - 1, j].type == 2 || Main.tile[i - 1, j].type == 23 || Main.tile[i - 1, j].type == 60 || Main.tile[i - 1, j].type == 109)) || (Main.tile[i + 1, j].active() && (Main.tile[i + 1, j].type == 2 || Main.tile[i + 1, j].type == 23 || Main.tile[i + 1, j].type == 60 || Main.tile[i + 1, j].type == 109))))
			{
				int num = 2;
				if (EmptyTileCheck(i - num, i + num, j - 55, j - 1, 20))
				{
					bool flag = false;
					bool flag2 = false;
					int num2 = genRand.Next(20, 30);
					if (drunkWorldGen)
					{
						num2 = genRand.Next(3, 7);
					}
					int num3;
					for (int k = j - num2; k < j; k++)
					{
						Main.tile[i, k].frameNumber((byte)genRand.Next(3));
						Main.tile[i, k].active(active: true);
						Main.tile[i, k].type = 5;
						num3 = genRand.Next(3);
						int num4 = genRand.Next(10);
						if (k == j - 1 || k == j - num2)
						{
							num4 = 0;
						}
						while (((num4 == 5 || num4 == 7) && flag) || ((num4 == 6 || num4 == 7) && flag2))
						{
							num4 = genRand.Next(10);
						}
						flag = false;
						flag2 = false;
						if (num4 == 5 || num4 == 7)
						{
							flag = true;
						}
						if (num4 == 6 || num4 == 7)
						{
							flag2 = true;
						}
						switch (num4)
						{
						case 1:
							if (num3 == 0)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 66;
							}
							if (num3 == 1)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 88;
							}
							if (num3 == 2)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 110;
							}
							break;
						case 2:
							if (num3 == 0)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 0;
							}
							if (num3 == 1)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 22;
							}
							if (num3 == 2)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 44;
							}
							break;
						case 3:
							if (num3 == 0)
							{
								Main.tile[i, k].frameX = 44;
								Main.tile[i, k].frameY = 66;
							}
							if (num3 == 1)
							{
								Main.tile[i, k].frameX = 44;
								Main.tile[i, k].frameY = 88;
							}
							if (num3 == 2)
							{
								Main.tile[i, k].frameX = 44;
								Main.tile[i, k].frameY = 110;
							}
							break;
						case 4:
							if (num3 == 0)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 66;
							}
							if (num3 == 1)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 88;
							}
							if (num3 == 2)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 110;
							}
							break;
						case 5:
							if (num3 == 0)
							{
								Main.tile[i, k].frameX = 88;
								Main.tile[i, k].frameY = 0;
							}
							if (num3 == 1)
							{
								Main.tile[i, k].frameX = 88;
								Main.tile[i, k].frameY = 22;
							}
							if (num3 == 2)
							{
								Main.tile[i, k].frameX = 88;
								Main.tile[i, k].frameY = 44;
							}
							break;
						case 6:
							if (num3 == 0)
							{
								Main.tile[i, k].frameX = 66;
								Main.tile[i, k].frameY = 66;
							}
							if (num3 == 1)
							{
								Main.tile[i, k].frameX = 66;
								Main.tile[i, k].frameY = 88;
							}
							if (num3 == 2)
							{
								Main.tile[i, k].frameX = 66;
								Main.tile[i, k].frameY = 110;
							}
							break;
						case 7:
							if (num3 == 0)
							{
								Main.tile[i, k].frameX = 110;
								Main.tile[i, k].frameY = 66;
							}
							if (num3 == 1)
							{
								Main.tile[i, k].frameX = 110;
								Main.tile[i, k].frameY = 88;
							}
							if (num3 == 2)
							{
								Main.tile[i, k].frameX = 110;
								Main.tile[i, k].frameY = 110;
							}
							break;
						default:
							if (num3 == 0)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 0;
							}
							if (num3 == 1)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 22;
							}
							if (num3 == 2)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 44;
							}
							break;
						}
						if (num4 == 5 || num4 == 7)
						{
							Main.tile[i - 1, k].active(active: true);
							Main.tile[i - 1, k].type = 5;
							num3 = genRand.Next(3);
							if (genRand.Next(3) < 2)
							{
								if (num3 == 0)
								{
									Main.tile[i - 1, k].frameX = 44;
									Main.tile[i - 1, k].frameY = 198;
								}
								if (num3 == 1)
								{
									Main.tile[i - 1, k].frameX = 44;
									Main.tile[i - 1, k].frameY = 220;
								}
								if (num3 == 2)
								{
									Main.tile[i - 1, k].frameX = 44;
									Main.tile[i - 1, k].frameY = 242;
								}
							}
							else
							{
								if (num3 == 0)
								{
									Main.tile[i - 1, k].frameX = 66;
									Main.tile[i - 1, k].frameY = 0;
								}
								if (num3 == 1)
								{
									Main.tile[i - 1, k].frameX = 66;
									Main.tile[i - 1, k].frameY = 22;
								}
								if (num3 == 2)
								{
									Main.tile[i - 1, k].frameX = 66;
									Main.tile[i - 1, k].frameY = 44;
								}
							}
						}
						if (num4 != 6 && num4 != 7)
						{
							continue;
						}
						Main.tile[i + 1, k].active(active: true);
						Main.tile[i + 1, k].type = 5;
						num3 = genRand.Next(3);
						if (genRand.Next(3) < 2)
						{
							if (num3 == 0)
							{
								Main.tile[i + 1, k].frameX = 66;
								Main.tile[i + 1, k].frameY = 198;
							}
							if (num3 == 1)
							{
								Main.tile[i + 1, k].frameX = 66;
								Main.tile[i + 1, k].frameY = 220;
							}
							if (num3 == 2)
							{
								Main.tile[i + 1, k].frameX = 66;
								Main.tile[i + 1, k].frameY = 242;
							}
						}
						else
						{
							if (num3 == 0)
							{
								Main.tile[i + 1, k].frameX = 88;
								Main.tile[i + 1, k].frameY = 66;
							}
							if (num3 == 1)
							{
								Main.tile[i + 1, k].frameX = 88;
								Main.tile[i + 1, k].frameY = 88;
							}
							if (num3 == 2)
							{
								Main.tile[i + 1, k].frameX = 88;
								Main.tile[i + 1, k].frameY = 110;
							}
						}
					}
					int num5 = genRand.Next(3);
					bool flag3 = false;
					bool flag4 = false;
					if (Main.tile[i - 1, j].active() && !Main.tile[i - 1, j].halfBrick() && Main.tile[i - 1, j].slope() == 0 && (Main.tile[i - 1, j].type == 2 || Main.tile[i - 1, j].type == 23 || Main.tile[i - 1, j].type == 60 || Main.tile[i - 1, j].type == 109))
					{
						flag3 = true;
					}
					if (Main.tile[i + 1, j].active() && !Main.tile[i + 1, j].halfBrick() && Main.tile[i + 1, j].slope() == 0 && (Main.tile[i + 1, j].type == 2 || Main.tile[i + 1, j].type == 23 || Main.tile[i + 1, j].type == 60 || Main.tile[i + 1, j].type == 109))
					{
						flag4 = true;
					}
					if (!flag3)
					{
						if (num5 == 0)
						{
							num5 = 2;
						}
						if (num5 == 1)
						{
							num5 = 3;
						}
					}
					if (!flag4)
					{
						if (num5 == 0)
						{
							num5 = 1;
						}
						if (num5 == 2)
						{
							num5 = 3;
						}
					}
					if (flag3 && !flag4)
					{
						num5 = 2;
					}
					if (flag4 && !flag3)
					{
						num5 = 1;
					}
					if (num5 == 0 || num5 == 1)
					{
						Main.tile[i + 1, j - 1].active(active: true);
						Main.tile[i + 1, j - 1].type = 5;
						num3 = genRand.Next(3);
						if (num3 == 0)
						{
							Main.tile[i + 1, j - 1].frameX = 22;
							Main.tile[i + 1, j - 1].frameY = 132;
						}
						if (num3 == 1)
						{
							Main.tile[i + 1, j - 1].frameX = 22;
							Main.tile[i + 1, j - 1].frameY = 154;
						}
						if (num3 == 2)
						{
							Main.tile[i + 1, j - 1].frameX = 22;
							Main.tile[i + 1, j - 1].frameY = 176;
						}
					}
					if (num5 == 0 || num5 == 2)
					{
						Main.tile[i - 1, j - 1].active(active: true);
						Main.tile[i - 1, j - 1].type = 5;
						num3 = genRand.Next(3);
						if (num3 == 0)
						{
							Main.tile[i - 1, j - 1].frameX = 44;
							Main.tile[i - 1, j - 1].frameY = 132;
						}
						if (num3 == 1)
						{
							Main.tile[i - 1, j - 1].frameX = 44;
							Main.tile[i - 1, j - 1].frameY = 154;
						}
						if (num3 == 2)
						{
							Main.tile[i - 1, j - 1].frameX = 44;
							Main.tile[i - 1, j - 1].frameY = 176;
						}
					}
					num3 = genRand.Next(3);
					switch (num5)
					{
					case 0:
						if (num3 == 0)
						{
							Main.tile[i, j - 1].frameX = 88;
							Main.tile[i, j - 1].frameY = 132;
						}
						if (num3 == 1)
						{
							Main.tile[i, j - 1].frameX = 88;
							Main.tile[i, j - 1].frameY = 154;
						}
						if (num3 == 2)
						{
							Main.tile[i, j - 1].frameX = 88;
							Main.tile[i, j - 1].frameY = 176;
						}
						break;
					case 1:
						if (num3 == 0)
						{
							Main.tile[i, j - 1].frameX = 0;
							Main.tile[i, j - 1].frameY = 132;
						}
						if (num3 == 1)
						{
							Main.tile[i, j - 1].frameX = 0;
							Main.tile[i, j - 1].frameY = 154;
						}
						if (num3 == 2)
						{
							Main.tile[i, j - 1].frameX = 0;
							Main.tile[i, j - 1].frameY = 176;
						}
						break;
					case 2:
						if (num3 == 0)
						{
							Main.tile[i, j - 1].frameX = 66;
							Main.tile[i, j - 1].frameY = 132;
						}
						if (num3 == 1)
						{
							Main.tile[i, j - 1].frameX = 66;
							Main.tile[i, j - 1].frameY = 154;
						}
						if (num3 == 2)
						{
							Main.tile[i, j - 1].frameX = 66;
							Main.tile[i, j - 1].frameY = 176;
						}
						break;
					}
					if (genRand.Next(13) != 0)
					{
						num3 = genRand.Next(3);
						if (num3 == 0)
						{
							Main.tile[i, j - num2].frameX = 22;
							Main.tile[i, j - num2].frameY = 198;
						}
						if (num3 == 1)
						{
							Main.tile[i, j - num2].frameX = 22;
							Main.tile[i, j - num2].frameY = 220;
						}
						if (num3 == 2)
						{
							Main.tile[i, j - num2].frameX = 22;
							Main.tile[i, j - num2].frameY = 242;
						}
					}
					else
					{
						num3 = genRand.Next(3);
						if (num3 == 0)
						{
							Main.tile[i, j - num2].frameX = 0;
							Main.tile[i, j - num2].frameY = 198;
						}
						if (num3 == 1)
						{
							Main.tile[i, j - num2].frameX = 0;
							Main.tile[i, j - num2].frameY = 220;
						}
						if (num3 == 2)
						{
							Main.tile[i, j - num2].frameX = 0;
							Main.tile[i, j - num2].frameY = 242;
						}
					}
					RangeFrame(i - 2, j - num2 - 1, i + 2, j + 1);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, (int)((double)j - (double)num2 * 0.5), num2 + 1);
					}
					return true;
				}
			}
			return false;
		}

		public static bool Pyramid(int i, int j)
		{
			ushort num = 151;
			int num2 = j - genRand.Next(0, 7);
			int num3 = genRand.Next(9, 13);
			int num4 = 1;
			int num5 = j + genRand.Next(75, 125);
			for (int k = num2; k < num5; k++)
			{
				for (int l = i - num4; l < i + num4 - 1; l++)
				{
					Main.tile[l, k].type = num;
					Main.tile[l, k].active(active: true);
					Main.tile[l, k].halfBrick(halfBrick: false);
					Main.tile[l, k].slope(0);
				}
				num4++;
			}
			for (int m = i - num4 - 5; m <= i + num4 + 5; m++)
			{
				for (int n = j - 1; n <= num5 + 1; n++)
				{
					bool flag = true;
					for (int num6 = m - 1; num6 <= m + 1; num6++)
					{
						for (int num7 = n - 1; num7 <= n + 1; num7++)
						{
							if (Main.tile[num6, num7].type != num)
							{
								flag = false;
							}
						}
					}
					if (flag)
					{
						Main.tile[m, n].wall = 34;
						SquareWallFrame(m, n);
					}
				}
			}
			int num8 = 1;
			if (genRand.Next(2) == 0)
			{
				num8 = -1;
			}
			int num9 = i - num3 * num8;
			int num10 = j + num3;
			int num11 = genRand.Next(5, 8);
			bool flag2 = true;
			int num12 = genRand.Next(20, 30);
			while (flag2)
			{
				flag2 = false;
				bool flag3 = false;
				for (int num13 = num10; num13 <= num10 + num11; num13++)
				{
					int num14 = num9;
					if (Main.tile[num14, num13 - 1].type == 53)
					{
						flag3 = true;
					}
					if (Main.tile[num14, num13].type == num)
					{
						Main.tile[num14, num13 + 1].wall = 34;
						Main.tile[num14 + num8, num13].wall = 34;
						Main.tile[num14, num13].active(active: false);
						flag2 = true;
					}
					if (flag3)
					{
						Main.tile[num14, num13].type = 53;
						Main.tile[num14, num13].active(active: true);
						Main.tile[num14, num13].halfBrick(halfBrick: false);
						Main.tile[num14, num13].slope(0);
					}
				}
				num9 -= num8;
			}
			num9 = i - num3 * num8;
			bool flag4 = true;
			bool flag5 = false;
			flag2 = true;
			while (flag2)
			{
				for (int num15 = num10; num15 <= num10 + num11; num15++)
				{
					int num16 = num9;
					Main.tile[num16, num15].active(active: false);
				}
				num9 += num8;
				num10++;
				num12--;
				if (num10 >= num5 - num11 * 2)
				{
					num12 = 10;
				}
				if (num12 <= 0)
				{
					bool flag6 = false;
					if (!flag4 && !flag5)
					{
						flag5 = true;
						flag6 = true;
						int num17 = genRand.Next(7, 13);
						int num18 = genRand.Next(23, 28);
						int num19 = num18;
						int num20 = num9;
						while (num18 > 0)
						{
							for (int num21 = num10 - num17 + num11; num21 <= num10 + num11; num21++)
							{
								if (num18 == num19 || num18 == 1)
								{
									if (num21 >= num10 - num17 + num11 + 2)
									{
										Main.tile[num9, num21].active(active: false);
									}
								}
								else if (num18 == num19 - 1 || num18 == 2 || num18 == num19 - 2 || num18 == 3)
								{
									if (num21 >= num10 - num17 + num11 + 1)
									{
										Main.tile[num9, num21].active(active: false);
									}
								}
								else
								{
									Main.tile[num9, num21].active(active: false);
								}
							}
							num18--;
							num9 += num8;
						}
						int num22 = num9 - num8;
						int num23 = num22;
						int num24 = num20;
						if (num22 > num20)
						{
							num23 = num20;
							num24 = num22;
						}
						int num25 = genRand.Next(3);
						switch (num25)
						{
						case 0:
							num25 = 857;
							break;
						case 1:
							num25 = 848;
							break;
						case 2:
							num25 = 934;
							break;
						}
						AddBuriedChest((num23 + num24) / 2, num10, num25, notNearOtherChests: false, 1, trySlope: false, 0);
						int num26 = genRand.Next(1, 10);
						for (int num27 = 0; num27 < num26; num27++)
						{
							int i2 = genRand.Next(num23, num24);
							int j2 = num10 + num11;
							PlaceSmallPile(i2, j2, genRand.Next(16, 19), 1, 185);
						}
						PlaceTile(num23 + 2, num10 - num17 + num11 + 1, 91, mute: true, forced: false, -1, genRand.Next(4, 7));
						PlaceTile(num23 + 3, num10 - num17 + num11, 91, mute: true, forced: false, -1, genRand.Next(4, 7));
						PlaceTile(num24 - 2, num10 - num17 + num11 + 1, 91, mute: true, forced: false, -1, genRand.Next(4, 7));
						PlaceTile(num24 - 3, num10 - num17 + num11, 91, mute: true, forced: false, -1, genRand.Next(4, 7));
						for (int num28 = num23; num28 <= num24; num28++)
						{
							PlacePot(num28, num10 + num11, 28, genRand.Next(25, 28));
						}
					}
					if (flag4)
					{
						flag4 = false;
						num8 *= -1;
						num12 = genRand.Next(15, 20);
					}
					else if (flag6)
					{
						num12 = genRand.Next(10, 15);
					}
					else
					{
						num8 *= -1;
						num12 = genRand.Next(20, 40);
					}
				}
				if (num10 >= num5 - num11)
				{
					flag2 = false;
				}
			}
			int num29 = genRand.Next(100, 200);
			int num30 = genRand.Next(500, 800);
			flag2 = true;
			int num31 = num11;
			num12 = genRand.Next(10, 50);
			if (num8 == 1)
			{
				num9 -= num31;
			}
			int num32 = genRand.Next(5, 10);
			while (flag2)
			{
				num29--;
				num30--;
				num12--;
				for (int num33 = num9 - num32 - genRand.Next(0, 2); num33 <= num9 + num31 + num32 + genRand.Next(0, 2); num33++)
				{
					int num34 = num10;
					if (num33 >= num9 && num33 <= num9 + num31)
					{
						Main.tile[num33, num34].active(active: false);
					}
					else
					{
						Main.tile[num33, num34].type = num;
						Main.tile[num33, num34].active(active: true);
						Main.tile[num33, num34].halfBrick(halfBrick: false);
						Main.tile[num33, num34].slope(0);
					}
					if (num33 >= num9 - 1 && num33 <= num9 + 1 + num31)
					{
						Main.tile[num33, num34].wall = 34;
					}
				}
				num10++;
				num9 += num8;
				if (num29 <= 0)
				{
					flag2 = false;
					for (int num35 = num9 + 1; num35 <= num9 + num31 - 1; num35++)
					{
						if (Main.tile[num35, num10].active())
						{
							flag2 = true;
						}
					}
				}
				if (num12 < 0)
				{
					num12 = genRand.Next(10, 50);
					num8 *= -1;
				}
				if (num30 <= 0)
				{
					flag2 = false;
				}
			}
			return true;
		}

		public static bool GrowLivingTree(int i, int j, bool patch = false)
		{
			int num = 0;
			int[] array = new int[1000];
			int[] array2 = new int[1000];
			int[] array3 = new int[1000];
			int[] array4 = new int[1000];
			int num2 = 0;
			int[] array5 = new int[2000];
			int[] array6 = new int[2000];
			bool[] array7 = new bool[2000];
			if (!SolidTile(i, j + 1))
			{
				return false;
			}
			if (Main.tile[i, j].active())
			{
				return false;
			}
			if (Main.tile[i, j + 1].type != 0 && Main.tile[i, j + 1].type != 2 && Main.tile[i, j + 1].type != 1 && Main.tile[i, j + 1].type != 40 && !TileID.Sets.Ore[Main.tile[i, j + 1].type])
			{
				return false;
			}
			if (j < 150)
			{
				return false;
			}
			int num3 = i - genRand.Next(2, 3);
			int num4 = i + genRand.Next(2, 3);
			if (genRand.Next(5) == 0)
			{
				if (genRand.Next(2) == 0)
				{
					num3--;
				}
				else
				{
					num4++;
				}
			}
			int num5 = num4 - num3;
			bool flag = num5 >= 4;
			int num6 = i - 50;
			int num7 = i + 50;
			if (patch)
			{
				num6 = i - 20;
				num7 = i + 20;
				num3 = i - genRand.Next(1, 3);
				num4 = i + genRand.Next(1, 3);
				flag = num5 >= 4;
			}
			for (int k = num6; k <= num7; k++)
			{
				for (int l = 5; l < j - 5; l++)
				{
					if (Main.tile[k, l].active())
					{
						if (!patch)
						{
							return false;
						}
						int type = Main.tile[k, l].type;
						if (type != 2 && type != 0 && type != 1 && type != 191 && type != 192)
						{
							return false;
						}
					}
				}
			}
			int num8 = num3;
			int num9 = num4;
			int minl = num3;
			int minr = num4;
			bool flag2 = true;
			int num10 = genRand.Next(-8, -4);
			int num11 = genRand.Next(2);
			int num12 = j;
			int num13 = genRand.Next(5, 15);
			Main.tileSolid[48] = false;
			while (flag2)
			{
				num10++;
				if (num10 > num13)
				{
					num13 = genRand.Next(5, 15);
					num10 = 0;
					array2[num] = num12 + genRand.Next(5);
					if (genRand.Next(5) == 0)
					{
						num11 = ((num11 == 0) ? 1 : 0);
					}
					if (num11 == 0)
					{
						array3[num] = -1;
						array[num] = num3;
						array4[num] = num4 - num3;
						if (genRand.Next(2) == 0)
						{
							num3++;
						}
						num8++;
						num11 = 1;
					}
					else
					{
						array3[num] = 1;
						array[num] = num4;
						array4[num] = num4 - num3;
						if (genRand.Next(2) == 0)
						{
							num4--;
						}
						num9--;
						num11 = 0;
					}
					if (num8 == num9)
					{
						flag2 = false;
					}
					num++;
				}
				for (int m = num3; m <= num4; m++)
				{
					Main.tile[m, num12].type = 191;
					Main.tile[m, num12].active(active: true);
					Main.tile[m, num12].halfBrick(halfBrick: false);
				}
				num12--;
			}
			for (int n = 0; n < num - 1; n++)
			{
				int num14 = array[n] + array3[n];
				int num15 = array2[n];
				int num16 = (int)((float)array4[n] * (1f + (float)genRand.Next(20, 30) * 0.1f));
				Main.tile[num14, num15 + 1].type = 191;
				Main.tile[num14, num15 + 1].active(active: true);
				Main.tile[num14, num15 + 1].halfBrick(halfBrick: false);
				int num17 = genRand.Next(3, 5);
				while (num16 > 0)
				{
					num16--;
					Main.tile[num14, num15].type = 191;
					Main.tile[num14, num15].active(active: true);
					Main.tile[num14, num15].halfBrick(halfBrick: false);
					if (genRand.Next(10) == 0)
					{
						num15 = ((genRand.Next(2) != 0) ? (num15 + 1) : (num15 - 1));
					}
					else
					{
						num14 += array3[n];
					}
					if (num17 > 0)
					{
						num17--;
					}
					else if (genRand.Next(2) == 0)
					{
						num17 = genRand.Next(2, 5);
						if (genRand.Next(2) == 0)
						{
							Main.tile[num14, num15].type = 191;
							Main.tile[num14, num15].active(active: true);
							Main.tile[num14, num15].halfBrick(halfBrick: false);
							Main.tile[num14, num15 - 1].type = 191;
							Main.tile[num14, num15 - 1].active(active: true);
							Main.tile[num14, num15 - 1].halfBrick(halfBrick: false);
							array5[num2] = num14;
							array6[num2] = num15;
							num2++;
						}
						else
						{
							Main.tile[num14, num15].type = 191;
							Main.tile[num14, num15].active(active: true);
							Main.tile[num14, num15].halfBrick(halfBrick: false);
							Main.tile[num14, num15 + 1].type = 191;
							Main.tile[num14, num15 + 1].active(active: true);
							Main.tile[num14, num15 + 1].halfBrick(halfBrick: false);
							array5[num2] = num14;
							array6[num2] = num15;
							num2++;
						}
					}
					if (num16 == 0)
					{
						array5[num2] = num14;
						array6[num2] = num15;
						num2++;
					}
				}
			}
			int num18 = (num3 + num4) / 2;
			int num19 = num12;
			int num20 = genRand.Next(num5 * 3, num5 * 5);
			int num21 = 0;
			int num22 = 0;
			while (num20 > 0)
			{
				Main.tile[num18, num19].type = 191;
				Main.tile[num18, num19].active(active: true);
				Main.tile[num18, num19].halfBrick(halfBrick: false);
				if (num21 > 0)
				{
					num21--;
				}
				if (num22 > 0)
				{
					num22--;
				}
				for (int num23 = -1; num23 < 2; num23++)
				{
					if (num23 == 0 || ((num23 >= 0 || num21 != 0) && (num23 <= 0 || num22 != 0)) || genRand.Next(2) != 0)
					{
						continue;
					}
					int num24 = num18;
					int num25 = num19;
					int num26 = genRand.Next(num5, num5 * 3);
					if (num23 < 0)
					{
						num21 = genRand.Next(3, 5);
					}
					if (num23 > 0)
					{
						num22 = genRand.Next(3, 5);
					}
					int num27 = 0;
					while (num26 > 0)
					{
						num26--;
						num24 += num23;
						Main.tile[num24, num25].type = 191;
						Main.tile[num24, num25].active(active: true);
						Main.tile[num24, num25].halfBrick(halfBrick: false);
						if (num26 == 0)
						{
							array5[num2] = num24;
							array6[num2] = num25;
							array7[num2] = true;
							num2++;
						}
						if (genRand.Next(5) == 0)
						{
							num25 = ((genRand.Next(2) != 0) ? (num25 + 1) : (num25 - 1));
							Main.tile[num24, num25].type = 191;
							Main.tile[num24, num25].active(active: true);
							Main.tile[num24, num25].halfBrick(halfBrick: false);
						}
						if (num27 > 0)
						{
							num27--;
						}
						else if (genRand.Next(3) == 0)
						{
							num27 = genRand.Next(2, 4);
							int num28 = num24;
							int num29 = num25;
							num29 = ((genRand.Next(2) != 0) ? (num29 + 1) : (num29 - 1));
							Main.tile[num28, num29].type = 191;
							Main.tile[num28, num29].active(active: true);
							Main.tile[num28, num29].halfBrick(halfBrick: false);
							array5[num2] = num28;
							array6[num2] = num29;
							array7[num2] = true;
							num2++;
							array5[num2] = num28 + genRand.Next(-5, 6);
							array6[num2] = num29 + genRand.Next(-5, 6);
							array7[num2] = true;
							num2++;
						}
					}
				}
				array5[num2] = num18;
				array6[num2] = num19;
				num2++;
				if (genRand.Next(4) == 0)
				{
					num18 = ((genRand.Next(2) != 0) ? (num18 + 1) : (num18 - 1));
					Main.tile[num18, num19].type = 191;
					Main.tile[num18, num19].active(active: true);
					Main.tile[num18, num19].halfBrick(halfBrick: false);
				}
				num19--;
				num20--;
			}
			for (int num30 = minl; num30 <= minr; num30++)
			{
				int num31 = genRand.Next(1, 6);
				int num32 = j + 1;
				while (num31 > 0)
				{
					if (SolidTile(num30, num32))
					{
						num31--;
					}
					Main.tile[num30, num32].type = 191;
					Main.tile[num30, num32].active(active: true);
					Main.tile[num30, num32].halfBrick(halfBrick: false);
					num32++;
				}
				int num33 = num32;
				int num34 = genRand.Next(2, num5 + 1);
				for (int num35 = 0; num35 < num34; num35++)
				{
					num32 = num33;
					int num36 = (minl + minr) / 2;
					int num37 = 0;
					int num38 = 1;
					num37 = ((num30 >= num36) ? 1 : (-1));
					if (num30 == num36 || (num5 > 6 && (num30 == num36 - 1 || num30 == num36 + 1)))
					{
						num37 = 0;
					}
					int num39 = num37;
					int num40 = num30;
					num31 = genRand.Next((int)((double)num5 * 3.5), num5 * 6);
					while (num31 > 0)
					{
						num31--;
						num40 += num37;
						if (Main.tile[num40, num32].wall != 244)
						{
							Main.tile[num40, num32].type = 191;
							Main.tile[num40, num32].active(active: true);
							Main.tile[num40, num32].halfBrick(halfBrick: false);
						}
						num32 += num38;
						if (Main.tile[num40, num32].wall != 244)
						{
							Main.tile[num40, num32].type = 191;
							Main.tile[num40, num32].active(active: true);
							Main.tile[num40, num32].halfBrick(halfBrick: false);
						}
						if (!Main.tile[num40, num32 + 1].active())
						{
							num37 = 0;
							num38 = 1;
						}
						if (genRand.Next(3) == 0)
						{
							num37 = ((num39 < 0) ? ((num37 == 0) ? (-1) : 0) : ((num39 <= 0) ? genRand.Next(-1, 2) : ((num37 == 0) ? 1 : 0)));
						}
						if (genRand.Next(3) == 0)
						{
							num38 = ((num38 == 0) ? 1 : 0);
						}
					}
				}
			}
			for (int num41 = 0; num41 < num2; num41++)
			{
				int num42 = genRand.Next(5, 8);
				num42 = (int)((float)num42 * (1f + (float)num5 * 0.05f));
				if (array7[num41])
				{
					num42 = genRand.Next(6, 12) + num5;
				}
				int num43 = array5[num41] - num42 * 2;
				int num44 = array5[num41] + num42 * 2;
				int num45 = array6[num41] - num42 * 2;
				int num46 = array6[num41] + num42 * 2;
				float num47 = 2f - (float)genRand.Next(5) * 0.1f;
				for (int num48 = num43; num48 <= num44; num48++)
				{
					for (int num49 = num45; num49 <= num46; num49++)
					{
						if (Main.tile[num48, num49].type == 191)
						{
							continue;
						}
						if (array7[num41])
						{
							if ((double)(new Vector2(array5[num41], array6[num41]) - new Vector2(num48, num49)).Length() < (double)num42 * 0.9)
							{
								Main.tile[num48, num49].type = 192;
								Main.tile[num48, num49].active(active: true);
								Main.tile[num48, num49].halfBrick(halfBrick: false);
							}
						}
						else if ((float)Math.Abs(array5[num41] - num48) + (float)Math.Abs(array6[num41] - num49) * num47 < (float)num42)
						{
							Main.tile[num48, num49].type = 192;
							Main.tile[num48, num49].active(active: true);
							Main.tile[num48, num49].halfBrick(halfBrick: false);
						}
					}
					if (genRand.Next(30) == 0)
					{
						int num50 = num45;
						if (!Main.tile[num48, num50].active())
						{
							for (; !Main.tile[num48, num50 + 1].active() && num50 < num46; num50++)
							{
							}
							if (Main.tile[num48, num50 + 1].type == 192)
							{
								PlaceTile(num48, num50, 187, mute: true, forced: false, -1, genRand.Next(50, 52));
							}
						}
					}
					if (array7[num41] || genRand.Next(15) != 0)
					{
						continue;
					}
					int num51 = num46;
					int num52 = num51 + 100;
					if (Main.tile[num48, num51].active())
					{
						continue;
					}
					for (; !Main.tile[num48, num51 + 1].active() && num51 < num52; num51++)
					{
					}
					if (Main.tile[num48, num51 + 1].type == 192)
					{
						continue;
					}
					if (genRand.Next(2) == 0)
					{
						PlaceTile(num48, num51, 187, mute: true, forced: false, -1, genRand.Next(47, 50));
						continue;
					}
					int num53 = genRand.Next(2);
					int x = 72;
					if (num53 == 1)
					{
						x = genRand.Next(59, 62);
					}
					PlaceSmallPile(num48, num51, x, num53, 185);
				}
			}
			if (flag)
			{
				bool flag3 = false;
				for (int num54 = j; num54 < j + 20 && !((double)num54 >= Main.worldSurface - 2.0); num54++)
				{
					for (int num55 = minl; num55 <= minr; num55++)
					{
						if (Main.tile[num55, num54].wall == 0 && !SolidTile(num55, num54))
						{
							flag3 = true;
						}
					}
				}
				if (!flag3)
				{
					GrowLivingTree_MakePassage(j, num5, minl, minr, patch);
				}
			}
			Main.tileSolid[48] = true;
			return true;
		}

		public static bool GrowDungeonTree(int i, int j, bool patch = false)
		{
			int num = 0;
			int[] array = new int[1000];
			int[] array2 = new int[1000];
			int[] array3 = new int[1000];
			int[] array4 = new int[1000];
			int num2 = 0;
			int[] array5 = new int[2000];
			int[] array6 = new int[2000];
			bool[] array7 = new bool[2000];
			int num3 = i - genRand.Next(2, 3);
			int num4 = i + genRand.Next(2, 3);
			if (genRand.Next(5) == 0)
			{
				if (genRand.Next(2) == 0)
				{
					num3--;
				}
				else
				{
					num4++;
				}
			}
			int num5 = num4 - num3;
			int num6 = num3;
			int num7 = num4;
			int minl = num3;
			int minr = num4;
			bool flag = true;
			int num8 = genRand.Next(-8, -4);
			int num9 = genRand.Next(2);
			int num10 = j;
			int num11 = genRand.Next(5, 15);
			Main.tileSolid[48] = false;
			while (flag)
			{
				num8++;
				if (num8 > num11)
				{
					num11 = genRand.Next(5, 15);
					num8 = 0;
					array2[num] = num10 + genRand.Next(5);
					if (genRand.Next(5) == 0)
					{
						num9 = ((num9 == 0) ? 1 : 0);
					}
					if (num9 == 0)
					{
						array3[num] = -1;
						array[num] = num3;
						array4[num] = num4 - num3;
						if (genRand.Next(2) == 0)
						{
							num3++;
						}
						num6++;
						num9 = 1;
					}
					else
					{
						array3[num] = 1;
						array[num] = num4;
						array4[num] = num4 - num3;
						if (genRand.Next(2) == 0)
						{
							num4--;
						}
						num7--;
						num9 = 0;
					}
					if (num6 == num7)
					{
						flag = false;
					}
					num++;
				}
				for (int k = num3; k <= num4; k++)
				{
					Main.tile[k, num10].type = 191;
					Main.tile[k, num10].active(active: true);
					Main.tile[k, num10].halfBrick(halfBrick: false);
					Main.tile[k, num10].color(28);
				}
				num10--;
			}
			for (int l = 0; l < num - 1; l++)
			{
				int num12 = array[l] + array3[l];
				int num13 = array2[l];
				int num14 = (int)((float)array4[l] * (1f + (float)genRand.Next(20, 30) * 0.1f));
				Main.tile[num12, num13 + 1].type = 191;
				Main.tile[num12, num13 + 1].active(active: true);
				Main.tile[num12, num13 + 1].halfBrick(halfBrick: false);
				Main.tile[num12, num13 + 1].color(28);
				int num15 = genRand.Next(3, 5);
				while (num14 > 0)
				{
					num14--;
					Main.tile[num12, num13].type = 191;
					Main.tile[num12, num13].active(active: true);
					Main.tile[num12, num13].halfBrick(halfBrick: false);
					Main.tile[num12, num13].color(28);
					if (genRand.Next(10) == 0)
					{
						num13 = ((genRand.Next(2) != 0) ? (num13 + 1) : (num13 - 1));
					}
					else
					{
						num12 += array3[l];
					}
					if (num15 > 0)
					{
						num15--;
					}
					else if (genRand.Next(2) == 0)
					{
						num15 = genRand.Next(2, 5);
						if (genRand.Next(2) == 0)
						{
							Main.tile[num12, num13].type = 191;
							Main.tile[num12, num13].active(active: true);
							Main.tile[num12, num13].halfBrick(halfBrick: false);
							Main.tile[num12, num13].color(28);
							Main.tile[num12, num13 - 1].type = 191;
							Main.tile[num12, num13 - 1].active(active: true);
							Main.tile[num12, num13 - 1].halfBrick(halfBrick: false);
							Main.tile[num12, num13 - 1].color(28);
							array5[num2] = num12;
							array6[num2] = num13;
							num2++;
						}
						else
						{
							Main.tile[num12, num13].type = 191;
							Main.tile[num12, num13].active(active: true);
							Main.tile[num12, num13].halfBrick(halfBrick: false);
							Main.tile[num12, num13].color(28);
							Main.tile[num12, num13 + 1].type = 191;
							Main.tile[num12, num13 + 1].active(active: true);
							Main.tile[num12, num13 + 1].halfBrick(halfBrick: false);
							Main.tile[num12, num13 + 1].color(28);
							array5[num2] = num12;
							array6[num2] = num13;
							num2++;
						}
					}
					if (num14 == 0)
					{
						array5[num2] = num12;
						array6[num2] = num13;
						num2++;
					}
				}
			}
			int num16 = (num3 + num4) / 2;
			int num17 = num10;
			int num18 = genRand.Next(num5 * 3, num5 * 5);
			int num19 = 0;
			int num20 = 0;
			while (num18 > 0)
			{
				Main.tile[num16, num17].type = 191;
				Main.tile[num16, num17].active(active: true);
				Main.tile[num16, num17].halfBrick(halfBrick: false);
				Main.tile[num16, num17].color(28);
				if (num19 > 0)
				{
					num19--;
				}
				if (num20 > 0)
				{
					num20--;
				}
				for (int m = -1; m < 2; m++)
				{
					if (m == 0 || ((m >= 0 || num19 != 0) && (m <= 0 || num20 != 0)) || genRand.Next(2) != 0)
					{
						continue;
					}
					int num21 = num16;
					int num22 = num17;
					int num23 = genRand.Next(num5, num5 * 3);
					if (m < 0)
					{
						num19 = genRand.Next(3, 5);
					}
					if (m > 0)
					{
						num20 = genRand.Next(3, 5);
					}
					int num24 = 0;
					while (num23 > 0)
					{
						num23--;
						num21 += m;
						Main.tile[num21, num22].type = 191;
						Main.tile[num21, num22].active(active: true);
						Main.tile[num21, num22].halfBrick(halfBrick: false);
						Main.tile[num21, num22].color(28);
						if (num23 == 0)
						{
							array5[num2] = num21;
							array6[num2] = num22;
							array7[num2] = true;
							num2++;
						}
						if (genRand.Next(5) == 0)
						{
							num22 = ((genRand.Next(2) != 0) ? (num22 + 1) : (num22 - 1));
							Main.tile[num21, num22].type = 191;
							Main.tile[num21, num22].active(active: true);
							Main.tile[num21, num22].halfBrick(halfBrick: false);
							Main.tile[num21, num22].color(28);
						}
						if (num24 > 0)
						{
							num24--;
						}
						else if (genRand.Next(3) == 0)
						{
							num24 = genRand.Next(2, 4);
							int num25 = num21;
							int num26 = num22;
							num26 = ((genRand.Next(2) != 0) ? (num26 + 1) : (num26 - 1));
							Main.tile[num25, num26].type = 191;
							Main.tile[num25, num26].active(active: true);
							Main.tile[num25, num26].halfBrick(halfBrick: false);
							Main.tile[num25, num26].color(28);
							array5[num2] = num25;
							array6[num2] = num26;
							array7[num2] = true;
							num2++;
							array5[num2] = num25 + genRand.Next(-5, 6);
							array6[num2] = num26 + genRand.Next(-5, 6);
							array7[num2] = true;
							num2++;
						}
					}
				}
				array5[num2] = num16;
				array6[num2] = num17;
				num2++;
				if (genRand.Next(4) == 0)
				{
					num16 = ((genRand.Next(2) != 0) ? (num16 + 1) : (num16 - 1));
					Main.tile[num16, num17].type = 191;
					Main.tile[num16, num17].active(active: true);
					Main.tile[num16, num17].halfBrick(halfBrick: false);
					Main.tile[num16, num17].color(28);
				}
				num17--;
				num18--;
			}
			for (int n = minl; n <= minr; n++)
			{
				int num27 = genRand.Next(1, 6);
				int num28 = j + 1;
				while (num27 > 0)
				{
					if (SolidTile(n, num28))
					{
						num27--;
					}
					Main.tile[n, num28].type = 191;
					Main.tile[n, num28].active(active: true);
					Main.tile[n, num28].halfBrick(halfBrick: false);
					num28++;
				}
				int num29 = num28;
				int num30 = genRand.Next(2, num5 + 1);
				for (int num31 = 0; num31 < num30; num31++)
				{
					num28 = num29;
					int num32 = (minl + minr) / 2;
					int num33 = 0;
					int num34 = 1;
					num33 = ((n >= num32) ? 1 : (-1));
					if (n == num32 || (num5 > 6 && (n == num32 - 1 || n == num32 + 1)))
					{
						num33 = 0;
					}
					int num35 = num33;
					int num36 = n;
					num27 = genRand.Next((int)((double)num5 * 3.5), num5 * 6);
					while (num27 > 0)
					{
						num27--;
						num36 += num33;
						if (Main.tile[num36, num28].wall != 244)
						{
							Main.tile[num36, num28].type = 191;
							Main.tile[num36, num28].active(active: true);
							Main.tile[num36, num28].halfBrick(halfBrick: false);
						}
						num28 += num34;
						if (Main.tile[num36, num28].wall != 244)
						{
							Main.tile[num36, num28].type = 191;
							Main.tile[num36, num28].active(active: true);
							Main.tile[num36, num28].halfBrick(halfBrick: false);
						}
						if (!Main.tile[num36, num28 + 1].active())
						{
							num33 = 0;
							num34 = 1;
						}
						if (genRand.Next(3) == 0)
						{
							num33 = ((num35 < 0) ? ((num33 == 0) ? (-1) : 0) : ((num35 <= 0) ? genRand.Next(-1, 2) : ((num33 == 0) ? 1 : 0)));
						}
						if (genRand.Next(3) == 0)
						{
							num34 = ((num34 == 0) ? 1 : 0);
						}
					}
				}
			}
			for (int num37 = 0; num37 < num2; num37++)
			{
				int num38 = genRand.Next(5, 8);
				num38 = (int)((float)num38 * (1f + (float)num5 * 0.05f));
				if (array7[num37])
				{
					num38 = genRand.Next(6, 12) + num5;
				}
				int num39 = array5[num37] - num38 * 2;
				int num40 = array5[num37] + num38 * 2;
				int num41 = array6[num37] - num38 * 2;
				int num42 = array6[num37] + num38 * 2;
				float num43 = 2f - (float)genRand.Next(5) * 0.1f;
				for (int num44 = num39; num44 <= num40; num44++)
				{
					for (int num45 = num41; num45 <= num42; num45++)
					{
						if (Main.tile[num44, num45].type == 191)
						{
							continue;
						}
						if (array7[num37])
						{
							if ((double)(new Vector2(array5[num37], array6[num37]) - new Vector2(num44, num45)).Length() < (double)num38 * 0.9)
							{
								Main.tile[num44, num45].type = 192;
								Main.tile[num44, num45].active(active: true);
								Main.tile[num44, num45].halfBrick(halfBrick: false);
								Main.tile[num44, num45].color(28);
							}
						}
						else if ((float)Math.Abs(array5[num37] - num44) + (float)Math.Abs(array6[num37] - num45) * num43 < (float)num38)
						{
							Main.tile[num44, num45].type = 192;
							Main.tile[num44, num45].active(active: true);
							Main.tile[num44, num45].halfBrick(halfBrick: false);
							Main.tile[num44, num45].color(28);
						}
					}
				}
			}
			GrowDungeonTree_MakePassage(j, num5, minl, minr, patch);
			Main.tileSolid[48] = true;
			return true;
		}

		private static bool GrowLivingTree_HorizontalTunnel(int i, int j)
		{
			int num = i;
			int num2 = i;
			int num3 = 80;
			bool flag = false;
			int num4 = 1;
			if (genRand.Next(2) == 0)
			{
				num4 *= -1;
			}
			for (int k = 0; k < 2; k++)
			{
				flag = false;
				if (num == i && num4 > 0)
				{
					for (int l = i + 5; l < i + num3; l++)
					{
						if (!InWorld(l, j, 10))
						{
							return false;
						}
						if ((double)j < Main.worldSurface)
						{
							for (int m = j - 7; m <= j + 7 && Main.tile[l, m].wall != 0; m++)
							{
							}
						}
						if (Main.tile[l, j].type == 48)
						{
							flag = true;
							break;
						}
						if (Main.tile[l, j].type == 191)
						{
							for (int n = j - 2; n <= j; n++)
							{
								if (Main.tile[l + 2, n].wall != 244)
								{
									flag = true;
								}
							}
							if (!flag)
							{
								k = 2;
								num2 = l + 2;
							}
							break;
						}
						if (Main.tile[l, j].active())
						{
							continue;
						}
						bool flag2 = true;
						for (int num5 = j - 2; num5 <= j; num5++)
						{
							if ((double)j < Main.worldSurface + 3.0 && (Main.tile[l + 1, num5].wall == 0 || Main.tile[l + 2, num5].wall == 0 || Main.tile[l + 3, num5].wall == 0))
							{
								return false;
							}
							if (Main.tile[l, num5].active() || Main.tile[l + 1, num5].active() || Main.tile[l + 2, num5].active())
							{
								flag2 = false;
							}
						}
						if (flag2)
						{
							k = 2;
							num2 = l;
							break;
						}
					}
				}
				flag = false;
				if (num2 == i && num4 < 0)
				{
					for (int num6 = i - 5; num6 > i - num3; num6--)
					{
						if (!InWorld(num6, j, 10))
						{
							return false;
						}
						if ((double)j < Main.worldSurface)
						{
							for (int num7 = j - 7; num7 <= j + 7 && Main.tile[num6, num7].wall != 0; num7++)
							{
							}
						}
						if (Main.tile[num6, j].type == 48)
						{
							flag = true;
							break;
						}
						if (Main.tile[num6, j].type == 191)
						{
							for (int num8 = j - 2; num8 <= j; num8++)
							{
								if (Main.tile[num6 - 3, num8].wall != 244)
								{
									flag = true;
								}
							}
							if (!flag)
							{
								k = 2;
								num = num6 - 2;
							}
							break;
						}
						if (!Main.tile[num6, j].active())
						{
							bool flag3 = true;
							for (int num9 = j - 2; num9 <= j; num9++)
							{
								if ((double)j < Main.worldSurface + 3.0 && (Main.tile[num6 - 1, num9].wall == 0 || Main.tile[num6 - 2, num9].wall == 0 || Main.tile[num6 - 3, num9].wall == 0))
								{
									return false;
								}
								if (Main.tile[num6, num9].active() || Main.tile[num6 - 1, num9].active() || Main.tile[num6 - 2, num9].active())
								{
									flag3 = false;
								}
							}
							if (flag3)
							{
								k = 2;
								num = num6;
								break;
							}
						}
					}
				}
				num4 *= -1;
			}
			if (num == num2)
			{
				return false;
			}
			bool flag4 = false;
			bool flag5 = false;
			for (int num10 = j - 5; num10 <= j + 1; num10++)
			{
				for (int num11 = num; num11 <= num2; num11++)
				{
					int num12 = 2;
					if (Math.Abs(num11 - num2) > 3 && Math.Abs(num11 - num) > 3)
					{
						num12 = 4;
					}
					if (Main.tile[num11, num10].wall != 244 && Main.tile[num11, num10].type != 19 && Main.tile[num11, num10].type != 15 && Main.tile[num11, num10].type != 304 && Main.tile[num11, num10].type != 21 && Main.tile[num11, num10].type != 10)
					{
						if (!Main.wallDungeon[Main.tile[num11, num10].wall] && (!Main.tile[num11, num10].active() || (!Main.wallDungeon[Main.tile[num11, num10 - 1].wall] && !Main.wallDungeon[Main.tile[num11, num10 + 1].wall])))
						{
							Main.tile[num11, num10].active(active: true);
							Main.tile[num11, num10].type = 191;
							Main.tile[num11, num10].halfBrick(halfBrick: false);
						}
						if (Main.tile[num11, num10 - 1].type == 40)
						{
							Main.tile[num11, num10 - 1].type = 0;
						}
						if (Main.tile[num11, num10 + 1].type == 40)
						{
							Main.tile[num11, num10 + 1].type = 0;
						}
					}
					if (num10 >= j - num12 && num10 <= j && Main.tile[num11, num10].type != 19 && Main.tile[num11, num10].type != 15 && Main.tile[num11, num10].type != 304 && Main.tile[num11, num10].type != 21 && Main.tile[num11, num10].type != 10 && Main.tile[num11, num10 - 1].type != 15 && Main.tile[num11, num10 - 1].type != 304 && Main.tile[num11, num10 - 1].type != 21 && Main.tile[num11, num10 - 1].type != 10 && Main.tile[num11, num10 + 1].type != 10)
					{
						if (!Main.wallDungeon[Main.tile[num11, num10].wall])
						{
							Main.tile[num11, num10].wall = 244;
						}
						Main.tile[num11, num10].liquid = 0;
						Main.tile[num11, num10].active(active: false);
					}
					if (num10 != j)
					{
						continue;
					}
					int style = 7;
					if (Main.wallDungeon[Main.tile[num11, num10].wall] || Main.wallDungeon[Main.tile[num11, num10 - 1].wall] || Main.wallDungeon[Main.tile[num11, num10 - 2].wall])
					{
						style = 13;
					}
					if (num11 <= num + 4 && !flag4)
					{
						if (Main.tile[num11 - 1, num10].type == 10 || Main.tile[num11 + 1, num10].type == 10)
						{
							flag4 = true;
						}
						else if (genRand.Next(3) == 0)
						{
							PlaceTile(num11, num10, 10, mute: true, forced: false, -1, style);
							if (Main.tile[num11, num10].type == 10)
							{
								flag4 = true;
							}
						}
					}
					if (num11 < num2 - 4 || flag5)
					{
						continue;
					}
					if (Main.tile[num11 - 1, num10].type == 10 || Main.tile[num11 + 1, num10].type == 10)
					{
						flag5 = true;
					}
					else if (genRand.Next(3) == 0)
					{
						PlaceTile(num11, num10, 10, mute: true, forced: false, -1, style);
						if (Main.tile[num11, num10].type == 10)
						{
							flag5 = true;
						}
					}
				}
			}
			return true;
		}

		private static void GrowDungeonTree_MakePassage(int j, int W, int minl, int minr, bool noSecretRoom = false)
		{
			int num = minl;
			int num2 = minr;
			_ = (minl + minr) / 2;
			int num3 = 5;
			int num4 = j - 6;
			int num5 = 0;
			bool flag = true;
			genRand.Next(5, 16);
			while (true)
			{
				num4++;
				if (num4 > dungeonY - 5)
				{
					break;
				}
				int num6 = (minl + minr) / 2;
				int num7 = 1;
				if (num4 > j && W <= 4)
				{
					num7++;
				}
				for (int i = minl - num7; i <= minr + num7; i++)
				{
					if (i > num6 - 2 && i <= num6 + 1)
					{
						if (num4 > j - 4)
						{
							if (Main.tile[i, num4].type != 19 && Main.tile[i, num4].type != 15 && Main.tile[i, num4].type != 304 && Main.tile[i, num4].type != 21 && Main.tile[i, num4].type != 10 && Main.tile[i, num4 - 1].type != 15 && Main.tile[i, num4 - 1].type != 304 && Main.tile[i, num4 - 1].type != 21 && Main.tile[i, num4 - 1].type != 10 && Main.tile[i, num4 + 1].type != 10)
							{
								Main.tile[i, num4].active(active: false);
							}
							if (!Main.wallDungeon[Main.tile[i, num4].wall])
							{
								Main.tile[i, num4].wall = 244;
							}
							if (!Main.wallDungeon[Main.tile[i - 1, num4].wall] && (Main.tile[i - 1, num4].wall > 0 || (double)num4 >= Main.worldSurface))
							{
								Main.tile[i - 1, num4].wall = 244;
							}
							if (!Main.wallDungeon[Main.tile[i + 1, num4].wall] && (Main.tile[i + 1, num4].wall > 0 || (double)num4 >= Main.worldSurface))
							{
								Main.tile[i + 1, num4].wall = 244;
							}
							if (num4 == j && i > num6 - 2 && i <= num6 + 1)
							{
								Main.tile[i, num4 + 1].active(active: false);
								PlaceTile(i, num4 + 1, 19, mute: true, forced: false, -1, 23);
							}
						}
					}
					else
					{
						if (Main.tile[i, num4].type != 15 && Main.tile[i, num4].type != 304 && Main.tile[i, num4].type != 21 && Main.tile[i, num4].type != 10 && Main.tile[i - 1, num4].type != 10 && Main.tile[i + 1, num4].type != 10)
						{
							if (!Main.wallDungeon[Main.tile[i, num4].wall])
							{
								Main.tile[i, num4].type = 191;
								Main.tile[i, num4].active(active: true);
								Main.tile[i, num4].halfBrick(halfBrick: false);
							}
							if (Main.tile[i - 1, num4].type == 40)
							{
								Main.tile[i - 1, num4].type = 0;
							}
							if (Main.tile[i + 1, num4].type == 40)
							{
								Main.tile[i + 1, num4].type = 0;
							}
						}
						if (num4 <= j && num4 > j - 4 && i > minl - num7 && i <= minr + num7 - 1)
						{
							Main.tile[i, num4].wall = 244;
						}
					}
					if (!gen)
					{
						SquareTileFrame(i, num4);
						SquareWallFrame(i, num4);
					}
				}
				num5++;
				if (num5 < 6)
				{
					continue;
				}
				num5 = 0;
				int num8 = genRand.Next(3);
				if (num8 == 0)
				{
					num8 = -1;
				}
				if (flag)
				{
					num8 = 2;
				}
				if (num8 == -1 && Main.tile[minl - num3, num4].wall == 244)
				{
					num8 = 1;
				}
				else if (num8 == 1 && Main.tile[minr + num3, num4].wall == 244)
				{
					num8 = -1;
				}
				if (num8 == 2)
				{
					flag = false;
					int num9 = 23;
					if (Main.wallDungeon[Main.tile[minl, num4 + 1].wall] || Main.wallDungeon[Main.tile[minl + 1, num4 + 1].wall] || Main.wallDungeon[Main.tile[minl + 2, num4 + 1].wall])
					{
						num9 = 12;
					}
					if (!SolidTile(minl - 1, num4 + 1) && !SolidTile(minr + 1, num4 + 1) && num9 == 12)
					{
						continue;
					}
					for (int k = minl; k <= minr; k++)
					{
						if (k > num6 - 2 && k <= num6 + 1)
						{
							Main.tile[k, num4 + 1].active(active: false);
							PlaceTile(k, num4 + 1, 19, mute: true, forced: false, -1, num9);
						}
					}
				}
				else
				{
					minl += num8;
					minr += num8;
				}
			}
			minl = num;
			minr = num2;
			_ = (minl + minr) / 2;
			for (int l = minl; l <= minr; l++)
			{
				for (int m = j - 3; m <= j; m++)
				{
					Main.tile[l, m].active(active: false);
					if (!Main.wallDungeon[Main.tile[l, m].wall])
					{
						Main.tile[l, m].wall = 244;
					}
				}
			}
		}

		private static void GrowLivingTree_MakePassage(int j, int W, int minl, int minr, bool noSecretRoom = false)
		{
			bool flag = noSecretRoom;
			int num = minl;
			int num2 = minr;
			bool flag2 = false;
			_ = (minl + minr) / 2;
			int num3 = 5;
			int num4 = j - 6;
			int num5 = 50;
			int num6 = genRand.Next(400, 700);
			int num7 = 0;
			bool flag3 = true;
			int num8 = genRand.Next(5, 16);
			while (num6 > 0)
			{
				num4++;
				num6--;
				num5--;
				int num9 = (minl + minr) / 2;
				if (!Main.tile[minl, num4].active() && Main.tile[minl, num4].wall == 244 && !Main.tile[minr, num4].active() && Main.tile[minr, num4].wall == 244)
				{
					num6 = 0;
					break;
				}
				int num10 = 1;
				if (num4 > j && W <= 4)
				{
					num10++;
				}
				for (int i = minl - num10; i <= minr + num10; i++)
				{
					if (Main.wallDungeon[Main.tile[i, num4].wall])
					{
						flag = true;
						flag2 = true;
					}
					if (i > num9 - 2 && i <= num9 + 1)
					{
						if (num4 > j - 4)
						{
							if (Main.tile[i, num4].type != 19 && Main.tile[i, num4].type != 15 && Main.tile[i, num4].type != 304 && Main.tile[i, num4].type != 21 && Main.tile[i, num4].type != 10 && Main.tile[i, num4 - 1].type != 15 && Main.tile[i, num4 - 1].type != 304 && Main.tile[i, num4 - 1].type != 21 && Main.tile[i, num4 - 1].type != 10 && Main.tile[i, num4 + 1].type != 10)
							{
								Main.tile[i, num4].active(active: false);
							}
							if (!Main.wallDungeon[Main.tile[i, num4].wall])
							{
								Main.tile[i, num4].wall = 244;
							}
							if (!Main.wallDungeon[Main.tile[i - 1, num4].wall] && (Main.tile[i - 1, num4].wall > 0 || (double)num4 >= Main.worldSurface))
							{
								Main.tile[i - 1, num4].wall = 244;
							}
							if (!Main.wallDungeon[Main.tile[i + 1, num4].wall] && (Main.tile[i + 1, num4].wall > 0 || (double)num4 >= Main.worldSurface))
							{
								Main.tile[i + 1, num4].wall = 244;
							}
							if (num4 == j && i > num9 - 2 && i <= num9 + 1)
							{
								Main.tile[i, num4 + 1].active(active: false);
								PlaceTile(i, num4 + 1, 19, mute: true, forced: false, -1, 23);
							}
						}
					}
					else
					{
						if (Main.tile[i, num4].type != 15 && Main.tile[i, num4].type != 304 && Main.tile[i, num4].type != 21 && Main.tile[i, num4].type != 10 && Main.tile[i - 1, num4].type != 10 && Main.tile[i + 1, num4].type != 10)
						{
							if (!Main.wallDungeon[Main.tile[i, num4].wall])
							{
								Main.tile[i, num4].type = 191;
								Main.tile[i, num4].active(active: true);
								Main.tile[i, num4].halfBrick(halfBrick: false);
							}
							if (Main.tile[i - 1, num4].type == 40)
							{
								Main.tile[i - 1, num4].type = 0;
							}
							if (Main.tile[i + 1, num4].type == 40)
							{
								Main.tile[i + 1, num4].type = 0;
							}
						}
						if (num4 <= j && num4 > j - 4 && i > minl - num10 && i <= minr + num10 - 1)
						{
							Main.tile[i, num4].wall = 244;
						}
					}
					if (!gen)
					{
						SquareTileFrame(i, num4);
						SquareWallFrame(i, num4);
					}
				}
				num7++;
				if (num7 >= 6)
				{
					num7 = 0;
					int num11 = genRand.Next(3);
					if (num11 == 0)
					{
						num11 = -1;
					}
					if (flag3)
					{
						num11 = 2;
					}
					if (num11 == -1 && Main.tile[minl - num3, num4].wall == 244)
					{
						num11 = 1;
					}
					else if (num11 == 1 && Main.tile[minr + num3, num4].wall == 244)
					{
						num11 = -1;
					}
					if (num11 == 2)
					{
						flag3 = false;
						int style = 23;
						if (Main.wallDungeon[Main.tile[minl, num4 + 1].wall] || Main.wallDungeon[Main.tile[minl + 1, num4 + 1].wall] || Main.wallDungeon[Main.tile[minl + 2, num4 + 1].wall])
						{
							style = 12;
						}
						for (int k = minl; k <= minr; k++)
						{
							if (k > num9 - 2 && k <= num9 + 1)
							{
								Main.tile[k, num4 + 1].active(active: false);
								PlaceTile(k, num4 + 1, 19, mute: true, forced: false, -1, style);
							}
						}
					}
					else
					{
						minl += num11;
						minr += num11;
					}
					if (noSecretRoom)
					{
						num8--;
						if (num8 <= 0)
						{
							num8 = ((!GrowLivingTree_HorizontalTunnel(num9, num4)) ? genRand.Next(2, 11) : genRand.Next(5, 21));
						}
					}
					if (num5 <= 0 && !flag)
					{
						flag = true;
						GrowLivingTreePassageRoom(minl, minr, num4);
					}
				}
				if (flag2)
				{
					bool flag4 = true;
					for (int l = minl; l <= minr; l++)
					{
						for (int m = num4 + 1; m <= num4 + 2; m++)
						{
							if (SolidTile(l, m))
							{
								flag4 = false;
							}
						}
					}
					if (flag4)
					{
						num6 = 0;
					}
				}
				else
				{
					if (num5 > 0)
					{
						continue;
					}
					bool flag5 = true;
					for (int n = minl; n <= minr; n++)
					{
						for (int num12 = num4 + 1; num12 <= num4 + 4; num12++)
						{
							if (SolidTile(n, num12))
							{
								flag5 = false;
							}
						}
					}
					if (flag5)
					{
						num6 = 0;
					}
				}
			}
			minl = num;
			minr = num2;
			_ = (minl + minr) / 2;
			for (int num13 = minl; num13 <= minr; num13++)
			{
				for (int num14 = j - 3; num14 <= j; num14++)
				{
					Main.tile[num13, num14].active(active: false);
					bool flag6 = true;
					for (int num15 = num13 - 1; num15 <= num13 + 1; num15++)
					{
						for (int num16 = num14 - 1; num16 <= num14 + 1; num16++)
						{
							if (!Main.tile[num15, num16].active() && Main.tile[num15, num16].wall == 0)
							{
								flag6 = false;
							}
						}
					}
					if (flag6 && !Main.wallDungeon[Main.tile[num13, num14].wall])
					{
						Main.tile[num13, num14].wall = 244;
					}
				}
			}
		}

		private static void GrowLivingTreePassageRoom(int minl, int minr, int Y)
		{
			int num = genRand.Next(2);
			if (num == 0)
			{
				num = -1;
			}
			int num2 = Y - 2;
			int num3 = (minl + minr) / 2;
			if (num < 0)
			{
				num3--;
			}
			if (num > 0)
			{
				num3++;
			}
			int num4 = genRand.Next(15, 30);
			int num5 = num3 + num4;
			if (num < 0)
			{
				num5 = num3;
				num3 -= num4;
			}
			for (int i = num3; i < num5; i++)
			{
				for (int j = Y - 20; j < Y + 10; j++)
				{
					if (Main.tile[i, j].wall == 0 && !Main.tile[i, j].active() && (double)j < Main.worldSurface)
					{
						return;
					}
				}
			}
			dMinX = num3;
			dMaxX = num5;
			if (num < 0)
			{
				dMinX -= 40;
			}
			else
			{
				dMaxX += 40;
			}
			for (int k = num3; k <= num5; k++)
			{
				for (int l = num2 - 2; l <= Y + 2; l++)
				{
					if (Main.tile[k - 1, l].type == 40)
					{
						Main.tile[k - 1, l].type = 0;
					}
					if (Main.tile[k + 1, l].type == 40)
					{
						Main.tile[k + 1, l].type = 0;
					}
					if (Main.tile[k, l - 1].type == 40)
					{
						Main.tile[k, l - 1].type = 0;
					}
					if (Main.tile[k, l + 1].type == 40)
					{
						Main.tile[k, l + 1].type = 0;
					}
					if (Main.tile[k, l].wall != 244 && Main.tile[k, l].type != 19)
					{
						Main.tile[k, l].active(active: true);
						Main.tile[k, l].type = 191;
						Main.tile[k, l].halfBrick(halfBrick: false);
					}
					if (l >= num2 && l <= Y)
					{
						Main.tile[k, l].liquid = 0;
						Main.tile[k, l].wall = 244;
						Main.tile[k, l].active(active: false);
					}
				}
			}
			int i2 = (minl + minr) / 2 + 3 * num;
			PlaceTile(i2, Y, 10, mute: true, forced: false, -1, 7);
			int num6 = genRand.Next(5, 9);
			int num7 = genRand.Next(4, 6);
			if (num < 0)
			{
				num5 = num3 + num6;
				num3 -= num6;
			}
			else
			{
				num3 = num5 - num6;
				num5 += num6;
			}
			num2 = Y - num7;
			for (int m = num3 - 2; m <= num5 + 2; m++)
			{
				for (int n = num2 - 2; n <= Y + 2; n++)
				{
					if (Main.tile[m - 1, n].type == 40)
					{
						Main.tile[m - 1, n].type = 40;
					}
					if (Main.tile[m + 1, n].type == 40)
					{
						Main.tile[m + 1, n].type = 40;
					}
					if (Main.tile[m, n - 1].type == 40)
					{
						Main.tile[m, n - 1].type = 40;
					}
					if (Main.tile[m, n + 1].type == 40)
					{
						Main.tile[m, n + 1].type = 40;
					}
					if (Main.tile[m, n].wall != 244 && Main.tile[m, n].type != 19)
					{
						Main.tile[m, n].active(active: true);
						Main.tile[m, n].type = 191;
						Main.tile[m, n].halfBrick(halfBrick: false);
					}
					if (n >= num2 && n <= Y && m >= num3 && m <= num5)
					{
						Main.tile[m, n].liquid = 0;
						Main.tile[m, n].wall = 244;
						Main.tile[m, n].active(active: false);
					}
				}
			}
			i2 = num3 - 2;
			if (num < 0)
			{
				i2 = num5 + 2;
			}
			PlaceTile(i2, Y, 10, mute: true, forced: false, -1, 7);
			int num8 = num5;
			if (num < 0)
			{
				num8 = num3;
			}
			int num9 = 2;
			if (genRand.Next(num9) == 0)
			{
				num9 += 2;
				PlaceTile(num8, Y, 15, mute: true, forced: false, -1, 5);
				if (num < 0)
				{
					Main.tile[num8, Y - 1].frameX += 18;
					Main.tile[num8, Y].frameX += 18;
				}
			}
			num8 = num5 - 2;
			if (num < 0)
			{
				num8 = num3 + 2;
			}
			PlaceTile(num8, Y, 304, mute: true);
			num8 = num5 - 4;
			if (num < 0)
			{
				num8 = num3 + 4;
			}
			if (genRand.Next(num9) == 0)
			{
				PlaceTile(num8, Y, 15, mute: true, forced: false, -1, 5);
				if (num > 0)
				{
					Main.tile[num8, Y - 1].frameX += 18;
					Main.tile[num8, Y].frameX += 18;
				}
			}
			num8 = num5 - 7;
			if (num < 0)
			{
				num8 = num3 + 8;
			}
			int contain = 832;
			if (genRand.Next(3) == 0)
			{
				contain = 4281;
			}
			AddBuriedChest(num8, Y, contain, notNearOtherChests: false, 12, trySlope: false, 0);
		}

		public static void TreeGrowFXCheck(int x, int y)
		{
			int treeHeight = 1;
			int passStyle = -1;
			Tile topTile = null;
			for (int num = -1; num > -100; num--)
			{
				Tile tile = Main.tile[x, y + num];
				if (!tile.active() || !TileID.Sets.GetsCheckedForLeaves[tile.type])
				{
					break;
				}
				topTile = tile;
				treeHeight++;
			}
			for (int i = 1; i < 5; i++)
			{
				Tile tile2 = Main.tile[x, y + i];
				if (tile2.active() && TileID.Sets.GetsCheckedForLeaves[tile2.type])
				{
					treeHeight++;
					continue;
				}
				GetTreeLeaf(x, topTile, tile2, treeHeight, out var _, out passStyle);
				break;
			}
			if (treeHeight > 0 && passStyle > 0)
			{
				if (Main.netMode == 2)
				{
					NetMessage.SendData(112, -1, -1, null, 1, x, y, treeHeight, passStyle);
				}
				if (Main.netMode == 0)
				{
					TreeGrowFX(x, y, treeHeight, passStyle);
				}
			}
		}

		public static void GetTreeLeaf(int x, Tile topTile, Tile t, int treeHeight, out int treeFrame, out int passStyle)
		{
			treeFrame = 0;
			passStyle = -1;
			if (topTile.frameX == 22 || topTile.frameX == 44 || topTile.frameX == 66)
			{
				if (topTile.frameY == 220)
				{
					treeFrame = 1;
				}
				else if (topTile.frameY == 242)
				{
					treeFrame = 2;
				}
			}
			if (topTile.frameX == 44 || topTile.frameX == 66)
			{
				if (topTile.frameY == 220)
				{
					treeFrame = 1;
				}
				else if (topTile.frameY == 242)
				{
					treeFrame = 2;
				}
			}
			switch (topTile.type)
			{
			case 596:
				passStyle = 1248;
				break;
			case 616:
				passStyle = 1257;
				break;
			case 583:
			case 584:
			case 585:
			case 586:
			case 587:
			case 588:
			case 589:
				passStyle = 1249 + (topTile.type - 583);
				break;
			}
			if (passStyle > -1)
			{
				return;
			}
			switch (t.type)
			{
			case 2:
			case 477:
				passStyle = 910;
				break;
			case 60:
				passStyle = 914;
				break;
			case 70:
				passStyle = 912;
				break;
			case 23:
			case 400:
				passStyle = 915;
				break;
			case 199:
			case 234:
				passStyle = 916;
				break;
			case 53:
				passStyle = 911;
				break;
			case 116:
				passStyle = 919;
				break;
			case 147:
				passStyle = 913;
				break;
			case 109:
			case 492:
			{
				int num = 917;
				int hollowTreeFoliageStyle = GetHollowTreeFoliageStyle();
				if (hollowTreeFoliageStyle != 20)
				{
					if (x % 3 == 1)
					{
						treeFrame += 3;
					}
					if (x % 3 == 2)
					{
						treeFrame += 6;
					}
					switch (treeFrame)
					{
					case 0:
						passStyle = 2;
						break;
					case 1:
						passStyle = 1;
						break;
					case 2:
						passStyle = 7;
						break;
					case 3:
						passStyle = 4;
						break;
					case 4:
						passStyle = 5;
						break;
					case 5:
						passStyle = 6;
						break;
					case 6:
						passStyle = 3;
						break;
					case 7:
						passStyle = 8;
						break;
					case 8:
						passStyle = 0;
						break;
					}
				}
				else
				{
					int num2 = 196;
					if (x % 6 == 1)
					{
						treeFrame += 3;
					}
					else if (x % 6 == 2)
					{
						treeFrame += 6;
					}
					else if (x % 6 == 3)
					{
						treeFrame += 9;
					}
					else if (x % 6 == 4)
					{
						treeFrame += 12;
					}
					else if (x % 6 == 5)
					{
						treeFrame += 15;
					}
					switch (treeFrame)
					{
					case 0:
						passStyle = num2;
						break;
					case 1:
						passStyle = num2;
						break;
					case 2:
						passStyle = num2;
						break;
					case 3:
						passStyle = num2 + 1;
						break;
					case 4:
						passStyle = num2 + 2;
						break;
					case 5:
						passStyle = num2 + 1;
						break;
					case 6:
						passStyle = num2 + 3;
						break;
					case 7:
						passStyle = num2 + 4;
						break;
					case 8:
						passStyle = num2 + 5;
						break;
					case 9:
						passStyle = num2 + 6;
						break;
					case 10:
						passStyle = num2 + 6;
						break;
					case 11:
						passStyle = num2 + 6;
						break;
					case 12:
						passStyle = num2 + 7;
						break;
					case 13:
						passStyle = num2 + 7;
						break;
					case 14:
						passStyle = num2 + 7;
						break;
					case 15:
						passStyle = num2 + 8;
						break;
					case 16:
						passStyle = num2 + 8;
						break;
					case 17:
						passStyle = num2 + 8;
						break;
					}
				}
				passStyle += num;
				treeHeight += 5;
				break;
			}
			}
		}

		public static void TreeGrowFX(int x, int y, int height, int treeGore, bool hitTree = false)
		{
			Vector2 value = new Vector2(x, y) * 16f + new Vector2(8f, 8f);
			int num = 4;
			int maxValue = 2;
			for (int num2 = 0; num2 > -height; num2--)
			{
				if (num2 > -height / 2 && Main.rand.Next(3) != 0)
				{
					for (int i = 0; i < 5; i++)
					{
						Dust.NewDust(value + new Vector2(-16f, num2 * 16) + Utils.RandomVector2(Main.rand, -20f, 20f), 4, 4, num + Main.rand.Next(maxValue), 0f, -4f, 100);
					}
				}
				else
				{
					float num3 = 10f;
					Vector2 value2 = new Vector2(5f, 7f);
					Gore.NewGore(value + new Vector2(-16f, num2 * 16) - value2, Utils.RandomVector2(Main.rand, 0f - num3, num3), treeGore, 0.7f + Main.rand.NextFloat() * 0.6f);
					Gore.NewGore(value + new Vector2(0f, num2 * 16) - value2, Utils.RandomVector2(Main.rand, 0f - num3, num3), treeGore, 0.7f + Main.rand.NextFloat() * 0.6f);
					Gore.NewGore(value + new Vector2(16f, num2 * 16) - value2, Utils.RandomVector2(Main.rand, 0f - num3, num3), treeGore, 0.7f + Main.rand.NextFloat() * 0.6f);
					if (num2 == -height + 1)
					{
						int num4 = 20;
						if (hitTree)
						{
							num4 = 5;
						}
						for (int j = 0; j < num4; j++)
						{
							Gore.NewGore(value + new Vector2(0f, num2 * 16 - 40) + Utils.RandomVector2(Main.rand, -40f, 40f) - value2, Utils.RandomVector2(Main.rand, -10f, 10f), treeGore, 0.7f + Main.rand.NextFloat() * 0.6f);
						}
					}
				}
			}
		}

		public static bool IsTileALeafyTreeTop(int i, int j)
		{
			Tile tileSafely = Framing.GetTileSafely(i, j);
			if (tileSafely.active() && TileID.Sets.GetsCheckedForLeaves[tileSafely.type])
			{
				if (tileSafely.type == 323 && tileSafely.frameX >= 88)
				{
					return true;
				}
				if (tileSafely.frameX == 22 && tileSafely.frameY >= 198 && tileSafely.frameY <= 242)
				{
					return true;
				}
			}
			return false;
		}

		public static bool IsTileTypeFitForTree(ushort type)
		{
			switch (type)
			{
			case 2:
			case 23:
			case 60:
			case 70:
			case 109:
			case 147:
			case 199:
			case 477:
			case 492:
				return true;
			default:
				return false;
			}
		}

		public static bool GrowTree(int i, int y)
		{
			int j;
			for (j = y; Main.tile[i, j].type == 20; j++)
			{
			}
			if ((Main.tile[i - 1, j - 1].liquid != 0 || Main.tile[i, j - 1].liquid != 0 || Main.tile[i + 1, j - 1].liquid != 0) && !notTheBees)
			{
				return false;
			}
			if (Main.tile[i, j].nactive() && !Main.tile[i, j].halfBrick() && Main.tile[i, j].slope() == 0 && IsTileTypeFitForTree(Main.tile[i, j].type) && (Main.tile[i, j - 1].wall == 0 || Main.tile[i, j - 1].wall == 106 || Main.tile[i, j - 1].wall == 107 || (Main.tile[i, j - 1].wall >= 138 && Main.tile[i, j - 1].wall <= 141) || Main.tile[i, j - 1].wall == 145 || Main.tile[i, j - 1].wall == 150 || Main.tile[i, j - 1].wall == 152 || Main.tile[i, j - 1].wall == 80) && ((Main.tile[i - 1, j].active() && IsTileTypeFitForTree(Main.tile[i - 1, j].type)) || (Main.tile[i + 1, j].active() && IsTileTypeFitForTree(Main.tile[i + 1, j].type))))
			{
				byte color = Main.tile[i, j].color();
				int num = 2;
				int num2 = genRand.Next(5, 17);
				int num3 = num2 + 4;
				if (Main.tile[i, j].type == 60)
				{
					num3 += 5;
				}
				bool flag = false;
				if (Main.tile[i, j].type == 70 && EmptyTileCheck(i - num, i + num, j - num3, j - 3, 20) && EmptyTileCheck(i - 1, i + 1, j - 2, j - 1, 20))
				{
					flag = true;
				}
				if (EmptyTileCheck(i - num, i + num, j - num3, j - 1, 20))
				{
					flag = true;
				}
				if (flag)
				{
					bool flag2 = false;
					bool flag3 = false;
					int num4;
					for (int k = j - num2; k < j; k++)
					{
						Main.tile[i, k].frameNumber((byte)genRand.Next(3));
						Main.tile[i, k].active(active: true);
						Main.tile[i, k].type = 5;
						Main.tile[i, k].color(color);
						num4 = genRand.Next(3);
						int num5 = genRand.Next(10);
						if (k == j - 1 || k == j - num2)
						{
							num5 = 0;
						}
						while (((num5 == 5 || num5 == 7) && flag2) || ((num5 == 6 || num5 == 7) && flag3))
						{
							num5 = genRand.Next(10);
						}
						flag2 = false;
						flag3 = false;
						if (num5 == 5 || num5 == 7)
						{
							flag2 = true;
						}
						if (num5 == 6 || num5 == 7)
						{
							flag3 = true;
						}
						switch (num5)
						{
						case 1:
							if (num4 == 0)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 66;
							}
							if (num4 == 1)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 88;
							}
							if (num4 == 2)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 110;
							}
							break;
						case 2:
							if (num4 == 0)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 0;
							}
							if (num4 == 1)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 22;
							}
							if (num4 == 2)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 44;
							}
							break;
						case 3:
							if (num4 == 0)
							{
								Main.tile[i, k].frameX = 44;
								Main.tile[i, k].frameY = 66;
							}
							if (num4 == 1)
							{
								Main.tile[i, k].frameX = 44;
								Main.tile[i, k].frameY = 88;
							}
							if (num4 == 2)
							{
								Main.tile[i, k].frameX = 44;
								Main.tile[i, k].frameY = 110;
							}
							break;
						case 4:
							if (num4 == 0)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 66;
							}
							if (num4 == 1)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 88;
							}
							if (num4 == 2)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 110;
							}
							break;
						case 5:
							if (num4 == 0)
							{
								Main.tile[i, k].frameX = 88;
								Main.tile[i, k].frameY = 0;
							}
							if (num4 == 1)
							{
								Main.tile[i, k].frameX = 88;
								Main.tile[i, k].frameY = 22;
							}
							if (num4 == 2)
							{
								Main.tile[i, k].frameX = 88;
								Main.tile[i, k].frameY = 44;
							}
							break;
						case 6:
							if (num4 == 0)
							{
								Main.tile[i, k].frameX = 66;
								Main.tile[i, k].frameY = 66;
							}
							if (num4 == 1)
							{
								Main.tile[i, k].frameX = 66;
								Main.tile[i, k].frameY = 88;
							}
							if (num4 == 2)
							{
								Main.tile[i, k].frameX = 66;
								Main.tile[i, k].frameY = 110;
							}
							break;
						case 7:
							if (num4 == 0)
							{
								Main.tile[i, k].frameX = 110;
								Main.tile[i, k].frameY = 66;
							}
							if (num4 == 1)
							{
								Main.tile[i, k].frameX = 110;
								Main.tile[i, k].frameY = 88;
							}
							if (num4 == 2)
							{
								Main.tile[i, k].frameX = 110;
								Main.tile[i, k].frameY = 110;
							}
							break;
						default:
							if (num4 == 0)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 0;
							}
							if (num4 == 1)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 22;
							}
							if (num4 == 2)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 44;
							}
							break;
						}
						if (num5 == 5 || num5 == 7)
						{
							Main.tile[i - 1, k].active(active: true);
							Main.tile[i - 1, k].type = 5;
							Main.tile[i - 1, k].color(color);
							num4 = genRand.Next(3);
							if (genRand.Next(3) < 2)
							{
								if (num4 == 0)
								{
									Main.tile[i - 1, k].frameX = 44;
									Main.tile[i - 1, k].frameY = 198;
								}
								if (num4 == 1)
								{
									Main.tile[i - 1, k].frameX = 44;
									Main.tile[i - 1, k].frameY = 220;
								}
								if (num4 == 2)
								{
									Main.tile[i - 1, k].frameX = 44;
									Main.tile[i - 1, k].frameY = 242;
								}
							}
							else
							{
								if (num4 == 0)
								{
									Main.tile[i - 1, k].frameX = 66;
									Main.tile[i - 1, k].frameY = 0;
								}
								if (num4 == 1)
								{
									Main.tile[i - 1, k].frameX = 66;
									Main.tile[i - 1, k].frameY = 22;
								}
								if (num4 == 2)
								{
									Main.tile[i - 1, k].frameX = 66;
									Main.tile[i - 1, k].frameY = 44;
								}
							}
						}
						if (num5 != 6 && num5 != 7)
						{
							continue;
						}
						Main.tile[i + 1, k].active(active: true);
						Main.tile[i + 1, k].type = 5;
						Main.tile[i + 1, k].color(color);
						num4 = genRand.Next(3);
						if (genRand.Next(3) < 2)
						{
							if (num4 == 0)
							{
								Main.tile[i + 1, k].frameX = 66;
								Main.tile[i + 1, k].frameY = 198;
							}
							if (num4 == 1)
							{
								Main.tile[i + 1, k].frameX = 66;
								Main.tile[i + 1, k].frameY = 220;
							}
							if (num4 == 2)
							{
								Main.tile[i + 1, k].frameX = 66;
								Main.tile[i + 1, k].frameY = 242;
							}
						}
						else
						{
							if (num4 == 0)
							{
								Main.tile[i + 1, k].frameX = 88;
								Main.tile[i + 1, k].frameY = 66;
							}
							if (num4 == 1)
							{
								Main.tile[i + 1, k].frameX = 88;
								Main.tile[i + 1, k].frameY = 88;
							}
							if (num4 == 2)
							{
								Main.tile[i + 1, k].frameX = 88;
								Main.tile[i + 1, k].frameY = 110;
							}
						}
					}
					int num6 = genRand.Next(3);
					bool flag4 = false;
					bool flag5 = false;
					if (Main.tile[i - 1, j].nactive() && !Main.tile[i - 1, j].halfBrick() && Main.tile[i - 1, j].slope() == 0 && IsTileTypeFitForTree(Main.tile[i - 1, j].type))
					{
						flag4 = true;
					}
					if (Main.tile[i + 1, j].nactive() && !Main.tile[i + 1, j].halfBrick() && Main.tile[i + 1, j].slope() == 0 && IsTileTypeFitForTree(Main.tile[i + 1, j].type))
					{
						flag5 = true;
					}
					if (!flag4)
					{
						if (num6 == 0)
						{
							num6 = 2;
						}
						if (num6 == 1)
						{
							num6 = 3;
						}
					}
					if (!flag5)
					{
						if (num6 == 0)
						{
							num6 = 1;
						}
						if (num6 == 2)
						{
							num6 = 3;
						}
					}
					if (flag4 && !flag5)
					{
						num6 = 2;
					}
					if (flag5 && !flag4)
					{
						num6 = 1;
					}
					if (num6 == 0 || num6 == 1)
					{
						Main.tile[i + 1, j - 1].active(active: true);
						Main.tile[i + 1, j - 1].type = 5;
						Main.tile[i + 1, j - 1].color(color);
						num4 = genRand.Next(3);
						if (num4 == 0)
						{
							Main.tile[i + 1, j - 1].frameX = 22;
							Main.tile[i + 1, j - 1].frameY = 132;
						}
						if (num4 == 1)
						{
							Main.tile[i + 1, j - 1].frameX = 22;
							Main.tile[i + 1, j - 1].frameY = 154;
						}
						if (num4 == 2)
						{
							Main.tile[i + 1, j - 1].frameX = 22;
							Main.tile[i + 1, j - 1].frameY = 176;
						}
					}
					if (num6 == 0 || num6 == 2)
					{
						Main.tile[i - 1, j - 1].active(active: true);
						Main.tile[i - 1, j - 1].type = 5;
						Main.tile[i - 1, j - 1].color(color);
						num4 = genRand.Next(3);
						if (num4 == 0)
						{
							Main.tile[i - 1, j - 1].frameX = 44;
							Main.tile[i - 1, j - 1].frameY = 132;
						}
						if (num4 == 1)
						{
							Main.tile[i - 1, j - 1].frameX = 44;
							Main.tile[i - 1, j - 1].frameY = 154;
						}
						if (num4 == 2)
						{
							Main.tile[i - 1, j - 1].frameX = 44;
							Main.tile[i - 1, j - 1].frameY = 176;
						}
					}
					num4 = genRand.Next(3);
					switch (num6)
					{
					case 0:
						if (num4 == 0)
						{
							Main.tile[i, j - 1].frameX = 88;
							Main.tile[i, j - 1].frameY = 132;
						}
						if (num4 == 1)
						{
							Main.tile[i, j - 1].frameX = 88;
							Main.tile[i, j - 1].frameY = 154;
						}
						if (num4 == 2)
						{
							Main.tile[i, j - 1].frameX = 88;
							Main.tile[i, j - 1].frameY = 176;
						}
						break;
					case 1:
						if (num4 == 0)
						{
							Main.tile[i, j - 1].frameX = 0;
							Main.tile[i, j - 1].frameY = 132;
						}
						if (num4 == 1)
						{
							Main.tile[i, j - 1].frameX = 0;
							Main.tile[i, j - 1].frameY = 154;
						}
						if (num4 == 2)
						{
							Main.tile[i, j - 1].frameX = 0;
							Main.tile[i, j - 1].frameY = 176;
						}
						break;
					case 2:
						if (num4 == 0)
						{
							Main.tile[i, j - 1].frameX = 66;
							Main.tile[i, j - 1].frameY = 132;
						}
						if (num4 == 1)
						{
							Main.tile[i, j - 1].frameX = 66;
							Main.tile[i, j - 1].frameY = 154;
						}
						if (num4 == 2)
						{
							Main.tile[i, j - 1].frameX = 66;
							Main.tile[i, j - 1].frameY = 176;
						}
						break;
					}
					if (genRand.Next(13) != 0)
					{
						num4 = genRand.Next(3);
						if (num4 == 0)
						{
							Main.tile[i, j - num2].frameX = 22;
							Main.tile[i, j - num2].frameY = 198;
						}
						if (num4 == 1)
						{
							Main.tile[i, j - num2].frameX = 22;
							Main.tile[i, j - num2].frameY = 220;
						}
						if (num4 == 2)
						{
							Main.tile[i, j - num2].frameX = 22;
							Main.tile[i, j - num2].frameY = 242;
						}
					}
					else
					{
						num4 = genRand.Next(3);
						if (num4 == 0)
						{
							Main.tile[i, j - num2].frameX = 0;
							Main.tile[i, j - num2].frameY = 198;
						}
						if (num4 == 1)
						{
							Main.tile[i, j - num2].frameX = 0;
							Main.tile[i, j - num2].frameY = 220;
						}
						if (num4 == 2)
						{
							Main.tile[i, j - num2].frameX = 0;
							Main.tile[i, j - num2].frameY = 242;
						}
					}
					RangeFrame(i - 2, j - num2 - 1, i + 2, j + 1);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, (int)((double)j - (double)num2 * 0.5), num2 + 1);
					}
					return true;
				}
			}
			return false;
		}

		public static bool DefaultTreeWallTest(int wallType)
		{
			switch (wallType)
			{
			case 0:
			case 80:
			case 106:
			case 107:
			case 138:
			case 139:
			case 140:
			case 141:
			case 145:
			case 150:
			case 152:
			case 245:
			case 315:
				return true;
			default:
				return false;
			}
		}

		public static bool GemTreeWallTest(int wallType)
		{
			if (DefaultTreeWallTest(wallType))
			{
				return true;
			}
			switch (wallType)
			{
			case 2:
			case 54:
			case 55:
			case 56:
			case 57:
			case 58:
			case 59:
			case 61:
			case 185:
			case 196:
			case 197:
			case 198:
			case 199:
			case 208:
			case 209:
			case 210:
			case 211:
			case 212:
			case 213:
			case 214:
			case 215:
				return true;
			default:
				return false;
			}
		}

		public static bool GemTreeGroundTest(int tileType)
		{
			if (tileType < 0)
			{
				return false;
			}
			if (TileID.Sets.Conversion.Stone[tileType] || TileID.Sets.Conversion.Moss[tileType])
			{
				return true;
			}
			return false;
		}

		public static bool VanityTreeGroundTest(int tileType)
		{
			if (tileType < 0)
			{
				return false;
			}
			if (TileID.Sets.Conversion.Grass[tileType])
			{
				return true;
			}
			return false;
		}

		public static bool TryGrowingTreeByType(int treeTileType, int checkedX, int checkedY)
		{
			bool result = false;
			switch (treeTileType)
			{
			case 5:
				result = GrowTree(checkedX, checkedY);
				break;
			case 587:
				result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Ruby);
				break;
			case 588:
				result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Diamond);
				break;
			case 583:
				result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Topaz);
				break;
			case 584:
				result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Amethyst);
				break;
			case 589:
				result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Amber);
				break;
			case 586:
				result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Emerald);
				break;
			case 585:
				result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Sappphire);
				break;
			case 596:
				result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.VanityTree_Sakura);
				break;
			case 616:
				result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.VanityTree_Willow);
				break;
			}
			return result;
		}

		public static bool GrowTreeWithSettings(int checkedX, int checkedY, GrowTreeSettings settings)
		{
			int i;
			for (i = checkedY; Main.tile[checkedX, i].type == settings.SaplingTileType; i++)
			{
			}
			if (Main.tile[checkedX - 1, i - 1].liquid != 0 || Main.tile[checkedX, i - 1].liquid != 0 || Main.tile[checkedX + 1, i - 1].liquid != 0)
			{
				return false;
			}
			Tile tile = Main.tile[checkedX, i];
			if (!tile.nactive() || tile.halfBrick() || tile.slope() != 0)
			{
				return false;
			}
			bool flag = settings.WallTest(Main.tile[checkedX, i - 1].wall);
			if (!settings.GroundTest(tile.type) || !flag)
			{
				return false;
			}
			if ((!Main.tile[checkedX - 1, i].active() || !settings.GroundTest(Main.tile[checkedX - 1, i].type)) && (!Main.tile[checkedX + 1, i].active() || !settings.GroundTest(Main.tile[checkedX + 1, i].type)))
			{
				return false;
			}
			byte color = Main.tile[checkedX, i].color();
			int num = 2;
			int num2 = genRand.Next(settings.TreeHeightMin, settings.TreeHeightMax + 1);
			int num3 = num2 + settings.TreeTopPaddingNeeded;
			if (!EmptyTileCheck(checkedX - num, checkedX + num, i - num3, i - 1, 20))
			{
				return false;
			}
			bool flag2 = false;
			bool flag3 = false;
			int num4;
			for (int j = i - num2; j < i; j++)
			{
				Tile tile2 = Main.tile[checkedX, j];
				tile2.frameNumber((byte)genRand.Next(3));
				tile2.active(active: true);
				tile2.type = settings.TreeTileType;
				tile2.color(color);
				num4 = genRand.Next(3);
				int num5 = genRand.Next(10);
				if (j == i - 1 || j == i - num2)
				{
					num5 = 0;
				}
				while (((num5 == 5 || num5 == 7) && flag2) || ((num5 == 6 || num5 == 7) && flag3))
				{
					num5 = genRand.Next(10);
				}
				flag2 = false;
				flag3 = false;
				if (num5 == 5 || num5 == 7)
				{
					flag2 = true;
				}
				if (num5 == 6 || num5 == 7)
				{
					flag3 = true;
				}
				switch (num5)
				{
				case 1:
					if (num4 == 0)
					{
						tile2.frameX = 0;
						tile2.frameY = 66;
					}
					if (num4 == 1)
					{
						tile2.frameX = 0;
						tile2.frameY = 88;
					}
					if (num4 == 2)
					{
						tile2.frameX = 0;
						tile2.frameY = 110;
					}
					break;
				case 2:
					if (num4 == 0)
					{
						tile2.frameX = 22;
						tile2.frameY = 0;
					}
					if (num4 == 1)
					{
						tile2.frameX = 22;
						tile2.frameY = 22;
					}
					if (num4 == 2)
					{
						tile2.frameX = 22;
						tile2.frameY = 44;
					}
					break;
				case 3:
					if (num4 == 0)
					{
						tile2.frameX = 44;
						tile2.frameY = 66;
					}
					if (num4 == 1)
					{
						tile2.frameX = 44;
						tile2.frameY = 88;
					}
					if (num4 == 2)
					{
						tile2.frameX = 44;
						tile2.frameY = 110;
					}
					break;
				case 4:
					if (num4 == 0)
					{
						tile2.frameX = 22;
						tile2.frameY = 66;
					}
					if (num4 == 1)
					{
						tile2.frameX = 22;
						tile2.frameY = 88;
					}
					if (num4 == 2)
					{
						tile2.frameX = 22;
						tile2.frameY = 110;
					}
					break;
				case 5:
					if (num4 == 0)
					{
						tile2.frameX = 88;
						tile2.frameY = 0;
					}
					if (num4 == 1)
					{
						tile2.frameX = 88;
						tile2.frameY = 22;
					}
					if (num4 == 2)
					{
						tile2.frameX = 88;
						tile2.frameY = 44;
					}
					break;
				case 6:
					if (num4 == 0)
					{
						tile2.frameX = 66;
						tile2.frameY = 66;
					}
					if (num4 == 1)
					{
						tile2.frameX = 66;
						tile2.frameY = 88;
					}
					if (num4 == 2)
					{
						tile2.frameX = 66;
						tile2.frameY = 110;
					}
					break;
				case 7:
					if (num4 == 0)
					{
						tile2.frameX = 110;
						tile2.frameY = 66;
					}
					if (num4 == 1)
					{
						tile2.frameX = 110;
						tile2.frameY = 88;
					}
					if (num4 == 2)
					{
						tile2.frameX = 110;
						tile2.frameY = 110;
					}
					break;
				default:
					if (num4 == 0)
					{
						tile2.frameX = 0;
						tile2.frameY = 0;
					}
					if (num4 == 1)
					{
						tile2.frameX = 0;
						tile2.frameY = 22;
					}
					if (num4 == 2)
					{
						tile2.frameX = 0;
						tile2.frameY = 44;
					}
					break;
				}
				if (num5 == 5 || num5 == 7)
				{
					Tile tile3 = Main.tile[checkedX - 1, j];
					tile3.active(active: true);
					tile3.type = settings.TreeTileType;
					tile3.color(color);
					num4 = genRand.Next(3);
					if (genRand.Next(3) < 2)
					{
						if (num4 == 0)
						{
							tile3.frameX = 44;
							tile3.frameY = 198;
						}
						if (num4 == 1)
						{
							tile3.frameX = 44;
							tile3.frameY = 220;
						}
						if (num4 == 2)
						{
							tile3.frameX = 44;
							tile3.frameY = 242;
						}
					}
					else
					{
						if (num4 == 0)
						{
							tile3.frameX = 66;
							tile3.frameY = 0;
						}
						if (num4 == 1)
						{
							tile3.frameX = 66;
							tile3.frameY = 22;
						}
						if (num4 == 2)
						{
							tile3.frameX = 66;
							tile3.frameY = 44;
						}
					}
				}
				if (num5 != 6 && num5 != 7)
				{
					continue;
				}
				Tile tile4 = Main.tile[checkedX + 1, j];
				tile4.active(active: true);
				tile4.type = settings.TreeTileType;
				tile4.color(color);
				num4 = genRand.Next(3);
				if (genRand.Next(3) < 2)
				{
					if (num4 == 0)
					{
						tile4.frameX = 66;
						tile4.frameY = 198;
					}
					if (num4 == 1)
					{
						tile4.frameX = 66;
						tile4.frameY = 220;
					}
					if (num4 == 2)
					{
						tile4.frameX = 66;
						tile4.frameY = 242;
					}
				}
				else
				{
					if (num4 == 0)
					{
						tile4.frameX = 88;
						tile4.frameY = 66;
					}
					if (num4 == 1)
					{
						tile4.frameX = 88;
						tile4.frameY = 88;
					}
					if (num4 == 2)
					{
						tile4.frameX = 88;
						tile4.frameY = 110;
					}
				}
			}
			bool flag4 = false;
			bool flag5 = false;
			if (Main.tile[checkedX - 1, i].nactive() && !Main.tile[checkedX - 1, i].halfBrick() && Main.tile[checkedX - 1, i].slope() == 0 && IsTileTypeFitForTree(Main.tile[checkedX - 1, i].type))
			{
				flag4 = true;
			}
			if (Main.tile[checkedX + 1, i].nactive() && !Main.tile[checkedX + 1, i].halfBrick() && Main.tile[checkedX + 1, i].slope() == 0 && IsTileTypeFitForTree(Main.tile[checkedX + 1, i].type))
			{
				flag5 = true;
			}
			if (genRand.Next(3) == 0)
			{
				flag4 = false;
			}
			if (genRand.Next(3) == 0)
			{
				flag5 = false;
			}
			if (flag5)
			{
				Main.tile[checkedX + 1, i - 1].active(active: true);
				Main.tile[checkedX + 1, i - 1].type = settings.TreeTileType;
				Main.tile[checkedX + 1, i - 1].color(color);
				num4 = genRand.Next(3);
				if (num4 == 0)
				{
					Main.tile[checkedX + 1, i - 1].frameX = 22;
					Main.tile[checkedX + 1, i - 1].frameY = 132;
				}
				if (num4 == 1)
				{
					Main.tile[checkedX + 1, i - 1].frameX = 22;
					Main.tile[checkedX + 1, i - 1].frameY = 154;
				}
				if (num4 == 2)
				{
					Main.tile[checkedX + 1, i - 1].frameX = 22;
					Main.tile[checkedX + 1, i - 1].frameY = 176;
				}
			}
			if (flag4)
			{
				Main.tile[checkedX - 1, i - 1].active(active: true);
				Main.tile[checkedX - 1, i - 1].type = settings.TreeTileType;
				Main.tile[checkedX - 1, i - 1].color(color);
				num4 = genRand.Next(3);
				if (num4 == 0)
				{
					Main.tile[checkedX - 1, i - 1].frameX = 44;
					Main.tile[checkedX - 1, i - 1].frameY = 132;
				}
				if (num4 == 1)
				{
					Main.tile[checkedX - 1, i - 1].frameX = 44;
					Main.tile[checkedX - 1, i - 1].frameY = 154;
				}
				if (num4 == 2)
				{
					Main.tile[checkedX - 1, i - 1].frameX = 44;
					Main.tile[checkedX - 1, i - 1].frameY = 176;
				}
			}
			num4 = genRand.Next(3);
			if (flag4 && flag5)
			{
				if (num4 == 0)
				{
					Main.tile[checkedX, i - 1].frameX = 88;
					Main.tile[checkedX, i - 1].frameY = 132;
				}
				if (num4 == 1)
				{
					Main.tile[checkedX, i - 1].frameX = 88;
					Main.tile[checkedX, i - 1].frameY = 154;
				}
				if (num4 == 2)
				{
					Main.tile[checkedX, i - 1].frameX = 88;
					Main.tile[checkedX, i - 1].frameY = 176;
				}
			}
			else if (flag4)
			{
				if (num4 == 0)
				{
					Main.tile[checkedX, i - 1].frameX = 0;
					Main.tile[checkedX, i - 1].frameY = 132;
				}
				if (num4 == 1)
				{
					Main.tile[checkedX, i - 1].frameX = 0;
					Main.tile[checkedX, i - 1].frameY = 154;
				}
				if (num4 == 2)
				{
					Main.tile[checkedX, i - 1].frameX = 0;
					Main.tile[checkedX, i - 1].frameY = 176;
				}
			}
			else if (flag5)
			{
				if (num4 == 0)
				{
					Main.tile[checkedX, i - 1].frameX = 66;
					Main.tile[checkedX, i - 1].frameY = 132;
				}
				if (num4 == 1)
				{
					Main.tile[checkedX, i - 1].frameX = 66;
					Main.tile[checkedX, i - 1].frameY = 154;
				}
				if (num4 == 2)
				{
					Main.tile[checkedX, i - 1].frameX = 66;
					Main.tile[checkedX, i - 1].frameY = 176;
				}
			}
			if (genRand.Next(13) != 0)
			{
				num4 = genRand.Next(3);
				if (num4 == 0)
				{
					Main.tile[checkedX, i - num2].frameX = 22;
					Main.tile[checkedX, i - num2].frameY = 198;
				}
				if (num4 == 1)
				{
					Main.tile[checkedX, i - num2].frameX = 22;
					Main.tile[checkedX, i - num2].frameY = 220;
				}
				if (num4 == 2)
				{
					Main.tile[checkedX, i - num2].frameX = 22;
					Main.tile[checkedX, i - num2].frameY = 242;
				}
			}
			else
			{
				num4 = genRand.Next(3);
				if (num4 == 0)
				{
					Main.tile[checkedX, i - num2].frameX = 0;
					Main.tile[checkedX, i - num2].frameY = 198;
				}
				if (num4 == 1)
				{
					Main.tile[checkedX, i - num2].frameX = 0;
					Main.tile[checkedX, i - num2].frameY = 220;
				}
				if (num4 == 2)
				{
					Main.tile[checkedX, i - num2].frameX = 0;
					Main.tile[checkedX, i - num2].frameY = 242;
				}
			}
			RangeFrame(checkedX - 2, i - num2 - 1, checkedX + 2, i + 1);
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, checkedX, (int)((double)i - (double)num2 * 0.5), num2 + 1);
			}
			return true;
		}

		public static void GrowUndergroundTree(int i, int y)
		{
			if (Main.tile[i, y].type != 60 || !Main.tile[i, y].nactive() || Main.tile[i, y].halfBrick() || Main.tile[i, y].slope() != 0 || Main.tile[i, y].type != 60 || ((!Main.tile[i - 1, y].active() || Main.tile[i - 1, y].type != 60) && (!Main.tile[i + 1, y].active() || Main.tile[i + 1, y].type != 60)))
			{
				return;
			}
			int num = 1;
			int num2 = genRand.Next(5, 15);
			int num3 = num2 + 2;
			if (Main.tile[i, y].type == 60)
			{
				num3 += 5;
			}
			if (!EmptyTileCheck(i - num, i + num, y - num3, y - 1, 20))
			{
				return;
			}
			bool flag = false;
			bool flag2 = false;
			int num4;
			for (int j = y - num2; j < y; j++)
			{
				Main.tile[i, j].frameNumber((byte)genRand.Next(3));
				Main.tile[i, j].active(active: true);
				Main.tile[i, j].type = 5;
				num4 = genRand.Next(3);
				int num5 = genRand.Next(10);
				if (j == y - 1 || j == y - num2)
				{
					num5 = 0;
				}
				while (((num5 == 5 || num5 == 7) && flag) || ((num5 == 6 || num5 == 7) && flag2))
				{
					num5 = genRand.Next(10);
				}
				flag = false;
				flag2 = false;
				if (num5 == 5 || num5 == 7)
				{
					flag = true;
				}
				if (num5 == 6 || num5 == 7)
				{
					flag2 = true;
				}
				switch (num5)
				{
				case 1:
					if (num4 == 0)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 66;
					}
					if (num4 == 1)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 88;
					}
					if (num4 == 2)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 110;
					}
					break;
				case 2:
					if (num4 == 0)
					{
						Main.tile[i, j].frameX = 22;
						Main.tile[i, j].frameY = 0;
					}
					if (num4 == 1)
					{
						Main.tile[i, j].frameX = 22;
						Main.tile[i, j].frameY = 22;
					}
					if (num4 == 2)
					{
						Main.tile[i, j].frameX = 22;
						Main.tile[i, j].frameY = 44;
					}
					break;
				case 3:
					if (num4 == 0)
					{
						Main.tile[i, j].frameX = 44;
						Main.tile[i, j].frameY = 66;
					}
					if (num4 == 1)
					{
						Main.tile[i, j].frameX = 44;
						Main.tile[i, j].frameY = 88;
					}
					if (num4 == 2)
					{
						Main.tile[i, j].frameX = 44;
						Main.tile[i, j].frameY = 110;
					}
					break;
				case 4:
					if (num4 == 0)
					{
						Main.tile[i, j].frameX = 22;
						Main.tile[i, j].frameY = 66;
					}
					if (num4 == 1)
					{
						Main.tile[i, j].frameX = 22;
						Main.tile[i, j].frameY = 88;
					}
					if (num4 == 2)
					{
						Main.tile[i, j].frameX = 22;
						Main.tile[i, j].frameY = 110;
					}
					break;
				case 5:
					if (num4 == 0)
					{
						Main.tile[i, j].frameX = 88;
						Main.tile[i, j].frameY = 0;
					}
					if (num4 == 1)
					{
						Main.tile[i, j].frameX = 88;
						Main.tile[i, j].frameY = 22;
					}
					if (num4 == 2)
					{
						Main.tile[i, j].frameX = 88;
						Main.tile[i, j].frameY = 44;
					}
					break;
				case 6:
					if (num4 == 0)
					{
						Main.tile[i, j].frameX = 66;
						Main.tile[i, j].frameY = 66;
					}
					if (num4 == 1)
					{
						Main.tile[i, j].frameX = 66;
						Main.tile[i, j].frameY = 88;
					}
					if (num4 == 2)
					{
						Main.tile[i, j].frameX = 66;
						Main.tile[i, j].frameY = 110;
					}
					break;
				case 7:
					if (num4 == 0)
					{
						Main.tile[i, j].frameX = 110;
						Main.tile[i, j].frameY = 66;
					}
					if (num4 == 1)
					{
						Main.tile[i, j].frameX = 110;
						Main.tile[i, j].frameY = 88;
					}
					if (num4 == 2)
					{
						Main.tile[i, j].frameX = 110;
						Main.tile[i, j].frameY = 110;
					}
					break;
				default:
					if (num4 == 0)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 0;
					}
					if (num4 == 1)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 22;
					}
					if (num4 == 2)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 44;
					}
					break;
				}
				if (num5 == 5 || num5 == 7)
				{
					Main.tile[i - 1, j].active(active: true);
					Main.tile[i - 1, j].type = 5;
					num4 = genRand.Next(3);
					if (genRand.Next(3) < 2)
					{
						if (num4 == 0)
						{
							Main.tile[i - 1, j].frameX = 44;
							Main.tile[i - 1, j].frameY = 198;
						}
						if (num4 == 1)
						{
							Main.tile[i - 1, j].frameX = 44;
							Main.tile[i - 1, j].frameY = 220;
						}
						if (num4 == 2)
						{
							Main.tile[i - 1, j].frameX = 44;
							Main.tile[i - 1, j].frameY = 242;
						}
					}
					else
					{
						if (num4 == 0)
						{
							Main.tile[i - 1, j].frameX = 66;
							Main.tile[i - 1, j].frameY = 0;
						}
						if (num4 == 1)
						{
							Main.tile[i - 1, j].frameX = 66;
							Main.tile[i - 1, j].frameY = 22;
						}
						if (num4 == 2)
						{
							Main.tile[i - 1, j].frameX = 66;
							Main.tile[i - 1, j].frameY = 44;
						}
					}
				}
				if (num5 != 6 && num5 != 7)
				{
					continue;
				}
				Main.tile[i + 1, j].active(active: true);
				Main.tile[i + 1, j].type = 5;
				num4 = genRand.Next(3);
				if (genRand.Next(3) < 2)
				{
					if (num4 == 0)
					{
						Main.tile[i + 1, j].frameX = 66;
						Main.tile[i + 1, j].frameY = 198;
					}
					if (num4 == 1)
					{
						Main.tile[i + 1, j].frameX = 66;
						Main.tile[i + 1, j].frameY = 220;
					}
					if (num4 == 2)
					{
						Main.tile[i + 1, j].frameX = 66;
						Main.tile[i + 1, j].frameY = 242;
					}
				}
				else
				{
					if (num4 == 0)
					{
						Main.tile[i + 1, j].frameX = 88;
						Main.tile[i + 1, j].frameY = 66;
					}
					if (num4 == 1)
					{
						Main.tile[i + 1, j].frameX = 88;
						Main.tile[i + 1, j].frameY = 88;
					}
					if (num4 == 2)
					{
						Main.tile[i + 1, j].frameX = 88;
						Main.tile[i + 1, j].frameY = 110;
					}
				}
			}
			int num6 = genRand.Next(3);
			bool flag3 = false;
			bool flag4 = false;
			if (Main.tile[i - 1, y].nactive() && !Main.tile[i - 1, y].halfBrick() && Main.tile[i - 1, y].slope() == 0 && (Main.tile[i - 1, y].type == 2 || Main.tile[i - 1, y].type == 23 || Main.tile[i - 1, y].type == 60 || Main.tile[i - 1, y].type == 109 || Main.tile[i - 1, y].type == 147))
			{
				flag3 = true;
			}
			if (Main.tile[i + 1, y].nactive() && !Main.tile[i + 1, y].halfBrick() && Main.tile[i + 1, y].slope() == 0 && (Main.tile[i + 1, y].type == 2 || Main.tile[i + 1, y].type == 23 || Main.tile[i + 1, y].type == 60 || Main.tile[i + 1, y].type == 109 || Main.tile[i + 1, y].type == 147))
			{
				flag4 = true;
			}
			if (!flag3)
			{
				if (num6 == 0)
				{
					num6 = 2;
				}
				if (num6 == 1)
				{
					num6 = 3;
				}
			}
			if (!flag4)
			{
				if (num6 == 0)
				{
					num6 = 1;
				}
				if (num6 == 2)
				{
					num6 = 3;
				}
			}
			if (flag3 && !flag4)
			{
				num6 = 2;
			}
			if (flag4 && !flag3)
			{
				num6 = 1;
			}
			if (num6 == 0 || num6 == 1)
			{
				Main.tile[i + 1, y - 1].active(active: true);
				Main.tile[i + 1, y - 1].type = 5;
				num4 = genRand.Next(3);
				if (num4 == 0)
				{
					Main.tile[i + 1, y - 1].frameX = 22;
					Main.tile[i + 1, y - 1].frameY = 132;
				}
				if (num4 == 1)
				{
					Main.tile[i + 1, y - 1].frameX = 22;
					Main.tile[i + 1, y - 1].frameY = 154;
				}
				if (num4 == 2)
				{
					Main.tile[i + 1, y - 1].frameX = 22;
					Main.tile[i + 1, y - 1].frameY = 176;
				}
			}
			if (num6 == 0 || num6 == 2)
			{
				Main.tile[i - 1, y - 1].active(active: true);
				Main.tile[i - 1, y - 1].type = 5;
				num4 = genRand.Next(3);
				if (num4 == 0)
				{
					Main.tile[i - 1, y - 1].frameX = 44;
					Main.tile[i - 1, y - 1].frameY = 132;
				}
				if (num4 == 1)
				{
					Main.tile[i - 1, y - 1].frameX = 44;
					Main.tile[i - 1, y - 1].frameY = 154;
				}
				if (num4 == 2)
				{
					Main.tile[i - 1, y - 1].frameX = 44;
					Main.tile[i - 1, y - 1].frameY = 176;
				}
			}
			num4 = genRand.Next(3);
			switch (num6)
			{
			case 0:
				if (num4 == 0)
				{
					Main.tile[i, y - 1].frameX = 88;
					Main.tile[i, y - 1].frameY = 132;
				}
				if (num4 == 1)
				{
					Main.tile[i, y - 1].frameX = 88;
					Main.tile[i, y - 1].frameY = 154;
				}
				if (num4 == 2)
				{
					Main.tile[i, y - 1].frameX = 88;
					Main.tile[i, y - 1].frameY = 176;
				}
				break;
			case 1:
				if (num4 == 0)
				{
					Main.tile[i, y - 1].frameX = 0;
					Main.tile[i, y - 1].frameY = 132;
				}
				if (num4 == 1)
				{
					Main.tile[i, y - 1].frameX = 0;
					Main.tile[i, y - 1].frameY = 154;
				}
				if (num4 == 2)
				{
					Main.tile[i, y - 1].frameX = 0;
					Main.tile[i, y - 1].frameY = 176;
				}
				break;
			case 2:
				if (num4 == 0)
				{
					Main.tile[i, y - 1].frameX = 66;
					Main.tile[i, y - 1].frameY = 132;
				}
				if (num4 == 1)
				{
					Main.tile[i, y - 1].frameX = 66;
					Main.tile[i, y - 1].frameY = 154;
				}
				if (num4 == 2)
				{
					Main.tile[i, y - 1].frameX = 66;
					Main.tile[i, y - 1].frameY = 176;
				}
				break;
			}
			if (genRand.Next(8) != 0)
			{
				num4 = genRand.Next(3);
				if (num4 == 0)
				{
					Main.tile[i, y - num2].frameX = 22;
					Main.tile[i, y - num2].frameY = 198;
				}
				if (num4 == 1)
				{
					Main.tile[i, y - num2].frameX = 22;
					Main.tile[i, y - num2].frameY = 220;
				}
				if (num4 == 2)
				{
					Main.tile[i, y - num2].frameX = 22;
					Main.tile[i, y - num2].frameY = 242;
				}
			}
			else
			{
				num4 = genRand.Next(3);
				if (num4 == 0)
				{
					Main.tile[i, y - num2].frameX = 0;
					Main.tile[i, y - num2].frameY = 198;
				}
				if (num4 == 1)
				{
					Main.tile[i, y - num2].frameX = 0;
					Main.tile[i, y - num2].frameY = 220;
				}
				if (num4 == 2)
				{
					Main.tile[i, y - num2].frameX = 0;
					Main.tile[i, y - num2].frameY = 242;
				}
			}
			RangeFrame(i - 2, y - num2 - 1, i + 2, y + 1);
			if (Main.netMode == 2 && !gen)
			{
				NetMessage.SendTileSquare(-1, i, (int)((double)y - (double)num2 * 0.5), num2 + 1);
			}
		}

		public static bool GrowShroom(int i, int y)
		{
			if (Main.tile[i - 1, y - 1].lava() || Main.tile[i - 1, y - 1].lava() || Main.tile[i + 1, y - 1].lava())
			{
				return false;
			}
			if (Main.tile[i, y].nactive() && Main.tile[i, y].type == 70 && Main.tile[i, y - 1].wall == 0 && Main.tile[i - 1, y].active() && Main.tile[i - 1, y].type == 70 && Main.tile[i + 1, y].active() && Main.tile[i + 1, y].type == 70 && EmptyTileCheck(i - 2, i + 2, y - 13, y - 3, 71) && EmptyTileCheck(i - 1, i + 1, y - 3, y - 1, 71))
			{
				if (gen && genRand.Next(3) != 0)
				{
					Main.tile[i, y].halfBrick(halfBrick: false);
					Main.tile[i, y].slope(0);
				}
				if (!Main.tile[i, y].halfBrick() && Main.tile[i, y].slope() == 0)
				{
					int num = genRand.Next(4, 11);
					for (int j = y - num; j < y; j++)
					{
						Main.tile[i, j].frameNumber((byte)genRand.Next(3));
						Main.tile[i, j].active(active: true);
						Main.tile[i, j].type = 72;
						int num2 = genRand.Next(3);
						if (num2 == 0)
						{
							Main.tile[i, j].frameX = 0;
							Main.tile[i, j].frameY = 0;
						}
						if (num2 == 1)
						{
							Main.tile[i, j].frameX = 0;
							Main.tile[i, j].frameY = 18;
						}
						if (num2 == 2)
						{
							Main.tile[i, j].frameX = 0;
							Main.tile[i, j].frameY = 36;
						}
					}
					int num3 = genRand.Next(3);
					if (num3 == 0)
					{
						Main.tile[i, y - num].frameX = 36;
						Main.tile[i, y - num].frameY = 0;
					}
					if (num3 == 1)
					{
						Main.tile[i, y - num].frameX = 36;
						Main.tile[i, y - num].frameY = 18;
					}
					if (num3 == 2)
					{
						Main.tile[i, y - num].frameX = 36;
						Main.tile[i, y - num].frameY = 36;
					}
					RangeFrame(i - 2, y - num - 1, i + 2, y + 1);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, (int)((double)y - (double)num * 0.5), num + 1);
					}
					return true;
				}
			}
			return false;
		}

		public static void AddTrees()
		{
			float num = 0.1f + genRand.NextFloat() * 0.35f;
			float num2 = 0.1f + genRand.NextFloat() * 0.35f;
			for (int i = 1; i < Main.maxTilesX - 1; i++)
			{
				for (int j = 20; (double)j < Main.worldSurface; j++)
				{
					if (i < 380)
					{
						if (genRand.NextFloat() < num && Main.tile[i, j].liquid == 0)
						{
							GrowPalmTree(i, j);
						}
					}
					else if (i > Main.maxTilesX - 380 && genRand.NextFloat() < num2 && Main.tile[i, j].liquid == 0)
					{
						GrowPalmTree(i, j);
					}
					int num3 = 20;
					if (drunkWorldGen)
					{
						num3 /= 3;
					}
					if (Main.tile[i, j].type == 2 && genRand.Next(num3) == 0)
					{
						if (genRand.Next(2) == 0)
						{
							GrowTreeWithSettings(i, j, GrowTreeSettings.Profiles.VanityTree_Willow);
						}
						else
						{
							GrowTreeWithSettings(i, j, GrowTreeSettings.Profiles.VanityTree_Sakura);
						}
					}
					else
					{
						GrowTree(i, j);
					}
				}
				if (genRand.Next(3) == 0)
				{
					i++;
				}
				if (genRand.Next(4) == 0)
				{
					i++;
				}
			}
		}

		public static void ExplodeMine(int i, int j)
		{
			_ = Main.tile[i, j].type;
			KillTile(i, j, fail: false, effectOnly: false, noItem: true);
			NetMessage.SendTileSquare(-1, i, j, 1);
			Projectile.NewProjectile(i * 16 + 8, j * 16 + 8, 0f, 0f, 164, 250, 10f, Main.myPlayer);
		}

		public static bool EmptyTileCheck(int startX, int endX, int startY, int endY, int ignoreID = -1)
		{
			if (startX < 0)
			{
				return false;
			}
			if (endX >= Main.maxTilesX)
			{
				return false;
			}
			if (startY < 0)
			{
				return false;
			}
			if (endY >= Main.maxTilesY)
			{
				return false;
			}
			bool flag = false;
			if (ignoreID != -1 && TileID.Sets.CommonSapling[ignoreID])
			{
				flag = true;
			}
			for (int i = startX; i < endX + 1; i++)
			{
				for (int j = startY; j < endY + 1; j++)
				{
					if (!Main.tile[i, j].active())
					{
						continue;
					}
					switch (ignoreID)
					{
					case -1:
						return false;
					case 11:
					{
						ushort type = Main.tile[i, j].type;
						if (type == 11)
						{
							continue;
						}
						return false;
					}
					case 71:
					{
						ushort type = Main.tile[i, j].type;
						if (type == 71)
						{
							continue;
						}
						return false;
					}
					}
					if (flag)
					{
						if (TileID.Sets.CommonSapling[Main.tile[i, j].type])
						{
							break;
						}
						switch (Main.tile[i, j].type)
						{
						case 3:
						case 24:
						case 32:
						case 61:
						case 62:
						case 69:
						case 71:
						case 73:
						case 74:
						case 82:
						case 83:
						case 84:
						case 110:
						case 113:
						case 201:
						case 233:
						case 352:
						case 485:
						case 529:
						case 530:
							continue;
						}
						return false;
					}
				}
			}
			return true;
		}

		public static void StartHardmode()
		{
			if (Main.netMode != 1 && !Main.hardMode)
			{
				Main.hardMode = true;
				ThreadPool.QueueUserWorkItem(smCallBack, 1);
			}
		}

		public static void smCallBack(object threadContext)
		{
			IsGeneratingHardMode = true;
			if (Main.rand == null)
			{
				Main.rand = new UnifiedRandom((int)DateTime.Now.Ticks);
			}
			float num = (float)genRand.Next(300, 400) * 0.001f;
			float num2 = (float)genRand.Next(200, 300) * 0.001f;
			int num3 = (int)((float)Main.maxTilesX * num);
			int num4 = (int)((float)Main.maxTilesX * (1f - num));
			int num5 = 1;
			if (genRand.Next(2) == 0)
			{
				num4 = (int)((float)Main.maxTilesX * num);
				num3 = (int)((float)Main.maxTilesX * (1f - num));
				num5 = -1;
			}
			int num6 = 1;
			if (dungeonX < Main.maxTilesX / 2)
			{
				num6 = -1;
			}
			if (num6 < 0)
			{
				if (num4 < num3)
				{
					num4 = (int)((float)Main.maxTilesX * num2);
				}
				else
				{
					num3 = (int)((float)Main.maxTilesX * num2);
				}
			}
			else if (num4 > num3)
			{
				num4 = (int)((float)Main.maxTilesX * (1f - num2));
			}
			else
			{
				num3 = (int)((float)Main.maxTilesX * (1f - num2));
			}
			GERunner(num3, 0, 3 * num5, 5f);
			GERunner(num4, 0, 3 * -num5, 5f, good: false);
			float num7 = (float)Main.maxTilesX / 4200f;
			int num8 = (int)(25f * num7);
			ShapeData shapeData = new ShapeData();
			int num9 = 0;
			while (num8 > 0)
			{
				if (++num9 % 15000 == 0)
				{
					num8--;
				}
				Point point = RandomWorldPoint((int)Main.worldSurface - 100, 1, 190, 1);
				Tile tile = Main.tile[point.X, point.Y];
				Tile tile2 = Main.tile[point.X, point.Y - 1];
				ushort num10 = 0;
				if (TileID.Sets.Crimson[tile.type])
				{
					num10 = (ushort)(192 + genRand.Next(4));
				}
				else if (TileID.Sets.Corrupt[tile.type])
				{
					num10 = (ushort)(188 + genRand.Next(4));
				}
				else if (TileID.Sets.Hallow[tile.type])
				{
					num10 = (ushort)(200 + genRand.Next(4));
				}
				if (tile.active() && num10 != 0 && !tile2.active())
				{
					bool flag = WorldUtils.Gen(new Point(point.X, point.Y - 1), new ShapeFloodFill(1000), Actions.Chain(new Modifiers.IsNotSolid(), new Modifiers.OnlyWalls(0, 54, 55, 56, 57, 58, 59, 61, 185, 212, 213, 214, 215, 2, 196, 197, 198, 199, 15, 40, 71, 64, 204, 205, 206, 207, 208, 209, 210, 211, 71), new Actions.Blank().Output(shapeData)));
					if (shapeData.Count > 50 && flag)
					{
						WorldUtils.Gen(new Point(point.X, point.Y), new ModShapes.OuterOutline(shapeData, useDiagonals: true, useInterior: true), new Actions.PlaceWall(num10));
						num8--;
					}
					shapeData.Clear();
				}
			}
			if (Main.netMode == 0)
			{
				Main.NewText(Lang.misc[15].Value, 50, byte.MaxValue, 130);
			}
			else if (Main.netMode == 2)
			{
				ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[15].Key), new Color(50, 255, 130));
			}
			AchievementsHelper.NotifyProgressionEvent(9);
			if (Main.netMode == 2)
			{
				Netplay.ResetSections();
			}
			IsGeneratingHardMode = false;
		}

		public static bool PlaceDoor(int i, int j, int type, int style = 0)
		{
			int num = style / 36;
			int num2 = style % 36;
			int num3 = 54 * num;
			int num4 = 54 * num2;
			try
			{
				if (Main.tile[i, j - 2].nactive() && Main.tileSolid[Main.tile[i, j - 2].type] && SolidTile(i, j + 2))
				{
					Main.tile[i, j - 1].active(active: true);
					Main.tile[i, j - 1].type = 10;
					Main.tile[i, j - 1].frameY = (short)num4;
					Main.tile[i, j - 1].frameX = (short)(num3 + genRand.Next(3) * 18);
					Main.tile[i, j].active(active: true);
					Main.tile[i, j].type = 10;
					Main.tile[i, j].frameY = (short)(num4 + 18);
					Main.tile[i, j].frameX = (short)(num3 + genRand.Next(3) * 18);
					Main.tile[i, j + 1].active(active: true);
					Main.tile[i, j + 1].type = 10;
					Main.tile[i, j + 1].frameY = (short)(num4 + 36);
					Main.tile[i, j + 1].frameX = (short)(num3 + genRand.Next(3) * 18);
					return true;
				}
				return false;
			}
			catch
			{
				return false;
			}
		}

		public static bool CloseDoor(int i, int j, bool forced = false)
		{
			int num = 0;
			int num2 = i;
			int num3 = j;
			if (Main.tile[i, j] == null)
			{
				Main.tile[i, j] = new Tile();
			}
			int frameX = Main.tile[i, j].frameX;
			Tile tile = Main.tile[i, j];
			if (tile.type != 11)
			{
				return false;
			}
			int num4 = tile.frameY;
			int num5 = 0;
			int num6 = 0;
			while (num4 >= 54)
			{
				num4 -= 54;
				num5++;
			}
			if (frameX >= 72)
			{
				num5 += 36 * (frameX / 72);
				num6 += 54 * (frameX / 72);
			}
			num3 = j - num4 / 18;
			switch (frameX % 72)
			{
			case 0:
				num2 = i;
				num = 1;
				break;
			case 18:
				num2 = i - 1;
				num = 1;
				break;
			case 36:
				num2 = i + 1;
				num = -1;
				break;
			case 54:
				num2 = i;
				num = -1;
				break;
			}
			int num7 = num2;
			if (num == -1)
			{
				num7 = num2 - 1;
			}
			if (!forced)
			{
				for (int k = num3; k < num3 + 3; k++)
				{
					if (!Collision.EmptyTile(num2, k, ignoreTiles: true))
					{
						return false;
					}
				}
			}
			for (int l = num7; l < num7 + 2; l++)
			{
				for (int m = num3; m < num3 + 3; m++)
				{
					if (l == num2)
					{
						if (Main.tile[l, m] == null)
						{
							Main.tile[l, m] = new Tile();
						}
						Main.tile[l, m].type = 10;
						Main.tile[l, m].frameX = (short)(genRand.Next(3) * 18 + num6);
					}
					else
					{
						if (Main.tile[l, m] == null)
						{
							Main.tile[l, m] = new Tile();
						}
						Main.tile[l, m].active(active: false);
					}
				}
			}
			if (Main.netMode != 1 && Wiring.running)
			{
				Wiring.SkipWire(num2, num3);
				Wiring.SkipWire(num2, num3 + 1);
				Wiring.SkipWire(num2, num3 + 2);
			}
			for (int n = num2 - 1; n <= num2 + 1; n++)
			{
				for (int num8 = num3 - 1; num8 <= num3 + 2; num8++)
				{
					TileFrame(n, num8);
				}
			}
			SoundEngine.PlaySound(9, i * 16, j * 16);
			return true;
		}

		public static bool AddLifeCrystal(int i, int j)
		{
			for (int k = j; k < Main.maxTilesY; k++)
			{
				if (Main.tile[i, k].active() && Main.tileSolid[Main.tile[i, k].type])
				{
					int num = k - 1;
					if (Main.tile[i, num - 1].lava() || Main.tile[i - 1, num - 1].lava())
					{
						return false;
					}
					if (!EmptyTileCheck(i - 1, i, num - 1, num))
					{
						return false;
					}
					if (Main.wallDungeon[Main.tile[i, num].wall])
					{
						return false;
					}
					Tile tile = Main.tile[i - 1, num + 1];
					Tile tile2 = Main.tile[i, num + 1];
					if (!tile.nactive() || !Main.tileSolid[tile.type])
					{
						return false;
					}
					if (!tile2.nactive() || !Main.tileSolid[tile2.type])
					{
						return false;
					}
					if (tile.blockType() != 0)
					{
						tile.slope(0);
						tile.halfBrick(halfBrick: false);
					}
					if (tile2.blockType() != 0)
					{
						tile2.slope(0);
						tile2.halfBrick(halfBrick: false);
					}
					Main.tile[i - 1, num - 1].active(active: true);
					Main.tile[i - 1, num - 1].type = 12;
					Main.tile[i - 1, num - 1].frameX = 0;
					Main.tile[i - 1, num - 1].frameY = 0;
					Main.tile[i, num - 1].active(active: true);
					Main.tile[i, num - 1].type = 12;
					Main.tile[i, num - 1].frameX = 18;
					Main.tile[i, num - 1].frameY = 0;
					Main.tile[i - 1, num].active(active: true);
					Main.tile[i - 1, num].type = 12;
					Main.tile[i - 1, num].frameX = 0;
					Main.tile[i - 1, num].frameY = 18;
					Main.tile[i, num].active(active: true);
					Main.tile[i, num].type = 12;
					Main.tile[i, num].frameX = 18;
					Main.tile[i, num].frameY = 18;
					return true;
				}
			}
			return false;
		}

		public static void AddShadowOrb(int x, int y)
		{
			if (x < 10 || x > Main.maxTilesX - 10 || y < 10 || y > Main.maxTilesY - 10)
			{
				return;
			}
			for (int i = x - 1; i < x + 1; i++)
			{
				for (int j = y - 1; j < y + 1; j++)
				{
					if (Main.tile[i, j].active() && Main.tile[i, j].type == 31)
					{
						return;
					}
				}
			}
			short num = 0;
			if (crimson)
			{
				num = (short)(num + 36);
			}
			Main.tile[x - 1, y - 1].active(active: true);
			Main.tile[x - 1, y - 1].type = 31;
			Main.tile[x - 1, y - 1].frameX = num;
			Main.tile[x - 1, y - 1].frameY = 0;
			Main.tile[x, y - 1].active(active: true);
			Main.tile[x, y - 1].type = 31;
			Main.tile[x, y - 1].frameX = (short)(18 + num);
			Main.tile[x, y - 1].frameY = 0;
			Main.tile[x - 1, y].active(active: true);
			Main.tile[x - 1, y].type = 31;
			Main.tile[x - 1, y].frameX = num;
			Main.tile[x - 1, y].frameY = 18;
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].type = 31;
			Main.tile[x, y].frameX = (short)(18 + num);
			Main.tile[x, y].frameY = 18;
		}

		public static void AddHellHouses()
		{
			int num = (int)((double)Main.maxTilesX * 0.25);
			for (int i = 100; i < Main.maxTilesX - 100; i++)
			{
				if ((drunkWorldGen && i > num && i < Main.maxTilesX - num) || (!drunkWorldGen && (i < num || i > Main.maxTilesX - num)))
				{
					continue;
				}
				int num2 = Main.maxTilesY - 40;
				while (Main.tile[i, num2].active() || Main.tile[i, num2].liquid > 0)
				{
					num2--;
				}
				if (Main.tile[i, num2 + 1].active())
				{
					ushort num3 = (ushort)genRand.Next(75, 77);
					byte wallType = 13;
					if (genRand.Next(5) > 0)
					{
						num3 = 75;
					}
					if (num3 == 75)
					{
						wallType = 14;
					}
					if (getGoodWorldGen)
					{
						num3 = 76;
					}
					HellFort(i, num2, num3, wallType);
					i += genRand.Next(30, 130);
					if (genRand.Next(10) == 0)
					{
						i += genRand.Next(0, 200);
					}
				}
			}
			float num4 = Main.maxTilesX / 4200;
			for (int j = 0; (float)j < 200f * num4; j++)
			{
				int num5 = 0;
				bool flag = false;
				while (!flag)
				{
					num5++;
					int num6 = genRand.Next((int)((double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.8));
					int num7 = genRand.Next(Main.maxTilesY - 300, Main.maxTilesY - 20);
					if (Main.tile[num6, num7].active() && (Main.tile[num6, num7].type == 75 || Main.tile[num6, num7].type == 76))
					{
						int num8 = 0;
						if (Main.tile[num6 - 1, num7].wall > 0)
						{
							num8 = -1;
						}
						else if (Main.tile[num6 + 1, num7].wall > 0)
						{
							num8 = 1;
						}
						if (!Main.tile[num6 + num8, num7].active() && !Main.tile[num6 + num8, num7 + 1].active())
						{
							bool flag2 = false;
							for (int k = num6 - 8; k < num6 + 8; k++)
							{
								for (int l = num7 - 8; l < num7 + 8; l++)
								{
									if (Main.tile[k, l].active() && Main.tile[k, l].type == 4)
									{
										flag2 = true;
										break;
									}
								}
							}
							if (!flag2)
							{
								PlaceTile(num6 + num8, num7, 4, mute: true, forced: true, -1, 7);
								flag = true;
							}
						}
					}
					if (num5 > 1000)
					{
						flag = true;
					}
				}
			}
			float num9 = 4200000f / (float)Main.maxTilesX;
			for (int m = 0; (float)m < num9; m++)
			{
				int num10 = 0;
				int num11 = genRand.Next(num, Main.maxTilesX - num);
				int n = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
				while ((Main.tile[num11, n].wall != 13 && Main.tile[num11, n].wall != 14) || Main.tile[num11, n].active())
				{
					num11 = genRand.Next(num, Main.maxTilesX - num);
					n = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
					if (drunkWorldGen)
					{
						num11 = ((genRand.Next(2) != 0) ? genRand.Next(Main.maxTilesX - num, Main.maxTilesX - 50) : genRand.Next(50, num));
					}
					num10++;
					if (num10 > 100000)
					{
						break;
					}
				}
				if (num10 > 100000 || (Main.tile[num11, n].wall != 13 && Main.tile[num11, n].wall != 14) || Main.tile[num11, n].active())
				{
					continue;
				}
				for (; !SolidTile(num11, n) && n < Main.maxTilesY - 20; n++)
				{
				}
				n--;
				int num12 = num11;
				int num13 = num11;
				while (!Main.tile[num12, n].active() && SolidTile(num12, n + 1))
				{
					num12--;
				}
				num12++;
				for (; !Main.tile[num13, n].active() && SolidTile(num13, n + 1); num13++)
				{
				}
				num13--;
				int num14 = num13 - num12;
				int num15 = (num13 + num12) / 2;
				if (Main.tile[num15, n].active() || (Main.tile[num15, n].wall != 13 && Main.tile[num15, n].wall != 14) || !SolidTile(num15, n + 1))
				{
					continue;
				}
				int style = 16;
				int style2 = 13;
				int style3 = 14;
				int style4 = 49;
				int style5 = 4;
				int style6 = 8;
				int style7 = 15;
				int style8 = 9;
				int style9 = 10;
				int style10 = 17;
				int style11 = 25;
				int style12 = 25;
				int style13 = 23;
				int style14 = 25;
				int num16 = genRand.Next(13);
				int num17 = 0;
				int num18 = 0;
				if (num16 == 0)
				{
					num17 = 5;
					num18 = 4;
				}
				if (num16 == 1)
				{
					num17 = 4;
					num18 = 3;
				}
				if (num16 == 2)
				{
					num17 = 3;
					num18 = 5;
				}
				if (num16 == 3)
				{
					num17 = 4;
					num18 = 6;
				}
				if (num16 == 4)
				{
					num17 = 3;
					num18 = 3;
				}
				if (num16 == 5)
				{
					num17 = 5;
					num18 = 3;
				}
				if (num16 == 6)
				{
					num17 = 5;
					num18 = 4;
				}
				if (num16 == 7)
				{
					num17 = 5;
					num18 = 4;
				}
				if (num16 == 8)
				{
					num17 = 5;
					num18 = 4;
				}
				if (num16 == 9)
				{
					num17 = 3;
					num18 = 5;
				}
				if (num16 == 10)
				{
					num17 = 5;
					num18 = 3;
				}
				if (num16 == 11)
				{
					num17 = 2;
					num18 = 4;
				}
				if (num16 == 12)
				{
					num17 = 3;
					num18 = 3;
				}
				for (int num19 = num15 - num17; num19 <= num15 + num17; num19++)
				{
					for (int num20 = n - num18; num20 <= n; num20++)
					{
						if (Main.tile[num19, num20].active())
						{
							num16 = -1;
							break;
						}
					}
				}
				if ((double)num14 < (double)num17 * 1.75)
				{
					num16 = -1;
				}
				switch (num16)
				{
				case 0:
				{
					PlaceTile(num15, n, 14, mute: true, forced: false, -1, style2);
					int num22 = genRand.Next(6);
					if (num22 < 3)
					{
						PlaceTile(num15 + num22, n - 2, 33, mute: true, forced: false, -1, style12);
					}
					if (!Main.tile[num15, n].active())
					{
						break;
					}
					if (!Main.tile[num15 - 2, n].active())
					{
						PlaceTile(num15 - 2, n, 15, mute: true, forced: false, -1, style);
						if (Main.tile[num15 - 2, n].active())
						{
							Main.tile[num15 - 2, n].frameX += 18;
							Main.tile[num15 - 2, n - 1].frameX += 18;
						}
					}
					if (!Main.tile[num15 + 2, n].active())
					{
						PlaceTile(num15 + 2, n, 15, mute: true, forced: false, -1, style);
					}
					break;
				}
				case 1:
				{
					PlaceTile(num15, n, 18, mute: true, forced: false, -1, style3);
					int num21 = genRand.Next(4);
					if (num21 < 2)
					{
						PlaceTile(num15 + num21, n - 1, 33, mute: true, forced: false, -1, style12);
					}
					if (!Main.tile[num15, n].active())
					{
						break;
					}
					if (genRand.Next(2) == 0)
					{
						if (!Main.tile[num15 - 1, n].active())
						{
							PlaceTile(num15 - 1, n, 15, mute: true, forced: false, -1, style);
							if (Main.tile[num15 - 1, n].active())
							{
								Main.tile[num15 - 1, n].frameX += 18;
								Main.tile[num15 - 1, n - 1].frameX += 18;
							}
						}
					}
					else if (!Main.tile[num15 + 2, n].active())
					{
						PlaceTile(num15 + 2, n, 15, mute: true, forced: false, -1, style);
					}
					break;
				}
				case 2:
					PlaceTile(num15, n, 105, mute: true, forced: false, -1, style4);
					break;
				case 3:
					PlaceTile(num15, n, 101, mute: true, forced: false, -1, style5);
					break;
				case 4:
					if (genRand.Next(2) == 0)
					{
						PlaceTile(num15, n, 15, mute: true, forced: false, -1, style);
						Main.tile[num15, n].frameX += 18;
						Main.tile[num15, n - 1].frameX += 18;
					}
					else
					{
						PlaceTile(num15, n, 15, mute: true, forced: false, -1, style);
					}
					break;
				case 5:
					if (genRand.Next(2) == 0)
					{
						Place4x2(num15, n, 79, 1, style6);
					}
					else
					{
						Place4x2(num15, n, 79, -1, style6);
					}
					break;
				case 6:
					PlaceTile(num15, n, 87, mute: true, forced: false, -1, style7);
					break;
				case 7:
					PlaceTile(num15, n, 88, mute: true, forced: false, -1, style8);
					break;
				case 8:
					PlaceTile(num15, n, 89, mute: true, forced: false, -1, style9);
					break;
				case 9:
					PlaceTile(num15, n, 104, mute: true, forced: false, -1, style10);
					break;
				case 10:
					if (genRand.Next(2) == 0)
					{
						Place4x2(num15, n, 90, 1, style14);
					}
					else
					{
						Place4x2(num15, n, 90, -1, style14);
					}
					break;
				case 11:
					PlaceTile(num15, n, 93, mute: true, forced: false, -1, style13);
					break;
				case 12:
					PlaceTile(num15, n, 100, mute: true, forced: false, -1, style11);
					break;
				}
			}
			num9 = 420000f / (float)Main.maxTilesX;
			for (int num23 = 0; (float)num23 < num9; num23++)
			{
				int num24 = 0;
				int num25 = genRand.Next(num, Main.maxTilesX - num);
				int num26 = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
				while ((Main.tile[num25, num26].wall != 13 && Main.tile[num25, num26].wall != 14) || Main.tile[num25, num26].active())
				{
					num25 = genRand.Next(num, Main.maxTilesX - num);
					num26 = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
					if (drunkWorldGen)
					{
						num25 = ((genRand.Next(2) != 0) ? genRand.Next(Main.maxTilesX - num, Main.maxTilesX - 50) : genRand.Next(50, num));
					}
					num24++;
					if (num24 > 100000)
					{
						break;
					}
				}
				if (num24 > 100000)
				{
					continue;
				}
				int num27 = num25;
				int num28 = num25;
				int num29 = num26;
				int num30 = num26;
				int num31 = 0;
				for (int num32 = 0; num32 < 2; num32++)
				{
					num27 = num25;
					num28 = num25;
					while (!Main.tile[num27, num26].active() && (Main.tile[num27, num26].wall == 13 || Main.tile[num27, num26].wall == 14))
					{
						num27--;
					}
					num27++;
					for (; !Main.tile[num28, num26].active() && (Main.tile[num28, num26].wall == 13 || Main.tile[num28, num26].wall == 14); num28++)
					{
					}
					num28--;
					num25 = (num27 + num28) / 2;
					num29 = num26;
					num30 = num26;
					while (!Main.tile[num25, num29].active() && (Main.tile[num25, num29].wall == 13 || Main.tile[num25, num29].wall == 14))
					{
						num29--;
					}
					num29++;
					for (; !Main.tile[num25, num30].active() && (Main.tile[num25, num30].wall == 13 || Main.tile[num25, num30].wall == 14); num30++)
					{
					}
					num30--;
					num26 = (num29 + num30) / 2;
				}
				num27 = num25;
				num28 = num25;
				while (!Main.tile[num27, num26].active() && !Main.tile[num27, num26 - 1].active() && !Main.tile[num27, num26 + 1].active())
				{
					num27--;
				}
				num27++;
				for (; !Main.tile[num28, num26].active() && !Main.tile[num28, num26 - 1].active() && !Main.tile[num28, num26 + 1].active(); num28++)
				{
				}
				num28--;
				num29 = num26;
				num30 = num26;
				while (!Main.tile[num25, num29].active() && !Main.tile[num25 - 1, num29].active() && !Main.tile[num25 + 1, num29].active())
				{
					num29--;
				}
				num29++;
				for (; !Main.tile[num25, num30].active() && !Main.tile[num25 - 1, num30].active() && !Main.tile[num25 + 1, num30].active(); num30++)
				{
				}
				num30--;
				num25 = (num27 + num28) / 2;
				num26 = (num29 + num30) / 2;
				int num33 = num28 - num27;
				num31 = num30 - num29;
				if (num33 <= 7 || num31 <= 5)
				{
					continue;
				}
				int num34 = 0;
				if (nearPicture2(num25, num26))
				{
					num34 = -1;
				}
				if (num34 == 0)
				{
					Vector2 vector = randHellPicture();
					int type = (int)vector.X;
					int style15 = (int)vector.Y;
					if (!nearPicture(num25, num26))
					{
						PlaceTile(num25, num26, type, mute: true, forced: false, -1, style15);
					}
				}
			}
			int[] array = new int[3]
			{
				genRand.Next(16, 22),
				genRand.Next(16, 22),
				genRand.Next(16, 22)
			};
			while (array[1] == array[0])
			{
				array[1] = genRand.Next(16, 22);
			}
			while (array[2] == array[0] || array[2] == array[1])
			{
				array[2] = genRand.Next(16, 22);
			}
			num9 = 420000f / (float)Main.maxTilesX;
			for (int num35 = 0; (float)num35 < num9; num35++)
			{
				int num36 = 0;
				int num37;
				int num38;
				do
				{
					num37 = genRand.Next(num, Main.maxTilesX - num);
					num38 = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
					if (drunkWorldGen)
					{
						num37 = ((genRand.Next(2) != 0) ? genRand.Next(Main.maxTilesX - num, Main.maxTilesX - 50) : genRand.Next(50, num));
					}
					num36++;
				}
				while (num36 <= 100000 && ((Main.tile[num37, num38].wall != 13 && Main.tile[num37, num38].wall != 14) || Main.tile[num37, num38].active()));
				if (num36 > 100000)
				{
					continue;
				}
				while (!SolidTile(num37, num38) && num38 > 10)
				{
					num38--;
				}
				num38++;
				if (Main.tile[num37, num38].wall != 13 && Main.tile[num37, num38].wall != 14)
				{
					continue;
				}
				int num39 = genRand.Next(3);
				int style16 = 32;
				int style17 = 32;
				int num40;
				int num41;
				switch (num39)
				{
				default:
					num40 = 1;
					num41 = 3;
					break;
				case 1:
					num40 = 3;
					num41 = 3;
					break;
				case 2:
					num40 = 1;
					num41 = 2;
					break;
				}
				for (int num42 = num37 - 1; num42 <= num37 + num40; num42++)
				{
					for (int num43 = num38; num43 <= num38 + num41; num43++)
					{
						Tile tile = Main.tile[num37, num38];
						if (num42 < num37 || num42 == num37 + num40)
						{
							if (tile.active())
							{
								switch (tile.type)
								{
								case 10:
								case 11:
								case 34:
								case 42:
								case 91:
									num39 = -1;
									break;
								}
							}
						}
						else if (tile.active())
						{
							num39 = -1;
						}
					}
				}
				switch (num39)
				{
				case 0:
					PlaceTile(num37, num38, 91, mute: true, forced: false, -1, array[genRand.Next(3)]);
					break;
				case 1:
					PlaceTile(num37, num38, 34, mute: true, forced: false, -1, style16);
					break;
				case 2:
					PlaceTile(num37, num38, 42, mute: true, forced: false, -1, style17);
					break;
				}
			}
		}

		public static void HellFort(int i, int j, ushort tileType = 75, byte wallType = 14)
		{
			int[] array = new int[5];
			int[] array2 = new int[5];
			int[] array3 = new int[10];
			int[] array4 = new int[10];
			int num = 8;
			int num2 = 20;
			if (drunkWorldGen)
			{
				num /= 2;
				num2 *= 2;
			}
			array[2] = i - genRand.Next(num / 2, num2 / 2);
			array2[2] = i + genRand.Next(num / 2, num2 / 2);
			array[3] = array2[2];
			array2[3] = array[3] + genRand.Next(num, num2);
			array[4] = array2[3];
			array2[4] = array[4] + genRand.Next(num, num2);
			array2[1] = array[2];
			array[1] = array2[1] - genRand.Next(num, num2);
			array2[0] = array[1];
			array[0] = array2[0] - genRand.Next(num, num2);
			num = 6;
			num2 = 12;
			array3[3] = j - genRand.Next(num, num2);
			array4[3] = j;
			for (int k = 4; k < 10; k++)
			{
				array3[k] = array4[k - 1];
				array4[k] = array3[k] + genRand.Next(num, num2);
			}
			for (int num3 = 2; num3 >= 0; num3--)
			{
				array4[num3] = array3[num3 + 1];
				array3[num3] = array4[num3] - genRand.Next(num, num2);
			}
			bool flag = false;
			bool flag2 = false;
			bool[,] array5 = new bool[5, 10];
			int num4 = 3;
			int num5 = 3;
			for (int l = 0; l < 2; l++)
			{
				if (genRand.Next(3) == 0 || drunkWorldGen)
				{
					flag = true;
					int num6 = genRand.Next(10);
					if (num6 < num4)
					{
						num4 = num6;
					}
					if (num6 > num5)
					{
						num5 = num6;
					}
					int num7 = 1;
					if (genRand.Next(2) == 0 || drunkWorldGen)
					{
						array5[0, num6] = true;
						array5[1, num6] = true;
						num7 = 0;
					}
					else
					{
						array5[1, num6] = true;
					}
					int num8 = genRand.Next(2);
					if (num8 == 0)
					{
						num8 = -1;
					}
					int num9 = genRand.Next(10);
					while (num9 > 0 && num6 >= 0 && num6 < 10)
					{
						array5[num7, num6] = true;
						num6 += num8;
					}
				}
				if (genRand.Next(3) == 0 || drunkWorldGen)
				{
					flag2 = true;
					int num10 = genRand.Next(10);
					if (num10 < num4)
					{
						num4 = num10;
					}
					if (num10 > num5)
					{
						num5 = num10;
					}
					int num11 = 3;
					if (genRand.Next(2) == 0 || drunkWorldGen)
					{
						array5[3, num10] = true;
						array5[4, num10] = true;
						num11 = 4;
					}
					else
					{
						array5[3, num10] = true;
					}
					int num12 = genRand.Next(2);
					if (num12 == 0)
					{
						num12 = -1;
					}
					int num13 = genRand.Next(10);
					while (num13 > 0 && num10 >= 0 && num10 < 10)
					{
						array5[num11, num10] = true;
						num10 += num12;
					}
				}
			}
			for (int m = 0; m < 5; m++)
			{
				int num14 = array[m];
				bool flag3 = false;
				if (num14 < 10 || num14 > Main.maxTilesX - 10)
				{
					flag3 = true;
				}
				else
				{
					for (int n = Main.UnderworldLayer; n < Main.maxTilesY; n++)
					{
						if (Main.tile[num14, n].wall > 0)
						{
							flag3 = true;
						}
					}
				}
				if (flag3)
				{
					for (int num15 = 0; num15 < 10; num15++)
					{
						array5[m, num15] = false;
					}
				}
			}
			int num16 = genRand.Next(10);
			if (num16 < num4)
			{
				num4 = num16;
			}
			num16 = genRand.Next(10);
			if (num16 > num5)
			{
				num5 = num16;
			}
			if (!flag && !flag2)
			{
				while (num5 - num4 < 5)
				{
					num16 = genRand.Next(10);
					if (num16 < num4)
					{
						num4 = num16;
					}
					num16 = genRand.Next(10);
					if (num16 > num5)
					{
						num5 = num16;
					}
				}
			}
			for (int num17 = num4; num17 <= num5; num17++)
			{
				array5[2, num17] = true;
			}
			for (int num18 = 0; num18 < 5; num18++)
			{
				for (int num19 = 0; num19 < 10; num19++)
				{
					if (array5[num18, num19] && (array3[num19] < Main.UnderworldLayer || array4[num19] > Main.maxTilesY - 20))
					{
						array5[num18, num19] = false;
					}
				}
			}
			for (int num20 = 0; num20 < 5; num20++)
			{
				for (int num21 = 0; num21 < 10; num21++)
				{
					if (!array5[num20, num21])
					{
						continue;
					}
					for (int num22 = array[num20]; num22 <= array2[num20]; num22++)
					{
						for (int num23 = array3[num21]; num23 <= array4[num21]; num23++)
						{
							if (num22 < 10)
							{
								break;
							}
							if (num22 > Main.maxTilesX - 10)
							{
								break;
							}
							Main.tile[num22, num23].liquid = 0;
							if (num22 == array[num20] || num22 == array2[num20] || num23 == array3[num21] || num23 == array4[num21])
							{
								Main.tile[num22, num23].active(active: true);
								Main.tile[num22, num23].type = tileType;
								Main.tile[num22, num23].halfBrick(halfBrick: false);
								Main.tile[num22, num23].slope(0);
							}
							else
							{
								Main.tile[num22, num23].wall = wallType;
								Main.tile[num22, num23].active(active: false);
							}
						}
					}
				}
			}
			int style = 19;
			int style2 = 13;
			for (int num24 = 0; num24 < 4; num24++)
			{
				bool[] array6 = new bool[10];
				bool flag4 = false;
				for (int num25 = 0; num25 < 10; num25++)
				{
					if (array5[num24, num25] && array5[num24 + 1, num25])
					{
						array6[num25] = true;
						flag4 = true;
					}
				}
				while (flag4)
				{
					int num26 = genRand.Next(10);
					if (array6[num26])
					{
						flag4 = false;
						Main.tile[array2[num24], array4[num26] - 1].active(active: false);
						Main.tile[array2[num24], array4[num26] - 2].active(active: false);
						Main.tile[array2[num24], array4[num26] - 3].active(active: false);
						Main.tile[array2[num24], array4[num26] - 1].wall = wallType;
						Main.tile[array2[num24], array4[num26] - 2].wall = wallType;
						Main.tile[array2[num24], array4[num26] - 3].wall = wallType;
						PlaceTile(array2[num24], array4[num26] - 1, 10, mute: true, forced: false, -1, style);
					}
				}
			}
			for (int num27 = 0; num27 < 5; num27++)
			{
				for (int num28 = 0; num28 < 10; num28++)
				{
					if (!array5[num27, num28])
					{
						continue;
					}
					if (num28 > 0 && array5[num27, num28 - 1])
					{
						int num29 = genRand.Next(array[num27] + 2, array2[num27] - 1);
						int num30 = genRand.Next(array[num27] + 2, array2[num27] - 1);
						int num31 = 0;
						while (num30 - num29 < 2 || num30 - num29 > 5)
						{
							num29 = genRand.Next(array[num27] + 2, array2[num27] - 1);
							num30 = genRand.Next(array[num27] + 2, array2[num27] - 1);
							num31++;
							if (num31 > 10000)
							{
								break;
							}
						}
						if (num31 > 10000)
						{
							break;
						}
						for (int num32 = num29; num32 <= num30 && num32 >= 20 && num32 <= Main.maxTilesX - 20; num32++)
						{
							Main.tile[num32, array3[num28]].active(active: false);
							PlaceTile(num32, array3[num28], 19, mute: true, forced: true, -1, style2);
							Main.tile[num32, array3[num28]].wall = wallType;
						}
					}
					if (num27 < 4 && array5[num27 + 1, num28] && genRand.Next(3) == 0)
					{
						Main.tile[array2[num27], array4[num28] - 1].active(active: false);
						Main.tile[array2[num27], array4[num28] - 2].active(active: false);
						Main.tile[array2[num27], array4[num28] - 3].active(active: false);
						Main.tile[array2[num27], array4[num28] - 1].wall = wallType;
						Main.tile[array2[num27], array4[num28] - 2].wall = wallType;
						Main.tile[array2[num27], array4[num28] - 3].wall = wallType;
						PlaceTile(array2[num27], array4[num28] - 1, 10, mute: true, forced: false, -1, style);
					}
				}
			}
			bool flag5 = false;
			for (int num33 = 0; num33 < 5; num33++)
			{
				bool[] array7 = new bool[10];
				for (int num34 = 0; num34 < 10; num34++)
				{
					if (array5[num33, num34])
					{
						flag5 = true;
						array7[num34] = true;
					}
				}
				if (!flag5)
				{
					continue;
				}
				bool flag6 = false;
				for (int num35 = 0; num35 < 10; num35++)
				{
					if (array7[num35])
					{
						if (!Main.tile[array[num33] - 1, array4[num35] - 1].active() && !Main.tile[array[num33] - 1, array4[num35] - 2].active() && !Main.tile[array[num33] - 1, array4[num35] - 3].active() && Main.tile[array[num33] - 1, array4[num35] - 1].liquid == 0 && Main.tile[array[num33] - 1, array4[num35] - 2].liquid == 0 && Main.tile[array[num33] - 1, array4[num35] - 3].liquid == 0)
						{
							flag6 = true;
						}
						else
						{
							array7[num35] = false;
						}
					}
				}
				while (flag6)
				{
					int num36 = genRand.Next(10);
					if (array7[num36])
					{
						flag6 = false;
						Main.tile[array[num33], array4[num36] - 1].active(active: false);
						Main.tile[array[num33], array4[num36] - 2].active(active: false);
						Main.tile[array[num33], array4[num36] - 3].active(active: false);
						PlaceTile(array[num33], array4[num36] - 1, 10, mute: true, forced: false, -1, style);
					}
				}
				break;
			}
			bool flag7 = false;
			for (int num37 = 4; num37 >= 0; num37--)
			{
				bool[] array8 = new bool[10];
				for (int num38 = 0; num38 < 10; num38++)
				{
					if (array5[num37, num38])
					{
						flag7 = true;
						array8[num38] = true;
					}
				}
				if (flag7)
				{
					bool flag8 = false;
					for (int num39 = 0; num39 < 10; num39++)
					{
						if (array8[num39])
						{
							if (num37 < 20 || num37 > Main.maxTilesX - 20)
							{
								break;
							}
							if (!Main.tile[array2[num37] + 1, array4[num39] - 1].active() && !Main.tile[array2[num37] + 1, array4[num39] - 2].active() && !Main.tile[array2[num37] + 1, array4[num39] - 3].active() && Main.tile[array2[num37] + 1, array4[num39] - 1].liquid == 0 && Main.tile[array2[num37] + 1, array4[num39] - 2].liquid == 0 && Main.tile[array2[num37] + 1, array4[num39] - 3].liquid == 0)
							{
								flag8 = true;
							}
							else
							{
								array8[num39] = false;
							}
						}
					}
					while (flag8)
					{
						int num40 = genRand.Next(10);
						if (array8[num40])
						{
							flag8 = false;
							Main.tile[array2[num37], array4[num40] - 1].active(active: false);
							Main.tile[array2[num37], array4[num40] - 2].active(active: false);
							Main.tile[array2[num37], array4[num40] - 3].active(active: false);
							PlaceTile(array2[num37], array4[num40] - 1, 10, mute: true, forced: false, -1, style);
						}
					}
					break;
				}
			}
			bool flag9 = false;
			for (int num41 = 0; num41 < 10; num41++)
			{
				bool[] array9 = new bool[10];
				for (int num42 = 0; num42 < 5; num42++)
				{
					if (array5[num42, num41])
					{
						flag9 = true;
						array9[num42] = true;
					}
				}
				if (!flag9)
				{
					continue;
				}
				bool flag10 = true;
				while (flag10)
				{
					int num43 = genRand.Next(5);
					if (!array9[num43])
					{
						continue;
					}
					int num44 = genRand.Next(array[num43] + 2, array2[num43] - 1);
					int num45 = genRand.Next(array[num43] + 2, array2[num43] - 1);
					int num46 = 0;
					while (num45 - num44 < 2 || num45 - num44 > 5)
					{
						num44 = genRand.Next(array[num43] + 2, array2[num43] - 1);
						num45 = genRand.Next(array[num43] + 2, array2[num43] - 1);
						num46++;
						if (num46 > 10000)
						{
							break;
						}
					}
					if (num46 > 10000)
					{
						break;
					}
					for (int num47 = num44; num47 <= num45 && num47 >= 10 && num47 <= Main.maxTilesX - 10; num47++)
					{
						if (Main.tile[num47, array3[num41] - 1].active() || Main.tile[num47, array3[num41] - 1].liquid > 0)
						{
							flag10 = false;
						}
					}
					if (flag10)
					{
						for (int num48 = num44; num48 <= num45 && num48 >= 10 && num48 <= Main.maxTilesX - 10; num48++)
						{
							Main.tile[num48, array3[num41]].active(active: false);
							PlaceTile(num48, array3[num41], 19, mute: true, forced: true, -1, style2);
						}
					}
					flag10 = false;
				}
				break;
			}
		}

		public static void HellHouse(int i, int j, byte type = 76, byte wall = 13)
		{
			int num = genRand.Next(8, 20);
			int num2 = genRand.Next(1, 3);
			int num3 = genRand.Next(4, 13);
			int num4 = j;
			for (int k = 0; k < num2; k++)
			{
				int num5 = genRand.Next(5, 9);
				HellRoom(i, num4, num, num5, type, wall);
				num4 -= num5;
			}
			num4 = j;
			for (int l = 0; l < num3; l++)
			{
				int num6 = genRand.Next(5, 9);
				num4 += num6;
				HellRoom(i, num4, num, num6, type, wall);
			}
			for (int m = i - num / 2; m <= i + num / 2; m++)
			{
				for (num4 = j; num4 < Main.maxTilesY && ((Main.tile[m, num4].active() && (Main.tile[m, num4].type == 76 || Main.tile[m, num4].type == 75)) || Main.tile[i, num4].wall == 13 || Main.tile[i, num4].wall == 14); num4++)
				{
				}
				int num7 = 6 + genRand.Next(3);
				while (num4 < Main.maxTilesY && !Main.tile[m, num4].active())
				{
					num7--;
					Main.tile[m, num4].active(active: true);
					Main.tile[m, num4].type = 57;
					num4++;
					if (num7 <= 0)
					{
						break;
					}
				}
			}
			int num8 = 0;
			int num9 = 0;
			for (num4 = j; num4 < Main.maxTilesY && ((Main.tile[i, num4].active() && (Main.tile[i, num4].type == 76 || Main.tile[i, num4].type == 75)) || Main.tile[i, num4].wall == 13 || Main.tile[i, num4].wall == 14); num4++)
			{
			}
			num4--;
			num9 = num4;
			while ((Main.tile[i, num4].active() && (Main.tile[i, num4].type == 76 || Main.tile[i, num4].type == 75)) || Main.tile[i, num4].wall == 13 || Main.tile[i, num4].wall == 14)
			{
				num4--;
				if (!Main.tile[i, num4].active() || (Main.tile[i, num4].type != 76 && Main.tile[i, num4].type != 75))
				{
					continue;
				}
				int num10 = genRand.Next(i - num / 2 + 1, i + num / 2 - 1);
				int num11 = genRand.Next(i - num / 2 + 1, i + num / 2 - 1);
				if (num10 > num11)
				{
					int num12 = num10;
					num10 = num11;
					num11 = num12;
				}
				if (num10 == num11)
				{
					if (num10 < i)
					{
						num11++;
					}
					else
					{
						num10--;
					}
				}
				for (int n = num10; n <= num11; n++)
				{
					if (Main.tile[n, num4 - 1].wall == 13)
					{
						Main.tile[n, num4].wall = 13;
					}
					if (Main.tile[n, num4 - 1].wall == 14)
					{
						Main.tile[n, num4].wall = 14;
					}
					Main.tile[n, num4].type = 19;
					Main.tile[n, num4].active(active: true);
				}
				num4--;
			}
			num8 = num4;
			float num13 = (float)((num9 - num8) * num) * 0.02f;
			for (int num14 = 0; (float)num14 < num13; num14++)
			{
				int num15 = genRand.Next(i - num / 2, i + num / 2 + 1);
				int num16 = genRand.Next(num8, num9);
				int num17 = genRand.Next(3, 8);
				for (int num18 = num15 - num17; num18 <= num15 + num17; num18++)
				{
					for (int num19 = num16 - num17; num19 <= num16 + num17; num19++)
					{
						float num20 = Math.Abs(num18 - num15);
						float num21 = Math.Abs(num19 - num16);
						if (!(Math.Sqrt(num20 * num20 + num21 * num21) < (double)num17 * 0.4))
						{
							continue;
						}
						try
						{
							if (Main.tile[num18, num19].type == 76 || Main.tile[num18, num19].type == 19)
							{
								Main.tile[num18, num19].active(active: false);
							}
							Main.tile[num18, num19].wall = 0;
						}
						catch
						{
						}
					}
				}
			}
		}

		public static void HellRoom(int i, int j, int width, int height, byte type = 76, byte wall = 13)
		{
			if (j > Main.maxTilesY - 40)
			{
				return;
			}
			for (int k = i - width / 2; k <= i + width / 2; k++)
			{
				for (int l = j - height; l <= j; l++)
				{
					try
					{
						Main.tile[k, l].active(active: true);
						Main.tile[k, l].type = type;
						Main.tile[k, l].liquid = 0;
						Main.tile[k, l].lava(lava: false);
					}
					catch
					{
					}
				}
			}
			for (int m = i - width / 2 + 1; m <= i + width / 2 - 1; m++)
			{
				for (int n = j - height + 1; n <= j - 1; n++)
				{
					try
					{
						Main.tile[m, n].active(active: false);
						Main.tile[m, n].wall = wall;
						Main.tile[m, n].liquid = 0;
						Main.tile[m, n].lava(lava: false);
					}
					catch
					{
					}
				}
			}
		}

		public static void templeCleaner(int x, int y)
		{
			int num = 0;
			if (Main.tile[x + 1, y].active() && Main.tile[x + 1, y].type == 226)
			{
				num++;
			}
			if (Main.tile[x - 1, y].active() && Main.tile[x - 1, y].type == 226)
			{
				num++;
			}
			if (Main.tile[x, y + 1].active() && Main.tile[x, y + 1].type == 226)
			{
				num++;
			}
			if (Main.tile[x, y - 1].active() && Main.tile[x, y - 1].type == 226)
			{
				num++;
			}
			if (Main.tile[x, y].active() && Main.tile[x, y].type == 226)
			{
				if (num <= 1)
				{
					Main.tile[x, y].active(active: false);
					Main.tile[x, y].wall = 87;
				}
			}
			else if (!Main.tile[x, y].active() && num == 3)
			{
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].type = 226;
				Main.tile[x, y].liquid = 0;
				Main.tile[x, y].slope(0);
				Main.tile[x, y].halfBrick(halfBrick: false);
			}
		}

		public static Vector2 templePather(Vector2 templePath, int destX, int destY)
		{
			int num = (int)templePath.X;
			int num2 = (int)templePath.Y;
			int num3 = genRand.Next(5, 20);
			int num4 = genRand.Next(2, 5);
			while (num3 > 0 && (num != destX || num2 != destY))
			{
				num3--;
				if (num > destX)
				{
					num--;
				}
				if (num < destX)
				{
					num++;
				}
				if (num2 > destY)
				{
					num2--;
				}
				if (num2 < destY)
				{
					num2++;
				}
				for (int i = num - num4; i < num + num4; i++)
				{
					for (int j = num2 - num4; j < num2 + num4; j++)
					{
						Main.tile[i, j].active(active: false);
						Main.tile[i, j].wall = 87;
					}
				}
			}
			return new Vector2(num, num2);
		}

		public static void outerTempled(int x, int y)
		{
			if ((Main.tile[x, y].active() & (Main.tile[x, y].type == 226)) || Main.tile[x, y].wall == 87)
			{
				return;
			}
			int num = 6;
			for (int i = x - num; i <= x + num; i++)
			{
				for (int j = y - num; j <= y + num; j++)
				{
					if (!Main.tile[i, j].active() && Main.tile[i, j].wall == 87)
					{
						i = x;
						j = y;
						Main.tile[i, j].active(active: true);
						Main.tile[i, j].type = 226;
						Main.tile[i, j].liquid = 0;
						Main.tile[i, j].slope(0);
						Main.tile[i, j].halfBrick(halfBrick: false);
						return;
					}
				}
			}
		}

		public static void makeTemple(int x, int y)
		{
			Rectangle[] array = new Rectangle[100];
			float num = Main.maxTilesX / 4200;
			int num2 = genRand.Next((int)(num * 10f), (int)(num * 16f));
			if (drunkWorldGen)
			{
				num2 *= 3;
			}
			if (getGoodWorldGen)
			{
				num2 *= 3;
			}
			int num3 = 1;
			if (genRand.Next(2) == 0)
			{
				num3 = -1;
			}
			int num4 = num3;
			int num5 = x;
			int num6 = y;
			int num7 = x;
			int num8 = y;
			int num9 = genRand.Next(1, 3);
			int num10 = 0;
			for (int i = 0; i < num2; i++)
			{
				num10++;
				int num11 = num3;
				int num12 = num7;
				int num13 = num8;
				bool flag = true;
				int num14 = 0;
				int num15 = 0;
				int num16 = -10;
				Rectangle rectangle = new Rectangle(num12 - num14 / 2, num13 - num15 / 2, num14, num15);
				while (flag)
				{
					num12 = num7;
					num13 = num8;
					num14 = genRand.Next(25, 50);
					num15 = genRand.Next(20, 35);
					if (num15 > num14)
					{
						num15 = num14;
					}
					if (i == num2 - 1)
					{
						num14 = genRand.Next(55, 65);
						num15 = genRand.Next(45, 50);
						if (num15 > num14)
						{
							num15 = num14;
						}
						num14 = (int)((double)num14 * 1.6);
						num15 = (int)((double)num15 * 1.35);
						num13 += genRand.Next(5, 10);
					}
					if (num10 > num9)
					{
						num13 += genRand.Next(num15 + 1, num15 + 3) + num16;
						num12 += genRand.Next(-5, 6);
						num11 = num3 * -1;
					}
					else
					{
						num12 += (genRand.Next(num14 + 1, num14 + 3) + num16) * num11;
						num13 += genRand.Next(-5, 6);
					}
					flag = false;
					rectangle = new Rectangle(num12 - num14 / 2, num13 - num15 / 2, num14, num15);
					for (int j = 0; j < i; j++)
					{
						if (rectangle.Intersects(array[j]))
						{
							flag = true;
						}
						if (genRand.Next(100) == 0)
						{
							num16++;
						}
					}
				}
				if (num10 > num9)
				{
					num9++;
					num10 = 1;
				}
				array[i] = rectangle;
				num3 = num11;
				num7 = num12;
				num8 = num13;
			}
			for (int k = 0; k < num2; k++)
			{
				for (int l = 0; l < 2; l++)
				{
					for (int m = 0; m < num2; m++)
					{
						for (int n = 0; n < 2; n++)
						{
							int num17 = array[k].X;
							if (l == 1)
							{
								num17 += array[k].Width - 1;
							}
							int num18 = array[k].Y;
							int num19 = num18 + array[k].Height;
							int num20 = array[m].X;
							if (n == 1)
							{
								num20 += array[m].Width - 1;
							}
							int y2 = array[m].Y;
							int num21 = y2 + array[m].Height;
							while (num17 != num20 || num18 != y2 || num19 != num21)
							{
								if (num17 < num20)
								{
									num17++;
								}
								if (num17 > num20)
								{
									num17--;
								}
								if (num18 < y2)
								{
									num18++;
								}
								if (num18 > y2)
								{
									num18--;
								}
								if (num19 < num21)
								{
									num19++;
								}
								if (num19 > num21)
								{
									num19--;
								}
								int num22 = num17;
								for (int num23 = num18; num23 < num19; num23++)
								{
									Main.tile[num22, num23].active(active: true);
									Main.tile[num22, num23].type = 226;
									Main.tile[num22, num23].liquid = 0;
									Main.tile[num22, num23].slope(0);
									Main.tile[num22, num23].halfBrick(halfBrick: false);
								}
							}
						}
					}
				}
			}
			for (int num24 = 0; num24 < num2; num24++)
			{
				if (false)
				{
					continue;
				}
				for (int num25 = array[num24].X; num25 < array[num24].X + array[num24].Width; num25++)
				{
					for (int num26 = array[num24].Y; num26 < array[num24].Y + array[num24].Height; num26++)
					{
						Main.tile[num25, num26].active(active: true);
						Main.tile[num25, num26].type = 226;
						Main.tile[num25, num26].liquid = 0;
						Main.tile[num25, num26].slope(0);
						Main.tile[num25, num26].halfBrick(halfBrick: false);
					}
				}
				int x2 = array[num24].X;
				int num27 = x2 + array[num24].Width;
				int y3 = array[num24].Y;
				int num28 = y3 + array[num24].Height;
				x2 += genRand.Next(3, 8);
				num27 -= genRand.Next(3, 8);
				y3 += genRand.Next(3, 8);
				num28 -= genRand.Next(3, 8);
				int num29 = x2;
				int num30 = num27;
				int num31 = y3;
				int num32 = num28;
				int num33 = (x2 + num27) / 2;
				int num34 = (y3 + num28) / 2;
				for (int num35 = x2; num35 < num27; num35++)
				{
					for (int num36 = y3; num36 < num28; num36++)
					{
						if (genRand.Next(20) == 0)
						{
							num31 += genRand.Next(-1, 2);
						}
						if (genRand.Next(20) == 0)
						{
							num32 += genRand.Next(-1, 2);
						}
						if (genRand.Next(20) == 0)
						{
							num29 += genRand.Next(-1, 2);
						}
						if (genRand.Next(20) == 0)
						{
							num30 += genRand.Next(-1, 2);
						}
						if (num29 < x2)
						{
							num29 = x2;
						}
						if (num30 > num27)
						{
							num30 = num27;
						}
						if (num31 < y3)
						{
							num31 = y3;
						}
						if (num32 > num28)
						{
							num32 = num28;
						}
						if (num29 > num33)
						{
							num29 = num33;
						}
						if (num30 < num33)
						{
							num30 = num33;
						}
						if (num31 > num34)
						{
							num31 = num34;
						}
						if (num32 < num34)
						{
							num32 = num34;
						}
						if (num35 >= num29 && num35 < num30 && num36 >= num31 && num36 <= num32)
						{
							Main.tile[num35, num36].active(active: false);
							Main.tile[num35, num36].wall = 87;
						}
					}
				}
				for (int num37 = num28; num37 > y3; num37--)
				{
					for (int num38 = num27; num38 > x2; num38--)
					{
						if (genRand.Next(20) == 0)
						{
							num31 += genRand.Next(-1, 2);
						}
						if (genRand.Next(20) == 0)
						{
							num32 += genRand.Next(-1, 2);
						}
						if (genRand.Next(20) == 0)
						{
							num29 += genRand.Next(-1, 2);
						}
						if (genRand.Next(20) == 0)
						{
							num30 += genRand.Next(-1, 2);
						}
						if (num29 < x2)
						{
							num29 = x2;
						}
						if (num30 > num27)
						{
							num30 = num27;
						}
						if (num31 < y3)
						{
							num31 = y3;
						}
						if (num32 > num28)
						{
							num32 = num28;
						}
						if (num29 > num33)
						{
							num29 = num33;
						}
						if (num30 < num33)
						{
							num30 = num33;
						}
						if (num31 > num34)
						{
							num31 = num34;
						}
						if (num32 < num34)
						{
							num32 = num34;
						}
						if (num38 >= num29 && num38 < num30 && num37 >= num31 && num37 <= num32)
						{
							Main.tile[num38, num37].active(active: false);
							Main.tile[num38, num37].wall = 87;
						}
					}
				}
			}
			Vector2 templePath = new Vector2(num5, num6);
			for (int num39 = 0; num39 < num2; num39++)
			{
				Rectangle rectangle2 = array[num39];
				rectangle2.X += 8;
				rectangle2.Y += 8;
				rectangle2.Width -= 16;
				rectangle2.Height -= 16;
				bool flag2 = true;
				while (flag2)
				{
					int num40 = genRand.Next(rectangle2.X, rectangle2.X + rectangle2.Width);
					int num41 = genRand.Next(rectangle2.Y, rectangle2.Y + rectangle2.Height);
					if (num39 == num2 - 1)
					{
						num40 = rectangle2.X + rectangle2.Width / 2 + genRand.Next(-10, 10);
						num41 = rectangle2.Y + rectangle2.Height / 2 + genRand.Next(-10, 10);
					}
					templePath = templePather(templePath, num40, num41);
					if (templePath.X == (float)num40 && templePath.Y == (float)num41)
					{
						flag2 = false;
					}
				}
				if (num39 >= num2 - 1)
				{
					continue;
				}
				if (genRand.Next(3) != 0)
				{
					int num42 = num39 + 1;
					if (array[num42].Y >= array[num39].Y + array[num39].Height)
					{
						rectangle2.X = array[num42].X;
						if (num39 == 0)
						{
							if (num3 > 0)
							{
								rectangle2.X += (int)((double)array[num42].Width * 0.8);
							}
							else
							{
								rectangle2.X += (int)((double)array[num42].Width * 0.2);
							}
						}
						else if (array[num42].X < array[num39].X)
						{
							rectangle2.X += (int)((double)array[num42].Width * 0.2);
						}
						else
						{
							rectangle2.X += (int)((double)array[num42].Width * 0.8);
						}
						rectangle2.Y = array[num42].Y;
					}
					else
					{
						rectangle2.X = (array[num39].X + array[num39].Width / 2 + array[num42].X + array[num42].Width / 2) / 2;
						rectangle2.Y = (int)((double)array[num42].Y + (double)array[num42].Height * 0.8);
					}
					int x3 = rectangle2.X;
					int y4 = rectangle2.Y;
					flag2 = true;
					while (flag2)
					{
						int num43 = genRand.Next(x3 - 6, x3 + 7);
						int num44 = genRand.Next(y4 - 6, y4 + 7);
						templePath = templePather(templePath, num43, num44);
						if (templePath.X == (float)num43 && templePath.Y == (float)num44)
						{
							flag2 = false;
						}
					}
					continue;
				}
				int num45 = num39 + 1;
				int num46 = (array[num39].X + array[num39].Width / 2 + array[num45].X + array[num45].Width / 2) / 2;
				int num47 = (array[num39].Y + array[num39].Height / 2 + array[num45].Y + array[num45].Height / 2) / 2;
				flag2 = true;
				while (flag2)
				{
					int num48 = genRand.Next(num46 - 6, num46 + 7);
					int num49 = genRand.Next(num47 - 6, num47 + 7);
					templePath = templePather(templePath, num48, num49);
					if (templePath.X == (float)num48 && templePath.Y == (float)num49)
					{
						flag2 = false;
					}
				}
			}
			int num50 = Main.maxTilesX - 20;
			int num51 = 20;
			int num52 = Main.maxTilesY - 20;
			int num53 = 20;
			for (int num54 = 0; num54 < num2; num54++)
			{
				if (array[num54].X < num50)
				{
					num50 = array[num54].X;
				}
				if (array[num54].X + array[num54].Width > num51)
				{
					num51 = array[num54].X + array[num54].Width;
				}
				if (array[num54].Y < num52)
				{
					num52 = array[num54].Y;
				}
				if (array[num54].Y + array[num54].Height > num53)
				{
					num53 = array[num54].Y + array[num54].Height;
				}
			}
			num50 -= 10;
			num51 += 10;
			num52 -= 10;
			num53 += 10;
			for (int num55 = num50; num55 < num51; num55++)
			{
				for (int num56 = num52; num56 < num53; num56++)
				{
					outerTempled(num55, num56);
				}
			}
			for (int num57 = num51; num57 >= num50; num57--)
			{
				for (int num58 = num52; num58 < num53 / 2; num58++)
				{
					outerTempled(num57, num58);
				}
			}
			for (int num59 = num52; num59 < num53; num59++)
			{
				for (int num60 = num50; num60 < num51; num60++)
				{
					outerTempled(num60, num59);
				}
			}
			for (int num61 = num53; num61 >= num52; num61--)
			{
				for (int num62 = num50; num62 < num51; num62++)
				{
					outerTempled(num62, num61);
				}
			}
			num3 = -num4;
			Vector2 vector = new Vector2(num5, num6);
			int num63 = genRand.Next(2, 5);
			bool flag3 = true;
			int num64 = 0;
			int num65 = genRand.Next(9, 14);
			while (flag3)
			{
				num64++;
				if (num64 >= num65)
				{
					num64 = 0;
					vector.Y -= 1f;
				}
				vector.X += num3;
				int num66 = (int)vector.X;
				flag3 = false;
				for (int num67 = (int)vector.Y - num63; (float)num67 < vector.Y + (float)num63; num67++)
				{
					if (Main.tile[num66, num67].wall == 87 || (Main.tile[num66, num67].active() && Main.tile[num66, num67].type == 226))
					{
						flag3 = true;
					}
					if (Main.tile[num66, num67].active() && Main.tile[num66, num67].type == 226)
					{
						Main.tile[num66, num67].active(active: false);
						Main.tile[num66, num67].wall = 87;
					}
				}
			}
			int num68 = num5;
			int num69;
			for (num69 = num6; !Main.tile[num68, num69].active(); num69++)
			{
			}
			num69 -= 4;
			int num70 = num69;
			while ((Main.tile[num68, num70].active() && Main.tile[num68, num70].type == 226) || Main.tile[num68, num70].wall == 87)
			{
				num70--;
			}
			num70 += 2;
			for (int num71 = num68 - 1; num71 <= num68 + 1; num71++)
			{
				for (int num72 = num70; num72 <= num69; num72++)
				{
					Main.tile[num71, num72].active(active: true);
					Main.tile[num71, num72].type = 226;
					Main.tile[num71, num72].liquid = 0;
					Main.tile[num71, num72].slope(0);
					Main.tile[num71, num72].halfBrick(halfBrick: false);
				}
			}
			for (int num73 = num68 - 4; num73 <= num68 + 4; num73++)
			{
				for (int num74 = num69 - 1; num74 < num69 + 3; num74++)
				{
					Main.tile[num73, num74].active(active: false);
					Main.tile[num73, num74].wall = 87;
				}
			}
			for (int num75 = num68 - 1; num75 <= num68 + 1; num75++)
			{
				for (int num76 = num69 - 5; num76 <= num69 + 8; num76++)
				{
					Main.tile[num75, num76].active(active: true);
					Main.tile[num75, num76].type = 226;
					Main.tile[num75, num76].liquid = 0;
					Main.tile[num75, num76].slope(0);
					Main.tile[num75, num76].halfBrick(halfBrick: false);
				}
			}
			for (int num77 = num68 - 3; num77 <= num68 + 3; num77++)
			{
				for (int num78 = num69 - 2; num78 < num69 + 3; num78++)
				{
					if (num78 >= num69 || num77 < num5 - 1 || num77 > num5 + 1)
					{
						Main.tile[num77, num78].active(active: false);
						Main.tile[num77, num78].wall = 87;
					}
				}
			}
			PlaceTile(num68, num69, 10, mute: true, forced: false, -1, 11);
			for (int num79 = num50; num79 < num51; num79++)
			{
				for (int num80 = num52; num80 < num53; num80++)
				{
					templeCleaner(num79, num80);
				}
			}
			for (int num81 = num53; num81 >= num52; num81--)
			{
				for (int num82 = num51; num82 >= num50; num82--)
				{
					templeCleaner(num82, num81);
				}
			}
			for (int num83 = num50; num83 < num51; num83++)
			{
				for (int num84 = num52; num84 < num53; num84++)
				{
					bool flag4 = true;
					for (int num85 = num83 - 1; num85 <= num83 + 1; num85++)
					{
						for (int num86 = num84 - 1; num86 <= num84 + 1; num86++)
						{
							if ((!Main.tile[num85, num86].active() || Main.tile[num85, num86].type != 226) && Main.tile[num85, num86].wall != 87)
							{
								flag4 = false;
								break;
							}
						}
					}
					if (flag4)
					{
						Main.tile[num83, num84].wall = 87;
					}
				}
			}
			int num87 = 0;
			Rectangle rectangle3 = array[num2 - 1];
			int num88 = rectangle3.Width / 2;
			int num89 = rectangle3.Height / 2;
			while (true)
			{
				num87++;
				int num90 = rectangle3.X + num88 + 15 - genRand.Next(30);
				int num91 = rectangle3.Y + num89 + 15 - genRand.Next(30);
				PlaceTile(num90, num91, 237);
				if (Main.tile[num90, num91].type == 237)
				{
					lAltarX = num90 - Main.tile[num90, num91].frameX / 18;
					lAltarY = num91 - Main.tile[num90, num91].frameY / 18;
					break;
				}
				if (num87 < 1000)
				{
					continue;
				}
				num90 = rectangle3.X + num88;
				num91 = rectangle3.Y + num89;
				num90 += genRand.Next(-10, 11);
				for (num91 += genRand.Next(-10, 11); !Main.tile[num90, num91].active(); num91++)
				{
				}
				Main.tile[num90 - 1, num91].active(active: true);
				Main.tile[num90 - 1, num91].slope(0);
				Main.tile[num90 - 1, num91].halfBrick(halfBrick: false);
				Main.tile[num90 - 1, num91].type = 226;
				Main.tile[num90, num91].active(active: true);
				Main.tile[num90, num91].slope(0);
				Main.tile[num90, num91].halfBrick(halfBrick: false);
				Main.tile[num90, num91].type = 226;
				Main.tile[num90 + 1, num91].active(active: true);
				Main.tile[num90 + 1, num91].slope(0);
				Main.tile[num90 + 1, num91].halfBrick(halfBrick: false);
				Main.tile[num90 + 1, num91].type = 226;
				num91 -= 2;
				num90--;
				for (int num92 = -1; num92 <= 3; num92++)
				{
					for (int num93 = -1; num93 <= 1; num93++)
					{
						x = num90 + num92;
						y = num91 + num93;
						Main.tile[x, y].active(active: false);
					}
				}
				lAltarX = num90;
				lAltarY = num91;
				for (int num94 = 0; num94 <= 2; num94++)
				{
					for (int num95 = 0; num95 <= 1; num95++)
					{
						x = num90 + num94;
						y = num91 + num95;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].type = 237;
						Main.tile[x, y].frameX = (short)(num94 * 18);
						Main.tile[x, y].frameY = (short)(num95 * 18);
					}
				}
				for (int num96 = 0; num96 <= 2; num96++)
				{
					for (int num97 = 0; num97 <= 1; num97++)
					{
						x = num90 + num96;
						y = num91 + num97;
						SquareTileFrame(x, y);
					}
				}
				break;
			}
			float num98 = (float)num2 * 1.1f;
			num98 *= 1f + (float)genRand.Next(-25, 26) * 0.01f;
			if (drunkWorldGen)
			{
				num98 *= 1.5f;
			}
			int num99 = 0;
			while (num98 > 0f)
			{
				num99++;
				int num100 = genRand.Next(num2);
				int num101 = genRand.Next(array[num100].X, array[num100].X + array[num100].Width);
				int num102 = genRand.Next(array[num100].Y, array[num100].Y + array[num100].Height);
				if (Main.tile[num101, num102].wall == 87 && !Main.tile[num101, num102].active())
				{
					bool flag5 = false;
					if (genRand.Next(2) == 0)
					{
						int num103 = 1;
						if (genRand.Next(2) == 0)
						{
							num103 = -1;
						}
						for (; !Main.tile[num101, num102].active(); num102 += num103)
						{
						}
						num102 -= num103;
						int num104 = genRand.Next(2);
						int num105 = genRand.Next(3, 10);
						bool flag6 = true;
						for (int num106 = num101 - num105; num106 < num101 + num105; num106++)
						{
							for (int num107 = num102 - num105; num107 < num102 + num105; num107++)
							{
								if (Main.tile[num106, num107].active() && (Main.tile[num106, num107].type == 10 || Main.tile[num106, num107].type == 237))
								{
									flag6 = false;
									break;
								}
							}
						}
						if (flag6)
						{
							for (int num108 = num101 - num105; num108 < num101 + num105; num108++)
							{
								for (int num109 = num102 - num105; num109 < num102 + num105; num109++)
								{
									if (!SolidTile(num108, num109) || Main.tile[num108, num109].type == 232 || SolidTile(num108, num109 - num103))
									{
										continue;
									}
									Main.tile[num108, num109].type = 232;
									flag5 = true;
									if (num104 == 0)
									{
										Main.tile[num108, num109 - 1].type = 232;
										Main.tile[num108, num109 - 1].active(active: true);
										if (drunkWorldGen)
										{
											Main.tile[num108, num109 - 2].type = 232;
											Main.tile[num108, num109 - 2].active(active: true);
										}
									}
									else
									{
										Main.tile[num108, num109 + 1].type = 232;
										Main.tile[num108, num109 + 1].active(active: true);
										if (drunkWorldGen)
										{
											Main.tile[num108, num109 + 2].type = 232;
											Main.tile[num108, num109 + 2].active(active: true);
										}
									}
									num104++;
									if (num104 > 1)
									{
										num104 = 0;
									}
								}
							}
						}
						if (flag5)
						{
							num99 = 0;
							num98 -= 1f;
						}
					}
					else
					{
						int num110 = 1;
						if (genRand.Next(2) == 0)
						{
							num110 = -1;
						}
						for (; !Main.tile[num101, num102].active(); num101 += num110)
						{
						}
						num101 -= num110;
						int num111 = genRand.Next(2);
						int num112 = genRand.Next(3, 10);
						bool flag7 = true;
						for (int num113 = num101 - num112; num113 < num101 + num112; num113++)
						{
							for (int num114 = num102 - num112; num114 < num102 + num112; num114++)
							{
								if (Main.tile[num113, num114].active() && Main.tile[num113, num114].type == 10)
								{
									flag7 = false;
									break;
								}
							}
						}
						if (flag7)
						{
							for (int num115 = num101 - num112; num115 < num101 + num112; num115++)
							{
								for (int num116 = num102 - num112; num116 < num102 + num112; num116++)
								{
									if (!SolidTile(num115, num116) || Main.tile[num115, num116].type == 232 || SolidTile(num115 - num110, num116))
									{
										continue;
									}
									Main.tile[num115, num116].type = 232;
									flag5 = true;
									if (num111 == 0)
									{
										Main.tile[num115 - 1, num116].type = 232;
										Main.tile[num115 - 1, num116].active(active: true);
										if (drunkWorldGen)
										{
											Main.tile[num115 - 2, num116].type = 232;
											Main.tile[num115 - 2, num116].active(active: true);
										}
									}
									else
									{
										Main.tile[num115 + 1, num116].type = 232;
										Main.tile[num115 + 1, num116].active(active: true);
										if (drunkWorldGen)
										{
											Main.tile[num115 - 2, num116].type = 232;
											Main.tile[num115 - 2, num116].active(active: true);
										}
									}
									num111++;
									if (num111 > 1)
									{
										num111 = 0;
									}
								}
							}
						}
						if (flag5)
						{
							num99 = 0;
							num98 -= 1f;
						}
					}
				}
				if (num99 > 1000)
				{
					num99 = 0;
					num98 -= 1f;
				}
			}
			tLeft = num50;
			tRight = num51;
			tTop = num52;
			tBottom = num53;
			tRooms = num2;
		}

		public static void templePart2()
		{
			int minValue = tLeft;
			int maxValue = tRight;
			int minValue2 = tTop;
			int num = tBottom;
			int num2 = tRooms;
			float num3 = (float)num2 * 1.9f;
			num3 *= 1f + (float)genRand.Next(-15, 16) * 0.01f;
			int num4 = 0;
			while (num3 > 0f)
			{
				int num5 = genRand.Next(minValue, maxValue);
				int num6 = genRand.Next(minValue2, num);
				if (Main.tile[num5, num6].wall == 87 && !Main.tile[num5, num6].active())
				{
					if (mayanTrap(num5, num6))
					{
						num3 -= 1f;
						num4 = 0;
					}
					else
					{
						num4++;
					}
				}
				else
				{
					num4++;
				}
				if (num4 > 100)
				{
					num4 = 0;
					num3 -= 1f;
				}
			}
			Main.tileSolid[232] = false;
			float num7 = (float)num2 * 0.35f;
			num7 *= 1f + (float)genRand.Next(-15, 16) * 0.01f;
			int contain = 1293;
			num4 = 0;
			while (num7 > 0f)
			{
				int num8 = genRand.Next(minValue, maxValue);
				int num9 = genRand.Next(minValue2, num);
				if (Main.tile[num8, num9].wall == 87 && !Main.tile[num8, num9].active() && AddBuriedChest(num8, num9, contain, notNearOtherChests: true, 16, trySlope: false, 0))
				{
					num7 -= 1f;
					num4 = 0;
				}
				num4++;
				if (num4 > 10000)
				{
					break;
				}
			}
			float num10 = (float)num2 * 1.25f;
			num10 *= 1f + (float)genRand.Next(-25, 36) * 0.01f;
			num4 = 0;
			while (num10 > 0f)
			{
				num4++;
				int num11 = genRand.Next(minValue, maxValue);
				int num12 = genRand.Next(minValue2, num);
				if (Main.tile[num11, num12].wall != 87 || Main.tile[num11, num12].active())
				{
					continue;
				}
				int num13 = num11;
				int num14 = num12;
				while (!Main.tile[num13, num14].active())
				{
					num14++;
					if (num14 > num)
					{
						break;
					}
				}
				num14--;
				if (num14 <= num)
				{
					PlaceTile(num13, num14, 105, mute: true, forced: false, -1, genRand.Next(43, 46));
					if (Main.tile[num13, num14].type == 105)
					{
						num10 -= 1f;
					}
				}
			}
			float num15 = (float)num2 * 1.35f;
			num15 *= 1f + (float)genRand.Next(-15, 26) * 0.01f;
			num4 = 0;
			while (num15 > 0f)
			{
				num4++;
				int num16 = genRand.Next(minValue, maxValue);
				int num17 = genRand.Next(minValue2, num);
				if (Main.tile[num16, num17].wall == 87 && !Main.tile[num16, num17].active())
				{
					int num18 = num16;
					int num19 = num17;
					while (!Main.tile[num18, num19].active())
					{
						num19++;
						if (num19 > num)
						{
							break;
						}
					}
					num19--;
					if (num19 <= num)
					{
						switch (genRand.Next(3))
						{
						case 0:
							PlaceTile(num18, num19, 18, mute: true, forced: false, -1, 10);
							if (Main.tile[num18, num19].type == 18)
							{
								num15 -= 1f;
							}
							break;
						case 1:
							PlaceTile(num18, num19, 14, mute: true, forced: false, -1, 9);
							if (Main.tile[num18, num19].type == 14)
							{
								num15 -= 1f;
							}
							break;
						case 2:
							PlaceTile(num18, num19, 15, mute: true, forced: false, -1, 12);
							if (Main.tile[num18, num19].type == 15)
							{
								num15 -= 1f;
							}
							break;
						}
					}
				}
				if (num4 > 10000)
				{
					break;
				}
			}
			Main.tileSolid[232] = true;
		}

		public static bool nearPicture(int x, int y)
		{
			for (int i = x - 4; i <= x + 3; i++)
			{
				for (int j = y - 3; j <= y + 2; j++)
				{
					if (Main.tile[i, j].active())
					{
						return true;
					}
				}
			}
			return false;
		}

		public static bool nearPicture2(int x, int y)
		{
			if (Main.tile[x, y].wall != 7 && Main.tile[x, y].wall != 8 && Main.tile[x, y].wall != 9)
			{
				for (int i = x - 8; i <= x + 8; i++)
				{
					for (int j = y - 5; j <= y + 5; j++)
					{
						if (Main.tile[i, j].active() && (Main.tile[i, j].type == 240 || Main.tile[i, j].type == 241 || Main.tile[i, j].type == 242))
						{
							return true;
						}
					}
				}
			}
			else
			{
				for (int k = x - 15; k <= x + 15; k++)
				{
					for (int l = y - 10; l <= y + 10; l++)
					{
						if (Main.tile[k, l].active() && (Main.tile[k, l].type == 240 || Main.tile[k, l].type == 241 || Main.tile[k, l].type == 242))
						{
							return true;
						}
					}
				}
			}
			return false;
		}

		public static void MakeDungeon(int x, int y)
		{
			dEnteranceX = 0;
			numDRooms = 0;
			numDDoors = 0;
			numDungeonPlatforms = 0;
			int num = genRand.Next(3);
			genRand.Next(3);
			ushort num2;
			int num3;
			switch (num)
			{
			case 0:
				num2 = 41;
				num3 = 7;
				crackedType = 481;
				break;
			case 1:
				num2 = 43;
				num3 = 8;
				crackedType = 482;
				break;
			default:
				num2 = 44;
				num3 = 9;
				crackedType = 483;
				break;
			}
			Main.tileSolid[crackedType] = false;
			dungeonLake = true;
			numDDoors = 0;
			numDungeonPlatforms = 0;
			numDRooms = 0;
			dungeonX = x;
			dungeonY = y;
			dMinX = x;
			dMaxX = x;
			dMinY = y;
			dMaxY = y;
			dxStrength1 = genRand.Next(25, 30);
			dyStrength1 = genRand.Next(20, 25);
			dxStrength2 = genRand.Next(35, 50);
			dyStrength2 = genRand.Next(10, 15);
			float num4 = Main.maxTilesX / 60;
			num4 += (float)genRand.Next(0, (int)(num4 / 3f));
			float num5 = num4;
			int num6 = 5;
			DungeonRoom(dungeonX, dungeonY, num2, num3);
			while (num4 > 0f)
			{
				if (dungeonX < dMinX)
				{
					dMinX = dungeonX;
				}
				if (dungeonX > dMaxX)
				{
					dMaxX = dungeonX;
				}
				if (dungeonY > dMaxY)
				{
					dMaxY = dungeonY;
				}
				num4 -= 1f;
				Main.statusText = Lang.gen[58].Value + " " + (int)((num5 - num4) / num5 * 60f) + "%";
				if (num6 > 0)
				{
					num6--;
				}
				if ((num6 == 0) & (genRand.Next(3) == 0))
				{
					num6 = 5;
					if (genRand.Next(2) == 0)
					{
						int num7 = dungeonX;
						int num8 = dungeonY;
						DungeonHalls(dungeonX, dungeonY, num2, num3);
						if (genRand.Next(2) == 0)
						{
							DungeonHalls(dungeonX, dungeonY, num2, num3);
						}
						DungeonRoom(dungeonX, dungeonY, num2, num3);
						dungeonX = num7;
						dungeonY = num8;
					}
					else
					{
						DungeonRoom(dungeonX, dungeonY, num2, num3);
					}
				}
				else
				{
					DungeonHalls(dungeonX, dungeonY, num2, num3);
				}
			}
			DungeonRoom(dungeonX, dungeonY, num2, num3);
			int num9 = dRoomX[0];
			int num10 = dRoomY[0];
			for (int i = 0; i < numDRooms; i++)
			{
				if (dRoomY[i] < num10)
				{
					num9 = dRoomX[i];
					num10 = dRoomY[i];
				}
			}
			dungeonX = num9;
			dungeonY = num10;
			dEnteranceX = num9;
			dSurface = false;
			num6 = 5;
			if (drunkWorldGen)
			{
				dSurface = true;
			}
			while (!dSurface)
			{
				if (num6 > 0)
				{
					num6--;
				}
				if (num6 == 0 && genRand.Next(5) == 0 && (double)dungeonY > Main.worldSurface + 100.0)
				{
					num6 = 10;
					int num11 = dungeonX;
					int num12 = dungeonY;
					DungeonHalls(dungeonX, dungeonY, num2, num3, forceX: true);
					DungeonRoom(dungeonX, dungeonY, num2, num3);
					dungeonX = num11;
					dungeonY = num12;
				}
				DungeonStairs(dungeonX, dungeonY, num2, num3);
			}
			DungeonEnt(dungeonX, dungeonY, num2, num3);
			Main.statusText = Lang.gen[58].Value + " 65%";
			int num13 = Main.maxTilesX * 2;
			int num14;
			for (num14 = 0; num14 < num13; num14++)
			{
				int i2 = genRand.Next(dMinX, dMaxX);
				int num15 = dMinY;
				if ((double)num15 < Main.worldSurface)
				{
					num15 = (int)Main.worldSurface;
				}
				int j = genRand.Next(num15, dMaxY);
				num14 = ((!DungeonPitTrap(i2, j, num2, num3)) ? (num14 + 1) : (num14 + 1500));
			}
			for (int k = 0; k < numDRooms; k++)
			{
				for (int l = dRoomL[k]; l <= dRoomR[k]; l++)
				{
					if (!Main.tile[l, dRoomT[k] - 1].active())
					{
						dungeonPlatformX[numDungeonPlatforms] = l;
						dungeonPlatformY[numDungeonPlatforms] = dRoomT[k] - 1;
						numDungeonPlatforms++;
						break;
					}
				}
				for (int m = dRoomL[k]; m <= dRoomR[k]; m++)
				{
					if (!Main.tile[m, dRoomB[k] + 1].active())
					{
						dungeonPlatformX[numDungeonPlatforms] = m;
						dungeonPlatformY[numDungeonPlatforms] = dRoomB[k] + 1;
						numDungeonPlatforms++;
						break;
					}
				}
				for (int n = dRoomT[k]; n <= dRoomB[k]; n++)
				{
					if (!Main.tile[dRoomL[k] - 1, n].active())
					{
						DDoorX[numDDoors] = dRoomL[k] - 1;
						DDoorY[numDDoors] = n;
						DDoorPos[numDDoors] = -1;
						numDDoors++;
						break;
					}
				}
				for (int num16 = dRoomT[k]; num16 <= dRoomB[k]; num16++)
				{
					if (!Main.tile[dRoomR[k] + 1, num16].active())
					{
						DDoorX[numDDoors] = dRoomR[k] + 1;
						DDoorY[numDDoors] = num16;
						DDoorPos[numDDoors] = 1;
						numDDoors++;
						break;
					}
				}
			}
			Main.statusText = Lang.gen[58].Value + " 70%";
			int num17 = 0;
			int num18 = 1000;
			int num19 = 0;
			int num20 = Main.maxTilesX / 100;
			if (getGoodWorldGen)
			{
				num20 *= 3;
			}
			while (num19 < num20)
			{
				num17++;
				int num21 = genRand.Next(dMinX, dMaxX);
				int num22 = genRand.Next((int)Main.worldSurface + 25, dMaxY);
				if (drunkWorldGen)
				{
					num22 = genRand.Next(dungeonY + 25, dMaxY);
				}
				int num23 = num21;
				if (Main.tile[num21, num22].wall == num3 && !Main.tile[num21, num22].active())
				{
					int num24 = 1;
					if (genRand.Next(2) == 0)
					{
						num24 = -1;
					}
					for (; !Main.tile[num21, num22].active(); num22 += num24)
					{
					}
					if (Main.tile[num21 - 1, num22].active() && Main.tile[num21 + 1, num22].active() && Main.tile[num21 - 1, num22].type != crackedType && !Main.tile[num21 - 1, num22 - num24].active() && !Main.tile[num21 + 1, num22 - num24].active())
					{
						num19++;
						int num25 = genRand.Next(5, 13);
						while (Main.tile[num21 - 1, num22].active() && Main.tile[num21 - 1, num22].type != crackedType && Main.tile[num21, num22 + num24].active() && Main.tile[num21, num22].active() && !Main.tile[num21, num22 - num24].active() && num25 > 0)
						{
							Main.tile[num21, num22].type = 48;
							if (!Main.tile[num21 - 1, num22 - num24].active() && !Main.tile[num21 + 1, num22 - num24].active())
							{
								Main.tile[num21, num22 - num24].Clear(TileDataType.Slope);
								Main.tile[num21, num22 - num24].type = 48;
								Main.tile[num21, num22 - num24].active(active: true);
								Main.tile[num21, num22 - num24 * 2].Clear(TileDataType.Slope);
								Main.tile[num21, num22 - num24 * 2].type = 48;
								Main.tile[num21, num22 - num24 * 2].active(active: true);
							}
							num21--;
							num25--;
						}
						num25 = genRand.Next(5, 13);
						num21 = num23 + 1;
						while (Main.tile[num21 + 1, num22].active() && Main.tile[num21 + 1, num22].type != crackedType && Main.tile[num21, num22 + num24].active() && Main.tile[num21, num22].active() && !Main.tile[num21, num22 - num24].active() && num25 > 0)
						{
							Main.tile[num21, num22].type = 48;
							if (!Main.tile[num21 - 1, num22 - num24].active() && !Main.tile[num21 + 1, num22 - num24].active())
							{
								Main.tile[num21, num22 - num24].Clear(TileDataType.Slope);
								Main.tile[num21, num22 - num24].type = 48;
								Main.tile[num21, num22 - num24].active(active: true);
								Main.tile[num21, num22 - num24 * 2].Clear(TileDataType.Slope);
								Main.tile[num21, num22 - num24 * 2].type = 48;
								Main.tile[num21, num22 - num24 * 2].active(active: true);
							}
							num21++;
							num25--;
						}
					}
				}
				if (num17 > num18)
				{
					num17 = 0;
					num19++;
				}
			}
			num17 = 0;
			num18 = 1000;
			num19 = 0;
			Main.statusText = Lang.gen[58].Value + " 75%";
			while (num19 < num20)
			{
				num17++;
				int num26 = genRand.Next(dMinX, dMaxX);
				int num27 = genRand.Next((int)Main.worldSurface + 25, dMaxY);
				int num28 = num27;
				if (Main.tile[num26, num27].wall == num3 && !Main.tile[num26, num27].active())
				{
					int num29 = 1;
					if (genRand.Next(2) == 0)
					{
						num29 = -1;
					}
					for (; num26 > 5 && num26 < Main.maxTilesX - 5 && !Main.tile[num26, num27].active(); num26 += num29)
					{
					}
					if (Main.tile[num26, num27 - 1].active() && Main.tile[num26, num27 + 1].active() && Main.tile[num26, num27 - 1].type != crackedType && !Main.tile[num26 - num29, num27 - 1].active() && !Main.tile[num26 - num29, num27 + 1].active())
					{
						num19++;
						int num30 = genRand.Next(5, 13);
						while (Main.tile[num26, num27 - 1].active() && Main.tile[num26, num27 - 1].type != crackedType && Main.tile[num26 + num29, num27].active() && Main.tile[num26, num27].active() && !Main.tile[num26 - num29, num27].active() && num30 > 0)
						{
							Main.tile[num26, num27].type = 48;
							if (!Main.tile[num26 - num29, num27 - 1].active() && !Main.tile[num26 - num29, num27 + 1].active())
							{
								Main.tile[num26 - num29, num27].type = 48;
								Main.tile[num26 - num29, num27].active(active: true);
								Main.tile[num26 - num29, num27].Clear(TileDataType.Slope);
								Main.tile[num26 - num29 * 2, num27].type = 48;
								Main.tile[num26 - num29 * 2, num27].active(active: true);
								Main.tile[num26 - num29 * 2, num27].Clear(TileDataType.Slope);
							}
							num27--;
							num30--;
						}
						num30 = genRand.Next(5, 13);
						num27 = num28 + 1;
						while (Main.tile[num26, num27 + 1].active() && Main.tile[num26, num27 + 1].type != crackedType && Main.tile[num26 + num29, num27].active() && Main.tile[num26, num27].active() && !Main.tile[num26 - num29, num27].active() && num30 > 0)
						{
							Main.tile[num26, num27].type = 48;
							if (!Main.tile[num26 - num29, num27 - 1].active() && !Main.tile[num26 - num29, num27 + 1].active())
							{
								Main.tile[num26 - num29, num27].type = 48;
								Main.tile[num26 - num29, num27].active(active: true);
								Main.tile[num26 - num29, num27].Clear(TileDataType.Slope);
								Main.tile[num26 - num29 * 2, num27].type = 48;
								Main.tile[num26 - num29 * 2, num27].active(active: true);
								Main.tile[num26 - num29 * 2, num27].Clear(TileDataType.Slope);
							}
							num27++;
							num30--;
						}
					}
				}
				if (num17 > num18)
				{
					num17 = 0;
					num19++;
				}
			}
			Main.statusText = Lang.gen[58].Value + " 80%";
			for (int num31 = 0; num31 < numDDoors; num31++)
			{
				int num32 = DDoorX[num31] - 10;
				int num33 = DDoorX[num31] + 10;
				int num34 = 100;
				int num35 = 0;
				int num36 = 0;
				int num37 = 0;
				for (int num38 = num32; num38 < num33; num38++)
				{
					bool flag = true;
					int num39 = DDoorY[num31];
					while (num39 > 10 && !Main.tile[num38, num39].active())
					{
						num39--;
					}
					if (!Main.tileDungeon[Main.tile[num38, num39].type])
					{
						flag = false;
					}
					num36 = num39;
					for (num39 = DDoorY[num31]; !Main.tile[num38, num39].active(); num39++)
					{
					}
					if (!Main.tileDungeon[Main.tile[num38, num39].type])
					{
						flag = false;
					}
					num37 = num39;
					if (num37 - num36 < 3)
					{
						continue;
					}
					int num40 = num38 - 20;
					int num41 = num38 + 20;
					int num42 = num37 - 10;
					int num43 = num37 + 10;
					for (int num44 = num40; num44 < num41; num44++)
					{
						for (int num45 = num42; num45 < num43; num45++)
						{
							if (Main.tile[num44, num45].active() && Main.tile[num44, num45].type == 10)
							{
								flag = false;
								break;
							}
						}
					}
					if (flag)
					{
						for (int num46 = num37 - 3; num46 < num37; num46++)
						{
							for (int num47 = num38 - 3; num47 <= num38 + 3; num47++)
							{
								if (Main.tile[num47, num46].active())
								{
									flag = false;
									break;
								}
							}
						}
					}
					if (flag && num37 - num36 < 20)
					{
						bool flag2 = false;
						if (DDoorPos[num31] == 0 && num37 - num36 < num34)
						{
							flag2 = true;
						}
						if (DDoorPos[num31] == -1 && num38 > num35)
						{
							flag2 = true;
						}
						if (DDoorPos[num31] == 1 && (num38 < num35 || num35 == 0))
						{
							flag2 = true;
						}
						if (flag2)
						{
							num35 = num38;
							num34 = num37 - num36;
						}
					}
				}
				if (num34 >= 20)
				{
					continue;
				}
				int num48 = num35;
				int num49 = DDoorY[num31];
				int num50 = num49;
				for (; !Main.tile[num48, num49].active(); num49++)
				{
					Main.tile[num48, num49].active(active: false);
				}
				while (!Main.tile[num48, num50].active())
				{
					num50--;
				}
				num49--;
				num50++;
				for (int num51 = num50; num51 < num49 - 2; num51++)
				{
					Main.tile[num48, num51].Clear(TileDataType.Slope);
					Main.tile[num48, num51].active(active: true);
					Main.tile[num48, num51].type = num2;
				}
				int style = 13;
				if (genRand.Next(3) == 0)
				{
					switch (num3)
					{
					case 7:
						style = 16;
						break;
					case 8:
						style = 17;
						break;
					case 9:
						style = 18;
						break;
					}
				}
				PlaceTile(num48, num49, 10, mute: true, forced: false, -1, style);
				num48--;
				int num52 = num49 - 3;
				while (!Main.tile[num48, num52].active())
				{
					num52--;
				}
				if (num49 - num52 < num49 - num50 + 5 && Main.tileDungeon[Main.tile[num48, num52].type])
				{
					for (int num53 = num49 - 4 - genRand.Next(3); num53 > num52; num53--)
					{
						Main.tile[num48, num53].Clear(TileDataType.Slope);
						Main.tile[num48, num53].active(active: true);
						Main.tile[num48, num53].type = num2;
					}
				}
				num48 += 2;
				num52 = num49 - 3;
				while (!Main.tile[num48, num52].active())
				{
					num52--;
				}
				if (num49 - num52 < num49 - num50 + 5 && Main.tileDungeon[Main.tile[num48, num52].type])
				{
					for (int num54 = num49 - 4 - genRand.Next(3); num54 > num52; num54--)
					{
						Main.tile[num48, num54].active(active: true);
						Main.tile[num48, num54].Clear(TileDataType.Slope);
						Main.tile[num48, num54].type = num2;
					}
				}
				num49++;
				num48--;
				Main.tile[num48 - 1, num49].active(active: true);
				Main.tile[num48 - 1, num49].type = num2;
				Main.tile[num48 - 1, num49].Clear(TileDataType.Slope);
				Main.tile[num48 + 1, num49].active(active: true);
				Main.tile[num48 + 1, num49].type = num2;
				Main.tile[num48 + 1, num49].Clear(TileDataType.Slope);
			}
			int[] array = new int[3];
			switch (num3)
			{
			case 7:
				array[0] = 7;
				array[1] = 94;
				array[2] = 95;
				break;
			case 9:
				array[0] = 9;
				array[1] = 96;
				array[2] = 97;
				break;
			default:
				array[0] = 8;
				array[1] = 98;
				array[2] = 99;
				break;
			}
			for (int num55 = 0; num55 < 5; num55++)
			{
				for (int num56 = 0; num56 < 3; num56++)
				{
					int num57 = genRand.Next(40, 240);
					int num58 = genRand.Next(dMinX, dMaxX);
					int num59 = genRand.Next(dMinY, dMaxY);
					for (int num60 = num58 - num57; num60 < num58 + num57; num60++)
					{
						for (int num61 = num59 - num57; num61 < num59 + num57; num61++)
						{
							if ((double)num61 > Main.worldSurface)
							{
								float num62 = Math.Abs(num58 - num60);
								float num63 = Math.Abs(num59 - num61);
								if (Math.Sqrt(num62 * num62 + num63 * num63) < (double)num57 * 0.4 && Main.wallDungeon[Main.tile[num60, num61].wall])
								{
									Spread.WallDungeon(num60, num61, array[num56]);
								}
							}
						}
					}
				}
			}
			Main.statusText = Lang.gen[58].Value + " 85%";
			for (int num64 = 0; num64 < numDungeonPlatforms; num64++)
			{
				int num65 = dungeonPlatformX[num64];
				int num66 = dungeonPlatformY[num64];
				int num67 = Main.maxTilesX;
				int num68 = 10;
				if ((double)num66 < Main.worldSurface + 50.0)
				{
					num68 = 20;
				}
				for (int num69 = num66 - 5; num69 <= num66 + 5; num69++)
				{
					int num70 = num65;
					int num71 = num65;
					bool flag3 = false;
					if (Main.tile[num70, num69].active())
					{
						flag3 = true;
					}
					else
					{
						while (!Main.tile[num70, num69].active())
						{
							num70--;
							if (!Main.tileDungeon[Main.tile[num70, num69].type] || num70 == 0)
							{
								flag3 = true;
								break;
							}
						}
						while (!Main.tile[num71, num69].active())
						{
							num71++;
							if (!Main.tileDungeon[Main.tile[num71, num69].type] || num71 == Main.maxTilesX - 1)
							{
								flag3 = true;
								break;
							}
						}
					}
					if (flag3 || num71 - num70 > num68)
					{
						continue;
					}
					bool flag4 = true;
					int num72 = num65 - num68 / 2 - 2;
					int num73 = num65 + num68 / 2 + 2;
					int num74 = num69 - 5;
					int num75 = num69 + 5;
					for (int num76 = num72; num76 <= num73; num76++)
					{
						for (int num77 = num74; num77 <= num75; num77++)
						{
							if (Main.tile[num76, num77].active() && Main.tile[num76, num77].type == 19)
							{
								flag4 = false;
								break;
							}
						}
					}
					for (int num78 = num69 + 3; num78 >= num69 - 5; num78--)
					{
						if (Main.tile[num65, num78].active())
						{
							flag4 = false;
							break;
						}
					}
					if (flag4)
					{
						num67 = num69;
						break;
					}
				}
				if (num67 <= num66 - 10 || num67 >= num66 + 10)
				{
					continue;
				}
				int num79 = num65;
				int num80 = num67;
				int num81 = num65 + 1;
				while (!Main.tile[num79, num80].active())
				{
					Main.tile[num79, num80].active(active: true);
					Main.tile[num79, num80].type = 19;
					Main.tile[num79, num80].Clear(TileDataType.Slope);
					switch (num3)
					{
					case 7:
						Main.tile[num79, num80].frameY = 108;
						break;
					case 8:
						Main.tile[num79, num80].frameY = 144;
						break;
					default:
						Main.tile[num79, num80].frameY = 126;
						break;
					}
					TileFrame(num79, num80);
					num79--;
				}
				for (; !Main.tile[num81, num80].active(); num81++)
				{
					Main.tile[num81, num80].active(active: true);
					Main.tile[num81, num80].type = 19;
					Main.tile[num81, num80].Clear(TileDataType.Slope);
					switch (num3)
					{
					case 7:
						Main.tile[num81, num80].frameY = 108;
						break;
					case 8:
						Main.tile[num81, num80].frameY = 144;
						break;
					default:
						Main.tile[num81, num80].frameY = 126;
						break;
					}
					TileFrame(num81, num80);
				}
			}
			int num82 = 5;
			if (drunkWorldGen)
			{
				num82 = 6;
			}
			for (int num83 = 0; num83 < num82; num83++)
			{
				bool flag5 = false;
				while (!flag5)
				{
					int num84 = genRand.Next(dMinX, dMaxX);
					int num85 = genRand.Next((int)Main.worldSurface, dMaxY);
					if (!Main.wallDungeon[Main.tile[num84, num85].wall] || Main.tile[num84, num85].active())
					{
						continue;
					}
					ushort chestTileType = 21;
					int contain = 0;
					int style2 = 0;
					switch (num83)
					{
					case 0:
						style2 = 23;
						contain = 1156;
						break;
					case 1:
						if (!crimson)
						{
							style2 = 24;
							contain = 1571;
						}
						else
						{
							style2 = 25;
							contain = 1569;
						}
						break;
					case 5:
						if (crimson)
						{
							style2 = 24;
							contain = 1571;
						}
						else
						{
							style2 = 25;
							contain = 1569;
						}
						break;
					case 2:
						style2 = 26;
						contain = 1260;
						break;
					case 3:
						style2 = 27;
						contain = 1572;
						break;
					case 4:
						chestTileType = 467;
						style2 = 13;
						contain = 4607;
						break;
					}
					flag5 = AddBuriedChest(num84, num85, contain, notNearOtherChests: false, style2, trySlope: false, chestTileType);
				}
			}
			int[] array2 = new int[3]
			{
				genRand.Next(9, 13),
				genRand.Next(9, 13),
				0
			};
			while (array2[1] == array2[0])
			{
				array2[1] = genRand.Next(9, 13);
			}
			array2[2] = genRand.Next(9, 13);
			while (array2[2] == array2[0] || array2[2] == array2[1])
			{
				array2[2] = genRand.Next(9, 13);
			}
			Main.statusText = Lang.gen[58].Value + " 90%";
			num17 = 0;
			num18 = 1000;
			num19 = 0;
			while (num19 < Main.maxTilesX / 20)
			{
				num17++;
				int num86 = genRand.Next(dMinX, dMaxX);
				int num87 = genRand.Next(dMinY, dMaxY);
				bool flag6 = true;
				if (Main.wallDungeon[Main.tile[num86, num87].wall] && !Main.tile[num86, num87].active())
				{
					int num88 = 1;
					if (genRand.Next(2) == 0)
					{
						num88 = -1;
					}
					while (flag6 && !Main.tile[num86, num87].active())
					{
						num86 -= num88;
						if (num86 < 5 || num86 > Main.maxTilesX - 5)
						{
							flag6 = false;
						}
						else if (Main.tile[num86, num87].active() && !Main.tileDungeon[Main.tile[num86, num87].type])
						{
							flag6 = false;
						}
					}
					if (flag6 && Main.tile[num86, num87].active() && Main.tileDungeon[Main.tile[num86, num87].type] && Main.tile[num86, num87 - 1].active() && Main.tileDungeon[Main.tile[num86, num87 - 1].type] && Main.tile[num86, num87 + 1].active() && Main.tileDungeon[Main.tile[num86, num87 + 1].type])
					{
						num86 += num88;
						for (int num89 = num86 - 3; num89 <= num86 + 3; num89++)
						{
							for (int num90 = num87 - 3; num90 <= num87 + 3; num90++)
							{
								if (Main.tile[num89, num90].active() && Main.tile[num89, num90].type == 19)
								{
									flag6 = false;
									break;
								}
							}
						}
						if (flag6 && (!Main.tile[num86, num87 - 1].active() & !Main.tile[num86, num87 - 2].active() & !Main.tile[num86, num87 - 3].active()))
						{
							int num91 = num86;
							int num92 = num86;
							for (; num91 > dMinX && num91 < dMaxX && !Main.tile[num91, num87].active() && !Main.tile[num91, num87 - 1].active() && !Main.tile[num91, num87 + 1].active(); num91 += num88)
							{
							}
							num91 = Math.Abs(num86 - num91);
							bool flag7 = false;
							if (genRand.Next(2) == 0)
							{
								flag7 = true;
							}
							if (num91 > 5)
							{
								for (int num93 = genRand.Next(1, 4); num93 > 0; num93--)
								{
									Main.tile[num86, num87].active(active: true);
									Main.tile[num86, num87].Clear(TileDataType.Slope);
									Main.tile[num86, num87].type = 19;
									if (Main.tile[num86, num87].wall == array[0])
									{
										Main.tile[num86, num87].frameY = (short)(18 * array2[0]);
									}
									else if (Main.tile[num86, num87].wall == array[1])
									{
										Main.tile[num86, num87].frameY = (short)(18 * array2[1]);
									}
									else
									{
										Main.tile[num86, num87].frameY = (short)(18 * array2[2]);
									}
									TileFrame(num86, num87);
									if (flag7)
									{
										PlaceTile(num86, num87 - 1, 50, mute: true);
										if (genRand.Next(50) == 0 && (double)num87 > (Main.worldSurface + Main.rockLayer) / 2.0 && Main.tile[num86, num87 - 1].type == 50)
										{
											Main.tile[num86, num87 - 1].frameX = 90;
										}
									}
									num86 += num88;
								}
								num17 = 0;
								num19++;
								if (!flag7 && genRand.Next(2) == 0)
								{
									num86 = num92;
									num87--;
									int num94 = 0;
									if (genRand.Next(4) == 0)
									{
										num94 = 1;
									}
									switch (num94)
									{
									case 0:
										num94 = 13;
										break;
									case 1:
										num94 = 49;
										break;
									}
									PlaceTile(num86, num87, num94, mute: true);
									if (Main.tile[num86, num87].type == 13)
									{
										if (genRand.Next(2) == 0)
										{
											Main.tile[num86, num87].frameX = 18;
										}
										else
										{
											Main.tile[num86, num87].frameX = 36;
										}
									}
								}
							}
						}
					}
				}
				if (num17 > num18)
				{
					num17 = 0;
					num19++;
				}
			}
			Main.statusText = Lang.gen[58].Value + " 95%";
			int num95 = 1;
			for (int num96 = 0; num96 < numDRooms; num96++)
			{
				int num97 = 0;
				while (num97 < 1000)
				{
					int num98 = (int)((double)dRoomSize[num96] * 0.4);
					int i3 = dRoomX[num96] + genRand.Next(-num98, num98 + 1);
					int num99 = dRoomY[num96] + genRand.Next(-num98, num98 + 1);
					int num100 = 0;
					int style3 = 2;
					if (num95 == 1)
					{
						num95++;
					}
					switch (num95)
					{
					case 2:
						num100 = 155;
						break;
					case 3:
						num100 = 156;
						break;
					case 4:
						num100 = 157;
						break;
					case 5:
						num100 = 163;
						break;
					case 6:
						num100 = 113;
						break;
					case 7:
						num100 = 3317;
						break;
					case 8:
						num100 = 327;
						style3 = 0;
						break;
					default:
						num100 = 164;
						num95 = 0;
						break;
					}
					if ((double)num99 < Main.worldSurface + 50.0)
					{
						num100 = 327;
						style3 = 0;
					}
					if (num100 == 0 && genRand.Next(2) == 0)
					{
						num97 = 1000;
						continue;
					}
					if (AddBuriedChest(i3, num99, num100, notNearOtherChests: false, style3, trySlope: false, 0))
					{
						num97 += 1000;
						num95++;
					}
					num97++;
				}
			}
			dMinX -= 25;
			dMaxX += 25;
			dMinY -= 25;
			dMaxY += 25;
			if (dMinX < 0)
			{
				dMinX = 0;
			}
			if (dMaxX > Main.maxTilesX)
			{
				dMaxX = Main.maxTilesX;
			}
			if (dMinY < 0)
			{
				dMinY = 0;
			}
			if (dMaxY > Main.maxTilesY)
			{
				dMaxY = Main.maxTilesY;
			}
			num17 = 0;
			num18 = 1000;
			num19 = 0;
			MakeDungeon_Lights(num2, num17, num18, num19, array);
			num17 = 0;
			num18 = 1000;
			num19 = 0;
			MakeDungeon_Traps(num17, num18, num19);
			float count = MakeDungeon_GroundFurniture(num3);
			count = MakeDungeon_Pictures(array, count);
			count = MakeDungeon_Banners(array, count);
		}

		private static void MakeDungeon_Traps(int failCount, int failMax, int numAdd)
		{
			while (numAdd < Main.maxTilesX / 500)
			{
				failCount++;
				int num = genRand.Next(dMinX, dMaxX);
				int num2 = genRand.Next(dMinY, dMaxY);
				while ((double)num2 < Main.worldSurface)
				{
					num2 = genRand.Next(dMinY, dMaxY);
				}
				if (Main.wallDungeon[Main.tile[num, num2].wall] && placeTrap(num, num2, 0))
				{
					failCount = failMax;
				}
				if (failCount > failMax)
				{
					numAdd++;
					failCount = 0;
				}
			}
		}

		private static void MakeDungeon_Lights(ushort tileType, int failCount, int failMax, int numAdd, int[] roomWall)
		{
			int[] array = new int[3]
			{
				genRand.Next(7),
				genRand.Next(7),
				0
			};
			while (array[1] == array[0])
			{
				array[1] = genRand.Next(7);
			}
			array[2] = genRand.Next(7);
			while (array[2] == array[0] || array[2] == array[1])
			{
				array[2] = genRand.Next(7);
			}
			while (numAdd < Main.maxTilesX / 150)
			{
				failCount++;
				int num = genRand.Next(dMinX, dMaxX);
				int num2 = genRand.Next(dMinY, dMaxY);
				if (Main.wallDungeon[Main.tile[num, num2].wall])
				{
					for (int num3 = num2; num3 > dMinY; num3--)
					{
						if (Main.tile[num, num3 - 1].active() && Main.tile[num, num3 - 1].type == tileType)
						{
							bool flag = false;
							for (int i = num - 15; i < num + 15; i++)
							{
								for (int j = num3 - 15; j < num3 + 15; j++)
								{
									if (i > 0 && i < Main.maxTilesX && j > 0 && j < Main.maxTilesY && (Main.tile[i, j].type == 42 || Main.tile[i, j].type == 34))
									{
										flag = true;
										break;
									}
								}
							}
							if (Main.tile[num - 1, num3].active() || Main.tile[num + 1, num3].active() || Main.tile[num - 1, num3 + 1].active() || Main.tile[num + 1, num3 + 1].active() || Main.tile[num, num3 + 2].active())
							{
								flag = true;
							}
							if (flag)
							{
								break;
							}
							bool flag2 = false;
							if (!flag2 && genRand.Next(7) == 0)
							{
								int style = 27;
								switch (roomWall[0])
								{
								case 7:
									style = 27;
									break;
								case 8:
									style = 28;
									break;
								case 9:
									style = 29;
									break;
								}
								bool flag3 = false;
								for (int k = 0; k < 15; k++)
								{
									if (SolidTile(num, num3 + k))
									{
										flag3 = true;
										break;
									}
								}
								if (!flag3)
								{
									PlaceChand(num, num3, 34, style);
								}
								if (Main.tile[num, num3].type == 34)
								{
									flag2 = true;
									failCount = 0;
									numAdd++;
									for (int l = 0; l < 1000; l++)
									{
										int num4 = num + genRand.Next(-12, 13);
										int num5 = num3 + genRand.Next(3, 21);
										if (Main.tile[num4, num5].active() || Main.tile[num4, num5 + 1].active() || !Main.tileDungeon[Main.tile[num4 - 1, num5].type] || !Main.tileDungeon[Main.tile[num4 + 1, num5].type] || !Collision.CanHit(new Vector2(num4 * 16, num5 * 16), 16, 16, new Vector2(num * 16, num3 * 16 + 1), 16, 16))
										{
											continue;
										}
										if (((SolidTile(num4 - 1, num5) && Main.tile[num4 - 1, num5].type != 10) || (SolidTile(num4 + 1, num5) && Main.tile[num4 + 1, num5].type != 10) || SolidTile(num4, num5 + 1)) && Main.wallDungeon[Main.tile[num4, num5].wall] && (Main.tileDungeon[Main.tile[num4 - 1, num5].type] || Main.tileDungeon[Main.tile[num4 + 1, num5].type]))
										{
											PlaceTile(num4, num5, 136, mute: true);
										}
										if (!Main.tile[num4, num5].active())
										{
											continue;
										}
										while (num4 != num || num5 != num3)
										{
											Main.tile[num4, num5].wire(wire: true);
											if (num4 > num)
											{
												num4--;
											}
											if (num4 < num)
											{
												num4++;
											}
											Main.tile[num4, num5].wire(wire: true);
											if (num5 > num3)
											{
												num5--;
											}
											if (num5 < num3)
											{
												num5++;
											}
											Main.tile[num4, num5].wire(wire: true);
										}
										if (genRand.Next(3) > 0)
										{
											Main.tile[num, num3].frameX = 18;
											Main.tile[num, num3 + 1].frameX = 18;
										}
										break;
									}
								}
							}
							if (flag2)
							{
								break;
							}
							int style2 = array[0];
							if (Main.tile[num, num3].wall == roomWall[1])
							{
								style2 = array[1];
							}
							if (Main.tile[num, num3].wall == roomWall[2])
							{
								style2 = array[2];
							}
							Place1x2Top(num, num3, 42, style2);
							if (Main.tile[num, num3].type != 42)
							{
								break;
							}
							flag2 = true;
							failCount = 0;
							numAdd++;
							for (int m = 0; m < 1000; m++)
							{
								int num6 = num + genRand.Next(-12, 13);
								int num7 = num3 + genRand.Next(3, 21);
								if (Main.tile[num6, num7].active() || Main.tile[num6, num7 + 1].active() || Main.tile[num6 - 1, num7].type == 48 || Main.tile[num6 + 1, num7].type == 48 || !Collision.CanHit(new Vector2(num6 * 16, num7 * 16), 16, 16, new Vector2(num * 16, num3 * 16 + 1), 16, 16))
								{
									continue;
								}
								if ((SolidTile(num6 - 1, num7) && Main.tile[num6 - 1, num7].type != 10) || (SolidTile(num6 + 1, num7) && Main.tile[num6 + 1, num7].type != 10) || SolidTile(num6, num7 + 1))
								{
									PlaceTile(num6, num7, 136, mute: true);
								}
								if (!Main.tile[num6, num7].active())
								{
									continue;
								}
								while (num6 != num || num7 != num3)
								{
									Main.tile[num6, num7].wire(wire: true);
									if (num6 > num)
									{
										num6--;
									}
									if (num6 < num)
									{
										num6++;
									}
									Main.tile[num6, num7].wire(wire: true);
									if (num7 > num3)
									{
										num7--;
									}
									if (num7 < num3)
									{
										num7++;
									}
									Main.tile[num6, num7].wire(wire: true);
								}
								if (genRand.Next(3) > 0)
								{
									Main.tile[num, num3].frameX = 18;
									Main.tile[num, num3 + 1].frameX = 18;
								}
								break;
							}
							break;
						}
					}
				}
				if (failCount > failMax)
				{
					numAdd++;
					failCount = 0;
				}
			}
		}

		private static float MakeDungeon_Banners(int[] roomWall, float count)
		{
			count = 840000f / (float)Main.maxTilesX;
			for (int i = 0; (float)i < count; i++)
			{
				int num = genRand.Next(dMinX, dMaxX);
				int num2 = genRand.Next(dMinY, dMaxY);
				while (!Main.wallDungeon[Main.tile[num, num2].wall] || Main.tile[num, num2].active())
				{
					num = genRand.Next(dMinX, dMaxX);
					num2 = genRand.Next(dMinY, dMaxY);
				}
				while (!SolidTile(num, num2) && num2 > 10)
				{
					num2--;
				}
				num2++;
				if (!Main.wallDungeon[Main.tile[num, num2].wall] || Main.tile[num, num2 - 1].type == 48 || Main.tile[num, num2].active() || Main.tile[num, num2 + 1].active() || Main.tile[num, num2 + 2].active() || Main.tile[num, num2 + 3].active())
				{
					continue;
				}
				bool flag = true;
				for (int j = num - 1; j <= num + 1; j++)
				{
					for (int k = num2; k <= num2 + 3; k++)
					{
						if (Main.tile[j, k].active() && (Main.tile[j, k].type == 10 || Main.tile[j, k].type == 11 || Main.tile[j, k].type == 91))
						{
							flag = false;
						}
					}
				}
				if (flag)
				{
					int num3 = 10;
					if (Main.tile[num, num2].wall == roomWall[1])
					{
						num3 = 12;
					}
					if (Main.tile[num, num2].wall == roomWall[2])
					{
						num3 = 14;
					}
					num3 += genRand.Next(2);
					PlaceTile(num, num2, 91, mute: true, forced: false, -1, num3);
				}
			}
			return count;
		}

		private static float MakeDungeon_Pictures(int[] roomWall, float count)
		{
			count = 420000f / (float)Main.maxTilesX;
			for (int i = 0; (float)i < count; i++)
			{
				int num = genRand.Next(dMinX, dMaxX);
				int num2 = genRand.Next((int)Main.worldSurface, dMaxY);
				while (!Main.wallDungeon[Main.tile[num, num2].wall] || Main.tile[num, num2].active())
				{
					num = genRand.Next(dMinX, dMaxX);
					num2 = genRand.Next((int)Main.worldSurface, dMaxY);
				}
				int num3 = num;
				int num4 = num;
				int num5 = num2;
				int num6 = num2;
				int num7 = 0;
				int num8 = 0;
				for (int j = 0; j < 2; j++)
				{
					num3 = num;
					num4 = num;
					while (!Main.tile[num3, num2].active() && Main.wallDungeon[Main.tile[num3, num2].wall])
					{
						num3--;
					}
					num3++;
					for (; !Main.tile[num4, num2].active() && Main.wallDungeon[Main.tile[num4, num2].wall]; num4++)
					{
					}
					num4--;
					num = (num3 + num4) / 2;
					num5 = num2;
					num6 = num2;
					while (!Main.tile[num, num5].active() && Main.wallDungeon[Main.tile[num, num5].wall])
					{
						num5--;
					}
					num5++;
					for (; !Main.tile[num, num6].active() && Main.wallDungeon[Main.tile[num, num6].wall]; num6++)
					{
					}
					num6--;
					num2 = (num5 + num6) / 2;
				}
				num3 = num;
				num4 = num;
				while (!Main.tile[num3, num2].active() && !Main.tile[num3, num2 - 1].active() && !Main.tile[num3, num2 + 1].active())
				{
					num3--;
				}
				num3++;
				for (; !Main.tile[num4, num2].active() && !Main.tile[num4, num2 - 1].active() && !Main.tile[num4, num2 + 1].active(); num4++)
				{
				}
				num4--;
				num5 = num2;
				num6 = num2;
				while (!Main.tile[num, num5].active() && !Main.tile[num - 1, num5].active() && !Main.tile[num + 1, num5].active())
				{
					num5--;
				}
				num5++;
				for (; !Main.tile[num, num6].active() && !Main.tile[num - 1, num6].active() && !Main.tile[num + 1, num6].active(); num6++)
				{
				}
				num6--;
				num = (num3 + num4) / 2;
				num2 = (num5 + num6) / 2;
				num7 = num4 - num3;
				num8 = num6 - num5;
				if (num7 <= 7 || num8 <= 5)
				{
					continue;
				}
				bool[] array = new bool[3]
				{
					true,
					false,
					false
				};
				if (num7 > num8 * 3 && num7 > 21)
				{
					array[1] = true;
				}
				if (num8 > num7 * 3 && num8 > 21)
				{
					array[2] = true;
				}
				int num9 = genRand.Next(3);
				if (Main.tile[num, num2].wall == roomWall[0])
				{
					num9 = 0;
				}
				while (!array[num9])
				{
					num9 = genRand.Next(3);
				}
				if (nearPicture2(num, num2))
				{
					num9 = -1;
				}
				switch (num9)
				{
				case 0:
				{
					Vector2 vector2 = randPictureTile();
					if (Main.tile[num, num2].wall != roomWall[0])
					{
						vector2 = randBoneTile();
					}
					int type2 = (int)vector2.X;
					int style2 = (int)vector2.Y;
					if (!nearPicture(num, num2))
					{
						PlaceTile(num, num2, type2, mute: true, forced: false, -1, style2);
					}
					break;
				}
				case 1:
				{
					Vector2 vector3 = randPictureTile();
					if (Main.tile[num, num2].wall != roomWall[0])
					{
						vector3 = randBoneTile();
					}
					int type3 = (int)vector3.X;
					int style3 = (int)vector3.Y;
					if (!Main.tile[num, num2].active())
					{
						PlaceTile(num, num2, type3, mute: true, forced: false, -1, style3);
					}
					int num13 = num;
					int num14 = num2;
					int num15 = num2;
					for (int m = 0; m < 2; m++)
					{
						num += 7;
						num5 = num15;
						num6 = num15;
						while (!Main.tile[num, num5].active() && !Main.tile[num - 1, num5].active() && !Main.tile[num + 1, num5].active())
						{
							num5--;
						}
						num5++;
						for (; !Main.tile[num, num6].active() && !Main.tile[num - 1, num6].active() && !Main.tile[num + 1, num6].active(); num6++)
						{
						}
						num6--;
						num15 = (num5 + num6) / 2;
						vector3 = randPictureTile();
						if (Main.tile[num, num15].wall != roomWall[0])
						{
							vector3 = randBoneTile();
						}
						type3 = (int)vector3.X;
						style3 = (int)vector3.Y;
						if (Math.Abs(num14 - num15) >= 4 || nearPicture(num, num15))
						{
							break;
						}
						PlaceTile(num, num15, type3, mute: true, forced: false, -1, style3);
					}
					num15 = num2;
					num = num13;
					for (int n = 0; n < 2; n++)
					{
						num -= 7;
						num5 = num15;
						num6 = num15;
						while (!Main.tile[num, num5].active() && !Main.tile[num - 1, num5].active() && !Main.tile[num + 1, num5].active())
						{
							num5--;
						}
						num5++;
						for (; !Main.tile[num, num6].active() && !Main.tile[num - 1, num6].active() && !Main.tile[num + 1, num6].active(); num6++)
						{
						}
						num6--;
						num15 = (num5 + num6) / 2;
						vector3 = randPictureTile();
						if (Main.tile[num, num15].wall != roomWall[0])
						{
							vector3 = randBoneTile();
						}
						type3 = (int)vector3.X;
						style3 = (int)vector3.Y;
						if (Math.Abs(num14 - num15) >= 4 || nearPicture(num, num15))
						{
							break;
						}
						PlaceTile(num, num15, type3, mute: true, forced: false, -1, style3);
					}
					break;
				}
				case 2:
				{
					Vector2 vector = randPictureTile();
					if (Main.tile[num, num2].wall != roomWall[0])
					{
						vector = randBoneTile();
					}
					int type = (int)vector.X;
					int style = (int)vector.Y;
					if (!Main.tile[num, num2].active())
					{
						PlaceTile(num, num2, type, mute: true, forced: false, -1, style);
					}
					int num10 = num2;
					int num11 = num;
					int num12 = num;
					for (int k = 0; k < 3; k++)
					{
						num2 += 7;
						num3 = num12;
						num4 = num12;
						while (!Main.tile[num3, num2].active() && !Main.tile[num3, num2 - 1].active() && !Main.tile[num3, num2 + 1].active())
						{
							num3--;
						}
						num3++;
						for (; !Main.tile[num4, num2].active() && !Main.tile[num4, num2 - 1].active() && !Main.tile[num4, num2 + 1].active(); num4++)
						{
						}
						num4--;
						num12 = (num3 + num4) / 2;
						vector = randPictureTile();
						if (Main.tile[num12, num2].wall != roomWall[0])
						{
							vector = randBoneTile();
						}
						type = (int)vector.X;
						style = (int)vector.Y;
						if (Math.Abs(num11 - num12) >= 4 || nearPicture(num12, num2))
						{
							break;
						}
						PlaceTile(num12, num2, type, mute: true, forced: false, -1, style);
					}
					num12 = num;
					num2 = num10;
					for (int l = 0; l < 3; l++)
					{
						num2 -= 7;
						num3 = num12;
						num4 = num12;
						while (!Main.tile[num3, num2].active() && !Main.tile[num3, num2 - 1].active() && !Main.tile[num3, num2 + 1].active())
						{
							num3--;
						}
						num3++;
						for (; !Main.tile[num4, num2].active() && !Main.tile[num4, num2 - 1].active() && !Main.tile[num4, num2 + 1].active(); num4++)
						{
						}
						num4--;
						num12 = (num3 + num4) / 2;
						vector = randPictureTile();
						if (Main.tile[num12, num2].wall != roomWall[0])
						{
							vector = randBoneTile();
						}
						type = (int)vector.X;
						style = (int)vector.Y;
						if (Math.Abs(num11 - num12) >= 4 || nearPicture(num12, num2))
						{
							break;
						}
						PlaceTile(num12, num2, type, mute: true, forced: false, -1, style);
					}
					break;
				}
				}
			}
			return count;
		}

		private static float MakeDungeon_GroundFurniture(int wallType)
		{
			float num = 2000f * (float)Main.maxTilesX / 4200f;
			int num2 = 1 + Main.maxTilesX / 4200;
			int num3 = 1 + Main.maxTilesX / 4200;
			for (int i = 0; (float)i < num; i++)
			{
				if (num2 > 0 || num3 > 0)
				{
					i--;
				}
				int num4 = genRand.Next(dMinX, dMaxX);
				int j = genRand.Next((int)Main.worldSurface + 10, dMaxY);
				while (!Main.wallDungeon[Main.tile[num4, j].wall] || Main.tile[num4, j].active())
				{
					num4 = genRand.Next(dMinX, dMaxX);
					j = genRand.Next((int)Main.worldSurface + 10, dMaxY);
				}
				if (!Main.wallDungeon[Main.tile[num4, j].wall] || Main.tile[num4, j].active())
				{
					continue;
				}
				for (; !SolidTile(num4, j) && j < Main.UnderworldLayer; j++)
				{
				}
				j--;
				int num5 = num4;
				int k = num4;
				while (!Main.tile[num5, j].active() && SolidTile(num5, j + 1))
				{
					num5--;
				}
				num5++;
				for (; !Main.tile[k, j].active() && SolidTile(k, j + 1); k++)
				{
				}
				k--;
				int num6 = k - num5;
				int num7 = (k + num5) / 2;
				if (Main.tile[num7, j].active() || !Main.wallDungeon[Main.tile[num7, j].wall] || !SolidTile(num7, j + 1) || Main.tile[num7, j + 1].type == 48)
				{
					continue;
				}
				int style = 13;
				int style2 = 10;
				int style3 = 11;
				int num8 = 1;
				int num9 = 46;
				int style4 = 1;
				int num10 = 5;
				int num11 = 11;
				int num12 = 5;
				int num13 = 6;
				int num14 = 21;
				int num15 = 22;
				int num16 = 24;
				int num17 = 30;
				switch (wallType)
				{
				case 8:
					style = 14;
					style2 = 11;
					style3 = 12;
					num8 = 2;
					num9 = 47;
					style4 = 2;
					num10 = 6;
					num11 = 12;
					num12 = 6;
					num13 = 7;
					num14 = 22;
					num15 = 23;
					num16 = 25;
					num17 = 31;
					break;
				case 9:
					style = 15;
					style2 = 12;
					style3 = 13;
					num8 = 3;
					num9 = 48;
					style4 = 3;
					num10 = 7;
					num11 = 13;
					num12 = 7;
					num13 = 8;
					num14 = 23;
					num15 = 24;
					num16 = 26;
					num17 = 32;
					break;
				}
				if (Main.tile[num7, j].wall >= 94 && Main.tile[num7, j].wall <= 105)
				{
					style = 17;
					style2 = 14;
					style3 = 15;
					num8 = -1;
					num9 = -1;
					style4 = 5;
					num10 = -1;
					num11 = -1;
					num12 = -1;
					num13 = -1;
					num14 = -1;
					num15 = -1;
					num16 = -1;
					num17 = -1;
				}
				int num18 = genRand.Next(13);
				if ((num18 == 10 || num18 == 11 || num18 == 12) && genRand.Next(4) != 0)
				{
					num18 = genRand.Next(13);
				}
				while ((num18 == 2 && num9 == -1) || (num18 == 5 && num10 == -1) || (num18 == 6 && num11 == -1) || (num18 == 7 && num12 == -1) || (num18 == 8 && num13 == -1) || (num18 == 9 && num14 == -1) || (num18 == 10 && num15 == -1) || (num18 == 11 && num16 == -1) || (num18 == 12 && num17 == -1))
				{
					num18 = genRand.Next(13);
				}
				int num19 = 0;
				int num20 = 0;
				if (num18 == 0)
				{
					num19 = 5;
					num20 = 4;
				}
				if (num18 == 1)
				{
					num19 = 4;
					num20 = 3;
				}
				if (num18 == 2)
				{
					num19 = 3;
					num20 = 5;
				}
				if (num18 == 3)
				{
					num19 = 4;
					num20 = 6;
				}
				if (num18 == 4)
				{
					num19 = 3;
					num20 = 3;
				}
				if (num18 == 5)
				{
					num19 = 5;
					num20 = 3;
				}
				if (num18 == 6)
				{
					num19 = 5;
					num20 = 4;
				}
				if (num18 == 7)
				{
					num19 = 5;
					num20 = 4;
				}
				if (num18 == 8)
				{
					num19 = 5;
					num20 = 4;
				}
				if (num18 == 9)
				{
					num19 = 5;
					num20 = 3;
				}
				if (num18 == 10)
				{
					num19 = 2;
					num20 = 4;
				}
				if (num18 == 11)
				{
					num19 = 3;
					num20 = 3;
				}
				if (num18 == 12)
				{
					num19 = 2;
					num20 = 5;
				}
				for (int l = num7 - num19; l <= num7 + num19; l++)
				{
					for (int m = j - num20; m <= j; m++)
					{
						if (Main.tile[l, m].active())
						{
							num18 = -1;
							break;
						}
					}
				}
				if ((double)num6 < (double)num19 * 1.75)
				{
					num18 = -1;
				}
				if (num2 > 0 || num3 > 0)
				{
					if (num2 > 0)
					{
						PlaceTile(num7, j, 355, mute: true);
						if (Main.tile[num7, j].type == 355)
						{
							num2--;
						}
					}
					else if (num3 > 0)
					{
						PlaceTile(num7, j, 354, mute: true);
						if (Main.tile[num7, j].type == 354)
						{
							num3--;
						}
					}
					continue;
				}
				switch (num18)
				{
				case 0:
				{
					PlaceTile(num7, j, 14, mute: true, forced: false, -1, style2);
					if (Main.tile[num7, j].active())
					{
						if (!Main.tile[num7 - 2, j].active())
						{
							PlaceTile(num7 - 2, j, 15, mute: true, forced: false, -1, style);
							if (Main.tile[num7 - 2, j].active())
							{
								Main.tile[num7 - 2, j].frameX += 18;
								Main.tile[num7 - 2, j - 1].frameX += 18;
							}
						}
						if (!Main.tile[num7 + 2, j].active())
						{
							PlaceTile(num7 + 2, j, 15, mute: true, forced: false, -1, style);
						}
					}
					for (int num22 = num7 - 1; num22 <= num7 + 1; num22++)
					{
						if (genRand.Next(2) == 0 && !Main.tile[num22, j - 2].active())
						{
							int num23 = genRand.Next(5);
							if (num8 != -1 && num23 <= 1 && !Main.tileLighted[Main.tile[num22 - 1, j - 2].type])
							{
								PlaceTile(num22, j - 2, 33, mute: true, forced: false, -1, num8);
							}
							if (num23 == 2 && !Main.tileLighted[Main.tile[num22 - 1, j - 2].type])
							{
								PlaceTile(num22, j - 2, 49, mute: true);
							}
							if (num23 == 3)
							{
								PlaceTile(num22, j - 2, 50, mute: true);
							}
							if (num23 == 4)
							{
								PlaceTile(num22, j - 2, 103, mute: true);
							}
						}
					}
					break;
				}
				case 1:
				{
					PlaceTile(num7, j, 18, mute: true, forced: false, -1, style3);
					if (!Main.tile[num7, j].active())
					{
						break;
					}
					if (genRand.Next(2) == 0)
					{
						if (!Main.tile[num7 - 1, j].active())
						{
							PlaceTile(num7 - 1, j, 15, mute: true, forced: false, -1, style);
							if (Main.tile[num7 - 1, j].active())
							{
								Main.tile[num7 - 1, j].frameX += 18;
								Main.tile[num7 - 1, j - 1].frameX += 18;
							}
						}
					}
					else if (!Main.tile[num7 + 2, j].active())
					{
						PlaceTile(num7 + 2, j, 15, mute: true, forced: false, -1, style);
					}
					for (int n = num7; n <= num7 + 1; n++)
					{
						if (genRand.Next(2) == 0 && !Main.tile[n, j - 1].active())
						{
							int num21 = genRand.Next(5);
							if (num8 != -1 && num21 <= 1 && !Main.tileLighted[Main.tile[n - 1, j - 1].type])
							{
								PlaceTile(n, j - 1, 33, mute: true, forced: false, -1, num8);
							}
							if (num21 == 2 && !Main.tileLighted[Main.tile[n - 1, j - 1].type])
							{
								PlaceTile(n, j - 1, 49, mute: true);
							}
							if (num21 == 3)
							{
								PlaceTile(n, j - 1, 50, mute: true);
							}
							if (num21 == 4)
							{
								PlaceTile(n, j - 1, 103, mute: true);
							}
						}
					}
					break;
				}
				case 2:
					PlaceTile(num7, j, 105, mute: true, forced: false, -1, num9);
					break;
				case 3:
					PlaceTile(num7, j, 101, mute: true, forced: false, -1, style4);
					break;
				case 4:
					if (genRand.Next(2) == 0)
					{
						PlaceTile(num7, j, 15, mute: true, forced: false, -1, style);
						Main.tile[num7, j].frameX += 18;
						Main.tile[num7, j - 1].frameX += 18;
					}
					else
					{
						PlaceTile(num7, j, 15, mute: true, forced: false, -1, style);
					}
					break;
				case 5:
					if (genRand.Next(2) == 0)
					{
						Place4x2(num7, j, 79, 1, num10);
					}
					else
					{
						Place4x2(num7, j, 79, -1, num10);
					}
					break;
				case 6:
					PlaceTile(num7, j, 87, mute: true, forced: false, -1, num11);
					break;
				case 7:
					PlaceTile(num7, j, 88, mute: true, forced: false, -1, num12);
					break;
				case 8:
					PlaceTile(num7, j, 89, mute: true, forced: false, -1, num13);
					break;
				case 9:
					if (genRand.Next(2) == 0)
					{
						Place4x2(num7, j, 90, 1, num14);
					}
					else
					{
						Place4x2(num7, j, 90, -1, num14);
					}
					break;
				case 10:
					PlaceTile(num7, j, 93, mute: true, forced: false, -1, num16);
					break;
				case 11:
					PlaceTile(num7, j, 100, mute: true, forced: false, -1, num15);
					break;
				case 12:
					PlaceTile(num7, j, 104, mute: true, forced: false, -1, num17);
					break;
				}
			}
			return num;
		}

		public static Vector2 randBoneTile()
		{
			int num = genRand.Next(2);
			int num2 = 0;
			switch (num)
			{
			case 0:
				num = 240;
				num2 = genRand.Next(2);
				switch (num2)
				{
				case 0:
					num2 = 16;
					break;
				case 1:
					num2 = 17;
					break;
				}
				break;
			case 1:
				num = 241;
				num2 = genRand.Next(9);
				break;
			}
			return new Vector2(num, num2);
		}

		public static Vector2 randHellPicture()
		{
			int num = genRand.Next(4);
			int num2 = 0;
			if (num == 1)
			{
				num = genRand.Next(4);
			}
			switch (num)
			{
			case 0:
				num = 240;
				num2 = genRand.Next(5);
				switch (num2)
				{
				case 0:
					num2 = 27;
					break;
				case 1:
					num2 = 29;
					break;
				case 2:
					num2 = 30;
					break;
				case 3:
					num2 = 31;
					break;
				case 4:
					num2 = 32;
					break;
				}
				break;
			case 1:
				num = 242;
				num2 = 14;
				break;
			case 2:
				num = 245;
				num2 = genRand.Next(3);
				switch (num2)
				{
				case 0:
					num2 = 1;
					break;
				case 1:
					num2 = 2;
					break;
				case 2:
					num2 = 4;
					break;
				}
				break;
			default:
				num = 246;
				num2 = genRand.Next(3);
				switch (num2)
				{
				case 0:
					num2 = 0;
					break;
				case 1:
					num2 = 16;
					break;
				case 2:
					num2 = 17;
					break;
				}
				break;
			}
			return new Vector2(num, num2);
		}

		public static Vector2 RandHousePictureDesert()
		{
			int num = genRand.Next(4);
			int num2 = 0;
			if (num <= 1)
			{
				num = 240;
				int maxValue = 6;
				num2 = 63 + genRand.Next(maxValue);
			}
			else if (num == 2)
			{
				num = 245;
				int maxValue2 = 2;
				num2 = 7 + genRand.Next(maxValue2);
			}
			else
			{
				num = 242;
				int maxValue3 = 6;
				num2 = 37 + genRand.Next(maxValue3);
			}
			return new Vector2(num, num2);
		}

		public static Vector2 randHousePicture()
		{
			int num = genRand.Next(4);
			int num2 = 0;
			if (num >= 3 && genRand.Next(10) != 0)
			{
				num = genRand.Next(3);
			}
			if (num <= 1)
			{
				num = 240;
				int maxValue = 10;
				num2 = genRand.Next(maxValue);
				if (num2 == 9)
				{
					num2 = genRand.Next(maxValue);
				}
				if (num2 == 5)
				{
					num2 = genRand.Next(maxValue);
				}
				if (num2 == 6)
				{
					num2 = genRand.Next(maxValue);
				}
				switch (num2)
				{
				case 0:
					num2 = 26;
					break;
				case 1:
					num2 = 28;
					break;
				case 2:
					num2 = 20;
					break;
				case 3:
					num2 = 21;
					break;
				case 4:
					num2 = 22;
					break;
				case 5:
					num2 = 24;
					break;
				case 6:
					num2 = 25;
					break;
				case 7:
					num2 = 33;
					break;
				case 8:
					num2 = 34;
					break;
				case 9:
					num2 = 35;
					break;
				}
			}
			else if (num == 2)
			{
				int maxValue2 = 4;
				num = 245;
				num2 = genRand.Next(maxValue2);
				if (num2 == 2)
				{
					num2 = genRand.Next(maxValue2);
				}
				if (num2 == 0)
				{
					num2 = genRand.Next(maxValue2);
				}
				if (num2 == 0)
				{
					num2 = genRand.Next(maxValue2);
				}
				if (num2 == 0)
				{
					num2 = genRand.Next(maxValue2);
				}
				switch (num2)
				{
				case 0:
					num2 = 0;
					break;
				case 1:
					num2 = 3;
					break;
				case 2:
					num2 = 5;
					break;
				case 3:
					num2 = 6;
					break;
				}
			}
			else
			{
				num = 246;
				num2 = 1;
			}
			return new Vector2(num, num2);
		}

		public static Vector2 randPictureTile()
		{
			int num = genRand.Next(3);
			int num2 = 0;
			if (num <= 1)
			{
				int maxValue = 7;
				num = 240;
				num2 = genRand.Next(maxValue);
				if (num2 == 6)
				{
					num2 = genRand.Next(maxValue);
				}
				switch (num2)
				{
				case 0:
					num2 = 12;
					break;
				case 1:
					num2 = 13;
					break;
				case 2:
					num2 = 14;
					break;
				case 3:
					num2 = 15;
					break;
				case 4:
					num2 = 18;
					break;
				case 5:
					num2 = 19;
					break;
				case 6:
					num2 = 23;
					break;
				}
			}
			else if (num == 2)
			{
				num = 242;
				int maxValue2 = 17;
				num2 = genRand.Next(maxValue2);
				switch (num2)
				{
				case 14:
					num2 = 15;
					break;
				case 15:
					num2 = 16;
					break;
				case 16:
					num2 = 30;
					break;
				}
			}
			return new Vector2(num, num2);
		}

		public static void DungeonStairs(int i, int j, ushort tileType, int wallType)
		{
			Vector2 zero = Vector2.Zero;
			double num = genRand.Next(5, 9);
			int num2 = 1;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			int num3 = genRand.Next(10, 30);
			num2 = ((i <= dEnteranceX) ? 1 : (-1));
			if (i > Main.maxTilesX - 400)
			{
				num2 = -1;
			}
			else if (i < 400)
			{
				num2 = 1;
			}
			zero.Y = -1f;
			zero.X = num2;
			if (genRand.Next(3) != 0)
			{
				zero.X *= 1f + (float)genRand.Next(0, 200) * 0.01f;
			}
			else if (genRand.Next(3) == 0)
			{
				zero.X *= (float)genRand.Next(50, 76) * 0.01f;
			}
			else if (genRand.Next(6) == 0)
			{
				zero.Y *= 2f;
			}
			if (dungeonX < Main.maxTilesX / 2 && zero.X < 0f && (double)zero.X < 0.5)
			{
				zero.X = -0.5f;
			}
			if (dungeonX > Main.maxTilesX / 2 && zero.X > 0f && (double)zero.X > 0.5)
			{
				zero.X = -0.5f;
			}
			if (drunkWorldGen)
			{
				num2 *= -1;
				zero.X *= -1f;
			}
			while (num3 > 0)
			{
				num3--;
				int num4 = (int)((double)vector.X - num - 4.0 - (double)genRand.Next(6));
				int num5 = (int)((double)vector.X + num + 4.0 + (double)genRand.Next(6));
				int num6 = (int)((double)vector.Y - num - 4.0);
				int num7 = (int)((double)vector.Y + num + 4.0 + (double)genRand.Next(6));
				if (num4 < 0)
				{
					num4 = 0;
				}
				if (num5 > Main.maxTilesX)
				{
					num5 = Main.maxTilesX;
				}
				if (num6 < 0)
				{
					num6 = 0;
				}
				if (num7 > Main.maxTilesY)
				{
					num7 = Main.maxTilesY;
				}
				int num8 = 1;
				if (vector.X > (float)(Main.maxTilesX / 2))
				{
					num8 = -1;
				}
				int num9 = (int)(vector.X + (float)dxStrength1 * 0.6f * (float)num8 + (float)dxStrength2 * (float)num8);
				int num10 = (int)(dyStrength2 * 0.5);
				if ((double)vector.Y < Main.worldSurface - 5.0 && Main.tile[num9, (int)((double)vector.Y - num - 6.0 + (double)num10)].wall == 0 && Main.tile[num9, (int)((double)vector.Y - num - 7.0 + (double)num10)].wall == 0 && Main.tile[num9, (int)((double)vector.Y - num - 8.0 + (double)num10)].wall == 0)
				{
					dSurface = true;
					TileRunner(num9, (int)((double)vector.Y - num - 6.0 + (double)num10), genRand.Next(25, 35), genRand.Next(10, 20), -1, addTile: false, 0f, -1f);
				}
				for (int k = num4; k < num5; k++)
				{
					for (int l = num6; l < num7; l++)
					{
						Main.tile[k, l].liquid = 0;
						if (!Main.wallDungeon[Main.tile[k, l].wall])
						{
							Main.tile[k, l].wall = 0;
							Main.tile[k, l].active(active: true);
							Main.tile[k, l].type = tileType;
						}
					}
				}
				for (int m = num4 + 1; m < num5 - 1; m++)
				{
					for (int n = num6 + 1; n < num7 - 1; n++)
					{
						Main.tile[m, n].wall = (ushort)wallType;
					}
				}
				int num11 = 0;
				if (genRand.Next((int)num) == 0)
				{
					num11 = genRand.Next(1, 3);
				}
				num4 = (int)((double)vector.X - num * 0.5 - (double)num11);
				num5 = (int)((double)vector.X + num * 0.5 + (double)num11);
				num6 = (int)((double)vector.Y - num * 0.5 - (double)num11);
				num7 = (int)((double)vector.Y + num * 0.5 + (double)num11);
				if (num4 < 0)
				{
					num4 = 0;
				}
				if (num5 > Main.maxTilesX)
				{
					num5 = Main.maxTilesX;
				}
				if (num6 < 0)
				{
					num6 = 0;
				}
				if (num7 > Main.maxTilesY)
				{
					num7 = Main.maxTilesY;
				}
				for (int num12 = num4; num12 < num5; num12++)
				{
					for (int num13 = num6; num13 < num7; num13++)
					{
						Main.tile[num12, num13].active(active: false);
						PlaceWall(num12, num13, wallType, mute: true);
					}
				}
				if (dSurface)
				{
					num3 = 0;
				}
				vector += zero;
				if ((double)vector.Y < Main.worldSurface)
				{
					zero.Y *= 0.98f;
				}
			}
			dungeonX = (int)vector.X;
			dungeonY = (int)vector.Y;
		}

		public static bool PlaceSandTrap(int i, int j)
		{
			int num = 6;
			int num2 = 4;
			int num3 = 25;
			int k;
			for (k = j; !Main.tile[i, k].active() && k < Main.UnderworldLayer; k++)
			{
			}
			if (!Main.tileSolid[Main.tile[i, k].type] || Main.tile[i, k].halfBrick() || Main.tile[i, k].topSlope())
			{
				return false;
			}
			if ((Main.tile[i, k].type != 53 && Main.tile[i, k].type != 397 && Main.tile[i, k].type != 396) || (Main.tile[i, k].wall != 216 && Main.tile[i, k].wall != 187))
			{
				return false;
			}
			k--;
			int num4 = -1;
			int num5 = genRand.Next(6, 12);
			int num6 = genRand.Next(6, 14);
			for (int l = i - num3; l <= i + num3; l++)
			{
				for (int m = k - num3; m < k + num3; m++)
				{
					if (Main.tile[l, m].wire())
					{
						return false;
					}
					if (TileID.Sets.BasicChest[Main.tile[l, m].type])
					{
						return false;
					}
					if (TileID.Sets.Paintings[Main.tile[l, m].type])
					{
						return false;
					}
					if (Main.tile[l, m].type == 10)
					{
						return false;
					}
					if (Main.tile[l, m].type == 19)
					{
						return false;
					}
					if (Main.tile[l, m].type == 15)
					{
						return false;
					}
					if (Main.tile[l, m].type == 219)
					{
						return false;
					}
				}
			}
			for (int n = i - 2; n <= i + 2; n++)
			{
				for (int num7 = k + 1; num7 <= k + 3; num7++)
				{
					if (!Main.tile[n, num7].active() || !Main.tileSolid[Main.tile[n, num7].type])
					{
						return false;
					}
				}
			}
			for (int num8 = k; num8 > k - 30; num8--)
			{
				if (Main.tile[i, num8].active())
				{
					if (Main.tile[i, num8].type == 396)
					{
						num4 = num8;
						break;
					}
					return false;
				}
			}
			if (num4 <= -1)
			{
				return false;
			}
			if (k - num4 < num6 + num2)
			{
				return false;
			}
			int num9 = 0;
			int num10 = (k + num4) / 2;
			for (int num11 = i - num5; num11 <= i + num5; num11++)
			{
				if (Main.tile[num11, num10].active() && Main.tileSolid[Main.tile[num11, num10].type])
				{
					return false;
				}
				for (int num12 = num4 - num6; num12 <= num4; num12++)
				{
					if (Main.tile[num11, num12].active())
					{
						if (TileID.Sets.Ore[Main.tile[num11, num12].type] || Main.tile[num11, num12].type == 404)
						{
							return false;
						}
						if (Main.tileSolid[Main.tile[num11, num12].type])
						{
							num9++;
						}
					}
				}
			}
			float num13 = (float)((num5 * 2 + 1) * (num6 + 1)) * 0.75f;
			if ((float)num9 < num13)
			{
				return false;
			}
			for (int num14 = i - num5 - 1; num14 <= i + num5 + 1; num14++)
			{
				for (int num15 = num4 - num6; num15 <= num4; num15++)
				{
					bool flag = false;
					if (Main.tile[num14, num15].active() && Main.tileSolid[Main.tile[num14, num15].type])
					{
						flag = true;
					}
					if (num15 == num4)
					{
						Main.tile[num14, num15].slope(0);
						Main.tile[num14, num15].halfBrick(halfBrick: false);
						if (!flag)
						{
							Main.tile[num14, num15].active(active: true);
							Main.tile[num14, num15].type = 396;
						}
					}
					else if (num15 == num4 - num6)
					{
						Main.tile[num14, num15].ClearTile();
						Main.tile[num14, num15].active(active: true);
						if (flag && Main.tile[num14, num15 - 1].active() && Main.tileSolid[Main.tile[num14, num15 - 1].type])
						{
							Main.tile[num14, num15].type = 397;
						}
						else
						{
							Main.tile[num14, num15].type = 396;
						}
					}
					else if (num14 == i - num5 - 1 || num14 == i + num5 + 1)
					{
						if (!flag)
						{
							Main.tile[num14, num15].ClearTile();
							Main.tile[num14, num15].active(active: true);
							Main.tile[num14, num15].type = 396;
						}
						else
						{
							Main.tile[num14, num15].slope(0);
							Main.tile[num14, num15].halfBrick(halfBrick: false);
						}
					}
					else
					{
						Main.tile[num14, num15].ClearTile();
						Main.tile[num14, num15].active(active: true);
						Main.tile[num14, num15].type = 53;
					}
				}
			}
			for (int num16 = (int)((float)num4 - (float)num6 * 0.666f); (double)num16 <= (double)num4 - (double)(float)num6 * 0.333; num16++)
			{
				if ((float)num16 < (float)num4 - (float)num6 * 0.4f)
				{
					if (Main.tile[i - num5 - 2, num16].bottomSlope())
					{
						Main.tile[i - num5 - 2, num16].slope(0);
					}
				}
				else if ((float)num16 > (float)num4 - (float)num6 * 0.6f)
				{
					if (Main.tile[i - num5 - 2, num16].topSlope())
					{
						Main.tile[i - num5 - 2, num16].slope(0);
					}
					Main.tile[i - num5 - 2, num16].halfBrick(halfBrick: false);
				}
				else
				{
					Main.tile[i - num5 - 2, num16].halfBrick(halfBrick: false);
					Main.tile[i - num5 - 2, num16].slope(0);
				}
				if (!Main.tile[i - num5 - 2, num16].active() || !Main.tileSolid[Main.tile[i - num5 - 2, num16].type])
				{
					Main.tile[i - num5 - 2, num16].active(active: true);
					Main.tile[i - num5 - 2, num16].type = 396;
				}
				if (!Main.tile[i + num5 + 2, num16].active() || !Main.tileSolid[Main.tile[i + num5 + 2, num16].type])
				{
					Main.tile[i + num5 + 2, num16].active(active: true);
					Main.tile[i + num5 + 2, num16].type = 396;
				}
			}
			for (int num17 = num4 - num6; num17 <= num4; num17++)
			{
				Main.tile[i - num5 - 2, num17].slope(0);
				Main.tile[i - num5 - 2, num17].halfBrick(halfBrick: false);
				Main.tile[i - num5 - 1, num17].slope(0);
				Main.tile[i - num5 - 1, num17].halfBrick(halfBrick: false);
				Main.tile[i - num5 + 1, num17].slope(0);
				Main.tile[i - num5 + 1, num17].halfBrick(halfBrick: false);
				Main.tile[i - num5 + 2, num17].slope(0);
				Main.tile[i - num5 + 2, num17].halfBrick(halfBrick: false);
			}
			for (int num18 = i - num5 - 1; num18 < i + num5 + 1; num18++)
			{
				int num19 = k - num6 - 1;
				if (Main.tile[num18, num19].bottomSlope())
				{
					Main.tile[num18, num19].slope(0);
				}
				Main.tile[num18, num19].halfBrick(halfBrick: false);
			}
			KillTile(i - 2, k);
			KillTile(i - 1, k);
			KillTile(i + 1, k);
			KillTile(i + 2, k);
			PlaceTile(i, k, 135, mute: true, forced: false, -1, 7);
			for (int num20 = i - num5; num20 <= i + num5; num20++)
			{
				int num21 = k;
				if ((double)num20 < (double)i - (double)num5 * 0.8 || (double)num20 > (double)i + (double)num5 * 0.8)
				{
					num21 = k - 3;
				}
				else if ((double)num20 < (double)i - (double)num5 * 0.6 || (double)num20 > (double)i + (double)num5 * 0.6)
				{
					num21 = k - 2;
				}
				else if ((double)num20 < (double)i - (double)num5 * 0.4 || (double)num20 > (double)i + (double)num5 * 0.4)
				{
					num21 = k - 1;
				}
				for (int num22 = num4; num22 <= k; num22++)
				{
					if (num20 == i && num22 <= k)
					{
						Main.tile[i, num22].wire(wire: true);
					}
					if (Main.tile[num20, num22].active() && Main.tileSolid[Main.tile[num20, num22].type])
					{
						if (num22 < num4 + num - 4)
						{
							Main.tile[num20, num22].actuator(actuator: true);
							Main.tile[num20, num22].wire(wire: true);
						}
						else if (num22 < num21)
						{
							KillTile(num20, num22);
						}
					}
				}
			}
			return true;
		}

		public static bool DungeonPitTrap(int i, int j, ushort tileType, int wallType)
		{
			int num = 30;
			int num2 = j;
			int num3 = num2;
			int num4 = genRand.Next(8, 19);
			int num5 = genRand.Next(19, 46);
			int num6 = num4 + genRand.Next(6, 10);
			int num7 = num5 + genRand.Next(6, 10);
			if (!Main.wallDungeon[Main.tile[i, num2].wall])
			{
				return false;
			}
			if (Main.tile[i, num2].active())
			{
				return false;
			}
			for (int k = num2; k < Main.maxTilesY; k++)
			{
				if (k > Main.maxTilesY - 300)
				{
					return false;
				}
				if (Main.tile[i, k].active() && SolidTile(i, k))
				{
					if (Main.tile[i, k].type == 48)
					{
						return false;
					}
					num2 = k;
					break;
				}
			}
			if (!Main.wallDungeon[Main.tile[i - num4, num2].wall] || !Main.wallDungeon[Main.tile[i + num4, num2].wall])
			{
				return false;
			}
			bool flag = true;
			for (int l = num2; l < num2 + num; l++)
			{
				flag = true;
				for (int m = i - num4; m <= i + num4; m++)
				{
					Tile tile = Main.tile[m, l];
					if (tile.active() && Main.tileDungeon[tile.type])
					{
						flag = false;
					}
				}
				if (flag)
				{
					num2 = l;
					break;
				}
			}
			for (int n = i - num4; n <= i + num4; n++)
			{
				for (int num8 = num2; num8 <= num2 + num5; num8++)
				{
					Tile tile2 = Main.tile[n, num8];
					if (tile2.active() && (Main.tileDungeon[tile2.type] || tile2.type == crackedType))
					{
						return false;
					}
				}
			}
			bool flag2 = false;
			if (dungeonLake)
			{
				flag2 = true;
				dungeonLake = false;
			}
			else if (genRand.Next(8) == 0)
			{
				flag2 = true;
			}
			for (int num9 = i - num4; num9 <= i + num4; num9++)
			{
				for (int num10 = num3; num10 <= num2 + num5; num10++)
				{
					if (Main.tileDungeon[Main.tile[num9, num10].type])
					{
						Main.tile[num9, num10].type = crackedType;
						Main.tile[num9, num10].wall = (ushort)wallType;
					}
				}
			}
			for (int num11 = i - num6; num11 <= i + num6; num11++)
			{
				for (int num12 = num3; num12 <= num2 + num7; num12++)
				{
					Main.tile[num11, num12].lava(lava: false);
					Main.tile[num11, num12].liquid = 0;
					if (!Main.wallDungeon[Main.tile[num11, num12].wall] && Main.tile[num11, num12].type != crackedType)
					{
						Main.tile[num11, num12].Clear(TileDataType.Slope);
						Main.tile[num11, num12].type = tileType;
						Main.tile[num11, num12].active(active: true);
						if (num11 > i - num6 && num11 < i + num6 && num12 < num2 + num7)
						{
							Main.tile[num11, num12].wall = (ushort)wallType;
						}
					}
				}
			}
			for (int num13 = i - num4; num13 <= i + num4; num13++)
			{
				for (int num14 = num3; num14 <= num2 + num5; num14++)
				{
					if (Main.tile[num13, num14].type != crackedType)
					{
						if (flag2)
						{
							Main.tile[num13, num14].liquid = byte.MaxValue;
						}
						if (num13 == i - num4 || num13 == i + num4 || num14 == num2 + num5)
						{
							Main.tile[num13, num14].type = 48;
						}
						else if ((num13 == i - num4 + 1 && num14 % 2 == 0) || (num13 == i + num4 - 1 && num14 % 2 == 0) || (num14 == num2 + num5 - 1 && num13 % 2 == 0))
						{
							Main.tile[num13, num14].type = 48;
						}
						else
						{
							Main.tile[num13, num14].active(active: false);
						}
					}
				}
			}
			return true;
		}

		public static void DungeonHalls(int i, int j, ushort tileType, int wallType, bool forceX = false)
		{
			Vector2 zero = Vector2.Zero;
			double num = genRand.Next(4, 6);
			double num2 = num;
			Vector2 zero2 = Vector2.Zero;
			Vector2 zero3 = Vector2.Zero;
			int num3 = 1;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			int num4 = genRand.Next(35, 80);
			bool flag = false;
			if (genRand.Next(5) == 0)
			{
				flag = true;
			}
			if (forceX)
			{
				num4 += 20;
				lastDungeonHall = Vector2.Zero;
			}
			else if (genRand.Next(5) == 0)
			{
				num *= 2.0;
				num4 /= 2;
			}
			bool flag2 = false;
			bool flag3 = false;
			bool flag4 = true;
			bool flag5 = false;
			while (!flag2)
			{
				flag5 = false;
				if (flag4 && !forceX)
				{
					bool flag6 = true;
					bool flag7 = true;
					bool flag8 = true;
					bool flag9 = true;
					int num5 = num4;
					bool flag10 = false;
					for (int num6 = j; num6 > j - num5; num6--)
					{
						if (Main.tile[i, num6].wall == wallType)
						{
							if (flag10)
							{
								flag6 = false;
								break;
							}
						}
						else
						{
							flag10 = true;
						}
					}
					flag10 = false;
					for (int k = j; k < j + num5; k++)
					{
						if (Main.tile[i, k].wall == wallType)
						{
							if (flag10)
							{
								flag7 = false;
								break;
							}
						}
						else
						{
							flag10 = true;
						}
					}
					flag10 = false;
					for (int num7 = i; num7 > i - num5; num7--)
					{
						if (Main.tile[num7, j].wall == wallType)
						{
							if (flag10)
							{
								flag8 = false;
								break;
							}
						}
						else
						{
							flag10 = true;
						}
					}
					flag10 = false;
					for (int l = i; l < i + num5; l++)
					{
						if (Main.tile[l, j].wall == wallType)
						{
							if (flag10)
							{
								flag9 = false;
								break;
							}
						}
						else
						{
							flag10 = true;
						}
					}
					if (!flag8 && !flag9 && !flag6 && !flag7)
					{
						num3 = ((genRand.Next(2) != 0) ? 1 : (-1));
						if (genRand.Next(2) == 0)
						{
							flag5 = true;
						}
					}
					else
					{
						int num8 = genRand.Next(4);
						do
						{
							num8 = genRand.Next(4);
						}
						while (!(num8 == 0 && flag6) && !(num8 == 1 && flag7) && !(num8 == 2 && flag8) && !(num8 == 3 && flag9));
						switch (num8)
						{
						case 0:
							num3 = -1;
							break;
						case 1:
							num3 = 1;
							break;
						default:
							flag5 = true;
							num3 = ((num8 != 2) ? 1 : (-1));
							break;
						}
					}
				}
				else
				{
					num3 = ((genRand.Next(2) != 0) ? 1 : (-1));
					if (genRand.Next(2) == 0)
					{
						flag5 = true;
					}
				}
				flag4 = false;
				if (forceX)
				{
					flag5 = true;
				}
				if (flag5)
				{
					zero2.Y = 0f;
					zero2.X = num3;
					zero3.Y = 0f;
					zero3.X = -num3;
					zero.Y = 0f;
					zero.X = num3;
					if (genRand.Next(3) == 0)
					{
						if (genRand.Next(2) == 0)
						{
							zero.Y = -0.2f;
						}
						else
						{
							zero.Y = 0.2f;
						}
					}
				}
				else
				{
					num += 1.0;
					zero.Y = num3;
					zero.X = 0f;
					zero2.X = 0f;
					zero2.Y = num3;
					zero3.X = 0f;
					zero3.Y = -num3;
					if (genRand.Next(3) != 0)
					{
						flag3 = true;
						if (genRand.Next(2) == 0)
						{
							zero.X = (float)genRand.Next(10, 20) * 0.1f;
						}
						else
						{
							zero.X = (float)(-genRand.Next(10, 20)) * 0.1f;
						}
					}
					else if (genRand.Next(2) == 0)
					{
						if (genRand.Next(2) == 0)
						{
							zero.X = (float)genRand.Next(20, 40) * 0.01f;
						}
						else
						{
							zero.X = (float)(-genRand.Next(20, 40)) * 0.01f;
						}
					}
					else
					{
						num4 /= 2;
					}
				}
				if (lastDungeonHall != zero3)
				{
					flag2 = true;
				}
			}
			int num9 = 0;
			if (!forceX)
			{
				if (vector.X > (float)(lastMaxTilesX - 200))
				{
					num3 = -1;
					zero2.Y = 0f;
					zero2.X = num3;
					zero.Y = 0f;
					zero.X = num3;
					if (genRand.Next(3) == 0)
					{
						if (genRand.Next(2) == 0)
						{
							zero.Y = -0.2f;
						}
						else
						{
							zero.Y = 0.2f;
						}
					}
				}
				else if (vector.X < 200f)
				{
					num3 = 1;
					zero2.Y = 0f;
					zero2.X = num3;
					zero.Y = 0f;
					zero.X = num3;
					if (genRand.Next(3) == 0)
					{
						if (genRand.Next(2) == 0)
						{
							zero.Y = -0.2f;
						}
						else
						{
							zero.Y = 0.2f;
						}
					}
				}
				else if (vector.Y > (float)(lastMaxTilesY - 300))
				{
					num3 = -1;
					num += 1.0;
					zero.Y = num3;
					zero.X = 0f;
					zero2.X = 0f;
					zero2.Y = num3;
					if (genRand.Next(2) == 0)
					{
						if (genRand.Next(2) == 0)
						{
							zero.X = (float)genRand.Next(20, 50) * 0.01f;
						}
						else
						{
							zero.X = (float)(-genRand.Next(20, 50)) * 0.01f;
						}
					}
				}
				else if ((double)vector.Y < Main.rockLayer + 100.0)
				{
					num3 = 1;
					num += 1.0;
					zero.Y = num3;
					zero.X = 0f;
					zero2.X = 0f;
					zero2.Y = num3;
					if (genRand.Next(3) != 0)
					{
						flag3 = true;
						if (genRand.Next(2) == 0)
						{
							zero.X = (float)genRand.Next(10, 20) * 0.1f;
						}
						else
						{
							zero.X = (float)(-genRand.Next(10, 20)) * 0.1f;
						}
					}
					else if (genRand.Next(2) == 0)
					{
						if (genRand.Next(2) == 0)
						{
							zero.X = (float)genRand.Next(20, 50) * 0.01f;
						}
						else
						{
							zero.X = (float)genRand.Next(20, 50) * 0.01f;
						}
					}
				}
				else if (vector.X < (float)(Main.maxTilesX / 2) && (double)vector.X > (double)Main.maxTilesX * 0.25)
				{
					num3 = -1;
					zero2.Y = 0f;
					zero2.X = num3;
					zero.Y = 0f;
					zero.X = num3;
					if (genRand.Next(3) == 0)
					{
						if (genRand.Next(2) == 0)
						{
							zero.Y = -0.2f;
						}
						else
						{
							zero.Y = 0.2f;
						}
					}
				}
				else if (vector.X > (float)(Main.maxTilesX / 2) && (double)vector.X < (double)Main.maxTilesX * 0.75)
				{
					num3 = 1;
					zero2.Y = 0f;
					zero2.X = num3;
					zero.Y = 0f;
					zero.X = num3;
					if (genRand.Next(3) == 0)
					{
						if (genRand.Next(2) == 0)
						{
							zero.Y = -0.2f;
						}
						else
						{
							zero.Y = 0.2f;
						}
					}
				}
			}
			if (zero2.Y == 0f)
			{
				DDoorX[numDDoors] = (int)vector.X;
				DDoorY[numDDoors] = (int)vector.Y;
				DDoorPos[numDDoors] = 0;
				numDDoors++;
			}
			else
			{
				dungeonPlatformX[numDungeonPlatforms] = (int)vector.X;
				dungeonPlatformY[numDungeonPlatforms] = (int)vector.Y;
				numDungeonPlatforms++;
			}
			lastDungeonHall = zero2;
			if (Math.Abs(zero.X) > Math.Abs(zero.Y) && genRand.Next(3) != 0)
			{
				num = (int)((double)(float)num2 * ((double)genRand.Next(110, 150) * 0.01));
			}
			while (num4 > 0)
			{
				num9++;
				if (zero2.X > 0f && vector.X > (float)(Main.maxTilesX - 100))
				{
					num4 = 0;
				}
				else if (zero2.X < 0f && vector.X < 100f)
				{
					num4 = 0;
				}
				else if (zero2.Y > 0f && vector.Y > (float)(Main.maxTilesY - 100))
				{
					num4 = 0;
				}
				else if (zero2.Y < 0f && (double)vector.Y < Main.rockLayer + 50.0)
				{
					num4 = 0;
				}
				num4--;
				int num10 = (int)((double)vector.X - num - 4.0 - (double)genRand.Next(6));
				int num11 = (int)((double)vector.X + num + 4.0 + (double)genRand.Next(6));
				int num12 = (int)((double)vector.Y - num - 4.0 - (double)genRand.Next(6));
				int num13 = (int)((double)vector.Y + num + 4.0 + (double)genRand.Next(6));
				if (num10 < 0)
				{
					num10 = 0;
				}
				if (num11 > Main.maxTilesX)
				{
					num11 = Main.maxTilesX;
				}
				if (num12 < 0)
				{
					num12 = 0;
				}
				if (num13 > Main.maxTilesY)
				{
					num13 = Main.maxTilesY;
				}
				for (int m = num10; m < num11; m++)
				{
					for (int n = num12; n < num13; n++)
					{
						if (m < dMinX)
						{
							dMinX = m;
						}
						if (m > dMaxX)
						{
							dMaxX = m;
						}
						if (n > dMaxY)
						{
							dMaxY = n;
						}
						Main.tile[m, n].liquid = 0;
						if (!Main.wallDungeon[Main.tile[m, n].wall])
						{
							Main.tile[m, n].active(active: true);
							Main.tile[m, n].type = tileType;
							Main.tile[m, n].Clear(TileDataType.Slope);
						}
					}
				}
				for (int num14 = num10 + 1; num14 < num11 - 1; num14++)
				{
					for (int num15 = num12 + 1; num15 < num13 - 1; num15++)
					{
						Main.tile[num14, num15].wall = (ushort)wallType;
					}
				}
				int num16 = 0;
				if (zero.Y == 0f && genRand.Next((int)num + 1) == 0)
				{
					num16 = genRand.Next(1, 3);
				}
				else if (zero.X == 0f && genRand.Next((int)num - 1) == 0)
				{
					num16 = genRand.Next(1, 3);
				}
				else if (genRand.Next((int)num * 3) == 0)
				{
					num16 = genRand.Next(1, 3);
				}
				num10 = (int)((double)vector.X - num * 0.5 - (double)num16);
				num11 = (int)((double)vector.X + num * 0.5 + (double)num16);
				num12 = (int)((double)vector.Y - num * 0.5 - (double)num16);
				num13 = (int)((double)vector.Y + num * 0.5 + (double)num16);
				if (num10 < 0)
				{
					num10 = 0;
				}
				if (num11 > Main.maxTilesX)
				{
					num11 = Main.maxTilesX;
				}
				if (num12 < 0)
				{
					num12 = 0;
				}
				if (num13 > Main.maxTilesY)
				{
					num13 = Main.maxTilesY;
				}
				for (int num17 = num10; num17 < num11; num17++)
				{
					for (int num18 = num12; num18 < num13; num18++)
					{
						Main.tile[num17, num18].Clear(TileDataType.Slope);
						if (flag)
						{
							if (Main.tile[num17, num18].active() || Main.tile[num17, num18].wall != wallType)
							{
								Main.tile[num17, num18].active(active: true);
								Main.tile[num17, num18].type = crackedType;
							}
						}
						else
						{
							Main.tile[num17, num18].active(active: false);
						}
						Main.tile[num17, num18].Clear(TileDataType.Slope);
						Main.tile[num17, num18].wall = (ushort)wallType;
					}
				}
				vector += zero;
				if (flag3 && num9 > genRand.Next(10, 20))
				{
					num9 = 0;
					zero.X *= -1f;
				}
			}
			dungeonX = (int)vector.X;
			dungeonY = (int)vector.Y;
			if (zero2.Y == 0f)
			{
				DDoorX[numDDoors] = (int)vector.X;
				DDoorY[numDDoors] = (int)vector.Y;
				DDoorPos[numDDoors] = 0;
				numDDoors++;
			}
			else
			{
				dungeonPlatformX[numDungeonPlatforms] = (int)vector.X;
				dungeonPlatformY[numDungeonPlatforms] = (int)vector.Y;
				numDungeonPlatforms++;
			}
		}

		public static void DungeonRoom(int i, int j, ushort tileType, int wallType)
		{
			double num = genRand.Next(15, 30);
			Vector2 vector = default(Vector2);
			vector.X = (float)genRand.Next(-10, 11) * 0.1f;
			vector.Y = (float)genRand.Next(-10, 11) * 0.1f;
			Vector2 vector2 = default(Vector2);
			vector2.X = i;
			vector2.Y = (float)j - (float)num / 2f;
			int num2 = genRand.Next(10, 20);
			double num3 = vector2.X;
			double num4 = vector2.X;
			double num5 = vector2.Y;
			double num6 = vector2.Y;
			while (num2 > 0)
			{
				num2--;
				int num7 = (int)((double)vector2.X - num * 0.800000011920929 - 5.0);
				int num8 = (int)((double)vector2.X + num * 0.800000011920929 + 5.0);
				int num9 = (int)((double)vector2.Y - num * 0.800000011920929 - 5.0);
				int num10 = (int)((double)vector2.Y + num * 0.800000011920929 + 5.0);
				if (num7 < 0)
				{
					num7 = 0;
				}
				if (num8 > Main.maxTilesX)
				{
					num8 = Main.maxTilesX;
				}
				if (num9 < 0)
				{
					num9 = 0;
				}
				if (num10 > Main.maxTilesY)
				{
					num10 = Main.maxTilesY;
				}
				for (int k = num7; k < num8; k++)
				{
					for (int l = num9; l < num10; l++)
					{
						if (k < dMinX)
						{
							dMinX = k;
						}
						if (k > dMaxX)
						{
							dMaxX = k;
						}
						if (l > dMaxY)
						{
							dMaxY = l;
						}
						Main.tile[k, l].liquid = 0;
						if (!Main.wallDungeon[Main.tile[k, l].wall])
						{
							Main.tile[k, l].Clear(TileDataType.Slope);
							Main.tile[k, l].active(active: true);
							Main.tile[k, l].type = tileType;
						}
					}
				}
				for (int m = num7 + 1; m < num8 - 1; m++)
				{
					for (int n = num9 + 1; n < num10 - 1; n++)
					{
						Main.tile[m, n].wall = (ushort)wallType;
					}
				}
				num7 = (int)((double)vector2.X - num * 0.5);
				num8 = (int)((double)vector2.X + num * 0.5);
				num9 = (int)((double)vector2.Y - num * 0.5);
				num10 = (int)((double)vector2.Y + num * 0.5);
				if (num7 < 0)
				{
					num7 = 0;
				}
				if (num8 > Main.maxTilesX)
				{
					num8 = Main.maxTilesX;
				}
				if (num9 < 0)
				{
					num9 = 0;
				}
				if (num10 > Main.maxTilesY)
				{
					num10 = Main.maxTilesY;
				}
				if ((double)num7 < num3)
				{
					num3 = num7;
				}
				if ((double)num8 > num4)
				{
					num4 = num8;
				}
				if ((double)num9 < num5)
				{
					num5 = num9;
				}
				if ((double)num10 > num6)
				{
					num6 = num10;
				}
				for (int num11 = num7; num11 < num8; num11++)
				{
					for (int num12 = num9; num12 < num10; num12++)
					{
						Main.tile[num11, num12].active(active: false);
						Main.tile[num11, num12].wall = (ushort)wallType;
					}
				}
				vector2 += vector;
				vector.X += (float)genRand.Next(-10, 11) * 0.05f;
				vector.Y += (float)genRand.Next(-10, 11) * 0.05f;
				if (vector.X > 1f)
				{
					vector.X = 1f;
				}
				if (vector.X < -1f)
				{
					vector.X = -1f;
				}
				if (vector.Y > 1f)
				{
					vector.Y = 1f;
				}
				if (vector.Y < -1f)
				{
					vector.Y = -1f;
				}
			}
			dRoomX[numDRooms] = (int)vector2.X;
			dRoomY[numDRooms] = (int)vector2.Y;
			dRoomSize[numDRooms] = (int)num;
			dRoomL[numDRooms] = (int)num3;
			dRoomR[numDRooms] = (int)num4;
			dRoomT[numDRooms] = (int)num5;
			dRoomB[numDRooms] = (int)num6;
			dRoomTreasure[numDRooms] = false;
			numDRooms++;
		}

		public static void DungeonEnt(int i, int j, ushort tileType, int wallType)
		{
			int num = 60;
			for (int k = i - num; k < i + num; k++)
			{
				for (int l = j - num; l < j + num; l++)
				{
					Main.tile[k, l].liquid = 0;
					Main.tile[k, l].lava(lava: false);
					Main.tile[k, l].Clear(TileDataType.Slope);
				}
			}
			double num2 = dxStrength1;
			double num3 = dyStrength1;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = (float)j - (float)num3 / 2f;
			dMinY = (int)vector.Y;
			int num4 = 1;
			if (i > Main.maxTilesX / 2)
			{
				num4 = -1;
			}
			if (drunkWorldGen || getGoodWorldGen)
			{
				num4 *= -1;
			}
			int num5 = (int)((double)vector.X - num2 * 0.60000002384185791 - (double)genRand.Next(2, 5));
			int num6 = (int)((double)vector.X + num2 * 0.60000002384185791 + (double)genRand.Next(2, 5));
			int num7 = (int)((double)vector.Y - num3 * 0.60000002384185791 - (double)genRand.Next(2, 5));
			int num8 = (int)((double)vector.Y + num3 * 0.60000002384185791 + (double)genRand.Next(8, 16));
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesX)
			{
				num6 = Main.maxTilesX;
			}
			if (num7 < 0)
			{
				num7 = 0;
			}
			if (num8 > Main.maxTilesY)
			{
				num8 = Main.maxTilesY;
			}
			for (int m = num5; m < num6; m++)
			{
				for (int n = num7; n < num8; n++)
				{
					Main.tile[m, n].liquid = 0;
					if (Main.tile[m, n].wall != wallType)
					{
						Main.tile[m, n].wall = 0;
						if (m > num5 + 1 && m < num6 - 2 && n > num7 + 1 && n < num8 - 2)
						{
							Main.tile[m, n].wall = (ushort)wallType;
						}
						Main.tile[m, n].active(active: true);
						Main.tile[m, n].type = tileType;
						Main.tile[m, n].Clear(TileDataType.Slope);
					}
				}
			}
			int num9 = num5;
			int num10 = num5 + 5 + genRand.Next(4);
			int num11 = num7 - 3 - genRand.Next(3);
			int num12 = num7;
			for (int num13 = num9; num13 < num10; num13++)
			{
				for (int num14 = num11; num14 < num12; num14++)
				{
					Main.tile[num13, num14].liquid = 0;
					if (Main.tile[num13, num14].wall != wallType)
					{
						Main.tile[num13, num14].active(active: true);
						Main.tile[num13, num14].type = tileType;
						Main.tile[num13, num14].Clear(TileDataType.Slope);
					}
				}
			}
			num9 = num6 - 5 - genRand.Next(4);
			num10 = num6;
			num11 = num7 - 3 - genRand.Next(3);
			num12 = num7;
			for (int num15 = num9; num15 < num10; num15++)
			{
				for (int num16 = num11; num16 < num12; num16++)
				{
					Main.tile[num15, num16].liquid = 0;
					if (Main.tile[num15, num16].wall != wallType)
					{
						Main.tile[num15, num16].active(active: true);
						Main.tile[num15, num16].type = tileType;
						Main.tile[num15, num16].Clear(TileDataType.Slope);
					}
				}
			}
			int num17 = 1 + genRand.Next(2);
			int num18 = 2 + genRand.Next(4);
			int num19 = 0;
			for (int num20 = num5; num20 < num6; num20++)
			{
				for (int num21 = num7 - num17; num21 < num7; num21++)
				{
					Main.tile[num20, num21].liquid = 0;
					if (Main.tile[num20, num21].wall != wallType)
					{
						Main.tile[num20, num21].active(active: true);
						Main.tile[num20, num21].type = tileType;
						Main.tile[num20, num21].Clear(TileDataType.Slope);
					}
				}
				num19++;
				if (num19 >= num18)
				{
					num20 += num18;
					num19 = 0;
				}
			}
			for (int num22 = num5; num22 < num6; num22++)
			{
				for (int num23 = num8; (double)num23 < Main.worldSurface; num23++)
				{
					Main.tile[num22, num23].liquid = 0;
					if (!Main.wallDungeon[Main.tile[num22, num23].wall])
					{
						Main.tile[num22, num23].active(active: true);
						Main.tile[num22, num23].type = tileType;
					}
					if (num22 > num5 && num22 < num6 - 1)
					{
						Main.tile[num22, num23].wall = (ushort)wallType;
					}
					Main.tile[num22, num23].Clear(TileDataType.Slope);
				}
			}
			num5 = (int)((double)vector.X - num2 * 0.60000002384185791);
			num6 = (int)((double)vector.X + num2 * 0.60000002384185791);
			num7 = (int)((double)vector.Y - num3 * 0.60000002384185791);
			num8 = (int)((double)vector.Y + num3 * 0.60000002384185791);
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesX)
			{
				num6 = Main.maxTilesX;
			}
			if (num7 < 0)
			{
				num7 = 0;
			}
			if (num8 > Main.maxTilesY)
			{
				num8 = Main.maxTilesY;
			}
			for (int num24 = num5; num24 < num6; num24++)
			{
				for (int num25 = num7; num25 < num8; num25++)
				{
					Main.tile[num24, num25].liquid = 0;
					Main.tile[num24, num25].wall = (ushort)wallType;
					Main.tile[num24, num25].Clear(TileDataType.Slope);
				}
			}
			num5 = (int)((double)vector.X - num2 * 0.6 - 1.0);
			num6 = (int)((double)vector.X + num2 * 0.6 + 1.0);
			num7 = (int)((double)vector.Y - num3 * 0.6 - 1.0);
			num8 = (int)((double)vector.Y + num3 * 0.6 + 1.0);
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesX)
			{
				num6 = Main.maxTilesX;
			}
			if (num7 < 0)
			{
				num7 = 0;
			}
			if (num8 > Main.maxTilesY)
			{
				num8 = Main.maxTilesY;
			}
			if (drunkWorldGen)
			{
				num5 -= 4;
			}
			for (int num26 = num5; num26 < num6; num26++)
			{
				for (int num27 = num7; num27 < num8; num27++)
				{
					Main.tile[num26, num27].liquid = 0;
					Main.tile[num26, num27].wall = (ushort)wallType;
					Main.tile[num26, num27].Clear(TileDataType.Slope);
				}
			}
			num5 = (int)((double)vector.X - num2 * 0.5);
			num6 = (int)((double)vector.X + num2 * 0.5);
			num7 = (int)((double)vector.Y - num3 * 0.5);
			num8 = (int)((double)vector.Y + num3 * 0.5);
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesX)
			{
				num6 = Main.maxTilesX;
			}
			if (num7 < 0)
			{
				num7 = 0;
			}
			if (num8 > Main.maxTilesY)
			{
				num8 = Main.maxTilesY;
			}
			for (int num28 = num5; num28 < num6; num28++)
			{
				for (int num29 = num7; num29 < num8; num29++)
				{
					Main.tile[num28, num29].liquid = 0;
					Main.tile[num28, num29].active(active: false);
					Main.tile[num28, num29].wall = (ushort)wallType;
				}
			}
			int num30 = (int)vector.X;
			int num31 = num8;
			for (int num32 = 0; num32 < 20; num32++)
			{
				num30 = (int)vector.X - num32;
				if (!Main.tile[num30, num31].active() && Main.wallDungeon[Main.tile[num30, num31].wall])
				{
					dungeonPlatformX[numDungeonPlatforms] = num30;
					dungeonPlatformY[numDungeonPlatforms] = num31;
					numDungeonPlatforms++;
					break;
				}
				num30 = (int)vector.X + num32;
				if (!Main.tile[num30, num31].active() && Main.wallDungeon[Main.tile[num30, num31].wall])
				{
					dungeonPlatformX[numDungeonPlatforms] = num30;
					dungeonPlatformY[numDungeonPlatforms] = num31;
					numDungeonPlatforms++;
					break;
				}
			}
			vector.X += (float)num2 * 0.6f * (float)num4;
			vector.Y += (float)num3 * 0.5f;
			num2 = dxStrength2;
			num3 = dyStrength2;
			vector.X += (float)num2 * 0.55f * (float)num4;
			vector.Y -= (float)num3 * 0.5f;
			num5 = (int)((double)vector.X - num2 * 0.60000002384185791 - (double)genRand.Next(1, 3));
			num6 = (int)((double)vector.X + num2 * 0.60000002384185791 + (double)genRand.Next(1, 3));
			num7 = (int)((double)vector.Y - num3 * 0.60000002384185791 - (double)genRand.Next(1, 3));
			num8 = (int)((double)vector.Y + num3 * 0.60000002384185791 + (double)genRand.Next(6, 16));
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesX)
			{
				num6 = Main.maxTilesX;
			}
			if (num7 < 0)
			{
				num7 = 0;
			}
			if (num8 > Main.maxTilesY)
			{
				num8 = Main.maxTilesY;
			}
			for (int num33 = num5; num33 < num6; num33++)
			{
				for (int num34 = num7; num34 < num8; num34++)
				{
					Main.tile[num33, num34].liquid = 0;
					if (Main.tile[num33, num34].wall == wallType)
					{
						continue;
					}
					bool flag = true;
					if (num4 < 0)
					{
						if ((double)num33 < (double)vector.X - num2 * 0.5)
						{
							flag = false;
						}
					}
					else if ((double)num33 > (double)vector.X + num2 * 0.5 - 1.0)
					{
						flag = false;
					}
					if (flag)
					{
						Main.tile[num33, num34].wall = 0;
						Main.tile[num33, num34].active(active: true);
						Main.tile[num33, num34].type = tileType;
						Main.tile[num33, num34].Clear(TileDataType.Slope);
					}
				}
			}
			for (int num35 = num5; num35 < num6; num35++)
			{
				for (int num36 = num8; (double)num36 < Main.worldSurface; num36++)
				{
					Main.tile[num35, num36].liquid = 0;
					if (!Main.wallDungeon[Main.tile[num35, num36].wall])
					{
						Main.tile[num35, num36].active(active: true);
						Main.tile[num35, num36].type = tileType;
					}
					Main.tile[num35, num36].wall = (ushort)wallType;
					Main.tile[num35, num36].Clear(TileDataType.Slope);
				}
			}
			num5 = (int)((double)vector.X - num2 * 0.5);
			num6 = (int)((double)vector.X + num2 * 0.5);
			num9 = num5;
			if (num4 < 0)
			{
				num9++;
			}
			num10 = num9 + 5 + genRand.Next(4);
			num11 = num7 - 3 - genRand.Next(3);
			num12 = num7;
			for (int num37 = num9; num37 < num10; num37++)
			{
				for (int num38 = num11; num38 < num12; num38++)
				{
					Main.tile[num37, num38].liquid = 0;
					if (Main.tile[num37, num38].wall != wallType)
					{
						Main.tile[num37, num38].active(active: true);
						Main.tile[num37, num38].type = tileType;
						Main.tile[num37, num38].Clear(TileDataType.Slope);
					}
				}
			}
			num9 = num6 - 5 - genRand.Next(4);
			num10 = num6;
			num11 = num7 - 3 - genRand.Next(3);
			num12 = num7;
			for (int num39 = num9; num39 < num10; num39++)
			{
				for (int num40 = num11; num40 < num12; num40++)
				{
					Main.tile[num39, num40].liquid = 0;
					if (Main.tile[num39, num40].wall != wallType)
					{
						Main.tile[num39, num40].active(active: true);
						Main.tile[num39, num40].type = tileType;
						Main.tile[num39, num40].Clear(TileDataType.Slope);
					}
				}
			}
			num17 = 1 + genRand.Next(2);
			num18 = 2 + genRand.Next(4);
			num19 = 0;
			if (num4 < 0)
			{
				num6++;
			}
			for (int num41 = num5 + 1; num41 < num6 - 1; num41++)
			{
				for (int num42 = num7 - num17; num42 < num7; num42++)
				{
					Main.tile[num41, num42].liquid = 0;
					if (Main.tile[num41, num42].wall != wallType)
					{
						Main.tile[num41, num42].active(active: true);
						Main.tile[num41, num42].type = tileType;
						Main.tile[num41, num42].Clear(TileDataType.Slope);
					}
				}
				num19++;
				if (num19 >= num18)
				{
					num41 += num18;
					num19 = 0;
				}
			}
			if (!drunkWorldGen)
			{
				num5 = (int)((double)vector.X - num2 * 0.6);
				num6 = (int)((double)vector.X + num2 * 0.6);
				num7 = (int)((double)vector.Y - num3 * 0.6);
				num8 = (int)((double)vector.Y + num3 * 0.6);
				if (num5 < 0)
				{
					num5 = 0;
				}
				if (num6 > Main.maxTilesX)
				{
					num6 = Main.maxTilesX;
				}
				if (num7 < 0)
				{
					num7 = 0;
				}
				if (num8 > Main.maxTilesY)
				{
					num8 = Main.maxTilesY;
				}
				for (int num43 = num5; num43 < num6; num43++)
				{
					for (int num44 = num7; num44 < num8; num44++)
					{
						Main.tile[num43, num44].liquid = 0;
						Main.tile[num43, num44].wall = 0;
					}
				}
			}
			num5 = (int)((double)vector.X - num2 * 0.5);
			num6 = (int)((double)vector.X + num2 * 0.5);
			num7 = (int)((double)vector.Y - num3 * 0.5);
			num8 = (int)((double)vector.Y + num3 * 0.5);
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesX)
			{
				num6 = Main.maxTilesX;
			}
			if (num7 < 0)
			{
				num7 = 0;
			}
			if (num8 > Main.maxTilesY)
			{
				num8 = Main.maxTilesY;
			}
			for (int num45 = num5; num45 < num6; num45++)
			{
				for (int num46 = num7; num46 < num8; num46++)
				{
					Main.tile[num45, num46].liquid = 0;
					Main.tile[num45, num46].active(active: false);
					Main.tile[num45, num46].wall = 0;
				}
			}
			Main.dungeonX = (int)vector.X;
			Main.dungeonY = num8;
			int num47 = NPC.NewNPC(Main.dungeonX * 16 + 8, Main.dungeonY * 16, 37);
			Main.npc[num47].homeless = false;
			Main.npc[num47].homeTileX = Main.dungeonX;
			Main.npc[num47].homeTileY = Main.dungeonY;
			if (drunkWorldGen)
			{
				int num48 = (int)Main.worldSurface;
				while (Main.tile[dungeonX, num48].active() || Main.tile[dungeonX, num48].wall > 0 || Main.tile[dungeonX, num48 - 1].active() || Main.tile[dungeonX, num48 - 1].wall > 0 || Main.tile[dungeonX, num48 - 2].active() || Main.tile[dungeonX, num48 - 2].wall > 0 || Main.tile[dungeonX, num48 - 3].active() || Main.tile[dungeonX, num48 - 3].wall > 0 || Main.tile[dungeonX, num48 - 4].active() || Main.tile[dungeonX, num48 - 4].wall > 0)
				{
					num48--;
					if (num48 < 50)
					{
						break;
					}
				}
				if (num48 > 50)
				{
					GrowDungeonTree(dungeonX, num48);
				}
			}
			if (!drunkWorldGen)
			{
				int num49 = 100;
				if (num4 == 1)
				{
					int num50 = 0;
					for (int num51 = num6; num51 < num6 + num49; num51++)
					{
						num50++;
						for (int num52 = num8 + num50; num52 < num8 + num49; num52++)
						{
							Main.tile[num51, num52].liquid = 0;
							Main.tile[num51, num52 - 1].liquid = 0;
							Main.tile[num51, num52 - 2].liquid = 0;
							Main.tile[num51, num52 - 3].liquid = 0;
							if (!Main.wallDungeon[Main.tile[num51, num52].wall] && Main.tile[num51, num52].wall != 3 && Main.tile[num51, num52].wall != 83)
							{
								Main.tile[num51, num52].active(active: true);
								Main.tile[num51, num52].type = tileType;
								Main.tile[num51, num52].Clear(TileDataType.Slope);
							}
						}
					}
				}
				else
				{
					int num53 = 0;
					for (int num54 = num5; num54 > num5 - num49; num54--)
					{
						num53++;
						for (int num55 = num8 + num53; num55 < num8 + num49; num55++)
						{
							Main.tile[num54, num55].liquid = 0;
							Main.tile[num54, num55 - 1].liquid = 0;
							Main.tile[num54, num55 - 2].liquid = 0;
							Main.tile[num54, num55 - 3].liquid = 0;
							if (!Main.wallDungeon[Main.tile[num54, num55].wall] && Main.tile[num54, num55].wall != 3 && Main.tile[num54, num55].wall != 83)
							{
								Main.tile[num54, num55].active(active: true);
								Main.tile[num54, num55].type = tileType;
								Main.tile[num54, num55].Clear(TileDataType.Slope);
							}
						}
					}
				}
			}
			num17 = 1 + genRand.Next(2);
			num18 = 2 + genRand.Next(4);
			num19 = 0;
			num5 = (int)((double)vector.X - num2 * 0.5);
			num6 = (int)((double)vector.X + num2 * 0.5);
			if (drunkWorldGen)
			{
				if (num4 == 1)
				{
					num6--;
					num5--;
				}
				else
				{
					num5++;
					num6++;
				}
			}
			else
			{
				num5 += 2;
				num6 -= 2;
			}
			for (int num56 = num5; num56 < num6; num56++)
			{
				for (int num57 = num7; num57 < num8 + 1; num57++)
				{
					PlaceWall(num56, num57, wallType, mute: true);
				}
				if (!drunkWorldGen)
				{
					num19++;
					if (num19 >= num18)
					{
						num56 += num18 * 2;
						num19 = 0;
					}
				}
			}
			if (drunkWorldGen)
			{
				num5 = (int)((double)vector.X - num2 * 0.5);
				num6 = (int)((double)vector.X + num2 * 0.5);
				if (num4 == 1)
				{
					num5 = num6 - 3;
				}
				else
				{
					num6 = num5 + 3;
				}
				for (int num58 = num5; num58 < num6; num58++)
				{
					for (int num59 = num7; num59 < num8 + 1; num59++)
					{
						Main.tile[num58, num59].active(active: true);
						Main.tile[num58, num59].type = tileType;
						Main.tile[num58, num59].Clear(TileDataType.Slope);
					}
				}
			}
			vector.X -= (float)num2 * 0.6f * (float)num4;
			vector.Y += (float)num3 * 0.5f;
			num2 = 15.0;
			num3 = 3.0;
			vector.Y -= (float)num3 * 0.5f;
			num5 = (int)((double)vector.X - num2 * 0.5);
			num6 = (int)((double)vector.X + num2 * 0.5);
			num7 = (int)((double)vector.Y - num3 * 0.5);
			num8 = (int)((double)vector.Y + num3 * 0.5);
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesX)
			{
				num6 = Main.maxTilesX;
			}
			if (num7 < 0)
			{
				num7 = 0;
			}
			if (num8 > Main.maxTilesY)
			{
				num8 = Main.maxTilesY;
			}
			for (int num60 = num5; num60 < num6; num60++)
			{
				for (int num61 = num7; num61 < num8; num61++)
				{
					Main.tile[num60, num61].active(active: false);
				}
			}
			if (num4 < 0)
			{
				vector.X -= 1f;
			}
			PlaceTile((int)vector.X, (int)vector.Y + 1, 10, mute: true, forced: false, -1, 13);
		}

		public static bool AddBuriedChest(Point point, int contain = 0, bool notNearOtherChests = false, int Style = -1)
		{
			return AddBuriedChest(point.X, point.Y, contain, notNearOtherChests, Style, trySlope: false, 0);
		}

		public static bool IsChestRigged(int x, int y)
		{
			if (Main.tile[x, y].type == 467)
			{
				return Main.tile[x, y].frameX / 36 == 4;
			}
			return false;
		}

		private static bool IsUndergroundDesert(int x, int y)
		{
			if ((double)y < Main.worldSurface)
			{
				return false;
			}
			if ((double)x < (double)Main.maxTilesX * 0.15 || (double)x > (double)Main.maxTilesX * 0.85)
			{
				return false;
			}
			int num = 15;
			for (int i = x - num; i <= x + num; i++)
			{
				for (int j = y - num; j <= y + num; j++)
				{
					if (Main.tile[i, j].wall == 187 || Main.tile[i, j].wall == 216)
					{
						return true;
					}
				}
			}
			return false;
		}

		private static bool IsDungeon(int x, int y)
		{
			if ((double)y < Main.worldSurface)
			{
				return false;
			}
			if (x < 0 || x > Main.maxTilesX)
			{
				return false;
			}
			if (Main.wallDungeon[Main.tile[x, y].wall])
			{
				return true;
			}
			return false;
		}

		public static bool AddBuriedChest(int i, int j, int contain = 0, bool notNearOtherChests = false, int Style = -1, bool trySlope = false, ushort chestTileType = 0)
		{
			if (chestTileType == 0)
			{
				chestTileType = 21;
			}
			bool flag = false;
			bool flag2 = false;
			bool flag3 = false;
			bool flag4 = false;
			bool flag5 = false;
			bool flag6 = false;
			bool flag7 = false;
			bool flag8 = false;
			int maxValue = 15;
			for (int k = j; k < Main.maxTilesY - 10; k++)
			{
				int num = -1;
				int num2 = -1;
				if (trySlope && Main.tile[i, k].active() && Main.tileSolid[Main.tile[i, k].type] && !Main.tileSolidTop[Main.tile[i, k].type])
				{
					if (Style == 17)
					{
						int num3 = 30;
						for (int l = i - num3; l <= i + num3; l++)
						{
							for (int m = k - num3; m <= k + num3; m++)
							{
								if (!InWorld(l, m, 5))
								{
									return false;
								}
								if (Main.tile[l, m].active() && (Main.tile[l, m].type == 21 || Main.tile[l, m].type == 467))
								{
									return false;
								}
							}
						}
					}
					if (Main.tile[i - 1, k].topSlope())
					{
						num = Main.tile[i - 1, k].slope();
						Main.tile[i - 1, k].slope(0);
					}
					if (Main.tile[i, k].topSlope())
					{
						num2 = Main.tile[i, k].slope();
						Main.tile[i, k].slope(0);
					}
				}
				int num4 = 2;
				for (int n = i - num4; n <= i + num4; n++)
				{
					for (int num5 = k - num4; num5 <= k + num4; num5++)
					{
						if (Main.tile[n, num5].active() && (TileID.Sets.Boulders[Main.tile[n, num5].type] || Main.tile[n, num5].type == 26 || Main.tile[n, num5].type == 237))
						{
							return false;
						}
					}
				}
				if (!SolidTile(i, k))
				{
					continue;
				}
				bool flag9 = false;
				int num6 = k;
				int num7 = -1;
				int num8 = 0;
				if ((double)num6 >= Main.worldSurface + 25.0 || contain > 0)
				{
					num8 = 1;
				}
				if (Style >= 0)
				{
					num8 = Style;
				}
				if (contain == 0 && (double)num6 >= Main.worldSurface + 25.0 && num6 <= Main.maxTilesY - 205 && IsUndergroundDesert(i, k))
				{
					flag2 = true;
					num8 = 10;
					chestTileType = 467;
					int num9 = -1;
					int num10 = -1;
					for (int num11 = (int)Main.worldSurface - 100; num11 < Main.maxTilesY - 200; num11++)
					{
						for (int num12 = 100; num12 < Main.maxTilesX - 100; num12++)
						{
							if (Main.tile[num12, num11].wall == 216 || Main.tile[num12, num11].wall == 187)
							{
								if (num9 == -1)
								{
									num9 = num11;
								}
								num10 = num11;
								break;
							}
						}
					}
					contain = ((num6 <= (num9 * 3 + num10 * 4) / 7) ? Utils.SelectRandom(genRand, new short[4]
					{
						4056,
						4055,
						4262,
						4263
					}) : Utils.SelectRandom(genRand, new short[3]
					{
						4061,
						4062,
						4276
					}));
					if (getGoodWorldGen && genRand.Next(maxValue) == 0)
					{
						contain = 52;
					}
				}
				if (chestTileType == 21 && (num8 == 11 || (contain == 0 && (double)num6 >= Main.worldSurface + 25.0 && num6 <= Main.maxTilesY - 205 && (Main.tile[i, k].type == 147 || Main.tile[i, k].type == 161 || Main.tile[i, k].type == 162))))
				{
					flag = true;
					num8 = 11;
					contain = genRand.Next(6) switch
					{
						0 => 670, 
						1 => 724, 
						2 => 950, 
						3 => 1319, 
						4 => 987, 
						_ => 1579, 
					};
					if (genRand.Next(20) == 0)
					{
						contain = 997;
					}
					if (genRand.Next(50) == 0)
					{
						contain = 669;
					}
					if (getGoodWorldGen && genRand.Next(maxValue) == 0)
					{
						contain = 52;
					}
				}
				if (chestTileType == 21 && (Style == 10 || contain == 211 || contain == 212 || contain == 213 || contain == 753))
				{
					flag3 = true;
					num8 = 10;
					if (getGoodWorldGen && genRand.Next(maxValue) == 0)
					{
						contain = 52;
					}
				}
				if (chestTileType == 21 && num6 > Main.maxTilesY - 205 && contain == 0)
				{
					flag7 = true;
					if (hellChest == hellChestItem[1])
					{
						contain = 220;
						num8 = 4;
						flag9 = true;
					}
					else if (hellChest == hellChestItem[2])
					{
						contain = 112;
						num8 = 4;
						flag9 = true;
					}
					else if (hellChest == hellChestItem[3])
					{
						contain = 218;
						num8 = 4;
						flag9 = true;
					}
					else if (hellChest == hellChestItem[4])
					{
						contain = 274;
						num8 = 4;
						flag9 = true;
					}
					else if (hellChest == hellChestItem[5])
					{
						contain = 3019;
						num8 = 4;
						flag9 = true;
					}
					else
					{
						contain = 5010;
						num8 = 4;
						flag9 = true;
					}
					if (getGoodWorldGen && genRand.Next(maxValue) == 0)
					{
						contain = 52;
					}
				}
				if (chestTileType == 21 && num8 == 17)
				{
					flag4 = true;
					if (getGoodWorldGen && genRand.Next(maxValue) == 0)
					{
						contain = 52;
					}
				}
				if (chestTileType == 21 && num8 == 12)
				{
					flag5 = true;
					if (getGoodWorldGen && genRand.Next(maxValue) == 0)
					{
						contain = 52;
					}
				}
				if (chestTileType == 21 && num8 == 32)
				{
					flag6 = true;
					if (getGoodWorldGen && genRand.Next(maxValue) == 0)
					{
						contain = 52;
					}
				}
				if (chestTileType == 21 && num8 != 0 && IsDungeon(i, k))
				{
					flag8 = true;
					if (getGoodWorldGen && genRand.Next(maxValue) == 0)
					{
						contain = 52;
					}
				}
				num7 = ((chestTileType != 467) ? PlaceChest(i - 1, num6 - 1, chestTileType, notNearOtherChests, num8) : PlaceChest(i - 1, num6 - 1, chestTileType, notNearOtherChests, num8));
				if (num7 >= 0)
				{
					if (flag9)
					{
						hellChest++;
						if (hellChest > 4)
						{
							hellChest = 0;
						}
					}
					Chest chest = Main.chest[num7];
					int num13 = 0;
					while (num13 == 0)
					{
						if ((num8 == 0 && (double)num6 < Main.worldSurface + 25.0) || contain == 848)
						{
							if (contain > 0)
							{
								chest.item[num13].SetDefaults(contain);
								chest.item[num13].Prefix(-1);
								num13++;
								switch (contain)
								{
								case 848:
									chest.item[num13].SetDefaults(866);
									num13++;
									break;
								case 832:
									chest.item[num13].SetDefaults(933);
									num13++;
									if (genRand.Next(10) == 0)
									{
										int num14 = genRand.Next(2);
										switch (num14)
										{
										case 0:
											num14 = 4429;
											break;
										case 1:
											num14 = 4427;
											break;
										}
										chest.item[num13].SetDefaults(num14);
										num13++;
									}
									break;
								}
							}
							else
							{
								int num15 = genRand.Next(12);
								if (num15 == 0)
								{
									chest.item[num13].SetDefaults(280);
									chest.item[num13].Prefix(-1);
								}
								if (num15 == 1)
								{
									chest.item[num13].SetDefaults(281);
									chest.item[num13].Prefix(-1);
								}
								if (num15 == 2)
								{
									chest.item[num13].SetDefaults(284);
									chest.item[num13].Prefix(-1);
								}
								if (num15 == 3)
								{
									chest.item[num13].SetDefaults(282);
									chest.item[num13].stack = genRand.Next(40, 75);
								}
								if (num15 == 4)
								{
									chest.item[num13].SetDefaults(279);
									chest.item[num13].stack = genRand.Next(150, 300);
								}
								if (num15 == 5)
								{
									chest.item[num13].SetDefaults(285);
									chest.item[num13].Prefix(-1);
								}
								if (num15 == 6)
								{
									chest.item[num13].SetDefaults(953);
									chest.item[num13].Prefix(-1);
								}
								if (num15 == 7)
								{
									chest.item[num13].SetDefaults(946);
									chest.item[num13].Prefix(-1);
								}
								if (num15 == 8)
								{
									chest.item[num13].SetDefaults(3068);
									chest.item[num13].Prefix(-1);
								}
								if (num15 == 9)
								{
									chest.item[num13].SetDefaults(3069);
									chest.item[num13].Prefix(-1);
								}
								if (num15 == 10)
								{
									chest.item[num13].SetDefaults(3084);
									chest.item[num13].Prefix(-1);
								}
								if (num15 == 11)
								{
									chest.item[num13].SetDefaults(4341);
									chest.item[num13].Prefix(-1);
								}
								num13++;
							}
							if (genRand.Next(6) == 0)
							{
								chest.item[num13].SetDefaults(3093);
								chest.item[num13].stack = 1;
								if (genRand.Next(5) == 0)
								{
									chest.item[num13].stack += genRand.Next(2);
								}
								if (genRand.Next(10) == 0)
								{
									chest.item[num13].stack += genRand.Next(3);
								}
								num13++;
							}
							if (genRand.Next(6) == 0)
							{
								chest.item[num13].SetDefaults(4345);
								chest.item[num13].stack = 1;
								if (genRand.Next(5) == 0)
								{
									chest.item[num13].stack += genRand.Next(2);
								}
								if (genRand.Next(10) == 0)
								{
									chest.item[num13].stack += genRand.Next(3);
								}
								num13++;
							}
							if (genRand.Next(3) == 0)
							{
								chest.item[num13].SetDefaults(168);
								chest.item[num13].stack = genRand.Next(3, 6);
								num13++;
							}
							if (genRand.Next(2) == 0)
							{
								int num16 = genRand.Next(2);
								int stack = genRand.Next(8) + 3;
								if (num16 == 0)
								{
									chest.item[num13].SetDefaults(copperBar);
								}
								if (num16 == 1)
								{
									chest.item[num13].SetDefaults(ironBar);
								}
								chest.item[num13].stack = stack;
								num13++;
							}
							if (genRand.Next(2) == 0)
							{
								int stack2 = genRand.Next(50, 101);
								chest.item[num13].SetDefaults(965);
								chest.item[num13].stack = stack2;
								num13++;
							}
							if (genRand.Next(3) != 0)
							{
								int num17 = genRand.Next(2);
								int stack3 = genRand.Next(26) + 25;
								if (num17 == 0)
								{
									chest.item[num13].SetDefaults(40);
								}
								if (num17 == 1)
								{
									chest.item[num13].SetDefaults(42);
								}
								chest.item[num13].stack = stack3;
								num13++;
							}
							if (genRand.Next(2) == 0)
							{
								int stack4 = genRand.Next(3) + 3;
								chest.item[num13].SetDefaults(28);
								chest.item[num13].stack = stack4;
								num13++;
							}
							if (genRand.Next(3) != 0)
							{
								chest.item[num13].SetDefaults(2350);
								chest.item[num13].stack = genRand.Next(3, 6);
								num13++;
							}
							if (genRand.Next(3) > 0)
							{
								int num18 = genRand.Next(6);
								int stack5 = genRand.Next(1, 3);
								if (num18 == 0)
								{
									chest.item[num13].SetDefaults(292);
								}
								if (num18 == 1)
								{
									chest.item[num13].SetDefaults(298);
								}
								if (num18 == 2)
								{
									chest.item[num13].SetDefaults(299);
								}
								if (num18 == 3)
								{
									chest.item[num13].SetDefaults(290);
								}
								if (num18 == 4)
								{
									chest.item[num13].SetDefaults(2322);
								}
								if (num18 == 5)
								{
									chest.item[num13].SetDefaults(2325);
								}
								chest.item[num13].stack = stack5;
								num13++;
							}
							if (genRand.Next(2) == 0)
							{
								int num19 = genRand.Next(2);
								int stack6 = genRand.Next(11) + 10;
								if (num19 == 0)
								{
									chest.item[num13].SetDefaults(8);
								}
								if (num19 == 1)
								{
									chest.item[num13].SetDefaults(31);
								}
								chest.item[num13].stack = stack6;
								num13++;
							}
							if (genRand.Next(2) == 0)
							{
								chest.item[num13].SetDefaults(72);
								chest.item[num13].stack = genRand.Next(10, 30);
								num13++;
							}
							if (genRand.Next(2) == 0)
							{
								chest.item[num13].SetDefaults(9);
								chest.item[num13].stack = genRand.Next(50, 100);
								num13++;
							}
						}
						else if ((double)num6 < Main.rockLayer)
						{
							if (contain > 0)
							{
								if (contain == 832)
								{
									chest.item[num13].SetDefaults(933);
									num13++;
								}
								chest.item[num13].SetDefaults(contain);
								chest.item[num13].Prefix(-1);
								num13++;
								if (flag4 && genRand.Next(2) == 0)
								{
									chest.item[num13].SetDefaults(4460);
									num13++;
								}
								if (flag5 && genRand.Next(10) == 0)
								{
									int num20 = genRand.Next(2);
									switch (num20)
									{
									case 0:
										num20 = 4429;
										break;
									case 1:
										num20 = 4427;
										break;
									}
									chest.item[num13].SetDefaults(num20);
									num13++;
								}
								if (flag8 && (!generatedShadowKey || genRand.Next(3) == 0))
								{
									generatedShadowKey = true;
									chest.item[num13].SetDefaults(329);
									num13++;
								}
							}
							else
							{
								switch (genRand.Next(6))
								{
								case 0:
									chest.item[num13].SetDefaults(49);
									chest.item[num13].Prefix(-1);
									break;
								case 1:
									chest.item[num13].SetDefaults(50);
									chest.item[num13].Prefix(-1);
									break;
								case 2:
									chest.item[num13].SetDefaults(53);
									chest.item[num13].Prefix(-1);
									break;
								case 3:
									chest.item[num13].SetDefaults(54);
									chest.item[num13].Prefix(-1);
									break;
								case 4:
									chest.item[num13].SetDefaults(5011);
									chest.item[num13].Prefix(-1);
									break;
								default:
									chest.item[num13].SetDefaults(975);
									chest.item[num13].Prefix(-1);
									break;
								}
								num13++;
								if (genRand.Next(20) == 0)
								{
									chest.item[num13].SetDefaults(997);
									chest.item[num13].Prefix(-1);
									num13++;
								}
								else if (genRand.Next(20) == 0)
								{
									chest.item[num13].SetDefaults(930);
									chest.item[num13].Prefix(-1);
									num13++;
									chest.item[num13].SetDefaults(931);
									chest.item[num13].stack = genRand.Next(26) + 25;
									num13++;
								}
								if (flag6 && genRand.Next(2) == 0)
								{
									chest.item[num13].SetDefaults(4450);
									num13++;
								}
								if (flag6 && genRand.Next(3) == 0)
								{
									chest.item[num13].SetDefaults(4779);
									num13++;
									chest.item[num13].SetDefaults(4780);
									num13++;
									chest.item[num13].SetDefaults(4781);
									num13++;
								}
							}
							if (flag2)
							{
								if (genRand.Next(3) == 0)
								{
									chest.item[num13].SetDefaults(4423);
									chest.item[num13].stack = genRand.Next(10, 20);
									num13++;
								}
							}
							else if (genRand.Next(3) == 0)
							{
								chest.item[num13].SetDefaults(166);
								chest.item[num13].stack = genRand.Next(10, 20);
								num13++;
							}
							if (genRand.Next(5) == 0)
							{
								chest.item[num13].SetDefaults(52);
								num13++;
							}
							if (genRand.Next(3) == 0)
							{
								int stack7 = genRand.Next(50, 101);
								chest.item[num13].SetDefaults(965);
								chest.item[num13].stack = stack7;
								num13++;
							}
							if (genRand.Next(2) == 0)
							{
								int num21 = genRand.Next(2);
								int stack8 = genRand.Next(10) + 5;
								if (num21 == 0)
								{
									chest.item[num13].SetDefaults(ironBar);
								}
								if (num21 == 1)
								{
									chest.item[num13].SetDefaults(silverBar);
								}
								chest.item[num13].stack = stack8;
								num13++;
							}
							if (genRand.Next(2) == 0)
							{
								int num22 = genRand.Next(2);
								int stack9 = genRand.Next(25) + 25;
								if (num22 == 0)
								{
									chest.item[num13].SetDefaults(40);
								}
								if (num22 == 1)
								{
									chest.item[num13].SetDefaults(42);
								}
								chest.item[num13].stack = stack9;
								num13++;
							}
							if (genRand.Next(2) == 0)
							{
								int stack10 = genRand.Next(3) + 3;
								chest.item[num13].SetDefaults(28);
								chest.item[num13].stack = stack10;
								num13++;
							}
							if (genRand.Next(3) > 0)
							{
								int num23 = genRand.Next(9);
								int stack11 = genRand.Next(1, 3);
								if (num23 == 0)
								{
									chest.item[num13].SetDefaults(289);
								}
								if (num23 == 1)
								{
									chest.item[num13].SetDefaults(298);
								}
								if (num23 == 2)
								{
									chest.item[num13].SetDefaults(299);
								}
								if (num23 == 3)
								{
									chest.item[num13].SetDefaults(290);
								}
								if (num23 == 4)
								{
									chest.item[num13].SetDefaults(303);
								}
								if (num23 == 5)
								{
									chest.item[num13].SetDefaults(291);
								}
								if (num23 == 6)
								{
									chest.item[num13].SetDefaults(304);
								}
								if (num23 == 7)
								{
									chest.item[num13].SetDefaults(2322);
								}
								if (num23 == 8)
								{
									chest.item[num13].SetDefaults(2329);
								}
								chest.item[num13].stack = stack11;
								num13++;
							}
							if (genRand.Next(3) != 0)
							{
								int stack12 = genRand.Next(2, 5);
								chest.item[num13].SetDefaults(2350);
								chest.item[num13].stack = stack12;
								num13++;
							}
							if (genRand.Next(2) == 0)
							{
								int stack13 = genRand.Next(11) + 10;
								if (num8 == 11)
								{
									chest.item[num13].SetDefaults(974);
								}
								else
								{
									chest.item[num13].SetDefaults(8);
								}
								chest.item[num13].stack = stack13;
								num13++;
							}
							if (genRand.Next(2) == 0)
							{
								chest.item[num13].SetDefaults(72);
								chest.item[num13].stack = genRand.Next(50, 90);
								num13++;
							}
						}
						else if (num6 < Main.maxTilesY - 250)
						{
							if (contain > 0)
							{
								chest.item[num13].SetDefaults(contain);
								chest.item[num13].Prefix(-1);
								num13++;
								if (flag && genRand.Next(5) == 0)
								{
									chest.item[num13].SetDefaults(3199);
									num13++;
								}
								if (flag2)
								{
									if (genRand.Next(7) == 0)
									{
										chest.item[num13].SetDefaults(4346);
										num13++;
									}
									if (genRand.Next(15) == 0)
									{
										chest.item[num13].SetDefaults(4066);
										num13++;
									}
								}
								if (flag3 && genRand.Next(6) == 0)
								{
									chest.item[num13++].SetDefaults(3360);
									chest.item[num13++].SetDefaults(3361);
								}
								if (flag3 && genRand.Next(10) == 0)
								{
									chest.item[num13++].SetDefaults(4426);
								}
								if (flag4 && genRand.Next(2) == 0)
								{
									chest.item[num13].SetDefaults(4460);
									num13++;
								}
								if (flag8 && (!generatedShadowKey || genRand.Next(3) == 0))
								{
									generatedShadowKey = true;
									chest.item[num13].SetDefaults(329);
									num13++;
								}
							}
							else
							{
								int num24 = genRand.Next(7);
								if (genRand.Next(40) == 0 && num6 > lavaLine)
								{
									chest.item[num13].SetDefaults(906);
									chest.item[num13].Prefix(-1);
								}
								else if (genRand.Next(15) == 0)
								{
									chest.item[num13].SetDefaults(997);
									chest.item[num13].Prefix(-1);
								}
								else
								{
									if (num24 == 0)
									{
										chest.item[num13].SetDefaults(49);
										chest.item[num13].Prefix(-1);
									}
									if (num24 == 1)
									{
										chest.item[num13].SetDefaults(50);
										chest.item[num13].Prefix(-1);
									}
									if (num24 == 2)
									{
										chest.item[num13].SetDefaults(53);
										chest.item[num13].Prefix(-1);
									}
									if (num24 == 3)
									{
										chest.item[num13].SetDefaults(54);
										chest.item[num13].Prefix(-1);
									}
									if (num24 == 4)
									{
										chest.item[num13].SetDefaults(5011);
										chest.item[num13].Prefix(-1);
									}
									if (num24 == 5)
									{
										chest.item[num13].SetDefaults(975);
										chest.item[num13].Prefix(-1);
									}
									if (num24 == 6)
									{
										chest.item[num13].SetDefaults(930);
										chest.item[num13].Prefix(-1);
										num13++;
										chest.item[num13].SetDefaults(931);
										chest.item[num13].stack = genRand.Next(26) + 25;
									}
								}
								num13++;
								if (flag6 && genRand.Next(2) == 0)
								{
									chest.item[num13].SetDefaults(4450);
									num13++;
								}
								if (flag6 && genRand.Next(3) == 0)
								{
									chest.item[num13].SetDefaults(4779);
									num13++;
									chest.item[num13].SetDefaults(4780);
									num13++;
									chest.item[num13].SetDefaults(4781);
									num13++;
								}
							}
							if (genRand.Next(5) == 0)
							{
								chest.item[num13].SetDefaults(43);
								num13++;
							}
							if (genRand.Next(3) == 0)
							{
								chest.item[num13].SetDefaults(167);
								num13++;
							}
							if (genRand.Next(4) == 0)
							{
								chest.item[num13].SetDefaults(51);
								chest.item[num13].stack = genRand.Next(26) + 25;
								num13++;
							}
							if (genRand.Next(2) == 0)
							{
								int num25 = genRand.Next(2);
								int stack14 = genRand.Next(8) + 3;
								if (num25 == 0)
								{
									chest.item[num13].SetDefaults(goldBar);
								}
								if (num25 == 1)
								{
									chest.item[num13].SetDefaults(silverBar);
								}
								chest.item[num13].stack = stack14;
								num13++;
							}
							if (genRand.Next(2) == 0)
							{
								int num26 = genRand.Next(2);
								int stack15 = genRand.Next(26) + 25;
								if (num26 == 0)
								{
									chest.item[num13].SetDefaults(41);
								}
								if (num26 == 1)
								{
									chest.item[num13].SetDefaults(279);
								}
								chest.item[num13].stack = stack15;
								num13++;
							}
							if (genRand.Next(2) == 0)
							{
								int stack16 = genRand.Next(3) + 3;
								chest.item[num13].SetDefaults(188);
								chest.item[num13].stack = stack16;
								num13++;
							}
							if (genRand.Next(3) > 0)
							{
								int num27 = genRand.Next(6);
								int stack17 = genRand.Next(1, 3);
								if (num27 == 0)
								{
									chest.item[num13].SetDefaults(296);
								}
								if (num27 == 1)
								{
									chest.item[num13].SetDefaults(295);
								}
								if (num27 == 2)
								{
									chest.item[num13].SetDefaults(299);
								}
								if (num27 == 3)
								{
									chest.item[num13].SetDefaults(302);
								}
								if (num27 == 4)
								{
									chest.item[num13].SetDefaults(303);
								}
								if (num27 == 5)
								{
									chest.item[num13].SetDefaults(305);
								}
								chest.item[num13].stack = stack17;
								num13++;
							}
							if (genRand.Next(3) > 1)
							{
								int num28 = genRand.Next(6);
								int stack18 = genRand.Next(1, 3);
								if (num28 == 0)
								{
									chest.item[num13].SetDefaults(301);
								}
								if (num28 == 1)
								{
									chest.item[num13].SetDefaults(297);
								}
								if (num28 == 2)
								{
									chest.item[num13].SetDefaults(304);
								}
								if (num28 == 3)
								{
									chest.item[num13].SetDefaults(2329);
								}
								if (num28 == 4)
								{
									chest.item[num13].SetDefaults(2351);
								}
								if (num28 == 5)
								{
									chest.item[num13].SetDefaults(2326);
								}
								chest.item[num13].stack = stack18;
								num13++;
							}
							if (genRand.Next(2) == 0)
							{
								int stack19 = genRand.Next(2, 5);
								chest.item[num13].SetDefaults(2350);
								chest.item[num13].stack = stack19;
								num13++;
							}
							if (genRand.Next(2) == 0)
							{
								int num29 = genRand.Next(2);
								int stack20 = genRand.Next(15) + 15;
								if (num29 == 0)
								{
									if (num8 == 11)
									{
										chest.item[num13].SetDefaults(974);
									}
									else
									{
										chest.item[num13].SetDefaults(8);
									}
								}
								if (num29 == 1)
								{
									chest.item[num13].SetDefaults(282);
								}
								chest.item[num13].stack = stack20;
								num13++;
							}
							if (genRand.Next(2) == 0)
							{
								chest.item[num13].SetDefaults(73);
								chest.item[num13].stack = genRand.Next(1, 3);
								num13++;
							}
						}
						else
						{
							if (contain > 0)
							{
								chest.item[num13].SetDefaults(contain);
								chest.item[num13].Prefix(-1);
								num13++;
								if (flag7 && genRand.Next(10) == 0)
								{
									chest.item[num13].SetDefaults(4443);
									num13++;
								}
								if (flag7 && genRand.Next(10) == 0)
								{
									chest.item[num13].SetDefaults(4737);
									num13++;
								}
								else if (flag7 && genRand.Next(10) == 0)
								{
									chest.item[num13].SetDefaults(4551);
									num13++;
								}
							}
							else
							{
								int num30 = genRand.Next(4);
								if (num30 == 0)
								{
									chest.item[num13].SetDefaults(49);
									chest.item[num13].Prefix(-1);
								}
								if (num30 == 1)
								{
									chest.item[num13].SetDefaults(50);
									chest.item[num13].Prefix(-1);
								}
								if (num30 == 2)
								{
									chest.item[num13].SetDefaults(53);
									chest.item[num13].Prefix(-1);
								}
								if (num30 == 3)
								{
									chest.item[num13].SetDefaults(54);
									chest.item[num13].Prefix(-1);
								}
								num13++;
							}
							if (genRand.Next(3) == 0)
							{
								chest.item[num13].SetDefaults(167);
								num13++;
							}
							if (genRand.Next(2) == 0)
							{
								int num31 = genRand.Next(2);
								int stack21 = genRand.Next(15) + 15;
								if (num31 == 0)
								{
									chest.item[num13].SetDefaults(117);
								}
								if (num31 == 1)
								{
									chest.item[num13].SetDefaults(goldBar);
								}
								chest.item[num13].stack = stack21;
								num13++;
							}
							if (genRand.Next(2) == 0)
							{
								int num32 = genRand.Next(2);
								int stack22 = genRand.Next(25) + 50;
								if (num32 == 0)
								{
									chest.item[num13].SetDefaults(265);
								}
								if (num32 == 1)
								{
									if (SavedOreTiers.Silver == 168)
									{
										chest.item[num13].SetDefaults(4915);
									}
									else
									{
										chest.item[num13].SetDefaults(278);
									}
								}
								chest.item[num13].stack = stack22;
								num13++;
							}
							if (genRand.Next(2) == 0)
							{
								int stack23 = genRand.Next(6) + 15;
								chest.item[num13].SetDefaults(227);
								chest.item[num13].stack = stack23;
								num13++;
							}
							if (genRand.Next(4) > 0)
							{
								int num33 = genRand.Next(8);
								int stack24 = genRand.Next(1, 3);
								if (num33 == 0)
								{
									chest.item[num13].SetDefaults(296);
								}
								if (num33 == 1)
								{
									chest.item[num13].SetDefaults(295);
								}
								if (num33 == 2)
								{
									chest.item[num13].SetDefaults(293);
								}
								if (num33 == 3)
								{
									chest.item[num13].SetDefaults(288);
								}
								if (num33 == 4)
								{
									chest.item[num13].SetDefaults(294);
								}
								if (num33 == 5)
								{
									chest.item[num13].SetDefaults(297);
								}
								if (num33 == 6)
								{
									chest.item[num13].SetDefaults(304);
								}
								if (num33 == 7)
								{
									chest.item[num13].SetDefaults(2323);
								}
								chest.item[num13].stack = stack24;
								num13++;
							}
							if (genRand.Next(3) > 0)
							{
								int num34 = genRand.Next(8);
								int stack25 = genRand.Next(1, 3);
								if (num34 == 0)
								{
									chest.item[num13].SetDefaults(305);
								}
								if (num34 == 1)
								{
									chest.item[num13].SetDefaults(301);
								}
								if (num34 == 2)
								{
									chest.item[num13].SetDefaults(302);
								}
								if (num34 == 3)
								{
									chest.item[num13].SetDefaults(288);
								}
								if (num34 == 4)
								{
									chest.item[num13].SetDefaults(300);
								}
								if (num34 == 5)
								{
									chest.item[num13].SetDefaults(2351);
								}
								if (num34 == 6)
								{
									chest.item[num13].SetDefaults(2348);
								}
								if (num34 == 7)
								{
									chest.item[num13].SetDefaults(2345);
								}
								chest.item[num13].stack = stack25;
								num13++;
							}
							if (genRand.Next(3) == 0)
							{
								int stack26 = genRand.Next(1, 3);
								if (genRand.Next(2) == 0)
								{
									chest.item[num13].SetDefaults(2350);
								}
								else
								{
									chest.item[num13].SetDefaults(4870);
								}
								chest.item[num13].stack = stack26;
								num13++;
							}
							if (genRand.Next(2) == 0)
							{
								int num35 = genRand.Next(2);
								int stack27 = genRand.Next(15) + 15;
								if (num35 == 0)
								{
									chest.item[num13].SetDefaults(8);
								}
								if (num35 == 1)
								{
									chest.item[num13].SetDefaults(282);
								}
								chest.item[num13].stack = stack27;
								num13++;
							}
							if (genRand.Next(2) == 0)
							{
								chest.item[num13].SetDefaults(73);
								chest.item[num13].stack = genRand.Next(2, 5);
								num13++;
							}
						}
						if (num13 <= 0 || chestTileType != 21)
						{
							continue;
						}
						if (num8 == 10 && genRand.Next(4) == 0)
						{
							chest.item[num13].SetDefaults(2204);
							num13++;
						}
						if (num8 == 11 && genRand.Next(7) == 0)
						{
							chest.item[num13].SetDefaults(2198);
							num13++;
						}
						if (num8 == 13 && genRand.Next(3) == 0)
						{
							chest.item[num13].SetDefaults(2197);
							num13++;
						}
						if (num8 == 16)
						{
							chest.item[num13].SetDefaults(2195);
							num13++;
						}
						if (Main.wallDungeon[Main.tile[i, k].wall] && genRand.Next(8) == 0)
						{
							chest.item[num13].SetDefaults(2192);
							num13++;
						}
						if (num8 == 16)
						{
							if (genRand.Next(5) == 0)
							{
								chest.item[num13].SetDefaults(2767);
								num13++;
							}
							else
							{
								chest.item[num13].SetDefaults(2766);
								chest.item[num13].stack = genRand.Next(3, 8);
								num13++;
							}
						}
					}
					return true;
				}
				if (trySlope)
				{
					if (num > -1)
					{
						Main.tile[i - 1, k].slope((byte)num);
					}
					if (num2 > -1)
					{
						Main.tile[i, k].slope((byte)num2);
					}
				}
				return false;
			}
			return false;
		}

		public static void UnlockDoor(int i, int j)
		{
			int num = j;
			if (Main.tile[i, num] == null)
			{
				return;
			}
			while (Main.tile[i, num].frameY != 594)
			{
				num--;
				if (Main.tile[i, num].frameY < 594 || num <= 0)
				{
					return;
				}
			}
			SoundEngine.PlaySound(22, i * 16, num * 16 + 16);
			for (int k = num; k <= num + 2; k++)
			{
				if (Main.tile[i, k] == null)
				{
					Main.tile[i, k] = new Tile();
				}
				Main.tile[i, k].frameY += 54;
				for (int l = 0; l < 4; l++)
				{
					Dust.NewDust(new Vector2(i * 16, k * 16), 16, 16, 11);
				}
			}
			AchievementsHelper.NotifyProgressionEvent(22);
		}

		public static bool OpenDoor(int i, int j, int direction)
		{
			int num = 0;
			if (Main.tile[i, j - 1] == null)
			{
				Main.tile[i, j - 1] = new Tile();
			}
			if (Main.tile[i, j - 2] == null)
			{
				Main.tile[i, j - 2] = new Tile();
			}
			if (Main.tile[i, j + 1] == null)
			{
				Main.tile[i, j + 1] = new Tile();
			}
			if (Main.tile[i, j] == null)
			{
				Main.tile[i, j] = new Tile();
			}
			Tile tile = Main.tile[i, j];
			if (tile.type != 10)
			{
				return false;
			}
			if (IsLockedDoor(tile))
			{
				return false;
			}
			short num2 = 0;
			int num3 = tile.frameY;
			int num4 = 0;
			while (num3 >= 54)
			{
				num3 -= 54;
				num4++;
			}
			if (tile.frameX >= 54)
			{
				int num5 = tile.frameX / 54;
				num4 += 36 * num5;
				num2 = (short)(num2 + (short)(72 * num5));
			}
			num = j - num3 / 18;
			int num6 = i;
			byte color = Main.tile[num6, num].color();
			if (Main.tile[num6, num + 1] == null)
			{
				Main.tile[num6, num + 1] = new Tile();
			}
			byte color2 = Main.tile[num6, num + 1].color();
			if (Main.tile[num6, num + 2] == null)
			{
				Main.tile[num6, num + 2] = new Tile();
			}
			byte color3 = Main.tile[num6, num + 2].color();
			int num7;
			if (direction == -1)
			{
				num6 = i - 1;
				num2 = (short)(num2 + 36);
				num7 = i - 1;
			}
			else
			{
				num6 = i;
				num7 = i + 1;
			}
			for (int k = num; k < num + 3; k++)
			{
				if (Main.tile[num7, k] == null)
				{
					Main.tile[num7, k] = new Tile();
				}
				if (Main.tile[num7, k].active())
				{
					if (!Main.tileCut[Main.tile[num7, k].type] && Main.tile[num7, k].type != 3 && Main.tile[num7, k].type != 24 && Main.tile[num7, k].type != 52 && Main.tile[num7, k].type != 61 && Main.tile[num7, k].type != 62 && Main.tile[num7, k].type != 69 && Main.tile[num7, k].type != 71 && Main.tile[num7, k].type != 73 && Main.tile[num7, k].type != 74 && Main.tile[num7, k].type != 110 && Main.tile[num7, k].type != 113 && Main.tile[num7, k].type != 115 && Main.tile[num7, k].type != 165)
					{
						return false;
					}
					KillTile(num7, k);
				}
			}
			if (Main.netMode != 1 && Wiring.running)
			{
				Wiring.SkipWire(num6, num);
				Wiring.SkipWire(num6, num + 1);
				Wiring.SkipWire(num6, num + 2);
				Wiring.SkipWire(num6 + 1, num);
				Wiring.SkipWire(num6 + 1, num + 1);
				Wiring.SkipWire(num6 + 1, num + 2);
			}
			int num8 = num4 % 36 * 54;
			SoundEngine.PlaySound(8, i * 16, j * 16);
			Main.tile[num6, num].active(active: true);
			Main.tile[num6, num].type = 11;
			Main.tile[num6, num].frameY = (short)num8;
			Main.tile[num6, num].frameX = num2;
			Main.tile[num6, num].color(color);
			if (Main.tile[num6 + 1, num] == null)
			{
				Main.tile[num6 + 1, num] = new Tile();
			}
			Main.tile[num6 + 1, num].active(active: true);
			Main.tile[num6 + 1, num].type = 11;
			Main.tile[num6 + 1, num].frameY = (short)num8;
			Main.tile[num6 + 1, num].frameX = (short)(num2 + 18);
			Main.tile[num6 + 1, num].color(color);
			if (Main.tile[num6, num + 1] == null)
			{
				Main.tile[num6, num + 1] = new Tile();
			}
			Main.tile[num6, num + 1].active(active: true);
			Main.tile[num6, num + 1].type = 11;
			Main.tile[num6, num + 1].frameY = (short)(num8 + 18);
			Main.tile[num6, num + 1].frameX = num2;
			Main.tile[num6, num + 1].color(color2);
			if (Main.tile[num6 + 1, num + 1] == null)
			{
				Main.tile[num6 + 1, num + 1] = new Tile();
			}
			Main.tile[num6 + 1, num + 1].active(active: true);
			Main.tile[num6 + 1, num + 1].type = 11;
			Main.tile[num6 + 1, num + 1].frameY = (short)(num8 + 18);
			Main.tile[num6 + 1, num + 1].frameX = (short)(num2 + 18);
			Main.tile[num6 + 1, num + 1].color(color2);
			if (Main.tile[num6, num + 2] == null)
			{
				Main.tile[num6, num + 2] = new Tile();
			}
			Main.tile[num6, num + 2].active(active: true);
			Main.tile[num6, num + 2].type = 11;
			Main.tile[num6, num + 2].frameY = (short)(num8 + 36);
			Main.tile[num6, num + 2].frameX = num2;
			Main.tile[num6, num + 2].color(color3);
			if (Main.tile[num6 + 1, num + 2] == null)
			{
				Main.tile[num6 + 1, num + 2] = new Tile();
			}
			Main.tile[num6 + 1, num + 2].active(active: true);
			Main.tile[num6 + 1, num + 2].type = 11;
			Main.tile[num6 + 1, num + 2].frameY = (short)(num8 + 36);
			Main.tile[num6 + 1, num + 2].frameX = (short)(num2 + 18);
			Main.tile[num6 + 1, num + 2].color(color3);
			for (int l = num6 - 1; l <= num6 + 2; l++)
			{
				for (int m = num - 1; m <= num + 2; m++)
				{
					TileFrame(l, m);
				}
			}
			return true;
		}

		public static void Check1xX(int x, int j, short type)
		{
			if (destroyObject)
			{
				return;
			}
			int frameX = Main.tile[x, j].frameX;
			int num = 3;
			if (type == 92)
			{
				num = 6;
			}
			int num2 = Main.tile[x, j].frameY;
			int num3 = 0;
			while (num2 >= 18 * num)
			{
				num2 -= 18 * num;
				num3++;
			}
			int num4 = Main.tile[x, j].frameX / 18;
			int num5 = j - num2 / 18;
			bool flag = false;
			for (int i = 0; i < num; i++)
			{
				if (Main.tile[x, num5 + i] == null)
				{
					Main.tile[x, num5 + i] = new Tile();
				}
				if (!Main.tile[x, num5 + i].active())
				{
					flag = true;
				}
				else if (Main.tile[x, num5 + i].type != type)
				{
					flag = true;
				}
				else if (Main.tile[x, num5 + i].frameY != i * 18 + num3 * num * 18)
				{
					flag = true;
				}
				else if (Main.tile[x, num5 + i].frameX != frameX)
				{
					flag = true;
				}
			}
			if (Main.tile[x, num5 + num] == null)
			{
				Main.tile[x, num5 + num] = new Tile();
			}
			if (!SolidTileAllowBottomSlope(x, num5 + num))
			{
				flag = true;
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int k = 0; k < num; k++)
			{
				if (Main.tile[x, num5 + k].type == type)
				{
					KillTile(x, num5 + k);
				}
			}
			if (type == 92)
			{
				Item.NewItem(x * 16, j * 16, 32, 32, 341);
			}
			if (type == 453)
			{
				int num6 = 0;
				num6 = ((num4 < 2) ? 3744 : ((num4 >= 4) ? 3743 : 3745));
				Item.NewItem(x * 16, j * 16, 16, 32, num6);
			}
			if (type == 93)
			{
				int type2 = 0;
				switch (num3)
				{
				case 0:
					type2 = 342;
					break;
				case 1:
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7:
				case 8:
				case 9:
				case 10:
					type2 = 2082 + num3 - 1;
					break;
				default:
					if (num3 >= 11 && num3 <= 16)
					{
						type2 = 2129 + num3 - 11;
						break;
					}
					switch (num3)
					{
					case 17:
						type2 = 2225;
						break;
					case 18:
						type2 = 2533;
						break;
					case 19:
						type2 = 2547;
						break;
					case 20:
						type2 = 2563;
						break;
					case 21:
						type2 = 2578;
						break;
					case 22:
						type2 = 2643;
						break;
					case 23:
						type2 = 2644;
						break;
					case 24:
						type2 = 2645;
						break;
					case 25:
						type2 = 2646;
						break;
					case 26:
						type2 = 2647;
						break;
					case 27:
						type2 = 2819;
						break;
					case 28:
						type2 = 3135;
						break;
					case 29:
						type2 = 3137;
						break;
					case 30:
						type2 = 3136;
						break;
					case 31:
						type2 = 3892;
						break;
					case 32:
						type2 = 3942;
						break;
					case 33:
						type2 = 3969;
						break;
					case 34:
						type2 = 4156;
						break;
					case 35:
						type2 = 4177;
						break;
					case 36:
						type2 = 4198;
						break;
					case 37:
						type2 = 4219;
						break;
					case 38:
						type2 = 4308;
						break;
					case 39:
						type2 = 4577;
						break;
					}
					break;
				}
				Item.NewItem(x * 16, j * 16, 32, 32, type2);
			}
			destroyObject = false;
		}

		public static void Check2xX(int i, int j, ushort type)
		{
			if (destroyObject)
			{
				return;
			}
			int num = i;
			int num2;
			for (num2 = Main.tile[i, j].frameX; num2 >= 36; num2 -= 36)
			{
			}
			if (num2 == 18)
			{
				num--;
			}
			if (Main.tile[num, j] == null)
			{
				Main.tile[num, j] = new Tile();
			}
			int num3 = Main.tile[num, j].frameY / 18;
			int num4 = 3;
			if (type == 104)
			{
				num4 = 5;
			}
			if (type == 207)
			{
				num4 = 4;
			}
			int num5 = 0;
			while (num3 >= num4)
			{
				num3 -= num4;
				num5 += num4 * 18;
			}
			int num6 = j - num3;
			if (type == 410 && num5 != 0)
			{
				num5 += 2;
			}
			if (Main.tile[num, num6] == null)
			{
				Main.tile[num, num6] = new Tile();
			}
			int frameX = Main.tile[num, j].frameX;
			int frameY = Main.tile[num, j].frameY;
			bool flag = false;
			for (int k = 0; k < num4; k++)
			{
				if (Main.tile[num, num6 + k] == null)
				{
					Main.tile[num, num6 + k] = new Tile();
				}
				if (!Main.tile[num, num6 + k].active())
				{
					flag = true;
				}
				else if (Main.tile[num, num6 + k].type != type)
				{
					flag = true;
				}
				else if (Main.tile[num, num6 + k].frameY != k * 18 + num5)
				{
					flag = true;
				}
				else if (Main.tile[num, num6 + k].frameX != frameX)
				{
					flag = true;
				}
				if (Main.tile[num + 1, num6 + k] == null)
				{
					Main.tile[num + 1, num6 + k] = new Tile();
				}
				if (!Main.tile[num + 1, num6 + k].active())
				{
					flag = true;
				}
				else if (Main.tile[num + 1, num6 + k].type != type)
				{
					flag = true;
				}
				else if (Main.tile[num + 1, num6 + k].frameY != k * 18 + num5)
				{
					flag = true;
				}
				else if (Main.tile[num + 1, num6 + k].frameX != frameX + 18)
				{
					flag = true;
				}
			}
			if (type == 465 || type == 531 || type == 591 || type == 592)
			{
				for (int l = 0; l < 2; l++)
				{
					if (!SolidTileAllowTopSlope(num + l, num6 - 1))
					{
						flag = true;
						break;
					}
				}
			}
			else
			{
				if (!SolidTileAllowBottomSlope(num, num6 + num4))
				{
					flag = true;
				}
				if (!SolidTileAllowBottomSlope(num + 1, num6 + num4))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int m = 0; m < num4; m++)
			{
				if (Main.tile[num, num6 + m].type == type)
				{
					KillTile(num, num6 + m);
				}
				if (Main.tile[num + 1, num6 + m].type == type)
				{
					KillTile(num + 1, num6 + m);
				}
			}
			if (type == 104)
			{
				int num7 = frameX / 36;
				int num8 = 0;
				if (num7 >= 1 && num7 <= 5)
				{
					num8 = 2237 + num7 - 1;
				}
				else
				{
					switch (num7)
					{
					case 6:
						num8 = 2560;
						break;
					case 7:
						num8 = 2575;
						break;
					case 8:
					case 9:
					case 10:
					case 11:
					case 12:
					case 13:
					case 14:
					case 15:
					case 16:
					case 17:
					case 18:
					case 19:
					case 20:
					case 21:
					case 22:
					case 23:
						num8 = 2591 + num7 - 8;
						break;
					default:
						num8 = num7 switch
						{
							24 => 2809, 
							25 => 3126, 
							26 => 3128, 
							27 => 3127, 
							28 => 3898, 
							29 => 3899, 
							30 => 3900, 
							31 => 3901, 
							32 => 3902, 
							33 => 3940, 
							34 => 3966, 
							35 => 4154, 
							36 => 4175, 
							37 => 4196, 
							38 => 4217, 
							39 => 4306, 
							40 => 4575, 
							_ => 359, 
						};
						break;
					}
				}
				Item.NewItem(num * 16, j * 16, 32, 32, num8);
			}
			if (type == 105)
			{
				int num9 = frameX / 36;
				int num10 = frameY / 54;
				num10 %= 3;
				num9 += num10 * 55;
				switch (num9)
				{
				case 0:
					num9 = 360;
					break;
				case 1:
					num9 = 52;
					break;
				case 43:
					num9 = 1152;
					break;
				case 44:
					num9 = 1153;
					break;
				case 45:
					num9 = 1154;
					break;
				case 46:
					num9 = 1408;
					break;
				case 47:
					num9 = 1409;
					break;
				case 48:
					num9 = 1410;
					break;
				case 49:
					num9 = 1462;
					break;
				case 50:
					num9 = 2672;
					break;
				case 51:
				case 52:
				case 53:
				case 54:
				case 55:
				case 56:
				case 57:
				case 58:
				case 59:
				case 60:
				case 61:
				case 62:
					num9 = 3651 + num9 - 51;
					break;
				default:
					num9 = ((num9 >= 63 && num9 <= 75) ? (3708 + num9 - 63) : (num9 switch
					{
						76 => 4397, 
						77 => 4360, 
						78 => 4342, 
						79 => 4466, 
						_ => 438 + num9 - 2, 
					}));
					break;
				}
				Item.NewItem(num * 16, j * 16, 32, 32, num9);
			}
			if (type == 356)
			{
				Item.NewItem(num * 16, j * 16, 32, 32, 3064);
			}
			if (type == 456)
			{
				Item.NewItem(num * 16, j * 16, 32, 32, 3748);
			}
			if (type == 337)
			{
				int num11 = frameX / 36;
				Item.NewItem(num * 16, j * 16, 32, 32, 2702 + num11);
			}
			if (type == 207)
			{
				int num12 = frameX / 36;
				switch (num12)
				{
				case 0:
					num12 = 909;
					break;
				case 1:
					num12 = 910;
					break;
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7:
					num12 = 938 + num12;
					break;
				default:
					switch (num12)
					{
					case 8:
						num12 = 4922;
						break;
					case 9:
						num12 = 4417;
						break;
					}
					break;
				}
				Item.NewItem(num * 16, j * 16, 32, 32, num12);
			}
			if (type == 410)
			{
				int num13 = frameX / 36;
				Item.NewItem(num * 16, j * 16, 32, 32, num13 + 3536);
			}
			if (type == 480)
			{
				Item.NewItem(num * 16, j * 16, 32, 32, 4054);
			}
			if (type == 509)
			{
				Item.NewItem(num * 16, j * 16, 32, 32, 4318);
			}
			if (type == 489)
			{
				Item.NewItem(num * 16, j * 16, 32, 32, 4074);
			}
			if (type == 320)
			{
				Item.NewItem(num * 16, j * 16, 32, 32, 2496);
			}
			if (type == 349)
			{
				Item.NewItem(num * 16, j * 16, 32, 32, 470);
			}
			if (type == 506)
			{
				Item.NewItem(num * 16, j * 16, 32, 32, 4276);
			}
			if (type == 545)
			{
				Item.NewItem(num * 16, j * 16, 32, 32, 4420);
			}
			if (type == 465)
			{
				Item.NewItem(num * 16, j * 16, 32, 32, 3815);
			}
			if (type == 531)
			{
				Item.NewItem(num * 16, j * 16, 32, 32, 4355);
			}
			if (type == 378)
			{
				Item.NewItem(num * 16, j * 16, 32, 48, 3202);
				TETrainingDummy.Kill(num, num6);
			}
			if (type == 560)
			{
				int num14 = frameX / 36;
				Item.NewItem(num * 16, j * 16, 32, 32, num14 + 4599);
			}
			if (type == 591)
			{
				int num15 = frameX / 36;
				Item.NewItem(num * 16, j * 16, 32, 32, num15 + 4858);
			}
			if (type == 592)
			{
				Item.NewItem(num * 16, j * 16, 32, 32, 4867);
			}
			destroyObject = false;
		}

		public static void PlaceTight(int x, int y, bool spiders = false)
		{
			if (Main.tile[x, y - 1] == null)
			{
				Main.tile[x, y - 1] = new Tile();
			}
			if (Main.tile[x, y] == null)
			{
				Main.tile[x, y] = new Tile();
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = new Tile();
			}
			PlaceUncheckedStalactite(x, y, genRand.Next(2) == 0, genRand.Next(3), spiders);
			if (Main.tile[x, y].type == 165)
			{
				CheckTight(x, y);
			}
		}

		public static void PlaceUncheckedStalactite(int x, int y, bool preferSmall, int variation, bool spiders)
		{
			ushort type = 165;
			variation = Utils.Clamp(variation, 0, 2);
			if (SolidTile(x, y - 1) && !Main.tile[x, y].active() && !Main.tile[x, y + 1].active())
			{
				if (spiders)
				{
					int num = 108 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameX = (short)num;
					Main.tile[x, y].frameY = 0;
					Main.tile[x, y + 1].type = type;
					Main.tile[x, y + 1].active(active: true);
					Main.tile[x, y + 1].frameX = (short)num;
					Main.tile[x, y + 1].frameY = 18;
					return;
				}
				if (Main.tile[x, y - 1].type == 147 || Main.tile[x, y - 1].type == 161 || Main.tile[x, y - 1].type == 163 || Main.tile[x, y - 1].type == 164 || Main.tile[x, y - 1].type == 200)
				{
					if (preferSmall)
					{
						int num2 = variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num2;
						Main.tile[x, y].frameY = 72;
					}
					else
					{
						int num3 = variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num3;
						Main.tile[x, y].frameY = 0;
						Main.tile[x, y + 1].type = type;
						Main.tile[x, y + 1].active(active: true);
						Main.tile[x, y + 1].frameX = (short)num3;
						Main.tile[x, y + 1].frameY = 18;
					}
				}
				if (Main.tile[x, y - 1].type == 1 || Main.tileMoss[Main.tile[x, y - 1].type] || Main.tile[x, y - 1].type == 117 || Main.tile[x, y - 1].type == 25 || Main.tile[x, y - 1].type == 203)
				{
					if (preferSmall)
					{
						int num4 = 54 + variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num4;
						Main.tile[x, y].frameY = 72;
					}
					else
					{
						int num5 = 54 + variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num5;
						Main.tile[x, y].frameY = 0;
						Main.tile[x, y + 1].type = type;
						Main.tile[x, y + 1].active(active: true);
						Main.tile[x, y + 1].frameX = (short)num5;
						Main.tile[x, y + 1].frameY = 18;
					}
				}
				if (Main.tile[x, y - 1].type == 225)
				{
					int num6 = 162 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameX = (short)num6;
					Main.tile[x, y].frameY = 72;
				}
				if (Main.tile[x, y - 1].type == 396 || Main.tile[x, y - 1].type == 397)
				{
					if (preferSmall)
					{
						int num7 = 378 + variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num7;
						Main.tile[x, y].frameY = 72;
					}
					else
					{
						int num8 = 378 + variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num8;
						Main.tile[x, y].frameY = 0;
						Main.tile[x, y + 1].type = type;
						Main.tile[x, y + 1].active(active: true);
						Main.tile[x, y + 1].frameX = (short)num8;
						Main.tile[x, y + 1].frameY = 18;
					}
				}
				if (Main.tile[x, y - 1].type == 368)
				{
					if (preferSmall)
					{
						int num9 = 432 + variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num9;
						Main.tile[x, y].frameY = 72;
					}
					else
					{
						int num10 = 432 + variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num10;
						Main.tile[x, y].frameY = 0;
						Main.tile[x, y + 1].type = type;
						Main.tile[x, y + 1].active(active: true);
						Main.tile[x, y + 1].frameX = (short)num10;
						Main.tile[x, y + 1].frameY = 18;
					}
				}
				if (Main.tile[x, y - 1].type == 367)
				{
					if (preferSmall)
					{
						int num11 = 486 + variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num11;
						Main.tile[x, y].frameY = 72;
					}
					else
					{
						int num12 = 486 + variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num12;
						Main.tile[x, y].frameY = 0;
						Main.tile[x, y + 1].type = type;
						Main.tile[x, y + 1].active(active: true);
						Main.tile[x, y + 1].frameX = (short)num12;
						Main.tile[x, y + 1].frameY = 18;
					}
				}
			}
			else
			{
				if (spiders || !SolidTile(x, y + 1) || Main.tile[x, y].active() || Main.tile[x, y - 1].active())
				{
					return;
				}
				if (Main.tile[x, y + 1].type == 1 || Main.tileMoss[Main.tile[x, y + 1].type] || Main.tile[x, y - 1].type == 117 || Main.tile[x, y - 1].type == 25 || Main.tile[x, y - 1].type == 203)
				{
					if (preferSmall)
					{
						int num13 = 54 + variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num13;
						Main.tile[x, y].frameY = 90;
					}
					else
					{
						int num14 = 54 + variation * 18;
						Main.tile[x, y - 1].type = type;
						Main.tile[x, y - 1].active(active: true);
						Main.tile[x, y - 1].frameX = (short)num14;
						Main.tile[x, y - 1].frameY = 36;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num14;
						Main.tile[x, y].frameY = 54;
					}
				}
				if (Main.tile[x, y + 1].type == 225)
				{
					int num15 = 162 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameX = (short)num15;
					Main.tile[x, y].frameY = 90;
				}
				if (Main.tile[x, y + 1].type == 396 || Main.tile[x, y + 1].type == 397)
				{
					if (preferSmall)
					{
						int num16 = 378 + variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num16;
						Main.tile[x, y].frameY = 90;
					}
					else
					{
						int num17 = 378 + variation * 18;
						Main.tile[x, y - 1].type = type;
						Main.tile[x, y - 1].active(active: true);
						Main.tile[x, y - 1].frameX = (short)num17;
						Main.tile[x, y - 1].frameY = 36;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num17;
						Main.tile[x, y].frameY = 54;
					}
				}
				if (Main.tile[x, y + 1].type == 368)
				{
					if (preferSmall)
					{
						int num18 = 432 + variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num18;
						Main.tile[x, y].frameY = 90;
					}
					else
					{
						int num19 = 432 + variation * 18;
						Main.tile[x, y - 1].type = type;
						Main.tile[x, y - 1].active(active: true);
						Main.tile[x, y - 1].frameX = (short)num19;
						Main.tile[x, y - 1].frameY = 36;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num19;
						Main.tile[x, y].frameY = 54;
					}
				}
				if (Main.tile[x, y + 1].type == 367)
				{
					if (preferSmall)
					{
						int num20 = 486 + variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num20;
						Main.tile[x, y].frameY = 90;
					}
					else
					{
						int num21 = 486 + variation * 18;
						Main.tile[x, y - 1].type = type;
						Main.tile[x, y - 1].active(active: true);
						Main.tile[x, y - 1].frameX = (short)num21;
						Main.tile[x, y - 1].frameY = 36;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num21;
						Main.tile[x, y].frameY = 54;
					}
				}
			}
		}

		public static bool UpdateStalagtiteStyle(int x, int j)
		{
			if (Main.netMode == 1)
			{
				return true;
			}
			if (Main.tile[x, j] == null)
			{
				return true;
			}
			GetStalagtiteStyle(x, j, out var style, out var fail);
			if (fail)
			{
				return false;
			}
			GetDesiredStalagtiteStyle(x, j, out var fail2, out var desiredStyle, out var height, out var y);
			if (fail2)
			{
				return false;
			}
			if (style != desiredStyle)
			{
				int num = genRand.Next(3) * 18;
				switch (desiredStyle)
				{
				case 0:
					num += 54;
					break;
				case 1:
					num += 216;
					break;
				case 2:
					num += 270;
					break;
				case 3:
					num += 324;
					break;
				case 4:
					num += 378;
					break;
				case 5:
					num += 432;
					break;
				case 6:
					num += 486;
					break;
				case 7:
					num = num;
					break;
				case 8:
					num += 540;
					break;
				case 9:
					num += 594;
					break;
				case 10:
					num += 648;
					break;
				}
				for (int i = y; i < y + height; i++)
				{
					Main.tile[x, i].frameX = (short)num;
				}
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y, 2);
				}
			}
			return true;
		}

		private static void GetDesiredStalagtiteStyle(int x, int j, out bool fail, out int desiredStyle, out int height, out int y)
		{
			fail = false;
			desiredStyle = 0;
			height = 1;
			y = j;
			if (Main.tile[x, y].frameY == 72)
			{
				desiredStyle = Main.tile[x, y - 1].type;
			}
			else if (Main.tile[x, y].frameY == 90)
			{
				desiredStyle = Main.tile[x, y + 1].type;
			}
			else if (Main.tile[x, y].frameY >= 36)
			{
				if (Main.tile[x, y].frameY == 54)
				{
					y--;
				}
				height = 2;
				desiredStyle = Main.tile[x, y + 2].type;
			}
			else
			{
				if (Main.tile[x, y].frameY == 18)
				{
					y--;
				}
				height = 2;
				desiredStyle = Main.tile[x, y - 1].type;
			}
			if (desiredStyle == 1 || Main.tileMoss[desiredStyle])
			{
				desiredStyle = 0;
			}
			else if (desiredStyle == 200)
			{
				desiredStyle = 10;
			}
			else if (desiredStyle == 164)
			{
				desiredStyle = 8;
			}
			else if (desiredStyle == 163)
			{
				desiredStyle = 9;
			}
			else if (desiredStyle == 117 || desiredStyle == 402 || desiredStyle == 403)
			{
				desiredStyle = 1;
			}
			else if (desiredStyle == 25 || desiredStyle == 398 || desiredStyle == 400)
			{
				desiredStyle = 2;
			}
			else if (desiredStyle == 203 || desiredStyle == 399 || desiredStyle == 401)
			{
				desiredStyle = 3;
			}
			else if (desiredStyle == 396 || desiredStyle == 397)
			{
				desiredStyle = 4;
			}
			else if (desiredStyle == 367)
			{
				desiredStyle = 6;
			}
			else if (desiredStyle == 368)
			{
				desiredStyle = 5;
			}
			else if (desiredStyle == 161 || desiredStyle == 147)
			{
				desiredStyle = 7;
			}
			else
			{
				fail = true;
			}
		}

		private static void GetStalagtiteStyle(int x, int y, out int style, out bool fail)
		{
			style = 0;
			fail = false;
			switch (Main.tile[x, y].frameX / 54)
			{
			default:
				fail = true;
				break;
			case 0:
				style = 7;
				break;
			case 1:
				style = 0;
				break;
			case 4:
				style = 1;
				break;
			case 5:
				style = 2;
				break;
			case 6:
				style = 3;
				break;
			case 7:
				style = 4;
				break;
			case 8:
				style = 5;
				break;
			case 9:
				style = 6;
				break;
			case 10:
				style = 8;
				break;
			case 11:
				style = 9;
				break;
			case 12:
				style = 10;
				break;
			}
		}

		public static void CheckTight(int x, int j)
		{
			if (Main.tile[x, j] == null)
			{
				return;
			}
			int num = j;
			if (Main.tile[x, num].frameY == 72)
			{
				if (Main.tile[x, num - 1] == null)
				{
					Main.tile[x, num - 1] = new Tile();
				}
				if (Main.tile[x, num] == null)
				{
					Main.tile[x, num] = new Tile();
				}
				if (Main.tile[x, num + 1] == null)
				{
					Main.tile[x, num + 1] = new Tile();
				}
				bool flag = false;
				if (!SolidTile(x, num - 1))
				{
					flag = true;
				}
				if (!flag && !UpdateStalagtiteStyle(x, num))
				{
					flag = true;
				}
				if (flag)
				{
					destroyObject = true;
					if (Main.tile[x, num].type == Main.tile[x, j].type)
					{
						KillTile(x, num);
					}
					destroyObject = false;
				}
				return;
			}
			if (Main.tile[x, num].frameY == 90)
			{
				if (Main.tile[x, num - 1] == null)
				{
					Main.tile[x, num - 1] = new Tile();
				}
				if (Main.tile[x, num] == null)
				{
					Main.tile[x, num] = new Tile();
				}
				if (Main.tile[x, num + 1] == null)
				{
					Main.tile[x, num + 1] = new Tile();
				}
				bool flag2 = false;
				if (!SolidTile(x, num + 1))
				{
					flag2 = true;
				}
				if (!flag2 && !UpdateStalagtiteStyle(x, num))
				{
					flag2 = true;
				}
				if (flag2)
				{
					destroyObject = true;
					if (Main.tile[x, num].type == Main.tile[x, j].type)
					{
						KillTile(x, num);
					}
					destroyObject = false;
				}
				return;
			}
			if (Main.tile[x, num].frameY >= 36)
			{
				if (Main.tile[x, num].frameY == 54)
				{
					num--;
				}
				if (Main.tile[x, num] == null)
				{
					Main.tile[x, num] = new Tile();
				}
				if (Main.tile[x, num + 1] == null)
				{
					Main.tile[x, num + 1] = new Tile();
				}
				if (Main.tile[x, num + 2] == null)
				{
					Main.tile[x, num + 2] = new Tile();
				}
				bool flag3 = false;
				if (!SolidTile(x, num + 2))
				{
					flag3 = true;
				}
				if (Main.tile[x, num + 1].type != Main.tile[x, num].type)
				{
					flag3 = true;
				}
				if (Main.tile[x, num + 1].frameX != Main.tile[x, num].frameX)
				{
					flag3 = true;
				}
				if (!flag3 && !UpdateStalagtiteStyle(x, num))
				{
					flag3 = true;
				}
				if (flag3)
				{
					destroyObject = true;
					if (Main.tile[x, num].type == Main.tile[x, j].type)
					{
						KillTile(x, num);
					}
					if (Main.tile[x, num + 1].type == Main.tile[x, j].type)
					{
						KillTile(x, num + 1);
					}
					destroyObject = false;
				}
				return;
			}
			if (Main.tile[x, num].frameY == 18)
			{
				num--;
			}
			if (Main.tile[x, num - 1] == null)
			{
				Main.tile[x, num - 1] = new Tile();
			}
			if (Main.tile[x, num] == null)
			{
				Main.tile[x, num] = new Tile();
			}
			if (Main.tile[x, num + 1] == null)
			{
				Main.tile[x, num + 1] = new Tile();
			}
			bool flag4 = false;
			if (!SolidTile(x, num - 1))
			{
				flag4 = true;
			}
			if (Main.tile[x, num + 1].type != Main.tile[x, num].type)
			{
				flag4 = true;
			}
			if (Main.tile[x, num + 1].frameX != Main.tile[x, num].frameX)
			{
				flag4 = true;
			}
			if (!flag4 && !UpdateStalagtiteStyle(x, num))
			{
				flag4 = true;
			}
			if (flag4)
			{
				destroyObject = true;
				if (Main.tile[x, num].type == Main.tile[x, j].type)
				{
					KillTile(x, num);
				}
				if (Main.tile[x, num + 1].type == Main.tile[x, j].type)
				{
					KillTile(x, num + 1);
				}
				destroyObject = false;
			}
		}

		public static void Place1xX(int x, int y, ushort type, int style = 0)
		{
			int num = style * 18;
			int num2 = 3;
			if (type == 92)
			{
				num2 = 6;
			}
			bool flag = true;
			for (int i = y - num2 + 1; i < y + 1; i++)
			{
				if (Main.tile[x, i] == null)
				{
					Main.tile[x, i] = new Tile();
				}
				if (Main.tile[x, i].active())
				{
					flag = false;
				}
				if (type == 93 && Main.tile[x, i].liquid > 0)
				{
					flag = false;
				}
			}
			if (flag && SolidTile2(x, y + 1))
			{
				for (int j = 0; j < num2; j++)
				{
					Main.tile[x, y - num2 + 1 + j].active(active: true);
					Main.tile[x, y - num2 + 1 + j].frameY = (short)(j * 18 + num2 * num);
					Main.tile[x, y - num2 + 1 + j].frameX = 0;
					Main.tile[x, y - num2 + 1 + j].type = type;
				}
			}
		}

		public static int checkXmasTreeDrop(int x, int y, int obj)
		{
			int num = x;
			int num2 = y;
			if (Main.tile[x, y].frameX < 10)
			{
				num -= Main.tile[x, y].frameX;
				num2 -= Main.tile[x, y].frameY;
			}
			int num3 = 0;
			if ((Main.tile[num, num2].frameY & 1) == 1)
			{
				num3++;
			}
			if ((Main.tile[num, num2].frameY & 2) == 2)
			{
				num3 += 2;
			}
			if ((Main.tile[num, num2].frameY & 4) == 4)
			{
				num3 += 4;
			}
			int num4 = 0;
			if ((Main.tile[num, num2].frameY & 8) == 8)
			{
				num4++;
			}
			if ((Main.tile[num, num2].frameY & 0x10) == 16)
			{
				num4 += 2;
			}
			if ((Main.tile[num, num2].frameY & 0x20) == 32)
			{
				num4 += 4;
			}
			int num5 = 0;
			if ((Main.tile[num, num2].frameY & 0x40) == 64)
			{
				num5++;
			}
			if ((Main.tile[num, num2].frameY & 0x80) == 128)
			{
				num5 += 2;
			}
			if ((Main.tile[num, num2].frameY & 0x100) == 256)
			{
				num5 += 4;
			}
			if ((Main.tile[num, num2].frameY & 0x200) == 512)
			{
				num5 += 8;
			}
			int num6 = 0;
			if ((Main.tile[num, num2].frameY & 0x400) == 1024)
			{
				num6++;
			}
			if ((Main.tile[num, num2].frameY & 0x800) == 2048)
			{
				num6 += 2;
			}
			if ((Main.tile[num, num2].frameY & 0x1000) == 4096)
			{
				num6 += 4;
			}
			if ((Main.tile[num, num2].frameY & 0x2000) == 8192)
			{
				num6 += 8;
			}
			if (obj == 0 && num3 > 0)
			{
				return num3;
			}
			if (obj == 1 && num4 > 0)
			{
				return num4;
			}
			if (obj == 2 && num5 > 0)
			{
				return num5;
			}
			if (obj == 3 && num6 > 0)
			{
				return num6;
			}
			return -1;
		}

		public static void dropXmasTree(int x, int y, int obj)
		{
			int num = x;
			int num2 = y;
			if (Main.tile[x, y].frameX < 10)
			{
				num -= Main.tile[x, y].frameX;
				num2 -= Main.tile[x, y].frameY;
			}
			int num3 = 0;
			if ((Main.tile[num, num2].frameY & 1) == 1)
			{
				num3++;
			}
			if ((Main.tile[num, num2].frameY & 2) == 2)
			{
				num3 += 2;
			}
			if ((Main.tile[num, num2].frameY & 4) == 4)
			{
				num3 += 4;
			}
			int num4 = 0;
			if ((Main.tile[num, num2].frameY & 8) == 8)
			{
				num4++;
			}
			if ((Main.tile[num, num2].frameY & 0x10) == 16)
			{
				num4 += 2;
			}
			if ((Main.tile[num, num2].frameY & 0x20) == 32)
			{
				num4 += 4;
			}
			int num5 = 0;
			if ((Main.tile[num, num2].frameY & 0x40) == 64)
			{
				num5++;
			}
			if ((Main.tile[num, num2].frameY & 0x80) == 128)
			{
				num5 += 2;
			}
			if ((Main.tile[num, num2].frameY & 0x100) == 256)
			{
				num5 += 4;
			}
			if ((Main.tile[num, num2].frameY & 0x200) == 512)
			{
				num5 += 8;
			}
			int num6 = 0;
			if ((Main.tile[num, num2].frameY & 0x400) == 1024)
			{
				num6++;
			}
			if ((Main.tile[num, num2].frameY & 0x800) == 2048)
			{
				num6 += 2;
			}
			if ((Main.tile[num, num2].frameY & 0x1000) == 4096)
			{
				num6 += 4;
			}
			if ((Main.tile[num, num2].frameY & 0x2000) == 8192)
			{
				num6 += 8;
			}
			if (obj == 0 && num3 > 0)
			{
				int number = Item.NewItem(x * 16, y * 16, 16, 16, 1874 + num3 - 1);
				if (Main.netMode == 1)
				{
					NetMessage.SendData(21, -1, -1, null, number, 1f);
				}
			}
			else if (obj == 1 && num4 > 0)
			{
				int number2 = Item.NewItem(x * 16, y * 16, 16, 16, 1878 + num4 - 1);
				if (Main.netMode == 1)
				{
					NetMessage.SendData(21, -1, -1, null, number2, 1f);
				}
			}
			else if (obj == 2 && num5 > 0)
			{
				int number3 = Item.NewItem(x * 16, y * 16, 16, 16, 1884 + num5 - 1);
				if (Main.netMode == 1)
				{
					NetMessage.SendData(21, -1, -1, null, number3, 1f);
				}
			}
			else if (obj == 3 && num6 > 0)
			{
				int number4 = Item.NewItem(x * 16, y * 16, 16, 16, 1895 + num6 - 1);
				if (Main.netMode == 1)
				{
					NetMessage.SendData(21, -1, -1, null, number4, 1f);
				}
			}
		}

		public static void setXmasTree(int x, int y, int obj, int style)
		{
			int num = x;
			int num2 = y;
			if (Main.tile[x, y].frameX < 10)
			{
				num -= Main.tile[x, y].frameX;
				num2 -= Main.tile[x, y].frameY;
			}
			if (obj == 0)
			{
				if ((style & 1) == 1)
				{
					Main.tile[num, num2].frameY |= 1;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -2);
				}
				if ((style & 2) == 2)
				{
					Main.tile[num, num2].frameY |= 2;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -3);
				}
				if ((style & 4) == 4)
				{
					Main.tile[num, num2].frameY |= 4;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -5);
				}
			}
			if (obj == 1)
			{
				if ((style & 1) == 1)
				{
					Main.tile[num, num2].frameY |= 8;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -9);
				}
				if ((style & 2) == 2)
				{
					Main.tile[num, num2].frameY |= 16;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -17);
				}
				if ((style & 4) == 4)
				{
					Main.tile[num, num2].frameY |= 32;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -33);
				}
			}
			if (obj == 2)
			{
				if ((style & 1) == 1)
				{
					Main.tile[num, num2].frameY |= 64;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -65);
				}
				if ((style & 2) == 2)
				{
					Main.tile[num, num2].frameY |= 128;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -129);
				}
				if ((style & 4) == 4)
				{
					Main.tile[num, num2].frameY |= 256;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -257);
				}
				if ((style & 8) == 8)
				{
					Main.tile[num, num2].frameY |= 512;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -513);
				}
			}
			if (obj == 3)
			{
				if ((style & 1) == 1)
				{
					Main.tile[num, num2].frameY |= 1024;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -1025);
				}
				if ((style & 2) == 2)
				{
					Main.tile[num, num2].frameY |= 2048;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -2049);
				}
				if ((style & 4) == 4)
				{
					Main.tile[num, num2].frameY |= 4096;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -4097);
				}
				if ((style & 8) == 8)
				{
					Main.tile[num, num2].frameY |= 8192;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -8193);
				}
			}
		}

		public static int PlaceXmasTree_Direct(int x, int y, int type, int style, int dir, int alternate)
		{
			for (short num = 0; num < 4; num = (short)(num + 1))
			{
				for (short num2 = 0; num2 < 8; num2 = (short)(num2 + 1))
				{
					Tile tile = Main.tile[x + num, y + num2];
					tile.active(active: true);
					tile.type = (ushort)type;
					if (num == 0 && num2 == 0)
					{
						tile.frameX = 10;
						tile.frameY = 0;
					}
					else
					{
						tile.frameX = num;
						tile.frameY = num2;
					}
				}
			}
			return 0;
		}

		public static void PlaceXmasTree(int x, int y, ushort type = 171)
		{
			bool flag = true;
			int num = x - 1;
			int num2 = y - 7;
			for (int i = num; i < num + 4; i++)
			{
				for (int j = num2; j < num2 + 8; j++)
				{
					if (Main.tile[i, j].active())
					{
						flag = false;
					}
				}
				if (i > num && i < num + 3 && !SolidTile(i, num2 + 8))
				{
					flag = false;
				}
			}
			if (!flag)
			{
				return;
			}
			int num3 = 0;
			for (int k = num; k < num + 4; k++)
			{
				int num4 = 0;
				for (int l = num2; l < num2 + 8; l++)
				{
					Main.tile[k, l].active(active: true);
					if (num3 == 0 && num4 == 0)
					{
						Main.tile[k, l].frameX = 10;
						Main.tile[k, l].frameY = 0;
					}
					else
					{
						Main.tile[k, l].frameX = (short)num3;
						Main.tile[k, l].frameY = (short)num4;
					}
					Main.tile[k, l].type = type;
					Main.tile[k, l].active(active: true);
					num4++;
				}
				num3++;
			}
		}

		public static void CheckXmasTree(int x, int y)
		{
			if (destroyObject)
			{
				return;
			}
			int num = x;
			int num2 = y;
			if (Main.tile[x, y].frameX < 10)
			{
				num -= Main.tile[x, y].frameX;
				num2 -= Main.tile[x, y].frameY;
			}
			bool flag = false;
			int num3 = 0;
			for (int i = num; i < num + 4; i++)
			{
				int num4 = 0;
				for (int j = num2; j < num2 + 8; j++)
				{
					if (Main.tile[i, j].active() && Main.tile[i, j].type == 171)
					{
						if (num3 != 0 && num4 != 0 && Main.tile[i, j].frameX != num3 && Main.tile[i, j].frameY != num4)
						{
							flag = true;
						}
					}
					else
					{
						flag = true;
					}
					num4++;
				}
				num3++;
				if (i > num && i < num + 3 && !SolidTile2(i, num2 + 8))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int k = num; k < num + 4; k++)
			{
				for (int l = num2; l < num2 + 8; l++)
				{
					if (Main.tile[k, l].type == 171)
					{
						KillTile(k, l);
					}
				}
			}
			Item.NewItem(x * 16, y * 16, 32, 32, 1873);
			destroyObject = false;
		}

		public static void Place2xX(int x, int y, ushort type, int style = 0)
		{
			int num = style * 36;
			int num2 = 0;
			int num3 = 3;
			if (type == 105 && style == 34)
			{
				type = 349;
				style = 0;
				num = 0;
			}
			if (type == 105)
			{
				int num4 = style / 55;
				num -= 1980 * num4;
				num2 += 54 * num4;
			}
			if (type == 104)
			{
				num3 = 5;
			}
			if (type == 207)
			{
				num3 = 4;
			}
			bool flag = true;
			for (int i = y - num3 + 1; i < y + 1; i++)
			{
				if (Main.tile[x, i] == null)
				{
					Main.tile[x, i] = new Tile();
				}
				if (Main.tile[x, i].active())
				{
					flag = false;
				}
				if (Main.tile[x + 1, i] == null)
				{
					Main.tile[x + 1, i] = new Tile();
				}
				if (Main.tile[x + 1, i].active())
				{
					flag = false;
				}
			}
			if (flag && SolidTile2(x, y + 1) && SolidTile2(x + 1, y + 1))
			{
				for (int j = 0; j < num3; j++)
				{
					Main.tile[x, y - num3 + 1 + j].active(active: true);
					Main.tile[x, y - num3 + 1 + j].frameY = (short)(num2 + j * 18);
					Main.tile[x, y - num3 + 1 + j].frameX = (short)num;
					Main.tile[x, y - num3 + 1 + j].type = type;
					Main.tile[x + 1, y - num3 + 1 + j].active(active: true);
					Main.tile[x + 1, y - num3 + 1 + j].frameY = (short)(num2 + j * 18);
					Main.tile[x + 1, y - num3 + 1 + j].frameX = (short)(num + 18);
					Main.tile[x + 1, y - num3 + 1 + j].type = type;
				}
			}
		}

		public static int GetItemDrop_Benches(int style)
		{
			return style switch
			{
				1 => 2397, 
				2 => 2398, 
				3 => 2399, 
				4 => 2400, 
				5 => 2401, 
				6 => 2402, 
				7 => 2403, 
				8 => 2404, 
				9 => 2405, 
				10 => 2406, 
				11 => 2407, 
				12 => 2408, 
				13 => 2409, 
				14 => 2410, 
				15 => 2411, 
				16 => 2412, 
				17 => 2413, 
				18 => 2414, 
				19 => 2415, 
				20 => 2416, 
				21 => 2521, 
				22 => 2527, 
				23 => 2539, 
				24 => 858, 
				25 => 2582, 
				26 => 2634, 
				27 => 2635, 
				28 => 2636, 
				29 => 2823, 
				30 => 3150, 
				31 => 3152, 
				32 => 3151, 
				33 => 3918, 
				34 => 3919, 
				35 => 3947, 
				36 => 3973, 
				37 => 4161, 
				38 => 4182, 
				39 => 4203, 
				40 => 4224, 
				41 => 4313, 
				42 => 4582, 
				43 => 4993, 
				_ => 335, 
			};
		}

		public static int GetItemDrop_PicnicTables(int style)
		{
			if (style == 0 || style != 1)
			{
				return 4064;
			}
			return 4065;
		}

		public static int GetItemDrop_Chair(int style)
		{
			switch (style)
			{
			default:
				return 34;
			case 1:
				return 358;
			case 2:
				return 628;
			case 3:
				return 629;
			case 4:
				return 630;
			case 5:
				return 806;
			case 6:
				return 807;
			case 7:
				return 808;
			case 8:
				return 809;
			case 9:
				return 810;
			case 10:
				return 826;
			case 11:
				return 915;
			case 12:
				return 1143;
			case 13:
				return 1396;
			case 14:
				return 1399;
			case 15:
				return 1402;
			case 16:
				return 1459;
			case 17:
				return 1509;
			case 18:
			case 19:
			case 20:
			case 21:
			case 22:
			case 23:
				return 1703 + style - 18;
			case 24:
				return 1792;
			case 25:
				return 1814;
			case 26:
				return 1925;
			case 27:
				return 2228;
			case 28:
				return 2288;
			case 29:
				return 2524;
			case 30:
				return 2557;
			case 31:
				return 2572;
			case 32:
				return 2812;
			case 33:
				return 3174;
			case 34:
				return 3176;
			case 35:
				return 3175;
			case 36:
				return 3889;
			case 37:
				return 3937;
			case 38:
				return 3963;
			case 39:
				return 4151;
			case 40:
				return 4172;
			case 41:
				return 4193;
			case 42:
				return 4214;
			case 43:
				return 4304;
			case 44:
				return 4572;
			}
		}

		public static int GetItemDrop_Toilet(int style)
		{
			int num = 4096 + style;
			switch (style)
			{
			case 32:
				num = 4141;
				break;
			case 33:
				num = 4165;
				break;
			case 34:
				num = 4186;
				break;
			case 35:
				num = 4207;
				break;
			case 36:
				num = 4228;
				break;
			case 37:
				num = 4316;
				break;
			case 38:
				num = 4586;
				break;
			case 39:
				num = 4731;
				break;
			}
			if (num > 4731)
			{
				num = 4731;
			}
			return num;
		}

		public static void Check1x2(int x, int j, ushort type)
		{
			if (destroyObject)
			{
				return;
			}
			int num = j;
			bool flag = true;
			if (Main.tile[x, num] == null)
			{
				Main.tile[x, num] = new Tile();
			}
			if (Main.tile[x, num + 1] == null)
			{
				Main.tile[x, num + 1] = new Tile();
			}
			int num2 = Main.tile[x, num].frameY;
			int num3 = 0;
			while (num2 >= 40)
			{
				num2 -= 40;
				num3++;
			}
			if (num2 == 18)
			{
				num--;
			}
			int num4 = Main.tile[x, num].frameX / 18;
			if (Main.tile[x, num].frameX == -1)
			{
				num4 = Main.tile[x, num + 1].frameX / 18;
			}
			if (Main.tile[x, num] == null)
			{
				Main.tile[x, num] = new Tile();
			}
			if (Main.tile[x, num].frameY == 40 * num3 && Main.tile[x, num + 1].frameY == 40 * num3 + 18 && Main.tile[x, num].type == type && Main.tile[x, num + 1].type == type)
			{
				flag = false;
			}
			if (Main.tile[x, num + 2] == null)
			{
				Main.tile[x, num + 2] = new Tile();
			}
			if (!SolidTileAllowBottomSlope(x, num + 2) && !TileID.Sets.Platforms[Main.tile[x, num + 2].type])
			{
				flag = true;
			}
			if (Main.tile[x, num].type == 20)
			{
				int num5 = Main.tile[x, num].frameX / 54;
				int type2 = Main.tile[x, num + 2].type;
				int num6 = -1;
				switch (type2)
				{
				case 2:
				case 477:
					num6 = 0;
					break;
				case 147:
					num6 = 1;
					break;
				case 60:
					num6 = 2;
					break;
				case 23:
					num6 = 3;
					break;
				case 199:
					num6 = 4;
					break;
				case 109:
				case 492:
					num6 = 5;
					break;
				case 53:
					num6 = 6;
					break;
				case 116:
					num6 = 7;
					break;
				case 234:
					num6 = 8;
					break;
				case 112:
					num6 = 9;
					break;
				default:
					flag = true;
					break;
				}
				if (!flag && num5 != num6)
				{
					int num7 = 54 * num6;
					num7 += genRand.Next(3) * 18;
					Main.tile[x, num].frameX = (short)num7;
					Main.tile[x, num + 1].frameX = (short)num7;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			if (Main.tile[x, num].type == type)
			{
				KillTile(x, num);
			}
			if (Main.tile[x, num + 1].type == type)
			{
				KillTile(x, num + 1);
			}
			if (type == 216)
			{
				Item.NewItem(x * 16, num * 16, 32, 32, 970 + num3);
			}
			if (type == 338)
			{
				Item.NewItem(x * 16, num * 16, 32, 32, 2738);
			}
			if (type == 390)
			{
				Item.NewItem(x * 16, num * 16, 16, 32, 3253);
			}
			if (type == 493)
			{
				int num8 = 0;
				switch (num4)
				{
				case 0:
					num8 = 4083;
					break;
				case 1:
					num8 = 4084;
					break;
				case 2:
					num8 = 4085;
					break;
				case 3:
					num8 = 4086;
					break;
				case 4:
					num8 = 4087;
					break;
				case 5:
					num8 = 4088;
					break;
				}
				if (num8 > 0)
				{
					Item.NewItem(x * 16, num * 16, 32, 32, num8);
				}
			}
			if (type == 15)
			{
				int itemDrop_Chair = GetItemDrop_Chair(num3);
				Item.NewItem(x * 16, num * 16, 32, 32, itemDrop_Chair);
			}
			switch (type)
			{
			case 497:
			{
				int itemDrop_Toilet = GetItemDrop_Toilet(num3);
				Item.NewItem(x * 16, num * 16, 32, 32, itemDrop_Toilet);
				break;
			}
			case 134:
				if (num3 == 1)
				{
					Item.NewItem(x * 16, num * 16, 32, 32, 1220);
				}
				else
				{
					Item.NewItem(x * 16, num * 16, 32, 32, 525);
				}
				break;
			}
			destroyObject = false;
		}

		public static void CheckOnTable1x1(int x, int y, int type)
		{
			if (Main.tile[x, y + 1] == null)
			{
				return;
			}
			if (Main.tile[x, y + 1].topSlope())
			{
				if (TileID.Sets.Platforms[Main.tile[x, y + 1].type])
				{
					if ((Main.tile[x, y + 1].blockType() != 3 || !Main.tile[x - 1, y + 1].active() || Main.tile[x - 1, y + 1].blockType() != 0 || !TileID.Sets.Platforms[Main.tile[x - 1, y + 1].type]) && (Main.tile[x, y + 1].blockType() != 2 || !Main.tile[x + 1, y + 1].active() || Main.tile[x + 1, y + 1].blockType() != 0 || !TileID.Sets.Platforms[Main.tile[x + 1, y + 1].type]))
					{
						KillTile(x, y);
					}
				}
				else
				{
					KillTile(x, y);
				}
			}
			else
			{
				if (Main.tile[x, y + 1].active() && Main.tileTable[Main.tile[x, y + 1].type] && !Main.tile[x, y + 1].halfBrick())
				{
					return;
				}
				if (type == 78)
				{
					if (!SolidTileAllowBottomSlope(x, y + 1))
					{
						KillTile(x, y);
					}
				}
				else
				{
					KillTile(x, y);
				}
			}
		}

		public static void CheckSign(int x, int y, ushort type)
		{
			if (destroyObject)
			{
				return;
			}
			int num = x - 2;
			int num2 = x + 3;
			int num3 = y - 2;
			int num4 = y + 3;
			if (num < 0 || num2 > Main.maxTilesX || num3 < 0 || num4 > Main.maxTilesY)
			{
				return;
			}
			bool flag = false;
			for (int i = num; i < num2; i++)
			{
				for (int j = num3; j < num4; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
				}
			}
			int num5 = Main.tile[x, y].frameX / 18;
			int num6 = Main.tile[x, y].frameY / 18;
			num5 %= 2;
			num6 %= 2;
			int num7 = x - num5;
			int num8 = y - num6;
			int num9 = Main.tile[num7, num8].frameX / 18 / 2;
			int num10 = Main.tile[num7, num8].frameY / 18 / 2;
			int num11 = Main.tile[x, y].frameX / 18;
			int num12 = 0;
			while (num11 > 1)
			{
				num11 -= 2;
				num12++;
			}
			num = num7;
			num2 = num7 + 2;
			num3 = num8;
			num4 = num8 + 2;
			num5 = 0;
			for (int k = num; k < num2; k++)
			{
				num6 = 0;
				for (int l = num3; l < num4; l++)
				{
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type)
					{
						flag = true;
						break;
					}
					if (Main.tile[k, l].frameX / 18 != num5 + num9 * 2 || Main.tile[k, l].frameY / 18 != num6 + num10 * 2)
					{
						flag = true;
						break;
					}
					num6++;
				}
				num5++;
			}
			if (!flag)
			{
				if (type == 85)
				{
					if (SolidTileAllowBottomSlope(num7, num8 + 2) && SolidTileAllowBottomSlope(num7 + 1, num8 + 2))
					{
						num9 = num12;
					}
					else
					{
						flag = true;
					}
				}
				else if (TopEdgeCanBeAttachedTo(num7, num8 + 2) && TopEdgeCanBeAttachedTo(num7 + 1, num8 + 2))
				{
					num9 = 0;
				}
				else if (BottomEdgeCanBeAttachedTo(num7, num8 - 1) && BottomEdgeCanBeAttachedTo(num7 + 1, num8 - 1))
				{
					num9 = 1;
				}
				else if (RightEdgeCanBeAttachedTo(num7 - 1, num8) && RightEdgeCanBeAttachedTo(num7 - 1, num8 + 1))
				{
					num9 = 2;
				}
				else if (LeftEdgeCanBeAttachedTo(num7 + 2, num8) && LeftEdgeCanBeAttachedTo(num7 + 2, num8 + 1))
				{
					num9 = 3;
				}
				else if (Main.tile[num7, num8].wall > 0 && Main.tile[num7 + 1, num8].wall > 0 && Main.tile[num7, num8 + 1].wall > 0 && Main.tile[num7 + 1, num8 + 1].wall > 0)
				{
					num9 = 4;
				}
				else
				{
					flag = true;
				}
			}
			if (flag)
			{
				if (type == 395)
				{
					int num13 = TEItemFrame.Find(num7, num8);
					if (num13 != -1 && ((TEItemFrame)TileEntity.ByID[num13]).item.stack > 0)
					{
						((TEItemFrame)TileEntity.ByID[num13]).DropItem();
						if (Main.netMode != 2)
						{
							Main.LocalPlayer.InterruptItemUsageIfOverTile(395);
						}
					}
				}
				destroyObject = true;
				for (int m = num; m < num2; m++)
				{
					for (int n = num3; n < num4; n++)
					{
						if (Main.tile[m, n].type == type)
						{
							KillTile(m, n);
						}
					}
				}
				if (type != 395)
				{
					Sign.KillSign(num7, num8);
				}
				switch (type)
				{
				case 85:
				{
					int type2 = 321;
					if (num12 >= 6 && num12 <= 10)
					{
						type2 = 3229 + num12 - 6;
					}
					else if (num12 >= 1 && num12 <= 5)
					{
						type2 = 1173 + num12 - 1;
					}
					Item.NewItem(x * 16, y * 16, 32, 32, type2);
					if (Main.netMode != 1 && genRand.Next(2) == 0 && NPC.CountNPCS(316) < 2)
					{
						int num14 = Player.FindClosest(new Vector2(x * 16, y * 16), 16, 16);
						if (Main.player[num14].ZoneGraveyard || !Main.dayTime || (double)y > Main.worldSurface)
						{
							NPC.SpawnOnPlayer(num14, 316);
						}
					}
					break;
				}
				case 395:
					Item.NewItem(num7 * 16, num8 * 16, 32, 32, 3270);
					TEItemFrame.Kill(num7, num8);
					break;
				case 425:
					Item.NewItem(num7 * 16, num8 * 16, 32, 32, 3617);
					break;
				case 573:
					Item.NewItem(num7 * 16, num8 * 16, 32, 32, 4710);
					break;
				case 511:
					Item.NewItem(num7 * 16, num8 * 16, 32, 32, 4320);
					break;
				case 510:
					Item.NewItem(num7 * 16, num8 * 16, 32, 32, 4319);
					break;
				default:
					Item.NewItem(x * 16, y * 16, 32, 32, 171);
					break;
				}
				destroyObject = false;
				return;
			}
			int num15 = 36 * num9;
			for (int num16 = 0; num16 < 2; num16++)
			{
				for (int num17 = 0; num17 < 2; num17++)
				{
					Main.tile[num7 + num16, num8 + num17].active(active: true);
					Main.tile[num7 + num16, num8 + num17].type = type;
					Main.tile[num7 + num16, num8 + num17].frameX = (short)(num15 + 18 * num16);
					Main.tile[num7 + num16, num8 + num17].frameY = (short)(18 * num17 + num10 * 36);
				}
			}
		}

		public static bool PlaceSign(int x, int y, ushort type, int Style = 0)
		{
			int num = x - 2;
			int num2 = x + 3;
			int num3 = y - 2;
			int num4 = y + 3;
			if (num < 0)
			{
				return false;
			}
			if (num2 > Main.maxTilesX)
			{
				return false;
			}
			if (num3 < 0)
			{
				return false;
			}
			if (num4 > Main.maxTilesY)
			{
				return false;
			}
			for (int i = num; i < num2; i++)
			{
				for (int j = num3; j < num4; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
				}
			}
			int num5 = x;
			int num6 = y;
			int num7 = 0;
			if (type == 55 || type == 425 || type == 510 || type == 511)
			{
				if (SolidTile2(x, y + 1) && SolidTile2(x + 1, y + 1))
				{
					num6--;
					num7 = 0;
				}
				else if (Main.tile[x, y - 1].nactive() && Main.tileSolid[Main.tile[x, y - 1].type] && !Main.tileSolidTop[Main.tile[x, y - 1].type] && Main.tile[x + 1, y - 1].nactive() && Main.tileSolid[Main.tile[x + 1, y - 1].type] && !Main.tileSolidTop[Main.tile[x + 1, y - 1].type])
				{
					num7 = 1;
				}
				else if (Main.tile[x - 1, y].nactive() && Main.tileSolid[Main.tile[x - 1, y].type] && !Main.tileSolidTop[Main.tile[x - 1, y].type] && !Main.tileNoAttach[Main.tile[x - 1, y].type] && Main.tile[x - 1, y + 1].nactive() && Main.tileSolid[Main.tile[x - 1, y + 1].type] && !Main.tileSolidTop[Main.tile[x - 1, y + 1].type] && !Main.tileNoAttach[Main.tile[x - 1, y + 1].type])
				{
					num7 = 2;
				}
				else if (Main.tile[x + 1, y].nactive() && Main.tileSolid[Main.tile[x + 1, y].type] && !Main.tileSolidTop[Main.tile[x + 1, y].type] && !Main.tileNoAttach[Main.tile[x + 1, y].type] && Main.tile[x + 1, y + 1].nactive() && Main.tileSolid[Main.tile[x + 1, y + 1].type] && !Main.tileSolidTop[Main.tile[x + 1, y + 1].type] && !Main.tileNoAttach[Main.tile[x + 1, y + 1].type])
				{
					num5--;
					num7 = 3;
				}
				else
				{
					if (Main.tile[num5, num6].wall <= 0 || Main.tile[num5 + 1, num6].wall <= 0 || Main.tile[num5, num6 + 1].wall <= 0 || Main.tile[num5 + 1, num6 + 1].wall <= 0)
					{
						return false;
					}
					num7 = 4;
				}
			}
			if (Main.tile[num5, num6].active() || Main.tile[num5 + 1, num6].active() || Main.tile[num5, num6 + 1].active() || Main.tile[num5 + 1, num6 + 1].active())
			{
				return false;
			}
			int num8 = 36 * num7;
			for (int k = 0; k < 2; k++)
			{
				for (int l = 0; l < 2; l++)
				{
					Main.tile[num5 + k, num6 + l].active(active: true);
					Main.tile[num5 + k, num6 + l].type = type;
					Main.tile[num5 + k, num6 + l].frameX = (short)(num8 + 18 * k);
					Main.tile[num5 + k, num6 + l].frameY = (short)(18 * l);
				}
			}
			return true;
		}

		public static bool Place2x2Horizontal(int x, int y, ushort type, int Style = 0)
		{
			int num = x - 2;
			int num2 = x + 3;
			int num3 = y - 2;
			int num4 = y + 3;
			if (num < 0)
			{
				return false;
			}
			if (num2 > Main.maxTilesX)
			{
				return false;
			}
			if (num3 < 0)
			{
				return false;
			}
			if (num4 > Main.maxTilesY)
			{
				return false;
			}
			for (int i = num; i < num2; i++)
			{
				for (int j = num3; j < num4; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
				}
			}
			int num5 = y;
			int num6 = 0;
			if (SolidTile2(x, y + 1) && SolidTile2(x + 1, y + 1))
			{
				num5--;
				num6 = Style;
				if (Main.tile[x, num5].active() || Main.tile[x + 1, num5].active() || Main.tile[x, num5 + 1].active() || Main.tile[x + 1, num5 + 1].active())
				{
					return false;
				}
				int num7 = 36 * num6;
				for (int k = 0; k < 2; k++)
				{
					for (int l = 0; l < 2; l++)
					{
						Main.tile[x + k, num5 + l].active(active: true);
						Main.tile[x + k, num5 + l].type = type;
						Main.tile[x + k, num5 + l].frameX = (short)(num7 + 18 * k);
						Main.tile[x + k, num5 + l].frameY = (short)(18 * l);
					}
				}
				return true;
			}
			return false;
		}

		public static Color paintColor(int color)
		{
			Color white = Color.White;
			if (color == 1 || color == 13)
			{
				white.R = byte.MaxValue;
				white.G = 0;
				white.B = 0;
			}
			if (color == 2 || color == 14)
			{
				white.R = byte.MaxValue;
				white.G = 127;
				white.B = 0;
			}
			if (color == 3 || color == 15)
			{
				white.R = byte.MaxValue;
				white.G = byte.MaxValue;
				white.B = 0;
			}
			if (color == 4 || color == 16)
			{
				white.R = 127;
				white.G = byte.MaxValue;
				white.B = 0;
			}
			if (color == 5 || color == 17)
			{
				white.R = 0;
				white.G = byte.MaxValue;
				white.B = 0;
			}
			if (color == 6 || color == 18)
			{
				white.R = 0;
				white.G = byte.MaxValue;
				white.B = 127;
			}
			if (color == 7 || color == 19)
			{
				white.R = 0;
				white.G = byte.MaxValue;
				white.B = byte.MaxValue;
			}
			if (color == 8 || color == 20)
			{
				white.R = 0;
				white.G = 127;
				white.B = byte.MaxValue;
			}
			if (color == 9 || color == 21)
			{
				white.R = 0;
				white.G = 0;
				white.B = byte.MaxValue;
			}
			if (color == 10 || color == 22)
			{
				white.R = 127;
				white.G = 0;
				white.B = byte.MaxValue;
			}
			if (color == 11 || color == 23)
			{
				white.R = byte.MaxValue;
				white.G = 0;
				white.B = byte.MaxValue;
			}
			if (color == 12 || color == 24)
			{
				white.R = byte.MaxValue;
				white.G = 0;
				white.B = 127;
			}
			if (color == 25)
			{
				white.R = 75;
				white.G = 75;
				white.B = 75;
			}
			if (color == 26)
			{
				white.R = byte.MaxValue;
				white.G = byte.MaxValue;
				white.B = byte.MaxValue;
			}
			if (color == 27)
			{
				white.R = 175;
				white.G = 175;
				white.B = 175;
			}
			if (color == 28)
			{
				white.R = byte.MaxValue;
				white.G = 178;
				white.B = 125;
			}
			if (color == 29)
			{
				white.R = 25;
				white.G = 25;
				white.B = 25;
			}
			if (color == 30)
			{
				white.R = 200;
				white.G = 200;
				white.B = 200;
				white.A = 150;
			}
			return white;
		}

		public static void paintEffect(int x, int y, byte color, byte oldColor)
		{
			int color2 = color;
			if (color == 0)
			{
				color2 = oldColor;
			}
			Color newColor = paintColor(color2);
			for (int i = 0; i < 10; i++)
			{
				int num = Dust.NewDust(new Vector2(x * 16, y * 16), 16, 16, 143, 0f, 0f, 50, newColor);
				if (genRand.Next(2) == 0)
				{
					Main.dust[num].noGravity = true;
					Main.dust[num].scale *= 1.2f;
				}
				else
				{
					Main.dust[num].scale *= 0.5f;
				}
			}
		}

		public static bool paintTile(int x, int y, byte color, bool broadCast = false)
		{
			if (Main.tile[x, y] == null || !Main.tile[x, y].active())
			{
				return false;
			}
			byte oldColor = Main.tile[x, y].color();
			Main.tile[x, y].color(color);
			if (broadCast)
			{
				NetMessage.SendData(63, -1, -1, null, x, y, (int)color);
			}
			paintEffect(x, y, color, oldColor);
			return true;
		}

		public static bool paintWall(int x, int y, byte color, bool broadCast = false)
		{
			if (Main.tile[x, y] == null || Main.tile[x, y].wall == 0)
			{
				return false;
			}
			byte oldColor = Main.tile[x, y].wallColor();
			Main.tile[x, y].wallColor(color);
			if (broadCast)
			{
				NetMessage.SendData(64, -1, -1, null, x, y, (int)color);
			}
			paintEffect(x, y, color, oldColor);
			return true;
		}

		public static void Place3x3Wall(int x, int y, ushort type, int style)
		{
			int num = x - 1;
			int num2 = y - 1;
			bool flag = true;
			for (int i = num; i < num + 3; i++)
			{
				for (int j = num2; j < num2 + 3; j++)
				{
					if (Main.tile[i, j].active() || Main.tile[i, j].wall == 0)
					{
						flag = false;
						break;
					}
				}
			}
			if (!flag)
			{
				return;
			}
			int num3 = 0;
			while (style > 35)
			{
				num3++;
				style -= 36;
			}
			int num4 = style * 54;
			int num5 = num3 * 54;
			for (int k = num; k < num + 3; k++)
			{
				for (int l = num2; l < num2 + 3; l++)
				{
					Main.tile[k, l].active(active: true);
					Main.tile[k, l].type = type;
					Main.tile[k, l].frameX = (short)(num4 + 18 * (k - num));
					Main.tile[k, l].frameY = (short)(num5 + 18 * (l - num2));
				}
			}
		}

		public static void Check3x3Wall(int x, int y)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int type = Main.tile[x, y].type;
			int num = 0;
			int num2 = 0;
			int num3 = Main.tile[x, y].frameX / 18;
			while (num3 >= 3)
			{
				num3 -= 3;
				num++;
			}
			int num4 = x - num3;
			int num5 = Main.tile[x, y].frameY / 18;
			while (num5 >= 3)
			{
				num5 -= 3;
				num2++;
			}
			int num6 = y - num5;
			num5 = num2 * 54;
			num3 = num * 54;
			for (int i = num4; i < num4 + 3; i++)
			{
				for (int j = num6; j < num6 + 3; j++)
				{
					if (Main.tile[i, j].type != type || !Main.tile[i, j].active() || Main.tile[i, j].wall <= 0 || Main.tile[i, j].frameX != num3 + (i - num4) * 18 || Main.tile[i, j].frameY != num5 + (j - num6) * 18)
					{
						flag = true;
						break;
					}
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int k = num4; k < num4 + 3; k++)
			{
				for (int l = num6; l < num6 + 3; l++)
				{
					if (Main.tile[k, l].type == type && Main.tile[k, l].active())
					{
						KillTile(k, l);
					}
				}
			}
			switch (type)
			{
			case 240:
				num += num2 * 36;
				switch (num)
				{
				case 37:
					Item.NewItem(x * 16, y * 16, 32, 32, 1856);
					break;
				case 36:
					Item.NewItem(x * 16, y * 16, 32, 32, 1855);
					break;
				case 38:
					Item.NewItem(x * 16, y * 16, 32, 32, 1960);
					break;
				case 39:
					Item.NewItem(x * 16, y * 16, 32, 32, 1961);
					break;
				case 40:
					Item.NewItem(x * 16, y * 16, 32, 32, 1962);
					break;
				case 33:
					Item.NewItem(x * 16, y * 16, 32, 32, 1574);
					break;
				case 34:
					Item.NewItem(x * 16, y * 16, 32, 32, 1575);
					break;
				case 35:
					Item.NewItem(x * 16, y * 16, 32, 32, 1576);
					break;
				case 18:
					Item.NewItem(x * 16, y * 16, 32, 32, 1419);
					break;
				case 19:
					Item.NewItem(x * 16, y * 16, 32, 32, 1420);
					break;
				case 20:
					Item.NewItem(x * 16, y * 16, 32, 32, 1427);
					break;
				case 21:
					Item.NewItem(x * 16, y * 16, 32, 32, 1428);
					break;
				case 54:
					Item.NewItem(x * 16, y * 16, 32, 32, 2489);
					break;
				case 55:
					Item.NewItem(x * 16, y * 16, 32, 32, 2589);
					break;
				case 56:
					Item.NewItem(x * 16, y * 16, 32, 32, 3357);
					break;
				case 57:
					Item.NewItem(x * 16, y * 16, 32, 32, 3358);
					break;
				case 58:
					Item.NewItem(x * 16, y * 16, 32, 32, 3359);
					break;
				case 59:
					Item.NewItem(x * 16, y * 16, 32, 32, 3595);
					break;
				case 60:
					Item.NewItem(x * 16, y * 16, 32, 32, 3867);
					break;
				case 61:
					Item.NewItem(x * 16, y * 16, 32, 32, 3866);
					break;
				case 62:
					Item.NewItem(x * 16, y * 16, 32, 32, 3868);
					break;
				case 69:
					Item.NewItem(x * 16, y * 16, 32, 32, 4660);
					break;
				case 70:
					Item.NewItem(x * 16, y * 16, 32, 32, 4723);
					break;
				case 71:
					Item.NewItem(x * 16, y * 16, 32, 32, 4724);
					break;
				case 72:
					Item.NewItem(x * 16, y * 16, 32, 32, 4783);
					break;
				case 73:
					Item.NewItem(x * 16, y * 16, 32, 32, 4958);
					break;
				case 63:
				case 64:
				case 65:
				case 66:
				case 67:
				case 68:
					Item.NewItem(x * 16, y * 16, 32, 32, 4626 + num - 63);
					break;
				default:
					if (num >= 41 && num <= 45)
					{
						Item.NewItem(x * 16, y * 16, 32, 32, 2114 + num - 41);
					}
					else if (num >= 46 && num <= 53)
					{
						Item.NewItem(x * 16, y * 16, 32, 32, 2442 + num - 46);
					}
					else if (num >= 22 && num <= 25)
					{
						Item.NewItem(x * 16, y * 16, 32, 32, 1440 + num - 22);
					}
					else if (num >= 26 && num <= 29)
					{
						Item.NewItem(x * 16, y * 16, 32, 32, 1496 + num - 26);
					}
					else if (num >= 30 && num <= 32)
					{
						Item.NewItem(x * 16, y * 16, 32, 32, 1538 + num - 30);
					}
					else
					{
						Item.NewItem(x * 16, y * 16, 32, 32, 1360 + num);
					}
					break;
				}
				break;
			case 440:
			{
				int num7 = -1;
				int num8 = -1;
				switch (num)
				{
				case 0:
					num7 = 3644;
					num8 = 1526;
					break;
				case 1:
					num7 = 3645;
					num8 = 1524;
					break;
				case 2:
					num7 = 3646;
					num8 = 1525;
					break;
				case 3:
					num7 = 3647;
					num8 = 1523;
					break;
				case 4:
					num7 = 3648;
					num8 = 1522;
					break;
				case 5:
					num7 = 3649;
					num8 = 1527;
					break;
				case 6:
					num7 = 3650;
					num8 = 3643;
					break;
				}
				if (num7 != -1)
				{
					Item.NewItem(x * 16, y * 16, 32, 32, num7);
				}
				if (num8 != -1 && num2 == 1)
				{
					Item.NewItem(x * 16, y * 16, 32, 32, num8);
				}
				break;
			}
			}
			destroyObject = false;
		}

		public static void Place2x3Wall(int x, int y, ushort type, int style)
		{
			int num = y - 1;
			bool flag = true;
			for (int i = x; i < x + 2; i++)
			{
				for (int j = num; j < num + 3; j++)
				{
					if (Main.tile[i, j].active() || Main.tile[i, j].wall == 0)
					{
						flag = false;
						break;
					}
				}
			}
			if (!flag)
			{
				return;
			}
			int num2 = style * 36;
			int num3 = 0;
			for (int k = x; k < x + 2; k++)
			{
				for (int l = num; l < num + 3; l++)
				{
					Main.tile[k, l].active(active: true);
					Main.tile[k, l].type = type;
					Main.tile[k, l].frameX = (short)(num2 + 18 * (k - x));
					Main.tile[k, l].frameY = (short)(num3 + 18 * (l - num));
				}
			}
		}

		public static void Check2x3Wall(int x, int y)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int type = Main.tile[x, y].type;
			int num = 0;
			int num2 = Main.tile[x, y].frameX / 18;
			while (num2 >= 2)
			{
				num2 -= 2;
				num++;
			}
			int num3 = x - num2;
			int num4 = y - Main.tile[x, y].frameY / 18;
			num2 = num * 36;
			for (int i = num3; i < num3 + 2; i++)
			{
				for (int j = num4; j < num4 + 3; j++)
				{
					if (Main.tile[i, j].type != type || !Main.tile[i, j].active() || Main.tile[i, j].wall <= 0 || Main.tile[i, j].frameX != num2 + (i - num3) * 18 || Main.tile[i, j].frameY != (j - num4) * 18)
					{
						flag = true;
						break;
					}
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int k = num3; k < num3 + 2; k++)
			{
				for (int l = num4; l < num4 + 3; l++)
				{
					if (Main.tile[k, l].type == type && Main.tile[k, l].active())
					{
						KillTile(k, l);
					}
				}
			}
			if (type == 245)
			{
				switch (num)
				{
				case 12:
					Item.NewItem(x * 16, y * 16, 32, 32, 4728);
					break;
				case 11:
					Item.NewItem(x * 16, y * 16, 32, 32, 4727);
					break;
				case 10:
					Item.NewItem(x * 16, y * 16, 32, 32, 4726);
					break;
				case 9:
					Item.NewItem(x * 16, y * 16, 32, 32, 4659);
					break;
				case 8:
					Item.NewItem(x * 16, y * 16, 32, 32, 4639);
					break;
				case 7:
					Item.NewItem(x * 16, y * 16, 32, 32, 4638);
					break;
				case 6:
					Item.NewItem(x * 16, y * 16, 32, 32, 1577);
					break;
				case 5:
					Item.NewItem(x * 16, y * 16, 32, 32, 1495);
					break;
				default:
					Item.NewItem(x * 16, y * 16, 32, 32, 1474 + num);
					break;
				}
			}
			destroyObject = false;
		}

		public static void Place3x2Wall(int x, int y, ushort type, int style)
		{
			int num = x - 1;
			bool flag = true;
			for (int i = num; i < num + 3; i++)
			{
				for (int j = y; j < y + 2; j++)
				{
					if (Main.tile[i, j].active() || Main.tile[i, j].wall == 0)
					{
						flag = false;
						break;
					}
				}
			}
			if (!flag)
			{
				return;
			}
			int num2 = 0;
			int num3 = style * 36;
			for (int k = num; k < num + 3; k++)
			{
				for (int l = y; l < y + 2; l++)
				{
					Main.tile[k, l].active(active: true);
					Main.tile[k, l].type = type;
					Main.tile[k, l].frameX = (short)(num2 + 18 * (k - num));
					Main.tile[k, l].frameY = (short)(num3 + 18 * (l - y));
				}
			}
		}

		public static void Check3x2Wall(int x, int y)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int type = Main.tile[x, y].type;
			int num = 0;
			int num2 = Main.tile[x, y].frameY / 18;
			while (num2 >= 2)
			{
				num2 -= 2;
				num++;
			}
			int num3 = y - num2;
			int num4 = x - Main.tile[x, y].frameX / 18;
			num2 = num * 36;
			for (int i = num4; i < num4 + 3; i++)
			{
				for (int j = num3; j < num3 + 2; j++)
				{
					if (Main.tile[i, j].type != type || !Main.tile[i, j].active() || Main.tile[i, j].wall <= 0 || Main.tile[i, j].frameY != num2 + (j - num3) * 18 || Main.tile[i, j].frameX != (i - num4) * 18)
					{
						flag = true;
						break;
					}
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int k = num4; k < num4 + 3; k++)
			{
				for (int l = num3; l < num3 + 2; l++)
				{
					if (Main.tile[k, l].type == type && Main.tile[k, l].active())
					{
						KillTile(k, l);
					}
				}
			}
			if (type == 246)
			{
				switch (num)
				{
				case 16:
					Item.NewItem(x * 16, y * 16, 32, 32, 1541);
					break;
				case 17:
					Item.NewItem(x * 16, y * 16, 32, 32, 1542);
					break;
				case 18:
					Item.NewItem(x * 16, y * 16, 32, 32, 1908);
					break;
				case 19:
					Item.NewItem(x * 16, y * 16, 32, 32, 4661);
					break;
				case 20:
					Item.NewItem(x * 16, y * 16, 32, 32, 4729);
					break;
				default:
					Item.NewItem(x * 16, y * 16, 32, 32, 1479 + num);
					break;
				}
			}
			destroyObject = false;
		}

		public static void Place4x3Wall(int x, int y, ushort type, int style)
		{
			int num = x - 1;
			int num2 = y - 1;
			bool flag = true;
			for (int i = num; i < num + 4; i++)
			{
				for (int j = num2; j < num2 + 3; j++)
				{
					if (Main.tile[i, j].active() || Main.tile[i, j].wall == 0)
					{
						flag = false;
						break;
					}
				}
			}
			if (!flag)
			{
				return;
			}
			int num3 = 0;
			int num4 = style * 54;
			for (int k = num; k < num + 4; k++)
			{
				for (int l = num2; l < num2 + 3; l++)
				{
					Main.tile[k, l].active(active: true);
					Main.tile[k, l].type = type;
					Main.tile[k, l].frameX = (short)(num3 + 18 * (k - num));
					Main.tile[k, l].frameY = (short)(num4 + 18 * (l - num2));
				}
			}
		}

		public static void Check4x3Wall(int x, int y)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int type = Main.tile[x, y].type;
			int num = 0;
			int num2 = Main.tile[x, y].frameY / 18;
			while (num2 >= 3)
			{
				num2 -= 3;
				num++;
			}
			int num3 = y - num2;
			int num4 = x - Main.tile[x, y].frameX / 18;
			num2 = num * 54;
			for (int i = num4; i < num4 + 4; i++)
			{
				for (int j = num3; j < num3 + 3; j++)
				{
					if (Main.tile[i, j].type != type || !Main.tile[i, j].active() || Main.tile[i, j].wall <= 0 || Main.tile[i, j].frameY != num2 + (j - num3) * 18 || Main.tile[i, j].frameX != (i - num4) * 18)
					{
						flag = true;
						break;
					}
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int k = num4; k < num4 + 4; k++)
			{
				for (int l = num3; l < num3 + 3; l++)
				{
					if (Main.tile[k, l].type == type && Main.tile[k, l].active())
					{
						KillTile(k, l);
					}
				}
			}
			if (type == 241)
			{
				Item.NewItem(x * 16, y * 16, 32, 32, 1417);
			}
			destroyObject = false;
		}

		public static void Place6x4Wall(int x, int y, ushort type, int style)
		{
			int num = x - 2;
			int num2 = y - 2;
			bool flag = true;
			for (int i = num; i < num + 6; i++)
			{
				for (int j = num2; j < num2 + 4; j++)
				{
					if (Main.tile[i, j].active() || Main.tile[i, j].wall == 0)
					{
						flag = false;
						break;
					}
				}
			}
			if (!flag)
			{
				return;
			}
			int num3 = 27;
			int num4 = style / num3 * 108;
			int num5 = style % num3 * 72;
			for (int k = num; k < num + 6; k++)
			{
				for (int l = num2; l < num2 + 4; l++)
				{
					Main.tile[k, l].active(active: true);
					Main.tile[k, l].type = type;
					Main.tile[k, l].frameX = (short)(num4 + 18 * (k - num));
					Main.tile[k, l].frameY = (short)(num5 + 18 * (l - num2));
				}
			}
		}

		public static void Check6x4Wall(int x, int y)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int type = Main.tile[x, y].type;
			int num = 0;
			int num2 = Main.tile[x, y].frameY / 18;
			int num3 = Main.tile[x, y].frameX / 18;
			num = 27 * (num3 / 6) + (num2 >> 2);
			num2 %= 4;
			num3 %= 6;
			int num4 = y - num2;
			int num5 = x - Main.tile[x, y].frameX / 18 % 6;
			num2 = num % 27 * 72;
			num3 = num / 27 * 108;
			for (int i = num5; i < num5 + 6; i++)
			{
				for (int j = num4; j < num4 + 4; j++)
				{
					if (Main.tile[i, j].type != type || !Main.tile[i, j].active() || Main.tile[i, j].wall <= 0 || Main.tile[i, j].frameY != num2 + (j - num4) * 18 || Main.tile[i, j].frameX != num3 + (i - num5) * 18)
					{
						flag = true;
						break;
					}
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int k = num5; k < num5 + 6; k++)
			{
				for (int l = num4; l < num4 + 4; l++)
				{
					if (Main.tile[k, l].type == type && Main.tile[k, l].active())
					{
						KillTile(k, l);
					}
				}
			}
			if (type == 242)
			{
				switch (num)
				{
				case 30:
					Item.NewItem(x * 16, y * 16, 32, 32, 2995);
					break;
				case 44:
					Item.NewItem(x * 16, y * 16, 32, 32, 4725);
					break;
				case 43:
					Item.NewItem(x * 16, y * 16, 32, 32, 4658);
					break;
				case 37:
				case 38:
				case 39:
				case 40:
				case 41:
				case 42:
					Item.NewItem(x * 16, y * 16, 32, 32, 4632 + num - 37);
					break;
				default:
					if (num >= 31 && num <= 35)
					{
						Item.NewItem(x * 16, y * 16, 32, 32, 3055 + num - 31);
					}
					else if (num >= 27 && num <= 29)
					{
						Item.NewItem(x * 16, y * 16, 32, 32, 2865 + num - 27);
					}
					else if (num == 36)
					{
						Item.NewItem(x * 16, y * 16, 32, 32, 3596);
					}
					else if (num == 26)
					{
						Item.NewItem(x * 16, y * 16, 32, 32, 2497);
					}
					else if (num == 25)
					{
						Item.NewItem(x * 16, y * 16, 32, 32, 2495);
					}
					else if (num >= 22)
					{
						Item.NewItem(x * 16, y * 16, 32, 32, 2281 + num - 22);
					}
					else if (num >= 17)
					{
						Item.NewItem(x * 16, y * 16, 32, 32, 1846 + num - 17);
					}
					else if (num == 16)
					{
						Item.NewItem(x * 16, y * 16, 32, 32, 1573);
					}
					else if (num >= 13)
					{
						Item.NewItem(x * 16, y * 16, 32, 32, 1500 + num - 13);
					}
					else if (num >= 6)
					{
						Item.NewItem(x * 16, y * 16, 32, 32, 1433 + num - 6);
					}
					else
					{
						Item.NewItem(x * 16, y * 16, 32, 32, 1421 + num);
					}
					break;
				}
			}
			destroyObject = false;
		}

		private static int RollRandomSeaShellStyle()
		{
			int result = genRand.Next(2);
			if (genRand.Next(10) == 0)
			{
				result = 2;
			}
			if (genRand.Next(10) == 0)
			{
				result = 3;
			}
			if (genRand.Next(50) == 0)
			{
				result = 4;
			}
			return result;
		}

		public static void Place1x1(int x, int y, int type, int style = 0)
		{
			Tile tile = Main.tile[x, y];
			if (Main.tile[x, y] == null)
			{
				tile = new Tile();
				Main.tile[x, y] = tile;
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = new Tile();
			}
			if (type == 324)
			{
				if (SolidTile2(x, y + 1) || (Main.tile[x, y + 1].nactive() && Main.tileTable[Main.tile[x, y + 1].type]))
				{
					tile.active(active: true);
					tile.type = (ushort)type;
					tile.frameX = (short)(22 * genRand.Next(3));
					tile.frameY = (short)(22 * style);
				}
			}
			else if (SolidTile2(x, y + 1) && !tile.active())
			{
				tile.active(active: true);
				tile.type = (ushort)type;
				switch (type)
				{
				case 324:
					tile.frameX = (short)(22 * RollRandomSeaShellStyle());
					tile.frameY = (short)(22 * style);
					break;
				case 36:
				case 144:
				case 239:
					tile.frameX = (short)(style * 18);
					tile.frameY = 0;
					break;
				default:
					tile.frameY = (short)(style * 18);
					break;
				}
			}
		}

		public static void Check1x1(int x, int y, int type)
		{
			if (Main.tile[x, y + 1] != null && !SolidTileAllowBottomSlope(x, y + 1))
			{
				KillTile(x, y);
			}
		}

		public static void CheckGolf1x1(int x, int y, int type)
		{
			Tile tile = Main.tile[x, y];
			bool flag = false;
			if (tile.frameX % 18 != 0)
			{
				flag = true;
			}
			if (tile.frameY % 18 != 0)
			{
				flag = true;
			}
			if (!SolidTileAllowBottomSlope(x, y + 1))
			{
				flag = true;
			}
			if (flag)
			{
				KillTile(x, y);
			}
		}

		public static void CheckLogicTiles(int x, int y, int type)
		{
			if (type == 419)
			{
				Tile tile = Main.tile[x, y + 1];
				if (tile != null && (!tile.active() || (tile.type != 420 && tile.type != 419)))
				{
					KillTile(x, y);
					return;
				}
			}
			Tile tile2 = Main.tile[x, y];
			bool flag = false;
			if (tile2.frameX % 18 != 0)
			{
				flag = true;
			}
			if (tile2.frameY % 18 != 0)
			{
				flag = true;
			}
			if (flag)
			{
				KillTile(x, y);
			}
		}

		public static void PlaceLogicTiles(int x, int y, int type, int style = 0)
		{
			Tile tile = Main.tile[x, y];
			if (Main.tile[x, y] == null)
			{
				tile = new Tile();
				Main.tile[x, y] = tile;
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = new Tile();
			}
			if (type == 419)
			{
				if (Main.tile[x, y + 1].active() && (Main.tile[x, y + 1].type == 419 || Main.tile[x, y + 1].type == 420))
				{
					tile.active(active: true);
					tile.type = (ushort)type;
					tile.frameX = (short)(style * 18);
					tile.frameY = 0;
				}
			}
			else if (!tile.active())
			{
				tile.active(active: true);
				tile.type = (ushort)type;
				tile.frameX = 0;
				tile.frameY = (short)(18 * style);
			}
		}

		public static void PlaceOnTable1x1(int x, int y, int type, int style = 0)
		{
			bool flag = false;
			if (Main.tile[x, y] == null)
			{
				Main.tile[x, y] = new Tile();
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = new Tile();
			}
			if (!Main.tile[x, y].active() && Main.tile[x, y + 1].nactive() && Main.tileTable[Main.tile[x, y + 1].type])
			{
				flag = true;
			}
			if (type == 78 && !Main.tile[x, y].active() && Main.tile[x, y + 1].nactive() && Main.tileSolid[Main.tile[x, y + 1].type] && !Main.tile[x, y + 1].halfBrick() && Main.tile[x, y + 1].slope() == 0)
			{
				flag = true;
			}
			if (flag)
			{
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].type = (ushort)type;
				if (type == 33)
				{
					Main.tile[x, y].frameX = 0;
					Main.tile[x, y].frameY = (short)(style * 22);
				}
				else
				{
					Main.tile[x, y].frameX = (short)(style * 18);
					Main.tile[x, y].frameY = 0;
				}
				if (type == 50)
				{
					Main.tile[x, y].frameX = (short)(18 * genRand.Next(5));
				}
			}
		}

		public static bool PlaceAlch(int x, int y, int style)
		{
			if (Main.tile[x, y] == null)
			{
				Main.tile[x, y] = new Tile();
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = new Tile();
			}
			if (!Main.tile[x, y].active() && Main.tile[x, y + 1].nactive() && !Main.tile[x, y + 1].halfBrick() && Main.tile[x, y + 1].slope() == 0)
			{
				bool flag = false;
				switch (style)
				{
				case 0:
					if (Main.tile[x, y + 1].type != 2 && Main.tile[x, y + 1].type != 477 && Main.tile[x, y + 1].type != 492 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 109)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0)
					{
						flag = true;
					}
					break;
				case 1:
					if (Main.tile[x, y + 1].type != 60 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0)
					{
						flag = true;
					}
					break;
				case 2:
					if (Main.tile[x, y + 1].type != 0 && Main.tile[x, y + 1].type != 59 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0)
					{
						flag = true;
					}
					break;
				case 3:
					if (Main.tile[x, y + 1].type != 203 && Main.tile[x, y + 1].type != 199 && Main.tile[x, y + 1].type != 23 && Main.tile[x, y + 1].type != 25 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0)
					{
						flag = true;
					}
					break;
				case 4:
					if (Main.tile[x, y + 1].type != 53 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 116)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
					{
						flag = true;
					}
					break;
				case 5:
					if (Main.tile[x, y + 1].type != 57 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0 && !Main.tile[x, y].lava())
					{
						flag = true;
					}
					break;
				case 6:
					if (Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 147 && Main.tile[x, y + 1].type != 161 && Main.tile[x, y + 1].type != 163 && Main.tile[x, y + 1].type != 164 && Main.tile[x, y + 1].type != 200)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
					{
						flag = true;
					}
					break;
				}
				if (!flag)
				{
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].type = 82;
					Main.tile[x, y].frameX = (short)(18 * style);
					Main.tile[x, y].frameY = 0;
					return true;
				}
			}
			return false;
		}

		public static void GrowSpike(int i, int j, ushort spikeType, ushort landType)
		{
			int num = i;
			int num2 = j;
			int num3 = 0;
			if (Main.tile[num + 1, num2].active() && Main.tile[num + 1, num2].type == spikeType)
			{
				num3++;
			}
			if (Main.tile[num - 1, num2].active() && Main.tile[num - 1, num2].type == spikeType)
			{
				num3++;
			}
			if (Main.tile[num, num2 + 1].active() && Main.tile[num, num2 + 1].type == spikeType)
			{
				num3++;
			}
			if (Main.tile[num, num2 - 1].active() && Main.tile[num, num2 - 1].type == spikeType)
			{
				num3++;
			}
			if (num3 >= 3 && Main.tile[i, j].type != landType)
			{
				return;
			}
			switch (genRand.Next(4))
			{
			case 0:
				num2--;
				break;
			case 1:
				num2++;
				break;
			case 2:
				num--;
				break;
			case 3:
				num++;
				break;
			}
			if (Main.tile[num, num2].active())
			{
				return;
			}
			num3 = 0;
			if (Main.tile[num + 1, num2].active() && Main.tile[num + 1, num2].type == spikeType)
			{
				num3++;
			}
			if (Main.tile[num - 1, num2].active() && Main.tile[num - 1, num2].type == spikeType)
			{
				num3++;
			}
			if (Main.tile[num, num2 + 1].active() && Main.tile[num, num2 + 1].type == spikeType)
			{
				num3++;
			}
			if (Main.tile[num, num2 - 1].active() && Main.tile[num, num2 - 1].type == spikeType)
			{
				num3++;
			}
			if (num3 >= 2)
			{
				return;
			}
			int num4 = 7;
			int num5 = num - num4;
			int num6 = num + num4;
			int num7 = num2 - num4;
			int num8 = num2 + num4;
			bool flag = false;
			for (int k = num5; k < num6; k++)
			{
				for (int l = num7; l < num8; l++)
				{
					if (Math.Abs(k - num) * 2 + Math.Abs(l - num2) < 9 && Main.tile[k, l].active() && Main.tile[k, l].type == landType && Main.tile[k, l - 1].active() && Main.tile[k, l - 1].type == spikeType && Main.tile[k, l - 1].liquid == 0)
					{
						flag = true;
						break;
					}
				}
			}
			if (flag)
			{
				Main.tile[num, num2].type = spikeType;
				Main.tile[num, num2].active(active: true);
				SquareTileFrame(num, num2);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, num, num2, 3);
				}
			}
		}

		private static bool GrowMoreVines(int x, int y)
		{
			if (!InWorld(x, y, 30))
			{
				return false;
			}
			int num = 4;
			int num2 = 6;
			int num3 = 10;
			int num4 = 60;
			int num5 = 0;
			if (Main.tile[x, y].type == 528)
			{
				num4 /= 5;
			}
			for (int i = x - num; i <= x + num; i++)
			{
				for (int j = y - num2; j <= y + num3; j++)
				{
					if (TileID.Sets.IsVine[Main.tile[i, j].type])
					{
						num5++;
						if (j > y && Collision.CanHitLine(new Vector2(x * 16, y * 16), 1, 1, new Vector2(i * 16, j * 16), 1, 1))
						{
							num5 = ((Main.tile[i, j].type != 528) ? (num5 + (j - y) * 2) : (num5 + (j - y) * 20));
						}
						if (num5 > num4)
						{
							return false;
						}
					}
				}
			}
			return true;
		}

		private static void MatureTheHerbPlants()
		{
			for (int i = 10; i < Main.maxTilesX - 10; i++)
			{
				for (int j = 10; j < Main.maxTilesY - 10; j++)
				{
					if ((double)j > Main.rockLayer && (Main.tile[i, j + 1].type == 59 || Main.tile[i, j + 1].type == 0) && SolidTile(i, j + 1) && !Main.tile[i, j].active() && Main.tile[i, j].liquid == 0 && genRand.Next(25) == 0)
					{
						Main.tile[i, j].active(active: true);
						Main.tile[i, j].type = 82;
						Main.tile[i, j].frameX = 36;
						Main.tile[i, j].frameY = 0;
					}
					if (Main.tile[i, j].type == 82 && genRand.Next(3) == 0)
					{
						Main.tile[i, j].type = 83;
						if (Main.tile[i, j].frameX == 36 && genRand.Next(2) == 0)
						{
							Main.tile[i, j].type = 84;
						}
						if (Main.tile[i, j].frameX == 108 && genRand.Next(3) == 0)
						{
							Main.tile[i, j].type = 84;
						}
					}
				}
			}
		}

		public static void GrowAlch(int x, int y)
		{
			if (!Main.tile[x, y].active())
			{
				return;
			}
			if (Main.tile[x, y].liquid > 0)
			{
				int num = Main.tile[x, y].frameX / 18;
				if ((!Main.tile[x, y].lava() || num != 5) && (Main.tile[x, y].liquidType() != 0 || (num != 1 && num != 4)))
				{
					KillTile(x, y);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y, 1);
					}
					SquareTileFrame(x, y);
				}
			}
			if (Main.tile[x, y].type == 82)
			{
				if (genRand.Next(50) == 0)
				{
					bool flag = false;
					if (Main.tile[x, y].frameX == 108)
					{
						if (genRand.Next(2) == 0)
						{
							flag = true;
						}
					}
					else
					{
						flag = true;
					}
					if (flag)
					{
						Main.tile[x, y].type = 83;
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, x, y, 1);
						}
						SquareTileFrame(x, y);
					}
				}
				else if (Main.dayTime && Main.tile[x, y].type == 82 && Main.tile[x, y].frameX == 0 && genRand.Next(50) == 0)
				{
					Main.tile[x, y].type = 83;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y, 1);
					}
					SquareTileFrame(x, y);
				}
				else if (!Main.dayTime && Main.tile[x, y].type == 82 && Main.tile[x, y].frameX == 18 && genRand.Next(50) == 0)
				{
					Main.tile[x, y].type = 83;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y, 1);
					}
					SquareTileFrame(x, y);
				}
				else if (Main.raining && Main.tile[x, y].type == 82 && Main.tile[x, y].frameX == 72 && genRand.Next(50) == 0)
				{
					Main.tile[x, y].type = 83;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y, 1);
					}
					SquareTileFrame(x, y);
				}
				else if ((double)y > Main.worldSurface && Main.tile[x, y].type == 82 && Main.tile[x, y].frameX == 36 && genRand.Next(50) == 0)
				{
					Main.tile[x, y].type = 83;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y, 1);
					}
					SquareTileFrame(x, y);
				}
				else if (y > Main.maxTilesY - 200 && Main.tile[x, y].type == 82 && Main.tile[x, y].frameX == 90 && genRand.Next(50) == 0)
				{
					Main.tile[x, y].type = 83;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y, 1);
					}
					SquareTileFrame(x, y);
				}
			}
			else if (Main.tile[x, y].frameX == 36 && genRand.Next(3) != 0)
			{
				if (Main.tile[x, y].type == 83)
				{
					if (genRand.Next(2) == 0)
					{
						Main.tile[x, y].type = 84;
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, x, y, 1);
						}
					}
				}
				else if (Main.tile[x, y].type == 84 && genRand.Next(5) == 0)
				{
					Main.tile[x, y].type = 83;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y, 1);
					}
				}
			}
			else if (Main.tile[x, y].frameX == 108 && Main.tile[x, y].type == 83 && genRand.Next(30) == 0)
			{
				Main.tile[x, y].type = 84;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y, 1);
				}
				SquareTileFrame(x, y);
			}
		}

		public static void PlantAlch()
		{
			int num = genRand.Next(20, Main.maxTilesX - 20);
			int num2 = 0;
			for (num2 = ((genRand.Next(40) == 0) ? genRand.Next((int)(Main.rockLayer + (double)Main.maxTilesY) / 2, Main.maxTilesY - 20) : ((genRand.Next(10) != 0) ? genRand.Next((int)Main.worldSurface, Main.maxTilesY - 20) : genRand.Next(20, Main.maxTilesY - 20))); num2 < Main.maxTilesY - 20 && !Main.tile[num, num2].active(); num2++)
			{
			}
			if (!Main.tile[num, num2].nactive() || Main.tile[num, num2 - 1].active() || Main.tile[num, num2 - 1].liquid != 0)
			{
				return;
			}
			int num3 = 15;
			int num4 = 5;
			int num5 = 0;
			num3 = (int)((float)num3 * ((float)Main.maxTilesX / 4200f));
			int num6 = Utils.Clamp(num - num3, 4, Main.maxTilesX - 4);
			int num7 = Utils.Clamp(num + num3, 4, Main.maxTilesX - 4);
			int num8 = Utils.Clamp(num2 - num3, 4, Main.maxTilesY - 4);
			int num9 = Utils.Clamp(num2 + num3, 4, Main.maxTilesY - 4);
			for (int i = num6; i <= num7; i++)
			{
				for (int j = num8; j <= num9; j++)
				{
					if (Main.tileAlch[Main.tile[i, j].type])
					{
						num5++;
					}
				}
			}
			if (num5 < num4)
			{
				if (Main.tile[num, num2].type == 2 || Main.tile[num, num2].type == 109)
				{
					PlaceAlch(num, num2 - 1, 0);
				}
				if (Main.tile[num, num2].type == 60)
				{
					PlaceAlch(num, num2 - 1, 1);
				}
				if (Main.tile[num, num2].type == 0 || Main.tile[num, num2].type == 59)
				{
					PlaceAlch(num, num2 - 1, 2);
				}
				if (Main.tile[num, num2].type == 23 || Main.tile[num, num2].type == 25 || Main.tile[num, num2].type == 203 || Main.tile[num, num2].type == 199)
				{
					PlaceAlch(num, num2 - 1, 3);
				}
				if ((Main.tile[num, num2].type == 53 || Main.tile[num, num2].type == 116) && num >= beachDistance && num <= Main.maxTilesX - beachDistance)
				{
					PlaceAlch(num, num2 - 1, 4);
				}
				if (Main.tile[num, num2].type == 57)
				{
					PlaceAlch(num, num2 - 1, 5);
				}
				if (Main.tile[num, num2].type == 147 || Main.tile[num, num2].type == 163 || Main.tile[num, num2].type == 164 || Main.tile[num, num2].type == 161 || Main.tile[num, num2].type == 200)
				{
					PlaceAlch(num, num2 - 1, 6);
				}
				if (Main.tile[num, num2 - 1].active() && Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, num, num2 - 1, 1);
				}
			}
		}

		public static void CheckAlch(int x, int y)
		{
			if (Main.tile[x, y] == null)
			{
				Main.tile[x, y] = new Tile();
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = new Tile();
			}
			bool flag = false;
			if (!Main.tile[x, y + 1].nactive())
			{
				flag = true;
			}
			if (Main.tile[x, y + 1].halfBrick())
			{
				flag = true;
			}
			int num = Main.tile[x, y].frameX / 18;
			Main.tile[x, y].frameY = 0;
			if (!flag)
			{
				switch (num)
				{
				case 0:
					if (Main.tile[x, y + 1].type != 109 && Main.tile[x, y + 1].type != 2 && Main.tile[x, y + 1].type != 477 && Main.tile[x, y + 1].type != 492 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
					{
						flag = true;
					}
					break;
				case 1:
					if (Main.tile[x, y + 1].type != 60 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
					{
						flag = true;
					}
					break;
				case 2:
					if (Main.tile[x, y + 1].type != 0 && Main.tile[x, y + 1].type != 59 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
					{
						flag = true;
					}
					break;
				case 3:
					if (Main.tile[x, y + 1].type != 199 && Main.tile[x, y + 1].type != 203 && Main.tile[x, y + 1].type != 23 && Main.tile[x, y + 1].type != 25 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
					{
						flag = true;
					}
					break;
				case 4:
					if (Main.tile[x, y + 1].type != 53 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 116)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
					{
						flag = true;
					}
					break;
				case 5:
					if (Main.tile[x, y + 1].type != 57 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
					{
						flag = true;
					}
					if (Main.tile[x, y].type == 82 || !Main.tile[x, y].lava() || Main.netMode == 1)
					{
						break;
					}
					if (Main.tile[x, y].liquid > 16)
					{
						if (Main.tile[x, y].type == 83)
						{
							Main.tile[x, y].type = 84;
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, x, y, 1);
							}
						}
					}
					else if (Main.tile[x, y].type == 84)
					{
						Main.tile[x, y].type = 83;
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, x, y, 1);
						}
					}
					break;
				case 6:
					if (Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 147 && Main.tile[x, y + 1].type != 161 && Main.tile[x, y + 1].type != 163 && Main.tile[x, y + 1].type != 164 && Main.tile[x, y + 1].type != 200)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
					{
						flag = true;
					}
					break;
				}
			}
			if (flag)
			{
				KillTile(x, y);
			}
		}

		public static void CheckBanner(int x, int j, byte type)
		{
			if (destroyObject)
			{
				return;
			}
			int num = Main.tile[x, j].frameY / 18;
			int num2 = 0;
			while (num >= 3)
			{
				num -= 3;
				num2++;
			}
			num = j - num;
			int frameX = Main.tile[x, j].frameX;
			bool flag = false;
			for (int i = 0; i < 3; i++)
			{
				if (Main.tile[x, num + i] == null)
				{
					Main.tile[x, num + i] = new Tile();
				}
				if (!Main.tile[x, num + i].active())
				{
					flag = true;
				}
				else if (Main.tile[x, num + i].type != type)
				{
					flag = true;
				}
				else if (Main.tile[x, num + i].frameY != i * 18 + num2 * 18 * 3)
				{
					flag = true;
				}
				else if (Main.tile[x, num + i].frameX != frameX)
				{
					flag = true;
				}
			}
			if (Main.tile[x, num - 1] == null)
			{
				Main.tile[x, num - 1] = new Tile();
			}
			if (!Main.tile[x, num - 1].nactive())
			{
				flag = true;
			}
			if ((!Main.tile[x, num - 1].topSlope() && !Main.tile[x, num - 1].halfBrick() && !Main.tileSolid[Main.tile[x, num - 1].type]) || (Main.tileSolidTop[Main.tile[x, num - 1].type] && (!TileID.Sets.Platforms[Main.tile[x, num - 1].type] || (!Main.tile[x, num - 1].halfBrick() && !Main.tile[x, num - 1].topSlope()))) || TileID.Sets.NotReallySolid[Main.tile[x, num - 1].type] || Main.tile[x, num - 1].bottomSlope())
			{
				flag = true;
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int k = 0; k < 3; k++)
			{
				if (Main.tile[x, num + k].type == type)
				{
					KillTile(x, num + k);
				}
			}
			if (type == 91)
			{
				int num3 = frameX / 18;
				num3 += num2 * 111;
				if (num3 >= 297)
				{
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 4668 + num3);
				}
				else if (num3 >= 295)
				{
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 4392 + num3);
				}
				else if (num3 >= 294)
				{
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 4602);
				}
				else if (num3 >= 288)
				{
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 4253 + num3);
				}
				else if (num3 >= 278)
				{
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 3559 + num3);
				}
				else if (num3 >= 273)
				{
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 3516 + num3);
				}
				else if (num3 >= 272)
				{
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 3780);
				}
				else if (num3 >= 270)
				{
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 3323 + num3);
				}
				else if (num3 >= 207)
				{
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 3183 + num3);
				}
				else if (num3 >= 109)
				{
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 2788 + num3);
				}
				else if (num3 >= 22)
				{
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 1593 + num3);
				}
				else if (num3 >= 10 && num3 <= 15)
				{
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 1441 + num3);
				}
				else if (num3 >= 16 && num3 <= 21)
				{
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 1448 + num3);
				}
				else if (num3 >= 7 && num3 <= 9)
				{
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 838 + num3);
				}
				else if (num3 >= 4 && num3 <= 6)
				{
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 785 + num3);
				}
				else
				{
					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 337 + num3);
				}
			}
			destroyObject = false;
		}

		public static void PlaceBanner(int x, int y, ushort type, int style = 0)
		{
			int num = style * 18;
			int num2 = 0;
			if (style >= 90)
			{
				num -= 1620;
				num2 += 54;
			}
			if (Main.tile[x, y - 1] == null)
			{
				Main.tile[x, y - 1] = new Tile();
			}
			if (Main.tile[x, y] == null)
			{
				Main.tile[x, y] = new Tile();
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = new Tile();
			}
			if (Main.tile[x, y + 2] == null)
			{
				Main.tile[x, y + 2] = new Tile();
			}
			if (Main.tile[x, y - 1].nactive() && Main.tileSolid[Main.tile[x, y - 1].type] && !Main.tileSolidTop[Main.tile[x, y - 1].type] && !Main.tile[x, y].active() && !Main.tile[x, y + 1].active() && !Main.tile[x, y + 2].active())
			{
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = (short)num2;
				Main.tile[x, y].frameX = (short)num;
				Main.tile[x, y].type = type;
				Main.tile[x, y + 1].active(active: true);
				Main.tile[x, y + 1].frameY = (short)(num2 + 18);
				Main.tile[x, y + 1].frameX = (short)num;
				Main.tile[x, y + 1].type = type;
				Main.tile[x, y + 2].active(active: true);
				Main.tile[x, y + 2].frameY = (short)(num2 + 36);
				Main.tile[x, y + 2].frameX = (short)num;
				Main.tile[x, y + 2].type = type;
			}
		}

		public static void PlaceMan(int i, int j, int dir)
		{
			for (int k = i; k <= i + 1; k++)
			{
				for (int l = j - 2; l <= j; l++)
				{
					if (Main.tile[k, l].active())
					{
						return;
					}
				}
			}
			if (SolidTile2(i, j + 1) && SolidTile2(i + 1, j + 1))
			{
				byte b = 0;
				if (dir == 1)
				{
					b = 36;
				}
				Main.tile[i, j - 2].active(active: true);
				Main.tile[i, j - 2].frameY = 0;
				Main.tile[i, j - 2].frameX = b;
				Main.tile[i, j - 2].type = 128;
				Main.tile[i, j - 1].active(active: true);
				Main.tile[i, j - 1].frameY = 18;
				Main.tile[i, j - 1].frameX = b;
				Main.tile[i, j - 1].type = 128;
				Main.tile[i, j].active(active: true);
				Main.tile[i, j].frameY = 36;
				Main.tile[i, j].frameX = b;
				Main.tile[i, j].type = 128;
				Main.tile[i + 1, j - 2].active(active: true);
				Main.tile[i + 1, j - 2].frameY = 0;
				Main.tile[i + 1, j - 2].frameX = (byte)(18 + b);
				Main.tile[i + 1, j - 2].type = 128;
				Main.tile[i + 1, j - 1].active(active: true);
				Main.tile[i + 1, j - 1].frameY = 18;
				Main.tile[i + 1, j - 1].frameX = (byte)(18 + b);
				Main.tile[i + 1, j - 1].type = 128;
				Main.tile[i + 1, j].active(active: true);
				Main.tile[i + 1, j].frameY = 36;
				Main.tile[i + 1, j].frameX = (byte)(18 + b);
				Main.tile[i + 1, j].type = 128;
			}
		}

		public static void PlaceWoman(int i, int j, int dir)
		{
			for (int k = i; k <= i + 1; k++)
			{
				for (int l = j - 2; l <= j; l++)
				{
					if (Main.tile[k, l].active())
					{
						return;
					}
				}
			}
			if (SolidTile2(i, j + 1) && SolidTile2(i + 1, j + 1))
			{
				byte b = 0;
				if (dir == 1)
				{
					b = 36;
				}
				Main.tile[i, j - 2].active(active: true);
				Main.tile[i, j - 2].frameY = 0;
				Main.tile[i, j - 2].frameX = b;
				Main.tile[i, j - 2].type = 269;
				Main.tile[i, j - 1].active(active: true);
				Main.tile[i, j - 1].frameY = 18;
				Main.tile[i, j - 1].frameX = b;
				Main.tile[i, j - 1].type = 269;
				Main.tile[i, j].active(active: true);
				Main.tile[i, j].frameY = 36;
				Main.tile[i, j].frameX = b;
				Main.tile[i, j].type = 269;
				Main.tile[i + 1, j - 2].active(active: true);
				Main.tile[i + 1, j - 2].frameY = 0;
				Main.tile[i + 1, j - 2].frameX = (byte)(18 + b);
				Main.tile[i + 1, j - 2].type = 269;
				Main.tile[i + 1, j - 1].active(active: true);
				Main.tile[i + 1, j - 1].frameY = 18;
				Main.tile[i + 1, j - 1].frameX = (byte)(18 + b);
				Main.tile[i + 1, j - 1].type = 269;
				Main.tile[i + 1, j].active(active: true);
				Main.tile[i + 1, j].frameY = 36;
				Main.tile[i + 1, j].frameX = (byte)(18 + b);
				Main.tile[i + 1, j].type = 269;
			}
		}

		public static void CheckWeaponsRack(int i, int j)
		{
			if (destroyObject)
			{
				return;
			}
			int num = i;
			int num2 = j - Main.tile[i, j].frameY / 18;
			int num3 = Main.tile[i, j].frameX;
			int num4 = 0;
			while (num3 >= 5000)
			{
				num3 -= 5000;
				num4++;
			}
			if (num4 != 0)
			{
				num3 = (num4 - 1) * 18;
			}
			num3 %= 54;
			num -= num3 / 18;
			bool flag = false;
			for (int k = 0; k < 3; k++)
			{
				for (int l = 0; l < 3; l++)
				{
					int num5 = num + k;
					int num6 = num2 + l;
					int num7 = Main.tile[num5, num6].frameX;
					int num8 = 0;
					while (num7 >= 5000)
					{
						num7 -= 5000;
						num8++;
					}
					if (num8 != 0)
					{
						num7 = (num8 - 1) * 18;
					}
					num7 %= 54;
					if (!Main.tile[num5, num6].active() || Main.tile[num5, num6].type != 334 || Main.tile[num5, num6].wall <= 0 || Main.tile[num5, num6].frameY != l * 18 || num7 != k * 18)
					{
						flag = true;
					}
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			Item.NewItem(i * 16, j * 16, 48, 48, 2699);
			for (int m = 0; m < 3; m++)
			{
				for (int n = 0; n < 3; n++)
				{
					int num9 = num + m;
					int num10 = num2 + n;
					if (Main.tile[num9, num10].active() && Main.tile[num9, num10].type == 334)
					{
						KillTile(num9, num10);
					}
				}
			}
			destroyObject = false;
		}

		public static void ToggleGemLock(int i, int j, bool on)
		{
			Tile tileSafely = Framing.GetTileSafely(i, j);
			if (!tileSafely.active() || tileSafely.type != 440 || (tileSafely.frameY < 54 && !on))
			{
				return;
			}
			bool flag = false;
			int num = -1;
			if (tileSafely.frameY >= 54)
			{
				flag = true;
			}
			int num2 = Main.tile[i, j].frameX / 54;
			int num3 = Main.tile[i, j].frameX % 54 / 18;
			int num4 = Main.tile[i, j].frameY % 54 / 18;
			switch (num2)
			{
			case 0:
				num = 1526;
				break;
			case 1:
				num = 1524;
				break;
			case 2:
				num = 1525;
				break;
			case 3:
				num = 1523;
				break;
			case 4:
				num = 1522;
				break;
			case 5:
				num = 1527;
				break;
			case 6:
				num = 3643;
				break;
			}
			for (int k = i - num3; k < i - num3 + 3; k++)
			{
				for (int l = j - num4; l < j - num4 + 3; l++)
				{
					Main.tile[k, l].frameY = (short)((on ? 54 : 0) + (l - j + num4) * 18);
				}
			}
			if (num != -1 && flag)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, num);
			}
			SquareTileFrame(i, j);
			NetMessage.SendTileSquare(-1, i - num3 + 1, j - num4 + 1, 3);
			Wiring.HitSwitch(i - num3, j - num4);
			NetMessage.SendData(59, -1, -1, null, i - num3, j - num4);
		}

		public static void CheckMan(int i, int j)
		{
			if (destroyObject)
			{
				return;
			}
			int num = i;
			int num2 = j - Main.tile[i, j].frameY / 18;
			int num3;
			for (num3 = Main.tile[i, j].frameX; num3 >= 100; num3 -= 100)
			{
			}
			while (num3 >= 36)
			{
				num3 -= 36;
			}
			num -= num3 / 18;
			bool flag = false;
			for (int k = 0; k <= 1; k++)
			{
				for (int l = 0; l <= 2; l++)
				{
					int num4 = num + k;
					int num5 = num2 + l;
					int num6;
					for (num6 = Main.tile[num4, num5].frameX; num6 >= 100; num6 -= 100)
					{
					}
					if (num6 >= 36)
					{
						num6 -= 36;
					}
					if (!Main.tile[num4, num5].active() || Main.tile[num4, num5].type != 128 || Main.tile[num4, num5].frameY != l * 18 || num6 != k * 18)
					{
						flag = true;
					}
				}
			}
			if (!SolidTileAllowBottomSlope(num, num2 + 3) || !SolidTileAllowBottomSlope(num + 1, num2 + 3))
			{
				flag = true;
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			Item.NewItem(i * 16, j * 16, 32, 32, 498);
			for (int m = 0; m <= 1; m++)
			{
				for (int n = 0; n <= 2; n++)
				{
					int num7 = num + m;
					int num8 = num2 + n;
					if (Main.tile[num7, num8].active() && Main.tile[num7, num8].type == 128)
					{
						KillTile(num7, num8);
					}
				}
			}
			destroyObject = false;
		}

		public static void CheckWoman(int i, int j)
		{
			if (destroyObject)
			{
				return;
			}
			int num = i;
			int num2 = j - Main.tile[i, j].frameY / 18;
			int num3;
			for (num3 = Main.tile[i, j].frameX; num3 >= 100; num3 -= 100)
			{
			}
			while (num3 >= 36)
			{
				num3 -= 36;
			}
			num -= num3 / 18;
			bool flag = false;
			for (int k = 0; k <= 1; k++)
			{
				for (int l = 0; l <= 2; l++)
				{
					int num4 = num + k;
					int num5 = num2 + l;
					int num6;
					for (num6 = Main.tile[num4, num5].frameX; num6 >= 100; num6 -= 100)
					{
					}
					if (num6 >= 36)
					{
						num6 -= 36;
					}
					if (!Main.tile[num4, num5].active() || Main.tile[num4, num5].type != 269 || Main.tile[num4, num5].frameY != l * 18 || num6 != k * 18)
					{
						flag = true;
					}
				}
			}
			if (!SolidTileAllowBottomSlope(num, num2 + 3) || !SolidTileAllowBottomSlope(num + 1, num2 + 3))
			{
				flag = true;
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			Item.NewItem(i * 16, j * 16, 32, 32, 1989);
			for (int m = 0; m <= 1; m++)
			{
				for (int n = 0; n <= 2; n++)
				{
					int num7 = num + m;
					int num8 = num2 + n;
					if (Main.tile[num7, num8].active() && Main.tile[num7, num8].type == 269)
					{
						KillTile(num7, num8);
					}
				}
			}
			destroyObject = false;
		}

		public static void Place1x2(int x, int y, ushort type, int style)
		{
			short frameX = 0;
			if (type == 20)
			{
				frameX = (short)(genRand.Next(3) * 18);
			}
			if (Main.tile[x, y - 1] == null)
			{
				Main.tile[x, y - 1] = new Tile();
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = new Tile();
			}
			if (SolidTile2(x, y + 1) & !Main.tile[x, y - 1].active())
			{
				short num = (short)(style * 40);
				Main.tile[x, y - 1].active(active: true);
				Main.tile[x, y - 1].frameY = num;
				Main.tile[x, y - 1].frameX = frameX;
				Main.tile[x, y - 1].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = (short)(num + 18);
				Main.tile[x, y].frameX = frameX;
				Main.tile[x, y].type = type;
			}
		}

		public static void Place1x2Top(int x, int y, ushort type, int style)
		{
			short frameX = 0;
			if (Main.tile[x, y - 1] == null)
			{
				Main.tile[x, y - 1] = new Tile();
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = new Tile();
			}
			if (Main.tile[x, y - 1].nactive() && Main.tileSolid[Main.tile[x, y - 1].type] && !Main.tileSolidTop[Main.tile[x, y - 1].type] && !Main.tile[x, y + 1].active())
			{
				short num = (short)(style * 36);
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = num;
				Main.tile[x, y].frameX = frameX;
				Main.tile[x, y].type = type;
				Main.tile[x, y + 1].active(active: true);
				Main.tile[x, y + 1].frameY = (short)(num + 18);
				Main.tile[x, y + 1].frameX = frameX;
				Main.tile[x, y + 1].type = type;
			}
		}

		public static void Check1x2Top(int x, int j, ushort type)
		{
			if (destroyObject)
			{
				return;
			}
			int num = j;
			bool flag = true;
			int num2 = Main.tile[x, num].frameY / 18;
			int num3 = 0;
			while (num2 >= 2)
			{
				num2 -= 2;
				num3++;
			}
			num -= num2;
			num2 = num3 * 36;
			if (Main.tile[x, num] == null)
			{
				Main.tile[x, num] = new Tile();
			}
			if (Main.tile[x, num + 1] == null)
			{
				Main.tile[x, num + 1] = new Tile();
			}
			if (Main.tile[x, num] == null)
			{
				Main.tile[x, num] = new Tile();
			}
			if (Main.tile[x, num].frameY == num2 && Main.tile[x, num + 1].frameY == num2 + 18 && Main.tile[x, num].type == type && Main.tile[x, num + 1].type == type)
			{
				flag = false;
			}
			if (Main.tile[x, num - 1] == null)
			{
				Main.tile[x, num - 1] = new Tile();
			}
			if (!Main.tile[x, num - 1].nactive() || !Main.tileSolid[Main.tile[x, num - 1].type] || Main.tileSolidTop[Main.tile[x, num - 1].type])
			{
				flag = true;
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			if (Main.tile[x, num].type == type)
			{
				KillTile(x, num);
			}
			if (Main.tile[x, num + 1].type == type)
			{
				KillTile(x, num + 1);
			}
			switch (type)
			{
			case 42:
			{
				int type2 = 0;
				if (num3 == 0)
				{
					type2 = 136;
				}
				else if (num3 == 7)
				{
					type2 = 1431;
				}
				else if (num3 == 8)
				{
					type2 = 1808;
				}
				else if (num3 == 9)
				{
					type2 = 1859;
				}
				else if (num3 < 10)
				{
					type2 = 1389 + num3;
				}
				else
				{
					switch (num3)
					{
					case 10:
						type2 = 2032;
						break;
					case 11:
						type2 = 2033;
						break;
					case 12:
						type2 = 2034;
						break;
					case 13:
						type2 = 2035;
						break;
					case 14:
						type2 = 2036;
						break;
					case 15:
						type2 = 2037;
						break;
					case 16:
						type2 = 2038;
						break;
					case 17:
						type2 = 2039;
						break;
					case 18:
						type2 = 2040;
						break;
					case 19:
						type2 = 2041;
						break;
					case 20:
						type2 = 2042;
						break;
					case 21:
						type2 = 2043;
						break;
					case 22:
					case 23:
					case 24:
					case 25:
						type2 = 2145 + num3 - 22;
						break;
					default:
						switch (num3)
						{
						case 26:
							type2 = 2226;
							break;
						case 27:
							type2 = 2530;
							break;
						case 28:
							type2 = 2546;
							break;
						case 29:
							type2 = 2564;
							break;
						case 30:
							type2 = 2579;
							break;
						case 31:
							type2 = 2641;
							break;
						case 32:
							type2 = 2642;
							break;
						case 33:
							type2 = 2820;
							break;
						case 34:
							type2 = 3138;
							break;
						case 35:
							type2 = 3140;
							break;
						case 36:
							type2 = 3139;
							break;
						case 37:
							type2 = 3891;
							break;
						case 38:
							type2 = 3943;
							break;
						case 39:
							type2 = 3970;
							break;
						case 40:
							type2 = 4157;
							break;
						case 41:
							type2 = 4178;
							break;
						case 42:
							type2 = 4199;
							break;
						case 43:
							type2 = 4220;
							break;
						case 44:
							type2 = 4309;
							break;
						case 45:
							type2 = 4578;
							break;
						}
						break;
					}
				}
				Item.NewItem(x * 16, num * 16, 32, 32, type2);
				break;
			}
			case 270:
				Item.NewItem(x * 16, num * 16, 32, 32, 1993);
				break;
			case 271:
				Item.NewItem(x * 16, num * 16, 32, 32, 2005);
				break;
			case 581:
				Item.NewItem(x * 16, num * 16, 32, 32, 4848);
				break;
			case 572:
				Item.NewItem(x * 16, num * 16, 32, 32, 4695 + num3);
				break;
			}
			destroyObject = false;
		}

		public static bool PlaceSmallPile(int i, int j, int X, int Y, ushort type = 185)
		{
			short frameY = (short)(Y * 18);
			short frameX = (short)(X * 18);
			if (Main.tile[i, j] == null)
			{
				Main.tile[i, j] = new Tile();
			}
			if (Main.tile[i + 1, j] == null)
			{
				Main.tile[i + 1, j] = new Tile();
			}
			if (Main.tile[i, j + 1] == null)
			{
				Main.tile[i, j + 1] = new Tile();
			}
			if (Main.tile[i + 1, j + 1] == null)
			{
				Main.tile[i + 1, j + 1] = new Tile();
			}
			if (Main.tile[i, j].lava())
			{
				return false;
			}
			if (Y == 1)
			{
				frameX = (short)(X * 36);
				bool flag = false;
				if (SolidTile2(i, j + 1) && SolidTile2(i + 1, j + 1) && !Main.tile[i, j].active() && !Main.tile[i + 1, j].active())
				{
					flag = true;
				}
				if (flag)
				{
					Main.tile[i, j].active(active: true);
					Main.tile[i, j].frameY = frameY;
					Main.tile[i, j].frameX = frameX;
					Main.tile[i, j].type = type;
					Main.tile[i + 1, j].active(active: true);
					Main.tile[i + 1, j].frameY = frameY;
					Main.tile[i + 1, j].frameX = (short)(frameX + 18);
					Main.tile[i + 1, j].type = type;
					return true;
				}
			}
			else if (SolidTile2(i, j + 1) && !Main.tile[i, j].active())
			{
				Main.tile[i, j].active(active: true);
				Main.tile[i, j].frameY = frameY;
				Main.tile[i, j].frameX = frameX;
				Main.tile[i, j].type = type;
				return true;
			}
			return false;
		}

		public static void CheckPile(int i, int y)
		{
			if (Main.tile[i, y] == null)
			{
				Main.tile[i, y] = new Tile();
			}
			if (Main.tile[i + 1, y] == null)
			{
				Main.tile[i + 1, y] = new Tile();
			}
			if (Main.tile[i, y + 1] == null)
			{
				Main.tile[i, y + 1] = new Tile();
			}
			if (Main.tile[i + 1, y + 1] == null)
			{
				Main.tile[i + 1, y + 1] = new Tile();
			}
			if (Main.tile[i, y].frameY == 18)
			{
				Check2x1(i, y, Main.tile[i, y].type);
			}
			else if (!SolidTile(i, y + 1))
			{
				KillTile(i, y);
			}
		}

		public static void Check2x1(int i, int y, ushort type)
		{
			if (destroyObject)
			{
				return;
			}
			int num = i;
			bool flag = true;
			if (Main.tile[num, y] == null)
			{
				Main.tile[num, y] = new Tile();
			}
			int num2 = Main.tile[num, y].frameX / 18;
			int num3 = num2 >> 1;
			num2 %= 2;
			num -= num2;
			if (Main.tile[num, y] == null)
			{
				Main.tile[num, y] = new Tile();
			}
			if (Main.tile[num + 1, y] == null)
			{
				Main.tile[num + 1, y] = new Tile();
			}
			if (Main.tile[num, y + 1] == null)
			{
				Main.tile[num, y + 1] = new Tile();
			}
			if (Main.tile[num + 1, y + 1] == null)
			{
				Main.tile[num + 1, y + 1] = new Tile();
			}
			if (Main.tile[num + 1, y].frameX == Main.tile[num, y].frameX + 18 && Main.tile[num, y].type == type && Main.tile[num + 1, y].type == type)
			{
				flag = false;
			}
			if (type == 29 || type == 103 || type == 462)
			{
				if (!Main.tile[num, y + 1].active() || !Main.tileTable[Main.tile[num, y + 1].type] || Main.tile[num, y + 1].halfBrick() || Main.tile[num, y + 1].topSlope())
				{
					flag = true;
				}
				if (!Main.tile[num + 1, y + 1].active() || !Main.tileTable[Main.tile[num + 1, y + 1].type] || Main.tile[num + 1, y + 1].halfBrick() || Main.tile[num + 1, y + 1].topSlope())
				{
					flag = true;
				}
			}
			else
			{
				if (!SolidTileAllowBottomSlope(num, y + 1))
				{
					flag = true;
				}
				if (!SolidTileAllowBottomSlope(num + 1, y + 1))
				{
					flag = true;
				}
			}
			if (type == 185 && Main.tile[num, y].frameX >= 1368 && Main.tile[num, y].frameX <= 1458 && Main.tile[num, y + 1].type != 2 && Main.tile[num + 1, y + 1].type != 2 && Main.tile[num, y + 1].type != 477 && Main.tile[num + 1, y + 1].type != 477 && Main.tile[num, y + 1].type != 492 && Main.tile[num + 1, y + 1].type != 492)
			{
				Main.tile[num, y].frameX -= 1368;
				Main.tile[num + 1, y].frameX -= 1368;
			}
			if (!flag)
			{
				return;
			}
			int frameX = Main.tile[num, y].frameX;
			if (!Main.tile[num, y].active())
			{
				frameX = Main.tile[num + 1, y].frameX;
			}
			destroyObject = true;
			if (Main.tile[num, y].type == type)
			{
				KillTile(num, y);
			}
			if (Main.tile[num + 1, y].type == type)
			{
				KillTile(num + 1, y);
			}
			if (type == 16)
			{
				if (num3 == 1)
				{
					Item.NewItem(num * 16, y * 16, 32, 32, 716);
				}
				else
				{
					Item.NewItem(num * 16, y * 16, 32, 32, 35);
				}
			}
			if (type == 18)
			{
				int type2 = 36;
				if (num3 >= 1 && num3 <= 3)
				{
					type2 = 634 + num3;
				}
				else if (num3 >= 4 && num3 <= 8)
				{
					type2 = 807 + num3;
				}
				else
				{
					switch (num3)
					{
					case 9:
						type2 = 916;
						break;
					case 10:
						type2 = 1145;
						break;
					case 11:
						type2 = 1398;
						break;
					case 12:
						type2 = 1401;
						break;
					case 13:
						type2 = 1404;
						break;
					case 14:
						type2 = 1461;
						break;
					case 15:
						type2 = 1511;
						break;
					case 16:
						type2 = 1795;
						break;
					case 17:
						type2 = 1817;
						break;
					case 18:
						type2 = 2229;
						break;
					case 19:
						type2 = 2251;
						break;
					case 20:
						type2 = 2252;
						break;
					case 21:
						type2 = 2253;
						break;
					case 22:
						type2 = 2534;
						break;
					case 23:
						type2 = 673;
						break;
					case 24:
						type2 = 2631;
						break;
					case 25:
						type2 = 2632;
						break;
					case 26:
						type2 = 2633;
						break;
					case 27:
						type2 = 2826;
						break;
					case 28:
						type2 = 3156;
						break;
					case 29:
						type2 = 3158;
						break;
					case 30:
						type2 = 3157;
						break;
					case 31:
						type2 = 3909;
						break;
					case 32:
						type2 = 3910;
						break;
					case 33:
						type2 = 3949;
						break;
					case 34:
						type2 = 3975;
						break;
					case 35:
						type2 = 4163;
						break;
					case 36:
						type2 = 4184;
						break;
					case 37:
						type2 = 4205;
						break;
					case 38:
						type2 = 4226;
						break;
					case 39:
						type2 = 4315;
						break;
					case 40:
						type2 = 4584;
						break;
					}
				}
				Item.NewItem(num * 16, y * 16, 32, 32, type2);
			}
			if (type == 185)
			{
				if (frameX >= 576 && frameX <= 610)
				{
					Item.NewItem(num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));
					Item.NewItem(num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
					if (genRand.Next(3) != 0)
					{
						Item.NewItem(num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));
					}
					if (genRand.Next(3) != 0)
					{
						Item.NewItem(num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
					}
					if (genRand.Next(2) == 0)
					{
						Item.NewItem(num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));
					}
					if (genRand.Next(2) == 0)
					{
						Item.NewItem(num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
					}
					if (genRand.Next(3) == 0)
					{
						Item.NewItem(num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));
					}
					if (genRand.Next(3) == 0)
					{
						Item.NewItem(num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
					}
					if (genRand.Next(4) == 0)
					{
						Item.NewItem(num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));
					}
					if (genRand.Next(4) == 0)
					{
						Item.NewItem(num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
					}
					if (genRand.Next(5) == 0)
					{
						Item.NewItem(num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));
					}
					if (genRand.Next(5) == 0)
					{
						Item.NewItem(num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
					}
				}
				if (frameX >= 612 && frameX <= 646)
				{
					Item.NewItem(num * 16, y * 16, 32, 32, 72, genRand.Next(10, 100));
					if (genRand.Next(2) == 0)
					{
						Item.NewItem(num * 16, y * 16, 32, 32, 72, genRand.Next(20, 100));
					}
					if (genRand.Next(3) == 0)
					{
						Item.NewItem(num * 16, y * 16, 32, 32, 72, genRand.Next(30, 100));
					}
				}
				if (frameX >= 648 && frameX <= 682)
				{
					Item.NewItem(num * 16, y * 16, 32, 32, 73, genRand.Next(1, 6));
					if (genRand.Next(2) == 0)
					{
						Item.NewItem(num * 16, y * 16, 32, 32, 73, genRand.Next(2, 6));
					}
					if (genRand.Next(3) == 0)
					{
						Item.NewItem(num * 16, y * 16, 32, 32, 73, genRand.Next(3, 6));
					}
				}
				if (frameX >= 684 && frameX <= 718)
				{
					Item.NewItem(num * 16, y * 16, 32, 32, 181, genRand.Next(1, 4));
				}
				if (frameX >= 720 && frameX <= 754)
				{
					Item.NewItem(num * 16, y * 16, 32, 32, 180, genRand.Next(1, 4));
				}
				if (frameX >= 756 && frameX <= 790)
				{
					Item.NewItem(num * 16, y * 16, 32, 32, 177, genRand.Next(1, 4));
				}
				if (frameX >= 792 && frameX <= 826)
				{
					Item.NewItem(num * 16, y * 16, 32, 32, 179, genRand.Next(1, 4));
				}
				if (frameX >= 828 && frameX <= 862)
				{
					Item.NewItem(num * 16, y * 16, 32, 32, 178, genRand.Next(1, 4));
				}
				if (frameX >= 864 && frameX <= 898)
				{
					Item.NewItem(num * 16, y * 16, 32, 32, 182, genRand.Next(1, 4));
				}
			}
			if (type == 462)
			{
				Item.NewItem(num * 16, y * 16, 32, 32, 3795);
			}
			if (type == 29)
			{
				Item.NewItem(num * 16, y * 16, 32, 32, 87);
				SoundEngine.PlaySound(13, i * 16, y * 16);
			}
			switch (type)
			{
			case 103:
			{
				int type3 = 356;
				if (num3 == 1)
				{
					type3 = 2235;
				}
				if (num3 == 2)
				{
					type3 = 2242;
				}
				if (num3 == 3)
				{
					type3 = 2243;
				}
				Item.NewItem(num * 16, y * 16, 32, 32, type3);
				SoundEngine.PlaySound(13, i * 16, y * 16);
				break;
			}
			case 134:
				if (num3 == 1)
				{
					Item.NewItem(num * 16, y * 16, 32, 32, 1220);
				}
				else
				{
					Item.NewItem(num * 16, y * 16, 32, 32, 525);
				}
				break;
			}
			destroyObject = false;
			SquareTileFrame(num, y);
			SquareTileFrame(num + 1, y);
		}

		public static void Place2x1(int x, int y, ushort type, int style = 0)
		{
			if (Main.tile[x, y] == null)
			{
				Main.tile[x, y] = new Tile();
			}
			if (Main.tile[x + 1, y] == null)
			{
				Main.tile[x + 1, y] = new Tile();
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = new Tile();
			}
			if (Main.tile[x + 1, y + 1] == null)
			{
				Main.tile[x + 1, y + 1] = new Tile();
			}
			bool flag = false;
			if (type != 29 && type != 103 && SolidTile2(x, y + 1) && SolidTile2(x + 1, y + 1) && !Main.tile[x, y].active() && !Main.tile[x + 1, y].active())
			{
				flag = true;
			}
			else if ((type == 29 || type == 103) && Main.tile[x, y + 1].active() && Main.tile[x + 1, y + 1].active() && Main.tileTable[Main.tile[x, y + 1].type] && Main.tileTable[Main.tile[x + 1, y + 1].type] && !Main.tile[x, y].active() && !Main.tile[x + 1, y].active())
			{
				flag = true;
			}
			if (flag)
			{
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = 0;
				Main.tile[x, y].frameX = (short)(36 * style);
				Main.tile[x, y].type = type;
				Main.tile[x + 1, y].active(active: true);
				Main.tile[x + 1, y].frameY = 0;
				Main.tile[x + 1, y].frameX = (short)(36 * style + 18);
				Main.tile[x + 1, y].type = type;
			}
		}

		public static void Check4x2(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = i;
			num = ((type != 487) ? (num + Main.tile[i, j].frameX / 18 * -1) : (num + Main.tile[i, j].frameX / 18 % 4 * -1));
			if ((type == 79 || type == 90) && Main.tile[i, j].frameX >= 72)
			{
				num += 4;
			}
			int num2 = Main.tile[i, j].frameY / 18;
			int num3 = 0;
			while (num2 > 1)
			{
				num2 -= 2;
				num3++;
			}
			num2 = j - num2;
			if (type == 487)
			{
				num3 = Main.tile[i, j].frameX / 72;
			}
			for (int k = num; k < num + 4; k++)
			{
				for (int l = num2; l < num2 + 2; l++)
				{
					int num4 = (k - num) * 18;
					int num5 = (l - num2) * 18;
					if ((type == 79 || type == 90) && Main.tile[i, j].frameX >= 72)
					{
						num4 = (k - num + 4) * 18;
					}
					if (type == 487)
					{
						num4 += num3 * 72;
					}
					else
					{
						num5 += num3 * 36;
					}
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != num4 || Main.tile[k, l].frameY != num5)
					{
						flag = true;
					}
				}
				if (Main.tile[k, num2 + 2] == null)
				{
					Main.tile[k, num2 + 2] = new Tile();
				}
				if (!SolidTileAllowBottomSlope(k, num2 + 2) && (!Main.tile[k, num2 + 2].active() || !TileID.Sets.Platforms[Main.tile[k, num2 + 2].type]))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int m = num; m < num + 4; m++)
			{
				for (int n = num2; n < num2 + 3; n++)
				{
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
					{
						KillTile(m, n);
					}
				}
			}
			if (type == 79)
			{
				int num6 = 0;
				switch (num3)
				{
				case 0:
					num6 = 224;
					break;
				case 4:
					num6 = 920;
					break;
				case 9:
				case 10:
				case 11:
				case 12:
					num6 = 1710 + num3;
					break;
				default:
					num6 = ((num3 >= 5 && num3 <= 8) ? (1465 + num3) : ((num3 >= 13 && num3 <= 18) ? (2066 + num3 - 13) : (num3 switch
					{
						19 => 2139, 
						20 => 2140, 
						21 => 2231, 
						22 => 2520, 
						23 => 2538, 
						24 => 2553, 
						25 => 2568, 
						26 => 2669, 
						27 => 2811, 
						28 => 3162, 
						29 => 3164, 
						30 => 3163, 
						31 => 3897, 
						32 => 3932, 
						33 => 3959, 
						34 => 4146, 
						35 => 4167, 
						36 => 4188, 
						37 => 4209, 
						38 => 4299, 
						39 => 4567, 
						_ => num3 + 643, 
					})));
					break;
				}
				Item.NewItem(i * 16, j * 16, 32, 32, num6);
			}
			if (type == 487)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, GetItemDrop_PicnicTables(num3));
			}
			if (type == 90)
			{
				int type2 = 0;
				switch (num3)
				{
				case 0:
					type2 = 336;
					break;
				case 1:
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7:
				case 8:
				case 9:
				case 10:
					type2 = 2072 + num3 - 1;
					break;
				default:
					if (num3 >= 11 && num3 <= 15)
					{
						type2 = 2124 + num3 - 11;
						break;
					}
					switch (num3)
					{
					case 16:
						type2 = 2232;
						break;
					case 17:
						type2 = 2519;
						break;
					case 18:
						type2 = 2537;
						break;
					case 19:
						type2 = 2552;
						break;
					case 20:
						type2 = 2567;
						break;
					case 21:
						type2 = 2658;
						break;
					case 22:
						type2 = 2659;
						break;
					case 23:
						type2 = 2660;
						break;
					case 24:
						type2 = 2661;
						break;
					case 25:
						type2 = 2662;
						break;
					case 26:
						type2 = 2663;
						break;
					case 27:
						type2 = 2810;
						break;
					case 28:
						type2 = 3159;
						break;
					case 29:
						type2 = 3161;
						break;
					case 30:
						type2 = 3160;
						break;
					case 31:
						type2 = 3895;
						break;
					case 32:
						type2 = 3931;
						break;
					case 33:
						type2 = 3958;
						break;
					case 34:
						type2 = 4145;
						break;
					case 35:
						type2 = 4166;
						break;
					case 36:
						type2 = 4187;
						break;
					case 37:
						type2 = 4208;
						break;
					case 38:
						type2 = 4298;
						break;
					case 39:
						type2 = 4566;
						break;
					}
					break;
				}
				Item.NewItem(i * 16, j * 16, 32, 32, type2);
			}
			destroyObject = false;
			for (int num7 = num - 1; num7 < num + 4; num7++)
			{
				for (int num8 = num2 - 1; num8 < num2 + 4; num8++)
				{
					TileFrame(num7, num8);
				}
			}
		}

		private static bool OasisPlantWaterCheck(int x, int y, bool boost = false)
		{
			int num = 45;
			int num2 = 20;
			if (boost)
			{
				num += 4;
				num2 += 3;
			}
			int num3 = 20;
			int num4 = 0;
			for (int i = x - num; i <= x + num; i++)
			{
				if (x <= beachDistance || x >= Main.maxTilesX - beachDistance)
				{
					continue;
				}
				for (int j = y - num2; j <= y + num2; j++)
				{
					if (InWorld(i, j) && !SolidTile(i, j))
					{
						num4 += Main.tile[i, j].liquid;
					}
				}
			}
			if (num4 / 255 >= num3)
			{
				return true;
			}
			return false;
		}

		public static void PlaceOasisPlant(int X, int Y, ushort type = 530)
		{
			int num = genRand.Next(9);
			int num2 = 0;
			if (X < beachDistance || X > Main.maxTilesX - beachDistance || Y < 5 || Y > Main.maxTilesY - 5)
			{
				return;
			}
			bool flag = true;
			for (int i = X - 1; i < X + 2; i++)
			{
				for (int j = Y - 1; j < Y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active() && Main.tile[i, j].type != 529)
					{
						flag = false;
					}
					if (Main.tile[i, j].liquid > 0)
					{
						flag = false;
					}
				}
				if (Main.tile[i, Y + 1] == null)
				{
					Main.tile[i, Y + 1] = new Tile();
				}
				if (!SolidTile(i, Y + 1) || !TileID.Sets.Conversion.Sand[Main.tile[i, Y + 1].type])
				{
					flag = false;
				}
			}
			if (flag && OasisPlantWaterCheck(X, Y))
			{
				short num3 = (short)(54 * num);
				short num4 = (short)(36 * num2);
				Main.tile[X - 1, Y - 1].active(active: true);
				Main.tile[X - 1, Y - 1].frameY = num4;
				Main.tile[X - 1, Y - 1].frameX = num3;
				Main.tile[X - 1, Y - 1].type = type;
				Main.tile[X, Y - 1].active(active: true);
				Main.tile[X, Y - 1].frameY = num4;
				Main.tile[X, Y - 1].frameX = (short)(num3 + 18);
				Main.tile[X, Y - 1].type = type;
				Main.tile[X + 1, Y - 1].active(active: true);
				Main.tile[X + 1, Y - 1].frameY = num4;
				Main.tile[X + 1, Y - 1].frameX = (short)(num3 + 36);
				Main.tile[X + 1, Y - 1].type = type;
				Main.tile[X - 1, Y].active(active: true);
				Main.tile[X - 1, Y].frameY = (short)(num4 + 18);
				Main.tile[X - 1, Y].frameX = num3;
				Main.tile[X - 1, Y].type = type;
				Main.tile[X, Y].active(active: true);
				Main.tile[X, Y].frameY = (short)(num4 + 18);
				Main.tile[X, Y].frameX = (short)(num3 + 18);
				Main.tile[X, Y].type = type;
				Main.tile[X + 1, Y].active(active: true);
				Main.tile[X + 1, Y].frameY = (short)(num4 + 18);
				Main.tile[X + 1, Y].frameX = (short)(num3 + 36);
				Main.tile[X + 1, Y].type = type;
			}
		}

		public static void CheckOasisPlant(int i, int j, int type = 530)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = j;
			Tile tileSafely = Framing.GetTileSafely(i, j);
			int num2 = tileSafely.frameY % 36;
			num += num2 / 18 * -1;
			int num3 = tileSafely.frameX / 18;
			int num4 = 0;
			_ = Framing.GetTileSafely(num3, num).frameY / 36;
			while (num3 > 2)
			{
				num3 -= 3;
				num4++;
			}
			num3 = i - num3;
			int num5 = num4 * 54;
			for (int k = num3; k < num3 + 3; k++)
			{
				for (int l = num; l < num + 2; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num3) * 18 + num5 || Main.tile[k, l].frameY != (l - num) * 18)
					{
						flag = true;
					}
				}
				if (Main.tile[k, num + 2] == null)
				{
					Main.tile[k, num + 2] = new Tile();
				}
				if (!SolidTile(k, num + 2) || !TileID.Sets.Conversion.Sand[Main.tile[k, num + 2].type])
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			_ = Main.tile[i, j].frameX;
			destroyObject = true;
			for (int m = num3; m < num3 + 3; m++)
			{
				for (int n = num; n < num + 2; n++)
				{
					if (Main.tile[m, n] == null)
					{
						Main.tile[m, n] = new Tile();
					}
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
					{
						KillTile(m, n);
					}
				}
			}
			destroyObject = false;
			for (int num6 = num3 - 1; num6 < num3 + 4; num6++)
			{
				for (int num7 = num - 1; num7 < num + 3; num7++)
				{
					TileFrame(num6, num7);
				}
			}
		}

		public static void GetBiomeInfluence(int startX, int endX, int startY, int endY, out int corruptCount, out int crimsonCount, out int hallowedCount)
		{
			corruptCount = 0;
			crimsonCount = 0;
			hallowedCount = 0;
			for (int i = startX; i <= endX; i++)
			{
				for (int j = startY; j <= endY; j++)
				{
					Tile tile = Main.tile[i, j];
					if (tile != null)
					{
						if (TileID.Sets.Corrupt[tile.type])
						{
							corruptCount++;
						}
						if (TileID.Sets.Crimson[tile.type])
						{
							crimsonCount++;
						}
						if (TileID.Sets.Hallow[tile.type])
						{
							hallowedCount++;
						}
					}
				}
			}
		}

		public static void PlaceJunglePlant(int X2, int Y2, ushort type, int styleX, int styleY)
		{
			if (styleY > 0 || type == 236 || type == 238)
			{
				int num = Y2;
				if (type == 95 || type == 126)
				{
					num++;
				}
				if (X2 < 5 || X2 > Main.maxTilesX - 5 || num < 5 || num > Main.maxTilesY - 5)
				{
					return;
				}
				bool flag = true;
				for (int i = X2 - 1; i < X2 + 1; i++)
				{
					for (int j = num - 1; j < num + 1; j++)
					{
						if (Main.tile[i, j] == null)
						{
							Main.tile[i, j] = new Tile();
						}
						if (Main.tile[i, j].active() && Main.tile[i, j].type != 61 && Main.tile[i, j].type != 62 && Main.tile[i, j].type != 69 && Main.tile[i, j].type != 74 && (type != 236 || Main.tile[i, j].type != 233) && (type != 238 || Main.tile[i, j].type != 233) && (Main.tile[i, j].type != 185 || Main.tile[i, j].frameY != 0))
						{
							flag = false;
						}
						if (type == 98 && Main.tile[i, j].liquid > 0)
						{
							flag = false;
						}
					}
					if (Main.tile[i, num + 1] == null)
					{
						Main.tile[i, num + 1] = new Tile();
					}
					if (!SolidTile(i, num + 1) || Main.tile[i, num + 1].type != 60)
					{
						flag = false;
					}
				}
				if (flag)
				{
					short num2 = 36;
					if (type == 236 || type == 238)
					{
						num2 = 0;
					}
					short num3 = (short)(36 * styleX);
					Main.tile[X2 - 1, num - 1].active(active: true);
					Main.tile[X2 - 1, num - 1].frameY = num2;
					Main.tile[X2 - 1, num - 1].frameX = num3;
					Main.tile[X2 - 1, num - 1].type = type;
					Main.tile[X2, num - 1].active(active: true);
					Main.tile[X2, num - 1].frameY = num2;
					Main.tile[X2, num - 1].frameX = (short)(18 + num3);
					Main.tile[X2, num - 1].type = type;
					Main.tile[X2 - 1, num].active(active: true);
					Main.tile[X2 - 1, num].frameY = (short)(num2 + 18);
					Main.tile[X2 - 1, num].frameX = num3;
					Main.tile[X2 - 1, num].type = type;
					Main.tile[X2, num].active(active: true);
					Main.tile[X2, num].frameY = (short)(num2 + 18);
					Main.tile[X2, num].frameX = (short)(18 + num3);
					Main.tile[X2, num].type = type;
				}
			}
			else
			{
				if (X2 < 5 || X2 > Main.maxTilesX - 5 || Y2 < 5 || Y2 > Main.maxTilesY - 5)
				{
					return;
				}
				bool flag2 = true;
				for (int k = X2 - 1; k < X2 + 2; k++)
				{
					for (int l = Y2 - 1; l < Y2 + 1; l++)
					{
						if (Main.tile[k, l] == null)
						{
							Main.tile[k, l] = new Tile();
						}
						if (Main.tile[k, l].active() && Main.tile[k, l].type != 61 && Main.tile[k, l].type != 62 && Main.tile[k, l].type != 69 && Main.tile[k, l].type != 74 && (Main.tile[k, l].type != 185 || Main.tile[k, l].frameY != 0))
						{
							flag2 = false;
						}
					}
					if (Main.tile[k, Y2 + 1] == null)
					{
						Main.tile[k, Y2 + 1] = new Tile();
					}
					if (!SolidTile(k, Y2 + 1) || Main.tile[k, Y2 + 1].type != 60)
					{
						flag2 = false;
					}
				}
				if (flag2)
				{
					short num4 = (short)(54 * styleX);
					Main.tile[X2 - 1, Y2 - 1].active(active: true);
					Main.tile[X2 - 1, Y2 - 1].frameY = 0;
					Main.tile[X2 - 1, Y2 - 1].frameX = num4;
					Main.tile[X2 - 1, Y2 - 1].type = type;
					Main.tile[X2, Y2 - 1].active(active: true);
					Main.tile[X2, Y2 - 1].frameY = 0;
					Main.tile[X2, Y2 - 1].frameX = (short)(num4 + 18);
					Main.tile[X2, Y2 - 1].type = type;
					Main.tile[X2 + 1, Y2 - 1].active(active: true);
					Main.tile[X2 + 1, Y2 - 1].frameY = 0;
					Main.tile[X2 + 1, Y2 - 1].frameX = (short)(num4 + 36);
					Main.tile[X2 + 1, Y2 - 1].type = type;
					Main.tile[X2 - 1, Y2].active(active: true);
					Main.tile[X2 - 1, Y2].frameY = 18;
					Main.tile[X2 - 1, Y2].frameX = num4;
					Main.tile[X2 - 1, Y2].type = type;
					Main.tile[X2, Y2].active(active: true);
					Main.tile[X2, Y2].frameY = 18;
					Main.tile[X2, Y2].frameX = (short)(num4 + 18);
					Main.tile[X2, Y2].type = type;
					Main.tile[X2 + 1, Y2].active(active: true);
					Main.tile[X2 + 1, Y2].frameY = 18;
					Main.tile[X2 + 1, Y2].frameX = (short)(num4 + 36);
					Main.tile[X2 + 1, Y2].type = type;
				}
			}
		}

		public static void CheckJunglePlant(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			if (Main.tile[i, j].frameY >= 36 || Main.tile[i, j].type == 236 || Main.tile[i, j].type == 238)
			{
				bool flag = false;
				int num = Main.tile[i, j].frameX / 18;
				int num2 = 0;
				while (num > 1)
				{
					num -= 2;
					num2++;
				}
				num = i - num;
				int num3 = 36;
				if (type == 236 || type == 238)
				{
					num3 = 0;
				}
				int num4;
				for (num4 = Main.tile[i, j].frameY / 18; num4 > 1; num4 -= 2)
				{
				}
				num4 = j - num4;
				int num5 = num2 * 36;
				for (int k = num; k < num + 2; k++)
				{
					for (int l = num4; l < num4 + 2; l++)
					{
						if (Main.tile[k, l] == null)
						{
							Main.tile[k, l] = new Tile();
						}
						if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num) * 18 + num5 || Main.tile[k, l].frameY != (l - num4) * 18 + num3)
						{
							flag = true;
						}
					}
					if (Main.tile[k, num4 + 2] == null)
					{
						Main.tile[k, num4 + 2] = new Tile();
					}
					if (!SolidTile(k, num4 + 2) || Main.tile[k, num4 + 2].type != 60)
					{
						flag = true;
					}
				}
				if (!flag)
				{
					return;
				}
				if (type == 238)
				{
					float num6 = i * 16;
					float num7 = j * 16;
					float num8 = -1f;
					int plr = 0;
					for (int m = 0; m < 255; m++)
					{
						float num9 = Math.Abs(Main.player[m].position.X - num6) + Math.Abs(Main.player[m].position.Y - num7);
						if (num9 < num8 || num8 == -1f)
						{
							plr = m;
							num8 = num9;
						}
					}
					if (num8 / 16f < 50f)
					{
						NPC.SpawnOnPlayer(plr, 262);
					}
				}
				if (type == 236)
				{
					Item.NewItem(i * 16, j * 16, 32, 32, 1291);
				}
				_ = Main.tile[i, j].frameX;
				destroyObject = true;
				for (int n = num; n < num + 2; n++)
				{
					for (int num10 = num4; num10 < num4 + 2; num10++)
					{
						if (Main.tile[n, num10] == null)
						{
							Main.tile[n, num10] = new Tile();
						}
						if (Main.tile[n, num10].type == type && Main.tile[n, num10].active())
						{
							KillTile(n, num10);
						}
					}
				}
				destroyObject = false;
				return;
			}
			bool flag2 = false;
			int num11 = j;
			num11 += Main.tile[i, j].frameY / 18 * -1;
			int num12 = Main.tile[i, j].frameX / 18;
			int num13 = 0;
			while (num12 > 2)
			{
				num12 -= 3;
				num13++;
			}
			num12 = i - num12;
			int num14 = num13 * 54;
			for (int num15 = num12; num15 < num12 + 3; num15++)
			{
				for (int num16 = num11; num16 < num11 + 2; num16++)
				{
					if (Main.tile[num15, num16] == null)
					{
						Main.tile[num15, num16] = new Tile();
					}
					if (!Main.tile[num15, num16].active() || Main.tile[num15, num16].type != type || Main.tile[num15, num16].frameX != (num15 - num12) * 18 + num14 || Main.tile[num15, num16].frameY != (num16 - num11) * 18)
					{
						flag2 = true;
					}
				}
				if (Main.tile[num15, num11 + 2] == null)
				{
					Main.tile[num15, num11 + 2] = new Tile();
				}
				if (!SolidTile(num15, num11 + 2) || Main.tile[num15, num11 + 2].type != 60)
				{
					flag2 = true;
				}
			}
			if (!flag2)
			{
				return;
			}
			_ = Main.tile[i, j].frameX;
			destroyObject = true;
			for (int num17 = num12; num17 < num12 + 3; num17++)
			{
				for (int num18 = num11; num18 < num11 + 3; num18++)
				{
					if (Main.tile[num17, num18] == null)
					{
						Main.tile[num17, num18] = new Tile();
					}
					if (Main.tile[num17, num18].type == type && Main.tile[num17, num18].active())
					{
						KillTile(num17, num18);
					}
				}
			}
			destroyObject = false;
		}

		public static void CheckSuper(int x, int y, int type)
		{
			if (destroyObject)
			{
				return;
			}
			Tile tile = Main.tile[x, y];
			int num = 0;
			if (type == 376)
			{
				num = tile.frameX / 36;
			}
			if (type == 443)
			{
				num = tile.frameX / 36;
			}
			if (type == 485)
			{
				num = tile.frameX / 36;
			}
			bool flag = type == 376;
			bool flag2 = type == 443;
			bool flag3 = type == 444;
			bool flag4 = type == 485;
			TileObjectData tileData = TileObjectData.GetTileData(type, num);
			bool styleHorizontal = tileData.StyleHorizontal;
			int width = tileData.Width;
			int height = tileData.Height;
			int num2 = x;
			int num3 = y;
			num2 -= tile.frameX / 18 % width;
			num3 -= tile.frameY / 18 % height;
			int num4 = 0;
			int num5 = 0;
			if (styleHorizontal)
			{
				num4 = tile.frameX / tileData.CoordinateFullWidth;
			}
			else
			{
				num5 = tile.frameY / tileData.CoordinateFullHeight;
			}
			bool flag5 = false;
			bool flag6 = false;
			for (int i = 0; i < width; i++)
			{
				for (int j = 0; j < height; j++)
				{
					Tile tileSafely = Framing.GetTileSafely(num2 + i, num3 + j);
					if (!tileSafely.active() || tileSafely.type != type || tileSafely.frameX != num4 * tileData.CoordinateFullWidth + i * (tileData.CoordinateWidth + 2) || tileSafely.frameY != num5 * tileData.CoordinateFullHeight + j * (tileData.CoordinateHeights[0] + 2))
					{
						flag5 = true;
					}
				}
			}
			if (flag)
			{
				for (int k = 0; k < width; k++)
				{
					Tile tileSafely = Framing.GetTileSafely(num2 + k, num3 + height);
					if (!tileSafely.active() || (!Main.tileSolid[tileSafely.type] && !Main.tileTable[tileSafely.type]))
					{
						flag5 = true;
					}
					if (tileSafely.halfBrick())
					{
						flag5 = true;
					}
				}
			}
			if (flag2)
			{
				bool flag7 = true;
				bool flag8 = true;
				for (int l = 0; l < width; l++)
				{
					if (!AnchorValid(Framing.GetTileSafely(num2 + l, num3 + height), AnchorType.SolidTile | AnchorType.SolidWithTop | AnchorType.SolidSide))
					{
						flag8 = false;
					}
					if (!AnchorValid(Framing.GetTileSafely(num2 + l, num3 - 1), AnchorType.SolidBottom))
					{
						flag7 = false;
					}
				}
				if (!flag7 && !flag8)
				{
					flag5 = true;
				}
				if (!flag5)
				{
					int num6 = 0;
					if (flag8)
					{
						for (int m = 0; m < width; m++)
						{
							Framing.GetTileSafely(num2 + m, num3).frameX = (short)(m * 18 + num / 2 * 36 + num6 * 36);
						}
					}
					else
					{
						for (int n = 0; n < width; n++)
						{
							Framing.GetTileSafely(num2 + n, num3).frameX = (short)(n * 18 + (num - 2) / 2 * 36 + 72 + num6 * 36);
						}
					}
				}
			}
			if (flag3)
			{
				bool flag9 = true;
				for (int num7 = 0; num7 < width; num7++)
				{
					if (!AnchorValid(Framing.GetTileSafely(num2 + num7, num3 - 1), AnchorType.SolidTile))
					{
						flag9 = false;
					}
				}
				if (!flag9)
				{
					flag5 = true;
				}
				for (int num8 = 0; num8 < width; num8++)
				{
					for (int num9 = 0; num9 < height; num9++)
					{
						Tile tileSafely = Framing.GetTileSafely(num2 + num8, num3 + num9);
						if (tileSafely.liquid > 0)
						{
							flag5 = true;
							flag6 = true;
						}
					}
				}
			}
			if (flag4)
			{
				bool flag10 = true;
				for (int num10 = 0; num10 < width; num10++)
				{
					if (!AnchorValid(Framing.GetTileSafely(num2 + num10, num3 + height), AnchorType.SolidTile))
					{
						flag10 = false;
					}
				}
				if (!flag10)
				{
					flag5 = true;
				}
			}
			if (!flag5)
			{
				return;
			}
			destroyObject = true;
			for (int num11 = 0; num11 < width; num11++)
			{
				for (int num12 = 0; num12 < height; num12++)
				{
					if (Main.tile[num2 + num11, num3 + num12].type == type && Main.tile[num2 + num11, num3 + num12].active())
					{
						KillTile(num2 + num11, num3 + num12);
					}
				}
			}
			int num13 = 0;
			if (type == 376)
			{
				switch (num)
				{
				case 0:
					num13 = 2334;
					break;
				case 1:
					num13 = 2335;
					break;
				case 2:
					num13 = 2336;
					break;
				case 3:
					num13 = 3203;
					break;
				case 4:
					num13 = 3204;
					break;
				case 5:
					num13 = 3205;
					break;
				case 6:
					num13 = 3206;
					break;
				case 7:
					num13 = 3207;
					break;
				case 8:
					num13 = 3208;
					break;
				case 9:
					num13 = 3979;
					break;
				case 10:
					num13 = 3980;
					break;
				case 11:
					num13 = 3981;
					break;
				case 12:
					num13 = 3982;
					break;
				case 13:
					num13 = 3983;
					break;
				case 14:
					num13 = 3984;
					break;
				case 15:
					num13 = 3985;
					break;
				case 16:
					num13 = 3986;
					break;
				case 17:
					num13 = 3987;
					break;
				case 18:
					num13 = 4405;
					break;
				case 19:
					num13 = 4406;
					break;
				case 20:
					num13 = 4407;
					break;
				case 21:
					num13 = 4408;
					break;
				case 22:
					num13 = 4877;
					break;
				case 23:
					num13 = 4878;
					break;
				case 24:
					num13 = 5002;
					break;
				case 25:
					num13 = 5003;
					break;
				}
			}
			if (type == 443)
			{
				num13 = 3722;
			}
			if (type == 485 && !gen && Main.netMode != 1)
			{
				int num14 = 1;
				for (int num15 = 0; num15 < num14; num15++)
				{
					int num16 = NPC.NewNPC(num2 * 16, num3 * 16 + 32, 582);
					Main.npc[num16].TargetClosest();
					Main.npc[num16].velocity = new Vector2((float)Main.npc[num16].direction * 1.5f, -5f);
					NetMessage.SendData(23, -1, -1, null, num16);
					int num17 = 20;
					int num18 = -1;
					Main.npc[num16].GetImmuneTime(num18, num17);
					NetMessage.SendData(131, -1, -1, null, num16, 1f, num18, num17);
				}
			}
			if (type == 444 && Main.netMode != 1 && !flag6)
			{
				Projectile.NewProjectile(num2 * 16 + 16, num3 * 16 + 16, 0f, 0f, 655, 0, 0f, Main.myPlayer);
			}
			if (num13 != 0)
			{
				Item.NewItem(num2 * 16, num3 * 16, tileData.CoordinateFullWidth, tileData.CoordinateFullHeight, num13);
			}
			destroyObject = false;
			for (int num19 = -1; num19 < width + 1; num19++)
			{
				for (int num20 = -1; num20 < height + 1; num20++)
				{
					TileFrame(num2 + num19, num3 + num20);
				}
			}
		}

		public static void Check2x2(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = 0;
			int num2 = Main.tile[i, j].frameX / 18 * -1;
			if (num2 < -1)
			{
				num2 += 2;
				num = 36;
			}
			num2 += i;
			int num3 = ((type == 172) ? 38 : 36);
			int num4 = Main.tile[i, j].frameY;
			int num5 = 0;
			while (num4 >= num3)
			{
				num4 -= num3;
				num5++;
			}
			int num6 = j - num4 / 18;
			for (int k = num2; k < num2 + 2; k++)
			{
				for (int l = num6; l < num6 + 2; l++)
				{
					Tile tileSafely = Framing.GetTileSafely(k, l);
					if (!tileSafely.active() || tileSafely.type != type || tileSafely.frameX != (k - num2) * 18 + num || tileSafely.frameY != (l - num6) * 18 + num5 * num3)
					{
						flag = true;
					}
				}
				switch (type)
				{
				case 95:
				case 126:
					Framing.GetTileSafely(k, num6 - 1);
					if (!Main.tile[k, num6 - 1].active() || !Main.tileSolid[Main.tile[k, num6 - 1].type] || Main.tileSolidTop[Main.tile[k, num6 - 1].type])
					{
						flag = true;
					}
					continue;
				case 132:
				case 138:
				case 484:
					continue;
				}
				Tile tileSafely2 = Framing.GetTileSafely(k, num6 + 2);
				if (!tileSafely2.active() || (!Main.tileSolid[tileSafely2.type] && !Main.tileTable[tileSafely2.type]))
				{
					flag = true;
				}
				if (tileSafely2.halfBrick())
				{
					flag = true;
				}
			}
			switch (type)
			{
			case 138:
			case 484:
			{
				ushort type4 = Main.tile[num2, num6 - 1].type;
				ushort type5 = Main.tile[num2 + 1, num6 - 1].type;
				if (!TileID.Sets.BasicChest[type4] && !TileID.Sets.BasicChest[type5] && type4 != 88 && type5 != 88 && !TileID.Sets.BasicChestFake[type4] && !TileID.Sets.BasicChestFake[type5] && type4 != 470 && type5 != 470 && type4 != 475 && type5 != 475 && !SolidTileAllowBottomSlope(num2, num6 + 2) && !SolidTileAllowBottomSlope(num2 + 1, num6 + 2))
				{
					flag = true;
				}
				break;
			}
			case 132:
			{
				flag = false;
				num6 = Main.tile[i, j].frameY / 18 * -1;
				num6 += j;
				num = 0;
				num2 = Main.tile[i, j].frameX / 18 * -1;
				while (num2 < -1)
				{
					num2 += 2;
					num += 36;
				}
				num2 += i;
				for (int m = num2; m < num2 + 2; m++)
				{
					for (int n = num6; n < num6 + 2; n++)
					{
						if (Main.tile[m, n] == null)
						{
							Main.tile[m, n] = new Tile();
						}
						if (!Main.tile[m, n].active() || Main.tile[m, n].type != type || Main.tile[m, n].frameX != (m - num2) * 18 + num || Main.tile[m, n].frameY != (n - num6) * 18)
						{
							flag = true;
						}
					}
				}
				if (Main.tile[num2, num6 + 2] == null)
				{
					Main.tile[num2, num6 + 2] = new Tile();
				}
				if (Main.tile[num2 + 1, num6 + 2] == null)
				{
					Main.tile[num2 + 1, num6 + 2] = new Tile();
				}
				bool flag2 = false;
				ushort type2 = Main.tile[num2, num6 + 2].type;
				ushort type3 = Main.tile[num2 + 1, num6 + 2].type;
				if (!Main.tile[num2, num6 + 2].active() || (!Main.tileSolid[type2] && !Main.tileSolidTop[type2]) || Main.tile[num2, num6 + 2].halfBrick() || (Main.tile[num2, num6 + 2].slope() != 0 && !Main.tile[num2, num6 + 2].bottomSlope()))
				{
					flag2 = true;
				}
				if (!Main.tile[num2 + 1, num6 + 2].active() || (!Main.tileSolid[type3] && !Main.tileSolidTop[type3]) || Main.tile[num2 + 1, num6 + 2].halfBrick() || (Main.tile[num2 + 1, num6 + 2].slope() != 0 && !Main.tile[num2 + 1, num6 + 2].bottomSlope()))
				{
					flag2 = true;
				}
				if (flag2)
				{
					if (Main.tile[num2, num6].wall < 1 || Main.tile[num2 + 1, num6].wall < 1 || Main.tile[num2, num6 + 1].wall < 1 || Main.tile[num2 + 1, num6 + 1].wall < 1)
					{
						flag = true;
					}
					else
					{
						if (num >= 72)
						{
							break;
						}
						for (int num7 = num2; num7 < num2 + 2; num7++)
						{
							for (int num8 = num6; num8 < num6 + 2; num8++)
							{
								Main.tile[num7, num8].frameX += 72;
							}
						}
					}
				}
				else
				{
					if (num < 72)
					{
						break;
					}
					for (int num9 = num2; num9 < num2 + 2; num9++)
					{
						for (int num10 = num6; num10 < num6 + 2; num10++)
						{
							Main.tile[num9, num10].frameX -= 72;
						}
					}
				}
				break;
			}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int num11 = num2; num11 < num2 + 2; num11++)
			{
				for (int num12 = num6; num12 < num6 + 2; num12++)
				{
					if (Main.tile[num11, num12].type == type && Main.tile[num11, num12].active())
					{
						KillTile(num11, num12);
					}
				}
			}
			int num13 = 0;
			switch (type)
			{
			case 521:
				num13 = 4327;
				break;
			case 522:
				num13 = 4328;
				break;
			case 523:
				num13 = 4329;
				break;
			case 524:
				num13 = 4330;
				break;
			case 525:
				num13 = 4331;
				break;
			case 526:
				num13 = 4332;
				break;
			case 527:
				num13 = 4333;
				break;
			case 564:
				num13 = 4553;
				break;
			case 565:
				num13 = 4552;
				break;
			case 594:
				num13 = 4869;
				break;
			case 621:
				num13 = 3750;
				break;
			case 622:
				num13 = 5008;
				break;
			}
			if (type == 598)
			{
				num13 = 4880;
			}
			if (type == 360)
			{
				num13 = 3072;
			}
			if (type == 580)
			{
				num13 = 4846;
			}
			if (type == 620)
			{
				num13 = 4964;
			}
			if (type == 505)
			{
				num13 = 4275;
			}
			if (type == 543)
			{
				num13 = 4398;
			}
			if (type == 568)
			{
				num13 = 4655;
			}
			if (type == 569)
			{
				num13 = 4656;
			}
			if (type == 570)
			{
				num13 = 4657;
			}
			if (type >= 288 && type <= 295)
			{
				num13 = 2178 + type - 288;
			}
			if (type >= 316 && type <= 318)
			{
				num13 = 2439 + type - 316;
			}
			if (type == 85)
			{
				num13 = 321;
			}
			if (type == 94)
			{
				num13 = 352;
			}
			if (type == 95)
			{
				num13 = 344;
			}
			if (type == 96)
			{
				num13 = 345;
			}
			if (type == 97)
			{
				num13 = 346;
			}
			if (type == 98)
			{
				num13 = 347;
			}
			if (type == 99)
			{
				num13 = 348;
			}
			if (type == 335)
			{
				num13 = 2700;
			}
			if (type == 411)
			{
				num13 = 3545;
			}
			if (type == 100)
			{
				switch (num5)
				{
				case 0:
					num13 = 349;
					break;
				case 1:
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7:
				case 8:
				case 9:
				case 10:
				case 11:
				case 12:
					num13 = 2092 + num5 - 1;
					break;
				default:
					if (num5 >= 13 && num5 <= 16)
					{
						num13 = 2149 + num5 - 13;
						break;
					}
					switch (num5)
					{
					case 17:
						num13 = 2227;
						break;
					case 18:
						num13 = 2522;
						break;
					case 19:
						num13 = 2541;
						break;
					case 20:
						num13 = 2555;
						break;
					case 21:
						num13 = 2570;
						break;
					case 22:
						num13 = 2664;
						break;
					case 23:
						num13 = 2665;
						break;
					case 24:
						num13 = 2666;
						break;
					case 25:
						num13 = 2667;
						break;
					case 26:
						num13 = 2668;
						break;
					case 27:
						num13 = 2825;
						break;
					case 28:
						num13 = 3168;
						break;
					case 29:
						num13 = 3170;
						break;
					case 30:
						num13 = 3169;
						break;
					case 31:
						num13 = 3893;
						break;
					case 32:
						num13 = 3935;
						break;
					case 33:
						num13 = 3961;
						break;
					case 34:
						num13 = 4149;
						break;
					case 35:
						num13 = 4170;
						break;
					case 36:
						num13 = 4191;
						break;
					case 37:
						num13 = 4212;
						break;
					case 38:
						num13 = 4302;
						break;
					case 39:
						num13 = 4570;
						break;
					}
					break;
				}
			}
			if (type == 173)
			{
				num13 = 714;
			}
			if (type == 125)
			{
				num13 = 487;
			}
			if (type == 287)
			{
				num13 = 2177;
			}
			if (type == 126)
			{
				num13 = 488;
			}
			if (type == 132)
			{
				num13 = 513;
			}
			if (type == 142)
			{
				num13 = 581;
			}
			if (type == 143)
			{
				num13 = 582;
			}
			if (type == 282)
			{
				num13 = 250;
			}
			if (type == 319)
			{
				num13 = 2490;
			}
			if (type == 490)
			{
				num13 = 4075;
			}
			if (type == 172)
			{
				num13 = 2827 + num5;
				switch (num5)
				{
				case 29:
					num13 = 3147;
					break;
				case 30:
					num13 = 3149;
					break;
				case 31:
					num13 = 3148;
					break;
				case 32:
					num13 = 3896;
					break;
				case 33:
					num13 = 3946;
					break;
				case 34:
					num13 = 3972;
					break;
				case 35:
					num13 = 4160;
					break;
				case 36:
					num13 = 4181;
					break;
				case 37:
					num13 = 4202;
					break;
				case 38:
					num13 = 4223;
					break;
				case 39:
					num13 = 4312;
					break;
				case 40:
					num13 = 4581;
					break;
				}
			}
			if (num13 != 0)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, num13);
			}
			if (type == 138 && !gen && Main.netMode != 1)
			{
				Projectile.NewProjectile((float)(num2 * 16) + 15.5f, num6 * 16 + 16, 0f, 0f, 99, 70, 10f, Main.myPlayer);
			}
			if (type == 484 && !gen && Main.netMode != 1)
			{
				Projectile.NewProjectile((float)(num2 * 16) + 15.5f, num6 * 16 + 16, 0f, 0f, 727, 70, 10f, Main.myPlayer);
			}
			destroyObject = false;
			for (int num14 = num2 - 1; num14 < num2 + 3; num14++)
			{
				for (int num15 = num6 - 1; num15 < num6 + 3; num15++)
				{
					TileFrame(num14, num15);
				}
			}
		}

		public static bool CheckBoulderChest(int i, int j)
		{
			int num = Main.tile[i, j].frameX / 18 * -1;
			if (num < -1)
			{
				num += 2;
			}
			num += i;
			int num2;
			for (num2 = Main.tile[i, j].frameY; num2 >= 36; num2 -= 36)
			{
			}
			num2 = j - num2 / 18;
			if (IsAContainer(Main.tile[num, num2 - 1]) || IsAContainer(Main.tile[num + 1, num2 - 1]))
			{
				return true;
			}
			return false;
		}

		public static bool IsAContainer(Tile t)
		{
			if (t.type != 88 && t.type != 470 && t.type != 475 && !TileID.Sets.BasicChest[t.type])
			{
				return TileID.Sets.BasicChestFake[t.type];
			}
			return true;
		}

		public static void OreRunner(int i, int j, double strength, int steps, ushort type)
		{
			double num = strength;
			float num2 = steps;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-10, 11) * 0.1f;
			vector2.Y = (float)genRand.Next(-10, 11) * 0.1f;
			while (num > 0.0 && num2 > 0f)
			{
				if (vector.Y < 0f && num2 > 0f && type == 59)
				{
					num2 = 0f;
				}
				num = strength * (double)(num2 / (float)steps);
				num2 -= 1f;
				int num3 = (int)((double)vector.X - num * 0.5);
				int num4 = (int)((double)vector.X + num * 0.5);
				int num5 = (int)((double)vector.Y - num * 0.5);
				int num6 = (int)((double)vector.Y + num * 0.5);
				if (num3 < 0)
				{
					num3 = 0;
				}
				if (num4 > Main.maxTilesX)
				{
					num4 = Main.maxTilesX;
				}
				if (num5 < 0)
				{
					num5 = 0;
				}
				if (num6 > Main.maxTilesY)
				{
					num6 = Main.maxTilesY;
				}
				for (int k = num3; k < num4; k++)
				{
					for (int l = num5; l < num6; l++)
					{
						if ((double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < strength * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[k, l].active() && (Main.tile[k, l].type == 0 || Main.tile[k, l].type == 1 || Main.tile[k, l].type == 23 || Main.tile[k, l].type == 25 || Main.tile[k, l].type == 40 || Main.tile[k, l].type == 53 || Main.tile[k, l].type == 57 || Main.tile[k, l].type == 59 || Main.tile[k, l].type == 60 || Main.tile[k, l].type == 70 || Main.tile[k, l].type == 109 || Main.tile[k, l].type == 112 || Main.tile[k, l].type == 116 || Main.tile[k, l].type == 117 || Main.tile[k, l].type == 147 || Main.tile[k, l].type == 161 || Main.tile[k, l].type == 163 || Main.tile[k, l].type == 164 || Main.tileMoss[Main.tile[k, l].type] || Main.tile[k, l].type == 199 || Main.tile[k, l].type == 200 || Main.tile[k, l].type == 203 || Main.tile[k, l].type == 234 || (Main.tile[k, l].type == 225 && Main.tile[k, l].wall != 108)))
						{
							Main.tile[k, l].type = type;
							SquareTileFrame(k, l);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
						}
					}
				}
				vector += vector2;
				vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
				if (vector2.X > 1f)
				{
					vector2.X = 1f;
				}
				if (vector2.X < -1f)
				{
					vector2.X = -1f;
				}
			}
		}

		public static void SmashAltar(int i, int j)
		{
			if (Main.netMode == 1 || !Main.hardMode || noTileActions || gen)
			{
				return;
			}
			int num = altarCount % 3;
			int num2 = altarCount / 3 + 1;
			float num3 = Main.maxTilesX / 4200;
			int num4 = 1 - num;
			num3 = num3 * 310f - (float)(85 * num);
			num3 *= 0.85f;
			num3 /= (float)num2;
			bool flag = false;
			if (Main.drunkWorld)
			{
				if (SavedOreTiers.Adamantite == 111)
				{
					SavedOreTiers.Adamantite = 223;
				}
				else if (SavedOreTiers.Adamantite == 223)
				{
					SavedOreTiers.Adamantite = 111;
				}
			}
			switch (num)
			{
			case 0:
			{
				if (SavedOreTiers.Cobalt == -1)
				{
					flag = true;
					SavedOreTiers.Cobalt = 107;
					if (genRand.Next(2) == 0)
					{
						SavedOreTiers.Cobalt = 221;
					}
				}
				int num6 = 12;
				if (SavedOreTiers.Cobalt == 221)
				{
					num6 += 9;
					num3 *= 0.9f;
				}
				if (Main.netMode == 0)
				{
					Main.NewText(Lang.misc[num6].Value, 50, byte.MaxValue, 130);
				}
				else if (Main.netMode == 2)
				{
					ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[num6].Key), new Color(50, 255, 130));
				}
				num = SavedOreTiers.Cobalt;
				num3 *= 1.05f;
				break;
			}
			case 1:
			{
				if (Main.drunkWorld)
				{
					if (SavedOreTiers.Mythril == 108)
					{
						SavedOreTiers.Mythril = 222;
					}
					else if (SavedOreTiers.Mythril == 222)
					{
						SavedOreTiers.Mythril = 108;
					}
				}
				if (SavedOreTiers.Mythril == -1)
				{
					flag = true;
					SavedOreTiers.Mythril = 108;
					if (genRand.Next(2) == 0)
					{
						SavedOreTiers.Mythril = 222;
					}
				}
				int num7 = 13;
				if (SavedOreTiers.Mythril == 222)
				{
					num7 += 9;
					num3 *= 0.9f;
				}
				if (Main.netMode == 0)
				{
					Main.NewText(Lang.misc[num7].Value, 50, byte.MaxValue, 130);
				}
				else if (Main.netMode == 2)
				{
					ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[num7].Key), new Color(50, 255, 130));
				}
				num = SavedOreTiers.Mythril;
				break;
			}
			default:
			{
				if (Main.drunkWorld)
				{
					if (SavedOreTiers.Cobalt == 107)
					{
						SavedOreTiers.Cobalt = 221;
					}
					else if (SavedOreTiers.Cobalt == 221)
					{
						SavedOreTiers.Cobalt = 107;
					}
				}
				if (SavedOreTiers.Adamantite == -1)
				{
					flag = true;
					SavedOreTiers.Adamantite = 111;
					if (genRand.Next(2) == 0)
					{
						SavedOreTiers.Adamantite = 223;
					}
				}
				int num5 = 14;
				if (SavedOreTiers.Adamantite == 223)
				{
					num5 += 9;
					num3 *= 0.9f;
				}
				if (Main.netMode == 0)
				{
					Main.NewText(Lang.misc[num5].Value, 50, byte.MaxValue, 130);
				}
				else if (Main.netMode == 2)
				{
					ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[num5].Key), new Color(50, 255, 130));
				}
				num = SavedOreTiers.Adamantite;
				break;
			}
			}
			if (flag)
			{
				NetMessage.SendData(7);
			}
			for (int k = 0; (float)k < num3; k++)
			{
				int i2 = genRand.Next(100, Main.maxTilesX - 100);
				double num8 = Main.worldSurface;
				if (num == 108 || num == 222)
				{
					num8 = Main.rockLayer;
				}
				if (num == 111 || num == 223)
				{
					num8 = (Main.rockLayer + Main.rockLayer + (double)Main.maxTilesY) / 3.0;
				}
				int j2 = genRand.Next((int)num8, Main.maxTilesY - 150);
				OreRunner(i2, j2, genRand.Next(5, 9 + num4), genRand.Next(5, 9 + num4), (ushort)num);
			}
			int num9 = genRand.Next(3);
			int num10 = 0;
			while (num9 != 2 && num10++ < 1000)
			{
				int num11 = genRand.Next(100, Main.maxTilesX - 100);
				int num12 = genRand.Next((int)Main.rockLayer + 50, Main.maxTilesY - 300);
				if (!Main.tile[num11, num12].active() || Main.tile[num11, num12].type != 1)
				{
					continue;
				}
				if (num9 == 0)
				{
					if (crimson)
					{
						Main.tile[num11, num12].type = 203;
					}
					else
					{
						Main.tile[num11, num12].type = 25;
					}
				}
				else
				{
					Main.tile[num11, num12].type = 117;
				}
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, num11, num12, 1);
				}
				break;
			}
			if (Main.netMode != 1)
			{
				int num13 = Main.rand.Next(2) + 1;
				for (int l = 0; l < num13; l++)
				{
					NPC.SpawnOnPlayer(Player.FindClosest(new Vector2(i * 16, j * 16), 16, 16), 82);
				}
			}
			altarCount++;
			AchievementsHelper.NotifyProgressionEvent(6);
		}

		public static void Check3x1(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = Main.tile[i, j].frameX / 18;
			int num2 = 0;
			while (num > 2)
			{
				num -= 3;
				num2++;
			}
			num = i - num;
			int num3 = num2 * 54;
			for (int k = num; k < num + 3; k++)
			{
				if (Main.tile[k, j] == null)
				{
					Main.tile[k, j] = new Tile();
				}
				if (!Main.tile[k, j].active() || Main.tile[k, j].type != type || Main.tile[k, j].frameX != (k - num) * 18 + num3 || Main.tile[k, j].frameY != 0)
				{
					flag = true;
				}
				if (Main.tile[k, j - 1].active() && (TileID.Sets.BasicChest[Main.tile[k, j - 1].type] || TileID.Sets.BasicChestFake[Main.tile[k, j - 1].type] || Main.tile[k, j - 1].type == 88 || Main.tile[k, j - 1].type == 470 || Main.tile[k, j - 1].type == 475 || Main.tile[k, j - 1].type == 597))
				{
					return;
				}
				if (!SolidTileAllowBottomSlope(k, j + 1))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			_ = Main.tile[i, j].frameX;
			destroyObject = true;
			if (type == 235)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 1263);
			}
			for (int l = num; l < num + 3; l++)
			{
				if (Main.tile[l, j] == null)
				{
					Main.tile[l, j] = new Tile();
				}
				if (Main.tile[l, j].type == type && Main.tile[l, j].active())
				{
					KillTile(l, j);
				}
			}
			destroyObject = false;
			for (int m = num - 1; m < num + 4; m++)
			{
				TileFrame(m, j);
			}
		}

		public static void Check3x2(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			bool flag2 = false;
			int num = j;
			if (Main.tile[i, j] == null)
			{
				Main.tile[i, j] = new Tile();
			}
			int num2 = 36;
			int num3 = Main.tile[i, j].frameY / num2;
			int num4 = Main.tile[i, j].frameY % num2;
			num -= num4 / 18;
			int num5 = Main.tile[i, j].frameX / 18;
			int num6 = 0;
			while (num5 > 2)
			{
				num5 -= 3;
				num6++;
			}
			num5 = i - num5;
			int num7 = num6 * 54;
			if (type == 14 && num6 == 25)
			{
				flag2 = true;
			}
			int num8 = num + 2;
			if (flag2)
			{
				num8--;
			}
			for (int k = num5; k < num5 + 3; k++)
			{
				for (int l = num; l < num8; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num5) * 18 + num7 || Main.tile[k, l].frameY != (l - num) * 18 + num3 * 36)
					{
						flag = true;
					}
				}
				switch (type)
				{
				default:
					switch (type)
					{
					case 532:
					case 533:
					case 544:
					case 555:
					case 556:
					case 582:
					case 619:
						break;
					case 488:
					{
						int num9 = 0;
						if (Main.tile[k, num8] != null && Main.tile[k, num8].active())
						{
							num9 = Main.tile[k, num8].type;
						}
						if (num9 != 2 && num9 != 477 && num9 != 109 && num9 != 492)
						{
							flag = true;
						}
						continue;
					}
					default:
						if (!SolidTileAllowBottomSlope(k, num8))
						{
							flag = true;
						}
						continue;
					}
					break;
				case 285:
				case 286:
				case 298:
				case 299:
				case 310:
				case 339:
				case 361:
				case 362:
				case 363:
				case 364:
				case 538:
					break;
				}
				if (!SolidTileAllowBottomSlope(k, num8) && (Main.tile[k, num8] == null || !Main.tile[k, num8].nactive() || !Main.tileSolidTop[Main.tile[k, num8].type] || Main.tile[k, num8].frameY != 0) && (Main.tile[k, num8] == null || !Main.tile[k, num8].active() || !TileID.Sets.Platforms[Main.tile[k, num8].type]))
				{
					flag = true;
				}
			}
			if (type == 187 && Main.tile[num5, num] != null && Main.tile[num5, num].frameX >= 756 && Main.tile[num5, num].frameX <= 900 && Main.tile[num5, num + 2].type != 2 && Main.tile[num5 + 1, num + 2].type != 2 && Main.tile[num5 + 2, num + 2].type != 2 && Main.tile[num5, num + 2].type != 477 && Main.tile[num5 + 1, num + 2].type != 477 && Main.tile[num5 + 2, num + 2].type != 477 && Main.tile[num5, num + 2].type != 492 && Main.tile[num5 + 1, num + 2].type != 492 && Main.tile[num5 + 2, num + 2].type != 492)
			{
				Main.tile[num5, num].frameX -= 378;
				Main.tile[num5 + 1, num].frameX -= 378;
				Main.tile[num5 + 2, num].frameX -= 378;
				Main.tile[num5, num + 1].frameX -= 378;
				Main.tile[num5 + 1, num + 1].frameX -= 378;
				Main.tile[num5 + 2, num + 1].frameX -= 378;
				Main.tile[num5, num].type = 186;
				Main.tile[num5 + 1, num].type = 186;
				Main.tile[num5 + 2, num].type = 186;
				Main.tile[num5, num + 1].type = 186;
				Main.tile[num5 + 1, num + 1].type = 186;
				Main.tile[num5 + 2, num + 1].type = 186;
			}
			if (flag && type == 488 && gen)
			{
				for (int m = num5; m < num5 + 3; m++)
				{
					for (int n = num; n < num + 2; n++)
					{
						Main.tile[m, n].active(active: true);
						Main.tile[m, n].type = 488;
						Main.tile[m, n].frameX = (short)((m - num5) * 18);
						Main.tile[m, n].frameY = (short)((n - num) * 18);
					}
					Main.tile[m, num + 2].active(active: true);
					Main.tile[m, num + 2].type = 2;
					Main.tile[m, num + 2].slope(0);
					Main.tile[m, num + 2].halfBrick(halfBrick: false);
				}
				flag = false;
			}
			if (!flag)
			{
				return;
			}
			int frameX = Main.tile[i, j].frameX;
			destroyObject = true;
			num8 = num + 3;
			if (flag2)
			{
				num8--;
			}
			for (int num10 = num5; num10 < num5 + 3; num10++)
			{
				for (int num11 = num; num11 < num + 3; num11++)
				{
					if (Main.tile[num10, num11] == null)
					{
						Main.tile[num10, num11] = new Tile();
					}
					if (Main.tile[num10, num11].type == type && Main.tile[num10, num11].active())
					{
						KillTile(num10, num11);
					}
				}
			}
			if (type == 14)
			{
				int type2 = ((num6 >= 1 && num6 <= 3) ? (637 + num6) : ((num6 >= 15 && num6 <= 20) ? (1698 + num6) : ((num6 >= 4 && num6 <= 7) ? (823 + num6) : (num6 switch
				{
					8 => 917, 
					9 => 1144, 
					10 => 1397, 
					11 => 1400, 
					12 => 1403, 
					13 => 1460, 
					14 => 1510, 
					23 => 1926, 
					21 => 1794, 
					22 => 1816, 
					24 => 2248, 
					25 => 2259, 
					26 => 2532, 
					27 => 2550, 
					28 => 677, 
					29 => 2583, 
					30 => 2743, 
					31 => 2824, 
					32 => 3153, 
					33 => 3155, 
					34 => 3154, 
					_ => 32, 
				}))));
				Item.NewItem(i * 16, j * 16, 32, 32, type2);
			}
			switch (type)
			{
			case 469:
			{
				int type4 = 3920;
				if (num6 == 1)
				{
					type4 = 3948;
				}
				if (num6 == 2)
				{
					type4 = 3974;
				}
				if (num6 == 3)
				{
					type4 = 4162;
				}
				if (num6 == 4)
				{
					type4 = 4183;
				}
				if (num6 == 5)
				{
					type4 = 4204;
				}
				if (num6 == 6)
				{
					type4 = 4225;
				}
				if (num6 == 7)
				{
					type4 = 4314;
				}
				if (num6 == 8)
				{
					type4 = 4583;
				}
				Item.NewItem(i * 16, j * 16, 32, 32, type4);
				break;
			}
			case 114:
				Item.NewItem(i * 16, j * 16, 32, 32, 398);
				break;
			case 26:
				if (!noTileActions && !IsGeneratingHardMode)
				{
					SmashAltar(i, j);
				}
				break;
			case 298:
				Item.NewItem(i * 16, j * 16, 32, 32, 2190);
				break;
			case 299:
				Item.NewItem(i * 16, j * 16, 32, 32, 2191);
				break;
			case 361:
			case 362:
			case 363:
			case 364:
				Item.NewItem(i * 16, j * 16, 32, 32, 3073 + type - 361);
				break;
			default:
				if (type >= 391 && type <= 394)
				{
					Item.NewItem(i * 16, j * 16, 48, 32, 3254 + type - 391);
					break;
				}
				switch (type)
				{
				case 285:
					Item.NewItem(i * 16, j * 16, 32, 32, 2174);
					break;
				case 286:
					Item.NewItem(i * 16, j * 16, 32, 32, 2175);
					break;
				case 582:
					Item.NewItem(i * 16, j * 16, 32, 32, 4850);
					break;
				case 619:
					Item.NewItem(i * 16, j * 16, 32, 32, 4963);
					break;
				case 310:
					Item.NewItem(i * 16, j * 16, 32, 32, 2207);
					break;
				case 339:
					Item.NewItem(i * 16, j * 16, 32, 32, 2741);
					break;
				case 538:
					Item.NewItem(i * 16, j * 16, 32, 32, 4380);
					break;
				case 544:
					Item.NewItem(i * 16, j * 16, 32, 32, 4399);
					break;
				case 532:
					Item.NewItem(i * 16, j * 16, 32, 32, 4364);
					break;
				case 533:
					Item.NewItem(i * 16, j * 16, 32, 32, 4376);
					break;
				case 555:
					Item.NewItem(i * 16, j * 16, 32, 32, 4475);
					break;
				case 556:
					Item.NewItem(i * 16, j * 16, 32, 32, 4476);
					break;
				case 217:
					Item.NewItem(i * 16, j * 16, 32, 32, 995);
					break;
				case 218:
					Item.NewItem(i * 16, j * 16, 32, 32, 996);
					break;
				case 219:
					Item.NewItem(i * 16, j * 16, 32, 32, 997);
					break;
				case 220:
					Item.NewItem(i * 16, j * 16, 32, 32, 998);
					break;
				case 377:
					Item.NewItem(i * 16, j * 16, 32, 32, 3198);
					break;
				case 228:
					Item.NewItem(i * 16, j * 16, 32, 32, 1120);
					break;
				case 405:
					Item.NewItem(i * 16, j * 16, 32, 32, 3364);
					break;
				case 486:
					Item.NewItem(i * 16, j * 16, 32, 32, 4063);
					break;
				case 488:
					Item.NewItem(i * 16, j * 16, 32, 32, 9, genRand.Next(10, 21));
					break;
				case 215:
					switch (num6)
					{
					case 0:
						Item.NewItem(i * 16, j * 16, 32, 32, 966);
						break;
					case 6:
						Item.NewItem(i * 16, j * 16, 32, 32, 3723);
						break;
					case 7:
						Item.NewItem(i * 16, j * 16, 32, 32, 3724);
						break;
					case 8:
					case 9:
					case 10:
					case 11:
					case 12:
					case 13:
						Item.NewItem(i * 16, j * 16, 32, 32, 4689 + num6 - 8);
						break;
					default:
						Item.NewItem(i * 16, j * 16, 32, 32, 3046 + num6 - 1);
						break;
					}
					break;
				case 244:
					Item.NewItem(i * 16, j * 16, 32, 32, 1449);
					break;
				case 17:
					Item.NewItem(i * 16, j * 16, 32, 32, 33);
					break;
				case 77:
					Item.NewItem(i * 16, j * 16, 32, 32, 221);
					break;
				case 86:
					Item.NewItem(i * 16, j * 16, 32, 32, 332);
					break;
				case 237:
					Item.NewItem(i * 16, j * 16, 32, 32, 1292);
					break;
				case 87:
				{
					int type3;
					if (num6 >= 1 && num6 <= 3)
					{
						type3 = 640 + num6;
					}
					else
					{
						switch (num6)
						{
						case 4:
							type3 = 919;
							break;
						case 5:
						case 6:
						case 7:
							type3 = 2245 + num6 - 5;
							break;
						default:
							type3 = ((num6 >= 8 && num6 <= 10) ? (2254 + num6 - 8) : ((num6 >= 11 && num6 <= 20) ? (2376 + num6 - 11) : (num6 switch
							{
								21 => 2531, 
								22 => 2548, 
								23 => 2565, 
								24 => 2580, 
								25 => 2671, 
								26 => 2821, 
								27 => 3141, 
								28 => 3143, 
								29 => 3142, 
								30 => 3915, 
								31 => 3916, 
								32 => 3944, 
								33 => 3971, 
								34 => 4158, 
								35 => 4179, 
								36 => 4200, 
								37 => 4221, 
								38 => 4310, 
								39 => 4579, 
								_ => 333, 
							})));
							break;
						}
					}
					Item.NewItem(i * 16, j * 16, 32, 32, type3);
					break;
				}
				case 88:
				{
					int dresserItemDrop = GetDresserItemDrop(num6);
					Item.NewItem(i * 16, j * 16, 32, 32, dresserItemDrop);
					break;
				}
				case 89:
					Item.NewItem(i * 16, j * 16, 32, 32, GetItemDrop_Benches(num6));
					break;
				case 133:
					if (frameX >= 54)
					{
						Item.NewItem(i * 16, j * 16, 32, 32, 1221);
					}
					else
					{
						Item.NewItem(i * 16, j * 16, 32, 32, 524);
					}
					break;
				case 186:
					if (frameX < 864)
					{
						break;
					}
					if (frameX <= 954)
					{
						Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));
						Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));
						Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
						if (genRand.Next(3) != 0)
						{
							Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));
						}
						if (genRand.Next(3) != 0)
						{
							Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));
						}
						if (genRand.Next(3) != 0)
						{
							Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
						}
						if (genRand.Next(2) == 0)
						{
							Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));
						}
						if (genRand.Next(2) == 0)
						{
							Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));
						}
						if (genRand.Next(2) == 0)
						{
							Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
						}
						if (genRand.Next(3) == 0)
						{
							Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));
						}
						if (genRand.Next(3) == 0)
						{
							Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));
						}
						if (genRand.Next(3) == 0)
						{
							Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
						}
						if (genRand.Next(4) == 0)
						{
							Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));
						}
						if (genRand.Next(4) == 0)
						{
							Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));
						}
						if (genRand.Next(4) == 0)
						{
							Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
						}
						if (genRand.Next(5) == 0)
						{
							Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));
						}
						if (genRand.Next(5) == 0)
						{
							Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));
						}
						if (genRand.Next(5) == 0)
						{
							Item.NewItem(i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
						}
					}
					else if (frameX <= 1062)
					{
						Item.NewItem(i * 16, j * 16, 32, 32, 72, genRand.Next(10, 100));
						if (genRand.Next(2) == 0)
						{
							Item.NewItem(i * 16, j * 16, 32, 32, 72, genRand.Next(20, 100));
						}
						if (genRand.Next(3) == 0)
						{
							Item.NewItem(i * 16, j * 16, 32, 32, 72, genRand.Next(30, 100));
						}
						if (genRand.Next(4) == 0)
						{
							Item.NewItem(i * 16, j * 16, 32, 32, 72, genRand.Next(40, 100));
						}
						if (genRand.Next(5) == 0)
						{
							Item.NewItem(i * 16, j * 16, 32, 32, 72, genRand.Next(50, 100));
						}
					}
					else if (frameX <= 1170)
					{
						Item.NewItem(i * 16, j * 16, 32, 32, 73, genRand.Next(1, 7));
						if (genRand.Next(2) == 0)
						{
							Item.NewItem(i * 16, j * 16, 32, 32, 73, genRand.Next(2, 7));
						}
						if (genRand.Next(3) == 0)
						{
							Item.NewItem(i * 16, j * 16, 32, 32, 73, genRand.Next(3, 7));
						}
						if (genRand.Next(4) == 0)
						{
							Item.NewItem(i * 16, j * 16, 32, 32, 73, genRand.Next(4, 7));
						}
						if (genRand.Next(5) == 0)
						{
							Item.NewItem(i * 16, j * 16, 32, 32, 73, genRand.Next(5, 7));
						}
					}
					break;
				case 187:
					if (frameX >= 918 && frameX <= 970)
					{
						if (Main.rand.Next(50) == 0)
						{
							Item.NewItem(i * 16, j * 16, 32, 32, 4144);
						}
						else
						{
							Item.NewItem(i * 16, j * 16, 32, 32, 989);
						}
					}
					break;
				}
				break;
			}
			destroyObject = false;
			for (int num12 = num5 - 1; num12 < num5 + 4; num12++)
			{
				for (int num13 = num - 1; num13 < num + 4; num13++)
				{
					TileFrame(num12, num13);
				}
			}
			if (type == 488)
			{
				mysticLogsEvent.FallenLogDestroyed();
			}
		}

		private static int GetDresserItemDrop(int style)
		{
			if (style >= 1 && style <= 3)
			{
				return 646 + style;
			}
			switch (style)
			{
			case 4:
				return 918;
			case 5:
			case 6:
			case 7:
			case 8:
			case 9:
			case 10:
			case 11:
			case 12:
			case 13:
			case 14:
			case 15:
				return 2386 + style - 5;
			default:
				return style switch
				{
					16 => 2529, 
					17 => 2545, 
					18 => 2562, 
					19 => 2577, 
					20 => 2637, 
					21 => 2638, 
					22 => 2639, 
					23 => 2640, 
					24 => 2816, 
					25 => 3132, 
					26 => 3134, 
					27 => 3133, 
					28 => 3911, 
					29 => 3912, 
					30 => 3913, 
					31 => 3914, 
					32 => 3934, 
					33 => 3968, 
					34 => 4148, 
					35 => 4169, 
					36 => 4190, 
					37 => 4211, 
					38 => 4301, 
					39 => 4569, 
					_ => 334, 
				};
			}
		}

		public static void Check3x4(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = i;
			int num2 = j;
			int num3 = 0;
			int num4 = 0;
			int num5 = Main.tile[i, j].frameX / 18;
			int num6 = Main.tile[i, j].frameY / 18;
			while (num5 >= 3)
			{
				num3++;
				num5 -= 3;
			}
			while (num6 >= 4)
			{
				num4++;
				num6 -= 4;
			}
			num -= num5;
			num2 -= num6;
			for (int k = num; k < num + 3; k++)
			{
				for (int l = num2; l < num2 + 4; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != num3 * 54 + (k - num) * 18 || Main.tile[k, l].frameY != num4 * 72 + (l - num2) * 18)
					{
						flag = true;
					}
				}
				if (Main.tile[k, num2 + 4] == null)
				{
					Main.tile[k, num2 + 4] = new Tile();
				}
				if (!SolidTileAllowBottomSlope(k, num2 + 4))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int m = num; m < num + 3; m++)
			{
				for (int n = num2; n < num2 + 4; n++)
				{
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
					{
						KillTile(m, n);
					}
				}
			}
			switch (type)
			{
			case 101:
			{
				int type3;
				switch (num3)
				{
				case 1:
					type3 = 1414;
					break;
				case 2:
					type3 = 1415;
					break;
				case 3:
					type3 = 1416;
					break;
				case 4:
					type3 = 1463;
					break;
				case 5:
					type3 = 1512;
					break;
				case 6:
					type3 = 2020;
					break;
				case 7:
					type3 = 2021;
					break;
				case 8:
					type3 = 2022;
					break;
				case 9:
					type3 = 2023;
					break;
				case 10:
					type3 = 2024;
					break;
				case 11:
					type3 = 2025;
					break;
				case 12:
					type3 = 2026;
					break;
				case 13:
					type3 = 2027;
					break;
				case 14:
					type3 = 2028;
					break;
				case 15:
					type3 = 2029;
					break;
				case 16:
					type3 = 2030;
					break;
				case 17:
					type3 = 2031;
					break;
				case 18:
				case 19:
				case 20:
				case 21:
					type3 = 2135 + num3 - 18;
					break;
				default:
					type3 = num3 switch
					{
						22 => 2233, 
						23 => 2536, 
						24 => 2540, 
						25 => 2554, 
						26 => 2569, 
						27 => 2670, 
						28 => 2817, 
						29 => 3165, 
						30 => 3167, 
						31 => 3166, 
						32 => 3917, 
						33 => 3933, 
						34 => 3960, 
						35 => 4147, 
						36 => 4168, 
						37 => 4189, 
						38 => 4210, 
						39 => 4300, 
						40 => 4568, 
						_ => 354, 
					};
					break;
				}
				Item.NewItem(i * 16, j * 16, 32, 32, type3);
				break;
			}
			case 102:
				Item.NewItem(i * 16, j * 16, 32, 32, 355);
				break;
			case 463:
				Item.NewItem(i * 16, j * 16, 32, 32, 3813);
				break;
			case 617:
			{
				int type2 = 4924 + num3;
				Item.NewItem(i * 16, j * 16, 32, 32, type2);
				break;
			}
			}
			destroyObject = false;
			for (int num7 = num - 1; num7 < num + 4; num7++)
			{
				for (int num8 = num2 - 1; num8 < num2 + 4; num8++)
				{
					TileFrame(num7, num8);
				}
			}
		}

		public static void Check5x4(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = i;
			int num2 = j;
			int num3 = 0;
			int num4;
			for (num4 = Main.tile[i, j].frameX / 18; num4 >= 5; num4 -= 5)
			{
				num3++;
			}
			num -= num4;
			num2 += Main.tile[i, j].frameY / 18 * -1;
			for (int k = num; k < num + 5; k++)
			{
				for (int l = num2; l < num2 + 4; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != num3 * 90 + (k - num) * 18 || Main.tile[k, l].frameY != (l - num2) * 18)
					{
						flag = true;
					}
				}
				if (Main.tile[k, num2 + 4] == null)
				{
					Main.tile[k, num2 + 4] = new Tile();
				}
				if (!SolidTileAllowBottomSlope(k, num2 + 4))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int m = num; m < num + 5; m++)
			{
				for (int n = num2; n < num2 + 4; n++)
				{
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
					{
						KillTile(m, n);
					}
				}
			}
			if (type == 464)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 3814);
			}
			if (type == 466)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 3816);
			}
			destroyObject = false;
			for (int num5 = num - 1; num5 < num + 6; num5++)
			{
				for (int num6 = num2 - 1; num6 < num2 + 5; num6++)
				{
					TileFrame(num5, num6);
				}
			}
		}

		public static void Check6x3(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = i;
			int num2 = j;
			num += Main.tile[i, j].frameX / 18 * -1;
			num2 += Main.tile[i, j].frameY / 18 * -1;
			for (int k = num; k < num + 6; k++)
			{
				for (int l = num2; l < num2 + 3; l++)
				{
					int num3 = (k - num) * 18;
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != num3 || Main.tile[k, l].frameY != (l - num2) * 18)
					{
						flag = true;
					}
				}
				if (Main.tile[k, num2 + 3] == null)
				{
					Main.tile[k, num2 + 3] = new Tile();
				}
				if (!SolidTileAllowBottomSlope(k, num2 + 3) && (!Main.tile[k, num2 + 3].nactive() || !Main.tileSolidTop[Main.tile[k, num2 + 3].type] || Main.tile[k, num2 + 3].frameY != 0))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int m = num; m < num + 6; m++)
			{
				for (int n = num2; n < num2 + 3; n++)
				{
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
					{
						KillTile(m, n);
					}
				}
			}
			if (type == 275)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 2162);
			}
			if (type == 413)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 3565);
			}
			if (type == 414)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 3566);
			}
			if (type == 276)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 2163);
			}
			if (type == 277)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 2164);
			}
			if (type == 278)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 2165);
			}
			if (type == 279)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 2166);
			}
			if (type == 280)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 2167);
			}
			if (type == 281)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 2168);
			}
			if (type == 296)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 2186);
			}
			if (type == 297)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 2187);
			}
			if (type == 309)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 2206);
			}
			if (type == 358)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 3070);
			}
			if (type == 359)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 3071);
			}
			if (type == 542)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4396);
			}
			if (type == 550)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4461);
			}
			if (type == 551)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4462);
			}
			if (type == 553)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4473);
			}
			if (type == 554)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4474);
			}
			if (type == 558)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4481);
			}
			if (type == 559)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4483);
			}
			if (type == 599)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4882);
			}
			if (type == 600)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4883);
			}
			if (type == 601)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4884);
			}
			if (type == 602)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4885);
			}
			if (type == 603)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4886);
			}
			if (type == 604)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4887);
			}
			if (type == 605)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4888);
			}
			if (type == 606)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4889);
			}
			if (type == 607)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4890);
			}
			if (type == 608)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4891);
			}
			if (type == 609)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4892);
			}
			if (type == 610)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4893);
			}
			if (type == 611)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4894);
			}
			if (type == 612)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4895);
			}
			destroyObject = false;
			for (int num4 = num - 1; num4 < num + 7; num4++)
			{
				for (int num5 = num2 - 1; num5 < num2 + 4; num5++)
				{
					TileFrame(num4, num5);
				}
			}
		}

		public static void Place6x3(int x, int y, ushort type, int direction = -1, int style = 0)
		{
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
			{
				return;
			}
			bool flag = true;
			for (int i = x - 3; i < x + 3; i++)
			{
				for (int j = y - 2; j <= y; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active())
					{
						flag = false;
					}
				}
				if (Main.tile[i, y + 1] == null)
				{
					Main.tile[i, y + 1] = new Tile();
				}
				if (!SolidTile2(i, y + 1) && (!Main.tile[i, y + 1].nactive() || !Main.tileSolidTop[Main.tile[i, y + 1].type] || Main.tile[i, y + 1].frameY != 0))
				{
					flag = false;
				}
			}
			if (!flag)
			{
				return;
			}
			int num = 0;
			for (int k = x - 3; k < x + 3; k++)
			{
				int num2 = 0;
				for (int l = y - 2; l <= y; l++)
				{
					Main.tile[k, l].active(active: true);
					Main.tile[k, l].frameY = (short)num2;
					Main.tile[k, l].frameX = (short)num;
					Main.tile[k, l].type = type;
					num2 += 18;
				}
				num += 18;
			}
		}

		public static void Place4x2(int x, int y, ushort type, int direction = -1, int style = 0)
		{
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
			{
				return;
			}
			bool flag = true;
			for (int i = x - 1; i < x + 3; i++)
			{
				for (int j = y - 1; j < y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active())
					{
						flag = false;
					}
				}
				if (Main.tile[i, y + 1] == null)
				{
					Main.tile[i, y + 1] = new Tile();
				}
				if (!SolidTile2(i, y + 1))
				{
					flag = false;
				}
			}
			short num = 0;
			if (direction == 1)
			{
				num = 72;
			}
			int num2 = 36 * style;
			if (flag)
			{
				Main.tile[x - 1, y - 1].active(active: true);
				Main.tile[x - 1, y - 1].frameY = (short)num2;
				Main.tile[x - 1, y - 1].frameX = num;
				Main.tile[x - 1, y - 1].type = type;
				Main.tile[x, y - 1].active(active: true);
				Main.tile[x, y - 1].frameY = (short)num2;
				Main.tile[x, y - 1].frameX = (short)(18 + num);
				Main.tile[x, y - 1].type = type;
				Main.tile[x + 1, y - 1].active(active: true);
				Main.tile[x + 1, y - 1].frameY = (short)num2;
				Main.tile[x + 1, y - 1].frameX = (short)(36 + num);
				Main.tile[x + 1, y - 1].type = type;
				Main.tile[x + 2, y - 1].active(active: true);
				Main.tile[x + 2, y - 1].frameY = (short)num2;
				Main.tile[x + 2, y - 1].frameX = (short)(54 + num);
				Main.tile[x + 2, y - 1].type = type;
				Main.tile[x - 1, y].active(active: true);
				Main.tile[x - 1, y].frameY = (short)(num2 + 18);
				Main.tile[x - 1, y].frameX = num;
				Main.tile[x - 1, y].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = (short)(num2 + 18);
				Main.tile[x, y].frameX = (short)(18 + num);
				Main.tile[x, y].type = type;
				Main.tile[x + 1, y].active(active: true);
				Main.tile[x + 1, y].frameY = (short)(num2 + 18);
				Main.tile[x + 1, y].frameX = (short)(36 + num);
				Main.tile[x + 1, y].type = type;
				Main.tile[x + 2, y].active(active: true);
				Main.tile[x + 2, y].frameY = (short)(num2 + 18);
				Main.tile[x + 2, y].frameX = (short)(54 + num);
				Main.tile[x + 2, y].type = type;
			}
		}

		public static void ShootFromCannon(int x, int y, int angle, int ammo, int Damage, float KnockBack, int owner)
		{
			float num = 14f;
			float num2 = 0f;
			float num3 = 0f;
			int type = 162;
			if (ammo == 2)
			{
				type = 281;
			}
			if (ammo == 3)
			{
				type = 178;
			}
			if (ammo == 4)
			{
				type = 601;
				num = 3f;
			}
			if (ammo == 5)
			{
				type = 601;
				num = 3f;
			}
			int num4 = 0;
			int num5 = 0;
			if (ammo == 5)
			{
				num4 = 1;
			}
			if (ammo == 2)
			{
				num5 = owner + 1;
			}
			if (angle == 0)
			{
				num2 = 10f;
				num3 = 0f;
			}
			if (angle == 1)
			{
				num2 = 7.5f;
				num3 = -2.5f;
			}
			if (angle == 2)
			{
				num2 = 5f;
				num3 = -5f;
			}
			if (angle == 3)
			{
				num2 = 2.75f;
				num3 = -6f;
			}
			if (angle == 4)
			{
				num2 = 0f;
				num3 = -10f;
			}
			if (angle == 5)
			{
				num2 = -2.75f;
				num3 = -6f;
			}
			if (angle == 6)
			{
				num2 = -5f;
				num3 = -5f;
			}
			if (angle == 7)
			{
				num2 = -7.5f;
				num3 = -2.5f;
			}
			if (angle == 8)
			{
				num2 = -10f;
				num3 = 0f;
			}
			Vector2 vector = new Vector2((x + 2) * 16, (y + 2) * 16);
			float num6 = num2;
			float num7 = num3;
			float num8 = (float)Math.Sqrt(num6 * num6 + num7 * num7);
			if (ammo == 4 || ammo == 5)
			{
				if (angle == 4)
				{
					vector.X += 5f;
				}
				vector.Y += 5f;
			}
			num8 = num / num8;
			num6 *= num8;
			num7 *= num8;
			if (Main.myPlayer != owner && Main.netMode == 2 && (ammo == 4 || ammo == 5))
			{
				NetMessage.SendData(108, owner, -1, null, Damage, KnockBack, x, y, angle, ammo, owner);
				return;
			}
			if (Main.netMode == 2)
			{
				owner = Main.myPlayer;
			}
			int num9 = Projectile.NewProjectile(vector.X, vector.Y, num6, num7, type, Damage, KnockBack, owner, num4, num5);
			Main.projectile[num9].originatedFromActivableTile = true;
		}

		public static void SwitchCannon(int i, int j)
		{
			int num;
			for (num = Main.tile[i, j].frameX / 18; num >= 4; num -= 4)
			{
			}
			int num2;
			for (num2 = Main.tile[i, j].frameY / 18; num2 >= 3; num2 -= 3)
			{
			}
			int num3 = 1;
			if (num < 2)
			{
				num3 = -1;
			}
			num = i - num;
			num2 = j - num2;
			if ((num3 == 1 && Main.tile[num, num2].frameY <= 52) || (num3 == -1 && Main.tile[num, num2].frameY >= 432))
			{
				return;
			}
			num3 *= -54;
			for (int k = num; k < num + 4; k++)
			{
				for (int l = num2; l < num2 + 3; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (Main.tile[k, l].active() && Main.tile[k, l].type == 209)
					{
						Main.tile[k, l].frameY = (short)(Main.tile[k, l].frameY + num3);
					}
				}
			}
			NetMessage.SendTileSquare(-1, num + 1, num2 + 1, 4);
		}

		public static void CheckCannon(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = Main.tile[i, j].frameX / 18;
			int num2 = 0;
			while (num >= 4)
			{
				num2++;
				num -= 4;
			}
			num = i - num;
			int num3 = Main.tile[i, j].frameY / 18;
			int num4 = 0;
			while (num3 >= 3)
			{
				num4 += 54;
				num3 -= 3;
			}
			num3 = j - num3;
			int num5 = 72 * num2;
			for (int k = num; k < num + 4; k++)
			{
				int num6 = num4;
				for (int l = num3; l < num3 + 3; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != num5 || Main.tile[k, l].frameY != num6)
					{
						flag = true;
					}
					num6 += 18;
				}
				if (Main.tile[k, num3 + 3] == null)
				{
					Main.tile[k, num3 + 3] = new Tile();
				}
				if (!SolidTileAllowBottomSlope(k, num3 + 3) && k != num && k != num + 3)
				{
					flag = true;
				}
				num5 += 18;
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int m = num; m < num + 4; m++)
			{
				for (int n = num3; n < num3 + 3; n++)
				{
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
					{
						KillTile(m, n);
					}
				}
			}
			int type2 = 928;
			switch (num2)
			{
			case 1:
				type2 = 1337;
				break;
			case 2:
				type2 = 3369;
				break;
			case 3:
			case 4:
				type2 = 3664;
				break;
			}
			Item.NewItem(i * 16, j * 16, 32, 32, type2);
			destroyObject = false;
			for (int num7 = num; num7 < num + 4; num7++)
			{
				for (int num8 = num3; num8 < num3 + 3; num8++)
				{
					TileFrame(num7, num8);
				}
			}
		}

		public static void PlaceCannon(int x, int y, ushort type, int style = 0)
		{
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
			{
				return;
			}
			bool flag = true;
			for (int i = x - 1; i < x + 3; i++)
			{
				for (int j = y - 2; j < y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active())
					{
						flag = false;
					}
				}
				if (Main.tile[i, y + 1] == null)
				{
					Main.tile[i, y + 1] = new Tile();
				}
				if (!SolidTile2(i, y + 1) && i != x - 1 && i != x + 2)
				{
					flag = false;
				}
			}
			int num = 72 * style;
			int num2 = 0;
			if (flag)
			{
				Main.tile[x - 1, y - 2].active(active: true);
				Main.tile[x - 1, y - 2].frameY = (short)num2;
				Main.tile[x - 1, y - 2].frameX = (short)num;
				Main.tile[x - 1, y - 2].type = type;
				Main.tile[x, y - 2].active(active: true);
				Main.tile[x, y - 2].frameY = (short)num2;
				Main.tile[x, y - 2].frameX = (short)(18 + num);
				Main.tile[x, y - 2].type = type;
				Main.tile[x + 1, y - 2].active(active: true);
				Main.tile[x + 1, y - 2].frameY = (short)num2;
				Main.tile[x + 1, y - 2].frameX = (short)(36 + num);
				Main.tile[x + 1, y - 2].type = type;
				Main.tile[x + 2, y - 2].active(active: true);
				Main.tile[x + 2, y - 2].frameY = (short)num2;
				Main.tile[x + 2, y - 2].frameX = (short)(54 + num);
				Main.tile[x + 2, y - 2].type = type;
				Main.tile[x - 1, y - 1].active(active: true);
				Main.tile[x - 1, y - 1].frameY = (short)(num2 + 18);
				Main.tile[x - 1, y - 1].frameX = (short)num;
				Main.tile[x - 1, y - 1].type = type;
				Main.tile[x, y - 1].active(active: true);
				Main.tile[x, y - 1].frameY = (short)(num2 + 18);
				Main.tile[x, y - 1].frameX = (short)(18 + num);
				Main.tile[x, y - 1].type = type;
				Main.tile[x + 1, y - 1].active(active: true);
				Main.tile[x + 1, y - 1].frameY = (short)(num2 + 18);
				Main.tile[x + 1, y - 1].frameX = (short)(36 + num);
				Main.tile[x + 1, y - 1].type = type;
				Main.tile[x + 2, y - 1].active(active: true);
				Main.tile[x + 2, y - 1].frameY = (short)(num2 + 18);
				Main.tile[x + 2, y - 1].frameX = (short)(54 + num);
				Main.tile[x + 2, y - 1].type = type;
				Main.tile[x - 1, y].active(active: true);
				Main.tile[x - 1, y].frameY = (short)(num2 + 36);
				Main.tile[x - 1, y].frameX = (short)num;
				Main.tile[x - 1, y].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = (short)(num2 + 36);
				Main.tile[x, y].frameX = (short)(18 + num);
				Main.tile[x, y].type = type;
				Main.tile[x + 1, y].active(active: true);
				Main.tile[x + 1, y].frameY = (short)(num2 + 36);
				Main.tile[x + 1, y].frameX = (short)(36 + num);
				Main.tile[x + 1, y].type = type;
				Main.tile[x + 2, y].active(active: true);
				Main.tile[x + 2, y].frameY = (short)(num2 + 36);
				Main.tile[x + 2, y].frameX = (short)(54 + num);
				Main.tile[x + 2, y].type = type;
			}
		}

		public static void SwitchMB(int i, int j)
		{
			int num = i;
			int num2 = j;
			int num3;
			for (num3 = Main.tile[i, j].frameY / 18; num3 >= 2; num3 -= 2)
			{
			}
			int num4 = Main.tile[i, j].frameX / 18;
			if (num4 >= 2)
			{
				num4 -= 2;
			}
			num = i - num4;
			num2 = j - num3;
			for (int k = num; k < num + 2; k++)
			{
				for (int l = num2; l < num2 + 2; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (Main.tile[k, l].active() && (Main.tile[k, l].type == 139 || Main.tile[k, l].type == 35))
					{
						if (Main.tile[k, l].frameX < 36)
						{
							Main.tile[k, l].frameX += 36;
						}
						else
						{
							Main.tile[k, l].frameX -= 36;
						}
					}
				}
			}
			if (Wiring.running)
			{
				Wiring.SkipWire(num, num2);
				Wiring.SkipWire(num + 1, num2);
				Wiring.SkipWire(num, num2 + 1);
				Wiring.SkipWire(num + 1, num2 + 1);
			}
			NetMessage.SendTileSquare(-1, num, num2, 3);
		}

		public static void SwitchMonolith(int i, int j)
		{
			int num = i;
			int num2 = j;
			int num3;
			for (num3 = Main.tile[i, j].frameX / 18; num3 >= 2; num3 -= 2)
			{
			}
			int num4 = Main.tile[i, j].frameY / 18;
			if (num4 >= 3)
			{
				num4 -= 3;
			}
			num = i - num3;
			num2 = j - num4;
			for (int k = num; k < num + 2; k++)
			{
				for (int l = num2; l < num2 + 3; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active())
					{
						continue;
					}
					if (Main.tile[k, l].type == 410)
					{
						if (Main.tile[k, l].frameY < 56)
						{
							Main.tile[k, l].frameY += 56;
						}
						else
						{
							Main.tile[k, l].frameY -= 56;
						}
					}
					else if (Main.tile[k, l].type == 480)
					{
						if (Main.tile[k, l].frameY < 54)
						{
							Main.tile[k, l].frameY += 54;
						}
						else
						{
							Main.tile[k, l].frameY -= 54;
						}
					}
					else if (Main.tile[k, l].type == 509)
					{
						if (Main.tile[k, l].frameY < 54)
						{
							Main.tile[k, l].frameY += 54;
						}
						else
						{
							Main.tile[k, l].frameY -= 54;
						}
					}
				}
			}
			if (Wiring.running)
			{
				Wiring.SkipWire(num, num2);
				Wiring.SkipWire(num, num2 + 1);
				Wiring.SkipWire(num, num2 + 2);
				Wiring.SkipWire(num + 1, num2);
				Wiring.SkipWire(num + 1, num2 + 1);
				Wiring.SkipWire(num + 1, num2 + 2);
			}
			NetMessage.SendTileSquare(-1, num, num2 + 1, 3);
		}

		public static void SwitchFountain(int i, int j)
		{
			int num = i;
			int num2 = j;
			int num3;
			for (num3 = Main.tile[i, j].frameX / 18; num3 >= 2; num3 -= 2)
			{
			}
			int num4 = Main.tile[i, j].frameY / 18;
			if (num4 >= 4)
			{
				num4 -= 4;
			}
			num = i - num3;
			num2 = j - num4;
			for (int k = num; k < num + 2; k++)
			{
				for (int l = num2; l < num2 + 4; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (Main.tile[k, l].active() && Main.tile[k, l].type == 207)
					{
						if (Main.tile[k, l].frameY < 72)
						{
							Main.tile[k, l].frameY += 72;
						}
						else
						{
							Main.tile[k, l].frameY -= 72;
						}
					}
				}
			}
			if (Wiring.running)
			{
				Wiring.SkipWire(num, num2);
				Wiring.SkipWire(num, num2 + 1);
				Wiring.SkipWire(num, num2 + 2);
				Wiring.SkipWire(num, num2 + 3);
				Wiring.SkipWire(num + 1, num2);
				Wiring.SkipWire(num + 1, num2 + 1);
				Wiring.SkipWire(num + 1, num2 + 2);
				Wiring.SkipWire(num + 1, num2 + 3);
			}
			NetMessage.SendTileSquare(-1, num, num2 + 1, 4);
		}

		public static void CheckMB(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = i;
			int num2 = j;
			int num3 = 0;
			int num4;
			for (num4 = Main.tile[i, j].frameY / 18; num4 >= 2; num4 -= 2)
			{
				num3++;
			}
			int num5 = Main.tile[i, j].frameX / 18;
			int num6 = 0;
			if (num5 >= 2)
			{
				num5 -= 2;
				num6++;
			}
			num = i - num5;
			num2 = j - num4;
			for (int k = num; k < num + 2; k++)
			{
				for (int l = num2; l < num2 + 2; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num) * 18 + num6 * 36 || Main.tile[k, l].frameY != (l - num2) * 18 + num3 * 36)
					{
						flag = true;
					}
				}
				if (!Main.tile[k, num2 + 2].nactive())
				{
					flag = true;
				}
				else if (!Main.tileSolid[Main.tile[k, num2 + 2].type] && !Main.tileTable[Main.tile[k, num2 + 2].type])
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int m = num; m < num + 2; m++)
			{
				for (int n = num2; n < num2 + 3; n++)
				{
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
					{
						KillTile(m, n);
					}
				}
			}
			if (type == 35)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 1813);
			}
			else if (num3 == 28)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 1963);
			}
			else if (num3 == 29)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 1964);
			}
			else if (num3 == 30)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 1965);
			}
			else if (num3 == 31)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 2742);
			}
			else if (num3 == 32)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 3044);
			}
			else if (num3 == 33)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 3235);
			}
			else if (num3 == 34)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 3236);
			}
			else if (num3 == 35)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 3237);
			}
			else if (num3 == 36)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 3370);
			}
			else if (num3 == 37)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 3371);
			}
			else if (num3 == 38)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 3796);
			}
			else if (num3 == 39)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 3869);
			}
			else if (num3 == 43)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4077);
			}
			else if (num3 == 41)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4078);
			}
			else if (num3 == 42)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4079);
			}
			else if (num3 == 44)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4080);
			}
			else if (num3 == 45)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4081);
			}
			else if (num3 == 40)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4082);
			}
			else if (num3 == 46)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4237);
			}
			else if (num3 == 47)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4356);
			}
			else if (num3 == 48)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4357);
			}
			else if (num3 == 49)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4358);
			}
			else if (num3 == 50)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4421);
			}
			else if (num3 == 51)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4606);
			}
			else if (num3 == 52)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4979);
			}
			else if (num3 == 53)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4985);
			}
			else if (num3 == 54)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4990);
			}
			else if (num3 == 55)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4991);
			}
			else if (num3 == 56)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4992);
			}
			else if (num3 == 57)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5006);
			}
			else if (num3 == 58)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5014);
			}
			else if (num3 == 59)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5015);
			}
			else if (num3 == 60)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5016);
			}
			else if (num3 == 61)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5017);
			}
			else if (num3 == 62)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5018);
			}
			else if (num3 == 63)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5019);
			}
			else if (num3 == 64)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5020);
			}
			else if (num3 == 65)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5021);
			}
			else if (num3 == 66)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5022);
			}
			else if (num3 == 67)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5023);
			}
			else if (num3 == 68)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5024);
			}
			else if (num3 == 69)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5025);
			}
			else if (num3 == 70)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5026);
			}
			else if (num3 == 71)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5027);
			}
			else if (num3 == 72)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5028);
			}
			else if (num3 == 73)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5029);
			}
			else if (num3 == 74)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5030);
			}
			else if (num3 == 75)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5031);
			}
			else if (num3 == 76)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5032);
			}
			else if (num3 == 77)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5033);
			}
			else if (num3 == 78)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5034);
			}
			else if (num3 == 79)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5035);
			}
			else if (num3 == 80)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5036);
			}
			else if (num3 == 81)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5037);
			}
			else if (num3 == 82)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5038);
			}
			else if (num3 == 83)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5039);
			}
			else if (num3 == 84)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5040);
			}
			else if (num3 == 85)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 5044);
			}
			else if (num3 >= 13)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 1596 + num3 - 13);
			}
			else
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 562 + num3);
			}
			for (int num7 = num - 1; num7 < num + 3; num7++)
			{
				for (int num8 = num2 - 1; num8 < num2 + 3; num8++)
				{
					TileFrame(num7, num8);
				}
			}
			destroyObject = false;
		}

		public static void PlaceMB(int X, int y, ushort type, int style)
		{
			int num = X + 1;
			if (num < 5 || num > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
			{
				return;
			}
			bool flag = true;
			for (int i = num - 1; i < num + 1; i++)
			{
				for (int j = y - 1; j < y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active())
					{
						flag = false;
					}
				}
				if (Main.tile[i, y + 1] == null)
				{
					Main.tile[i, y + 1] = new Tile();
				}
				if (!Main.tile[i, y + 1].active() || Main.tile[i, y + 1].halfBrick() || (!Main.tileSolid[Main.tile[i, y + 1].type] && !Main.tileTable[Main.tile[i, y + 1].type]))
				{
					flag = false;
				}
			}
			if (flag)
			{
				Main.tile[num - 1, y - 1].active(active: true);
				Main.tile[num - 1, y - 1].frameY = (short)(style * 36);
				Main.tile[num - 1, y - 1].frameX = 0;
				Main.tile[num - 1, y - 1].type = type;
				Main.tile[num, y - 1].active(active: true);
				Main.tile[num, y - 1].frameY = (short)(style * 36);
				Main.tile[num, y - 1].frameX = 18;
				Main.tile[num, y - 1].type = type;
				Main.tile[num - 1, y].active(active: true);
				Main.tile[num - 1, y].frameY = (short)(style * 36 + 18);
				Main.tile[num - 1, y].frameX = 0;
				Main.tile[num - 1, y].type = type;
				Main.tile[num, y].active(active: true);
				Main.tile[num, y].frameY = (short)(style * 36 + 18);
				Main.tile[num, y].frameX = 18;
				Main.tile[num, y].type = type;
			}
		}

		public static void Place2x2(int x, int y, ushort type, int style)
		{
			if (type == 95 || type == 126)
			{
				y++;
			}
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
			{
				return;
			}
			if (type == 172)
			{
				if (!CanPlaceSink(x, y, type, style))
				{
					return;
				}
			}
			else
			{
				for (int i = x - 1; i < x + 1; i++)
				{
					for (int j = y - 1; j < y + 1; j++)
					{
						Tile tileSafely = Framing.GetTileSafely(i, j);
						if (tileSafely.active() || (type == 98 && tileSafely.liquid > 0))
						{
							return;
						}
					}
					switch (type)
					{
					case 95:
					case 126:
					{
						Tile tileSafely = Framing.GetTileSafely(i, y - 2);
						if (!tileSafely.nactive() || !Main.tileSolid[tileSafely.type] || Main.tileSolidTop[tileSafely.type])
						{
							return;
						}
						break;
					}
					default:
					{
						Tile tileSafely = Framing.GetTileSafely(i, y + 1);
						if (!tileSafely.nactive() || (!SolidTile2(tileSafely) && !Main.tileTable[tileSafely.type]))
						{
							return;
						}
						break;
					}
					case 132:
						break;
					}
				}
			}
			if (type == 132)
			{
				bool flag = true;
				if (Main.tile[x - 1, y + 1] == null)
				{
					Main.tile[x - 1, y + 1] = new Tile();
				}
				if (Main.tile[x, y + 1] == null)
				{
					Main.tile[x, y + 1] = new Tile();
				}
				if (!Main.tile[x - 1, y + 1].nactive() || (!SolidTile2(x - 1, y + 1) && !Main.tileTable[Main.tile[x - 1, y + 1].type]))
				{
					flag = false;
				}
				if (!Main.tile[x, y + 1].nactive() || (!SolidTile2(x, y + 1) && !Main.tileTable[Main.tile[x, y + 1].type]))
				{
					flag = false;
				}
				if (!flag && (Main.tile[x - 1, y - 1].wall < 1 || Main.tile[x, y - 1].wall < 1 || Main.tile[x - 1, y].wall < 1 || Main.tile[x - 1, y].wall < 1))
				{
					return;
				}
			}
			x--;
			y--;
			int num = ((type == 172) ? 38 : 36);
			for (int k = 0; k < 2; k++)
			{
				for (int l = 0; l < 2; l++)
				{
					Tile tileSafely = Main.tile[x + k, y + l];
					tileSafely.active(active: true);
					tileSafely.frameX = (short)(k * 18);
					tileSafely.frameY = (short)(style * num + l * 18);
					tileSafely.type = type;
				}
			}
		}

		public static bool PlaceObject(int x, int y, int type, bool mute = false, int style = 0, int alternate = 0, int random = -1, int direction = -1)
		{
			if (type >= 623)
			{
				return false;
			}
			if (!TileObject.CanPlace(x, y, type, style, direction, out var objectData))
			{
				return false;
			}
			objectData.random = random;
			if (TileObject.Place(objectData) && !mute)
			{
				SquareTileFrame(x, y);
				SoundEngine.PlaySound(0, x * 16, y * 16);
			}
			return true;
		}

		public static bool ShiftTrapdoor(int x, int y, bool playerAbove, int onlyCloseOrOpen = -1)
		{
			Tile tileSafely = Framing.GetTileSafely(x, y);
			if (tileSafely.type == 386 && onlyCloseOrOpen != 1)
			{
				Point topLeftAndStyles = GetTopLeftAndStyles(x, y, 2, 2, 18, 18);
				if (topLeftAndStyles.X == 0)
				{
					if (Main.netMode != 1 && Wiring.running)
					{
						Wiring.SkipWire(x, y);
						Wiring.SkipWire(x, y + 1);
						Wiring.SkipWire(x + 1, y);
						Wiring.SkipWire(x + 1, y + 1);
					}
					if (!Collision.EmptyTile(x, y + 1, ignoreTiles: true) || !Collision.EmptyTile(x + 1, y + 1, ignoreTiles: true))
					{
						return false;
					}
					SoundEngine.PlaySound(8, x * 16 + 16, y * 16 + 16);
					for (int i = 0; i < 2; i++)
					{
						tileSafely = Framing.GetTileSafely(x + i, y);
						tileSafely.ClearTile();
					}
					for (int j = 0; j < 2; j++)
					{
						tileSafely = Framing.GetTileSafely(x + j, y + 1);
						tileSafely.type = 387;
						tileSafely.frameX = (short)(j * 18);
						tileSafely.frameY = (short)(topLeftAndStyles.Y * 18);
					}
					for (int k = -1; k < 3; k++)
					{
						for (int l = 0; l < 3; l++)
						{
							TileFrame(x + k, y + l);
						}
					}
					return true;
				}
				if (topLeftAndStyles.X == 1)
				{
					if (Main.netMode != 1 && Wiring.running)
					{
						Wiring.SkipWire(x, y - 1);
						Wiring.SkipWire(x, y);
						Wiring.SkipWire(x + 1, y - 1);
						Wiring.SkipWire(x + 1, y);
					}
					if (!Collision.EmptyTile(x, y, ignoreTiles: true) || !Collision.EmptyTile(x + 1, y, ignoreTiles: true))
					{
						return false;
					}
					SoundEngine.PlaySound(8, x * 16 + 16, y * 16);
					for (int m = 0; m < 2; m++)
					{
						tileSafely = Framing.GetTileSafely(x + m, y + 1);
						tileSafely.ClearTile();
					}
					for (int n = 0; n < 2; n++)
					{
						tileSafely = Framing.GetTileSafely(x + n, y);
						tileSafely.type = 387;
						tileSafely.frameX = (short)(n * 18);
						tileSafely.frameY = (short)(topLeftAndStyles.Y * 18);
					}
					for (int num = -1; num < 3; num++)
					{
						for (int num2 = -1; num2 < 2; num2++)
						{
							TileFrame(x + num, y + num2);
						}
					}
					return true;
				}
			}
			if (tileSafely.type == 387 && onlyCloseOrOpen != 0)
			{
				GetTopLeftAndStyles(x, y, 2, 1, 18, 18);
				int num3 = playerAbove.ToDirectionInt();
				for (int num4 = 0; num4 < 2; num4++)
				{
					tileSafely = Framing.GetTileSafely(x + num4, y + num3);
					if (tileSafely.active() && !Main.tileCut[tileSafely.type])
					{
						return false;
					}
				}
				if (Main.netMode != 1 && Wiring.running)
				{
					Wiring.SkipWire(x, y);
					Wiring.SkipWire(x, y + num3);
					Wiring.SkipWire(x + 1, y);
					Wiring.SkipWire(x + 1, y + num3);
				}
				SoundEngine.PlaySound(8, x * 16 + 16, y * 16);
				for (int num5 = 0; num5 < 2; num5++)
				{
					tileSafely = Framing.GetTileSafely(x + num5, y + num3);
					if (tileSafely.active() && Main.tileCut[tileSafely.type])
					{
						KillTile(x + num5, y + num3);
					}
				}
				for (int num6 = 0; num6 < 2; num6++)
				{
					tileSafely = Framing.GetTileSafely(x + num6, y);
					byte color = tileSafely.color();
					for (int num7 = 0; num7 < 2; num7++)
					{
						tileSafely = Framing.GetTileSafely(x + num6, y + num7 - (!playerAbove).ToInt());
						tileSafely.type = 386;
						tileSafely.frameX = (short)(num6 * 18 + playerAbove.ToInt() * 36);
						tileSafely.frameY = (short)(num7 * 18);
						tileSafely.color(color);
						tileSafely.active(active: true);
					}
				}
				for (int num8 = -1; num8 < 3; num8++)
				{
					for (int num9 = -1; num9 < 3; num9++)
					{
						TileFrame(x + num8, y + num9 - (!playerAbove).ToInt() * 2);
					}
				}
				return true;
			}
			SoundEngine.PlaySound(9, x * 16, y * 16);
			return false;
		}

		public static void CheckTrapDoor(int x, int y, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = 0;
			int num2 = 0;
			Point point = default(Point);
			if (type == 387)
			{
				num = 2;
				num2 = 1;
				point = GetTopLeftAndStyles(x, y, num, num2, 18, 18);
				flag = flag || !CheckTileFrames(type, x, y, num, num2, point.X, 18, point.Y, 18) || !CheckTileAnchors(x, y, num, num2, 1, AnchorType.SolidTile);
			}
			if (type == 386)
			{
				num = 2;
				num2 = 2;
				point = GetTopLeftAndStyles(x, y, num, num2, 18, 18);
				flag = flag || !CheckTileFrames(type, x, y, num, num2, point.X, 18, point.Y, 18);
				if (point.X == 0)
				{
					flag = flag || !CheckTileAnchors(x, y + 1, num, 1, 1, AnchorType.SolidTile);
				}
				else if (point.X == 1)
				{
					flag = flag || !CheckTileAnchors(x, y, num, 1, 1, AnchorType.SolidTile);
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int i = x; i < x + num; i++)
			{
				for (int j = y; j < y + num2; j++)
				{
					KillTile(i, j);
				}
			}
			int type2 = 3239;
			if (point.Y == 0)
			{
				type2 = 3239;
			}
			Item.NewItem(x * 16, y * 16, num * 16, num2 * 16, type2);
			for (int k = x - 1; k < x + num + 1; k++)
			{
				for (int l = y - 1; l < y + num2 + 1; l++)
				{
					TileFrame(k, l);
				}
			}
			destroyObject = false;
		}

		public static void CheckTallGate(int x, int y, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			Tile tileSafely = Framing.GetTileSafely(x, y);
			Point point = new Point(tileSafely.frameX / 18, 0);
			TileObjectData tileData = TileObjectData.GetTileData(type, point.X);
			point.Y = tileSafely.frameY / tileData.CoordinateFullHeight;
			int width = tileData.Width;
			int height = tileData.Height;
			int i = 0;
			for (int num = tileSafely.frameY % tileData.CoordinateFullHeight; i < height && num - tileData.CoordinateHeights[i] >= 0; i++)
			{
				num -= tileData.CoordinateHeights[i];
			}
			_ = tileData.CoordinateFullHeight;
			y -= i;
			int num2 = point.Y * tileData.CoordinateFullHeight;
			for (int j = 0; j < height; j++)
			{
				tileSafely = Framing.GetTileSafely(x, y + j);
				if (tileSafely.frameX != point.X * tileData.CoordinateFullWidth || tileSafely.frameY != num2)
				{
					flag = true;
					break;
				}
				num2 += tileData.CoordinateHeights[j] + tileData.CoordinatePadding;
			}
			if (!flag && CheckTileAnchors(x, y, width, height, 2, AnchorType.SolidTile))
			{
				return;
			}
			destroyObject = true;
			for (int k = x; k < x + width; k++)
			{
				for (int l = y; l < y + height; l++)
				{
					KillTile(k, l);
				}
			}
			int type2 = 3240;
			if (point.Y == 0)
			{
				type2 = 3240;
			}
			Item.NewItem(x * 16, y * 16, width * 16, height * 16, type2);
			for (int m = x - 1; m < x + width + 1; m++)
			{
				for (int n = y - 1; n < y + height + 1; n++)
				{
					TileFrame(m, n);
				}
			}
			destroyObject = false;
		}

		public static bool ShiftTallGate(int x, int y, bool closing, bool forced = false)
		{
			ushort type = (ushort)(closing ? 388 : 389);
			ushort num = (ushort)(closing ? 389 : 388);
			Tile tileSafely = Framing.GetTileSafely(x, y);
			if (tileSafely.type != num)
			{
				return false;
			}
			Point point = new Point(tileSafely.frameX / 18, 0);
			TileObjectData tileData = TileObjectData.GetTileData(388, point.X);
			point.Y = tileSafely.frameY / tileData.CoordinateFullHeight;
			_ = tileData.Width;
			int height = tileData.Height;
			int i = 0;
			for (int num2 = tileSafely.frameY % tileData.CoordinateFullHeight; i < height && num2 - tileData.CoordinateHeights[i] >= 0; i++)
			{
				num2 -= tileData.CoordinateHeights[i];
			}
			_ = tileData.CoordinateFullHeight;
			y -= i;
			if (Main.netMode != 1 && Wiring.running)
			{
				for (int j = 0; j < height; j++)
				{
					Wiring.SkipWire(x, y + j);
				}
			}
			for (int k = 0; k < height; k++)
			{
				if (!forced && !Collision.EmptyTile(x, y + k, ignoreTiles: true))
				{
					return false;
				}
			}
			SoundEngine.PlaySound(8, x * 16 + 16, y * 16 + 16);
			for (int l = 0; l < height; l++)
			{
				tileSafely = Framing.GetTileSafely(x, y + l);
				tileSafely.type = type;
			}
			for (int m = -1; m < 2; m++)
			{
				for (int n = -1; n < height + 1; n++)
				{
					TileFrame(x + m, y + n);
				}
			}
			return true;
		}

		public static Point GetTopLeftAndStyles(int x, int y, int w, int h, int frameXinc, int frameYinc)
		{
			Tile tileSafely = Framing.GetTileSafely(x, y);
			Point result = new Point(tileSafely.frameX / (w * frameXinc), tileSafely.frameY / (h * frameYinc));
			if (frameXinc != 0)
			{
				x -= tileSafely.frameX / frameXinc % w;
			}
			if (frameYinc != 0)
			{
				y -= tileSafely.frameY / frameYinc % h;
			}
			return result;
		}

		public static bool CheckTileFrames(int type, int sx, int sy, int w, int h, int styleX, int frameXinc, int styleY, int frameYinc)
		{
			for (int i = 0; i < w; i++)
			{
				for (int j = 0; j < h; j++)
				{
					Tile tileSafely = Framing.GetTileSafely(sx + i, sy + j);
					if (!tileSafely.active() || tileSafely.type != type || tileSafely.frameX != styleX * w * frameXinc + i * frameXinc || tileSafely.frameY != styleY * h * frameYinc + j * frameYinc)
					{
						return false;
					}
				}
			}
			return true;
		}

		public static bool CheckTileAnchors(int sx, int sy, int w, int h, int mode, AnchorType anchor)
		{
			if ((mode & 1) == 1)
			{
				for (int i = sy; i < sy + h; i++)
				{
					if (!AnchorValid(Framing.GetTileSafely(sx - 1, i), anchor))
					{
						return false;
					}
					if (!AnchorValid(Framing.GetTileSafely(sx + w, i), anchor))
					{
						return false;
					}
				}
			}
			if ((mode & 2) == 2)
			{
				for (int j = sx; j < sx + w; j++)
				{
					if (!AnchorValid(Framing.GetTileSafely(j, sy - 1), anchor))
					{
						return false;
					}
					if (!AnchorValid(Framing.GetTileSafely(j, sy + h), anchor))
					{
						return false;
					}
				}
			}
			return true;
		}

		public static bool AnchorValid(Tile tileCache, AnchorType anchor)
		{
			bool flag = false;
			if (tileCache.nactive())
			{
				if ((anchor & AnchorType.SolidTile) == AnchorType.SolidTile && Main.tileSolid[tileCache.type] && !Main.tileSolidTop[tileCache.type] && !Main.tileNoAttach[tileCache.type] && tileCache.blockType() == 0)
				{
					flag = true;
				}
				if ((anchor & AnchorType.SolidBottom) == AnchorType.SolidBottom && ((Main.tileSolid[tileCache.type] && (!Main.tileSolidTop[tileCache.type] || (TileID.Sets.Platforms[tileCache.type] && (tileCache.halfBrick() || tileCache.topSlope())))) || tileCache.topSlope() || tileCache.halfBrick()) && !TileID.Sets.NotReallySolid[tileCache.type] && !tileCache.bottomSlope())
				{
					flag = true;
				}
				if (!flag && ((anchor & AnchorType.SolidWithTop) == AnchorType.SolidWithTop || (anchor & AnchorType.Table) == AnchorType.Table))
				{
					if (TileID.Sets.Platforms[tileCache.type])
					{
						int num = tileCache.frameX / TileObjectData.PlatformFrameWidth();
						if ((!tileCache.halfBrick() && num >= 0 && num <= 7) || (num >= 12 && num <= 16) || (num >= 25 && num <= 26))
						{
							flag = true;
						}
					}
					else if (Main.tileSolid[tileCache.type] && Main.tileSolidTop[tileCache.type])
					{
						flag = true;
					}
				}
				if (!flag && (anchor & AnchorType.Table) == AnchorType.Table && !TileID.Sets.Platforms[tileCache.type] && Main.tileTable[tileCache.type] && tileCache.blockType() == 0)
				{
					flag = true;
				}
				if (!flag && (anchor & AnchorType.SolidSide) == AnchorType.SolidSide && Main.tileSolid[tileCache.type] && !Main.tileSolidTop[tileCache.type])
				{
					int num2 = tileCache.blockType();
					if ((uint)(num2 - 4) <= 1u)
					{
						flag = true;
					}
				}
			}
			else if (!flag && (anchor & AnchorType.EmptyTile) == AnchorType.EmptyTile)
			{
				flag = true;
			}
			return flag;
		}

		public static bool CanPlaceSink(int x, int y, ushort type, int style)
		{
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
			{
				return false;
			}
			bool result = true;
			x--;
			y--;
			for (int i = 0; i < 2; i++)
			{
				Tile tileSafely;
				for (int j = 0; j < 2; j++)
				{
					tileSafely = Framing.GetTileSafely(x + i, y + j);
					if (tileSafely.active())
					{
						result = false;
					}
				}
				tileSafely = Framing.GetTileSafely(x + i, y + 2);
				if (!tileSafely.nactive() || !SolidTile(tileSafely))
				{
					result = false;
				}
			}
			return result;
		}

		public static void Place3x4(int x, int y, ushort type, int style)
		{
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
			{
				return;
			}
			bool flag = true;
			for (int i = x - 1; i < x + 2; i++)
			{
				for (int j = y - 3; j < y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active())
					{
						flag = false;
					}
				}
				if (Main.tile[i, y + 1] == null)
				{
					Main.tile[i, y + 1] = new Tile();
				}
				if (!SolidTile2(i, y + 1))
				{
					flag = false;
				}
			}
			if (flag)
			{
				int num = style * 54;
				for (int k = -3; k <= 0; k++)
				{
					short frameY = (short)((3 + k) * 18);
					Main.tile[x - 1, y + k].active(active: true);
					Main.tile[x - 1, y + k].frameY = frameY;
					Main.tile[x - 1, y + k].frameX = (short)num;
					Main.tile[x - 1, y + k].type = type;
					Main.tile[x, y + k].active(active: true);
					Main.tile[x, y + k].frameY = frameY;
					Main.tile[x, y + k].frameX = (short)(num + 18);
					Main.tile[x, y + k].type = type;
					Main.tile[x + 1, y + k].active(active: true);
					Main.tile[x + 1, y + k].frameY = frameY;
					Main.tile[x + 1, y + k].frameX = (short)(num + 36);
					Main.tile[x + 1, y + k].type = type;
				}
			}
		}

		public static void Place5x4(int x, int y, ushort type, int style)
		{
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
			{
				return;
			}
			bool flag = true;
			for (int i = x - 2; i < x + 3; i++)
			{
				for (int j = y - 3; j < y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active())
					{
						flag = false;
					}
				}
				if (Main.tile[i, y + 1] == null)
				{
					Main.tile[i, y + 1] = new Tile();
				}
				if (!SolidTile2(i, y + 1))
				{
					flag = false;
				}
			}
			if (flag)
			{
				int num = style * 54;
				for (int k = -3; k <= 0; k++)
				{
					short frameY = (short)((3 + k) * 18);
					Main.tile[x - 2, y + k].active(active: true);
					Main.tile[x - 2, y + k].frameY = frameY;
					Main.tile[x - 2, y + k].frameX = (short)(num - 36);
					Main.tile[x - 2, y + k].type = type;
					Main.tile[x - 1, y + k].active(active: true);
					Main.tile[x - 1, y + k].frameY = frameY;
					Main.tile[x - 1, y + k].frameX = (short)(num - 18);
					Main.tile[x - 1, y + k].type = type;
					Main.tile[x, y + k].active(active: true);
					Main.tile[x, y + k].frameY = frameY;
					Main.tile[x, y + k].frameX = (short)num;
					Main.tile[x, y + k].type = type;
					Main.tile[x + 1, y + k].active(active: true);
					Main.tile[x + 1, y + k].frameY = frameY;
					Main.tile[x + 1, y + k].frameX = (short)(num + 18);
					Main.tile[x + 1, y + k].type = type;
					Main.tile[x + 1, y + k].active(active: true);
					Main.tile[x + 1, y + k].frameY = frameY;
					Main.tile[x + 1, y + k].frameX = (short)(num + 36);
					Main.tile[x + 1, y + k].type = type;
				}
			}
		}

		public static void Place3x1(int x, int y, ushort type, int style = 0)
		{
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
			{
				return;
			}
			bool flag = true;
			for (int i = x - 1; i < x + 2; i++)
			{
				if (Main.tile[i, y] == null)
				{
					Main.tile[i, y] = new Tile();
				}
				if (Main.tile[i, y].active())
				{
					flag = false;
				}
				if (Main.tile[i, y + 1] == null)
				{
					Main.tile[i, y + 1] = new Tile();
				}
				if (!SolidTile2(i, y + 1))
				{
					flag = false;
				}
			}
			if (flag)
			{
				short num = (short)(54 * style);
				Main.tile[x - 1, y].active(active: true);
				Main.tile[x - 1, y].frameY = 0;
				Main.tile[x - 1, y].frameX = num;
				Main.tile[x - 1, y].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = 0;
				Main.tile[x, y].frameX = (short)(num + 18);
				Main.tile[x, y].type = type;
				Main.tile[x + 1, y].active(active: true);
				Main.tile[x + 1, y].frameY = 0;
				Main.tile[x + 1, y].frameX = (short)(num + 36);
				Main.tile[x + 1, y].type = type;
			}
		}

		public static void Place3x2(int x, int y, ushort type, int style = 0)
		{
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
			{
				return;
			}
			bool flag = false;
			bool flag2 = true;
			if (type == 14 && style == 25)
			{
				flag = true;
			}
			int num = y - 1;
			if (flag)
			{
				num = y;
			}
			for (int i = x - 1; i < x + 2; i++)
			{
				for (int j = num; j < y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active())
					{
						flag2 = false;
					}
					if (type == 215 && Main.tile[i, j].liquid > 0)
					{
						flag2 = false;
					}
				}
				if (Main.tile[i, y + 1] == null)
				{
					Main.tile[i, y + 1] = new Tile();
				}
				switch (type)
				{
				default:
					if (type != 582 && type != 619)
					{
						if (type == 26 && Main.tile[i, y + 1].type == 484)
						{
							flag2 = false;
						}
						if (!SolidTile2(i, y + 1))
						{
							flag2 = false;
						}
						break;
					}
					goto case 285;
				case 285:
				case 286:
				case 298:
				case 299:
				case 310:
				case 361:
				case 362:
				case 363:
				case 364:
					if (!SolidTile2(i, y + 1) && (!Main.tile[i, y + 1].nactive() || !Main.tileSolidTop[Main.tile[i, y + 1].type] || Main.tile[i, y + 1].frameY != 0))
					{
						flag2 = false;
					}
					break;
				}
			}
			if (type == 88)
			{
				if (Chest.CreateChest(x - 1, y - 1) == -1)
				{
					flag2 = false;
				}
				else if (Main.netMode == 1)
				{
					NetMessage.SendData(34, -1, -1, null, 2, x, y, style);
				}
			}
			if (flag2)
			{
				short num2 = (short)(54 * style);
				if (flag)
				{
					Main.tile[x - 1, y].active(active: true);
					Main.tile[x - 1, y].frameY = 0;
					Main.tile[x - 1, y].frameX = num2;
					Main.tile[x - 1, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameY = 0;
					Main.tile[x, y].frameX = (short)(num2 + 18);
					Main.tile[x, y].type = type;
					Main.tile[x + 1, y].active(active: true);
					Main.tile[x + 1, y].frameY = 0;
					Main.tile[x + 1, y].frameX = (short)(num2 + 36);
					Main.tile[x + 1, y].type = type;
					return;
				}
				Main.tile[x - 1, y - 1].active(active: true);
				Main.tile[x - 1, y - 1].frameY = 0;
				Main.tile[x - 1, y - 1].frameX = num2;
				Main.tile[x - 1, y - 1].type = type;
				Main.tile[x, y - 1].active(active: true);
				Main.tile[x, y - 1].frameY = 0;
				Main.tile[x, y - 1].frameX = (short)(num2 + 18);
				Main.tile[x, y - 1].type = type;
				Main.tile[x + 1, y - 1].active(active: true);
				Main.tile[x + 1, y - 1].frameY = 0;
				Main.tile[x + 1, y - 1].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y - 1].type = type;
				Main.tile[x - 1, y].active(active: true);
				Main.tile[x - 1, y].frameY = 18;
				Main.tile[x - 1, y].frameX = num2;
				Main.tile[x - 1, y].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = 18;
				Main.tile[x, y].frameX = (short)(num2 + 18);
				Main.tile[x, y].type = type;
				Main.tile[x + 1, y].active(active: true);
				Main.tile[x + 1, y].frameY = 18;
				Main.tile[x + 1, y].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y].type = type;
			}
		}

		public static void Place2x2Style(int x, int y, ushort type, int style = 0)
		{
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
			{
				return;
			}
			short num = 0;
			if (type == 254)
			{
				num = (short)(x % 12 / 2);
				num = (short)(num * 36);
			}
			bool flag = true;
			for (int i = x - 1; i < x + 1; i++)
			{
				for (int j = y - 1; j < y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active())
					{
						flag = false;
					}
				}
				if (Main.tile[i, y + 1] == null)
				{
					Main.tile[i, y + 1] = new Tile();
				}
				if (!SolidTile(i, y + 1))
				{
					flag = false;
				}
				if (type == 254 && Main.tile[i, y + 1].type != 2 && Main.tile[i, y + 1].type != 477 && Main.tile[i, y + 1].type != 492 && Main.tile[i, y + 1].type != 109)
				{
					flag = false;
				}
			}
			if (flag)
			{
				short num2 = (short)(36 * style);
				Main.tile[x - 1, y - 1].active(active: true);
				Main.tile[x - 1, y - 1].frameY = num;
				Main.tile[x - 1, y - 1].frameX = num2;
				Main.tile[x - 1, y - 1].type = type;
				Main.tile[x, y - 1].active(active: true);
				Main.tile[x, y - 1].frameY = num;
				Main.tile[x, y - 1].frameX = (short)(num2 + 18);
				Main.tile[x, y - 1].type = type;
				Main.tile[x - 1, y].active(active: true);
				Main.tile[x - 1, y].frameY = (short)(num + 18);
				Main.tile[x - 1, y].frameX = num2;
				Main.tile[x - 1, y].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = (short)(num + 18);
				Main.tile[x, y].frameX = (short)(num2 + 18);
				Main.tile[x, y].type = type;
			}
		}

		public static bool NearFriendlyWall(int x, int y)
		{
			try
			{
				if (x < 2 || x >= Main.maxTilesX - 2 || y < 2 || y >= Main.maxTilesY - 2)
				{
					return true;
				}
				if (Main.tile[x, y].wall == 0 || Main.wallHouse[Main.tile[x, y].wall])
				{
					return true;
				}
				if (Main.tile[x - 1, y].wall == 0 || Main.wallHouse[Main.tile[x - 1, y].wall])
				{
					return true;
				}
				if (Main.tile[x + 1, y].wall == 0 || Main.wallHouse[Main.tile[x + 1, y].wall])
				{
					return true;
				}
				if (Main.tile[x, y - 1].wall == 0 || Main.wallHouse[Main.tile[x, y - 1].wall])
				{
					return true;
				}
				if (Main.tile[x, y + 1].wall == 0 || Main.wallHouse[Main.tile[x, y + 1].wall])
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static void Check2x2Style(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = j;
			int num2;
			for (num2 = Main.tile[i, j].frameY / 18; num2 > 1; num2 -= 2)
			{
			}
			num -= num2;
			int num3 = Main.tile[i, j].frameX / 18;
			int num4 = 0;
			while (num3 > 1)
			{
				num3 -= 2;
				num4++;
			}
			num3 = i - num3;
			int num5 = num4 * 36;
			for (int k = num3; k < num3 + 2; k++)
			{
				for (int l = num; l < num + 2; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num3) * 18 + num5)
					{
						flag = true;
					}
				}
				if (!SolidTileAllowBottomSlope(k, num + 2))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			int frameX = Main.tile[i, j].frameX;
			destroyObject = true;
			for (int m = num3; m < num3 + 2; m++)
			{
				for (int n = num; n < num + 2; n++)
				{
					if (Main.tile[m, n] == null)
					{
						Main.tile[m, n] = new Tile();
					}
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
					{
						KillTile(m, n);
					}
				}
			}
			switch (type)
			{
			case 254:
				if (frameX < 72)
				{
					break;
				}
				if (frameX < 108)
				{
					if (genRand.Next(2) == 0)
					{
						Item.NewItem(i * 16, j * 16, 32, 32, 1725, genRand.Next(1, 3));
					}
					break;
				}
				if (frameX < 144)
				{
					Item.NewItem(i * 16, j * 16, 32, 32, 1725, genRand.Next(2, 6));
					break;
				}
				Item.NewItem(i * 16, j * 16, 32, 32, 1725, genRand.Next(5, 11));
				if (Main.halloween && genRand.Next(200) == 0)
				{
					Item.NewItem(i * 16, j * 16, 32, 32, 1799);
				}
				break;
			case 457:
				Item.NewItem(i * 16, j * 16, 32, 32, 3749);
				break;
			case 96:
				if (num4 == 0)
				{
					Item.NewItem(i * 16, j * 16, 32, 32, 345);
				}
				if (num4 == 1)
				{
					Item.NewItem(i * 16, j * 16, 32, 32, 1791);
				}
				break;
			case 441:
			{
				int num7 = -1;
				switch (num4)
				{
				case 0:
					num7 = 3665;
					break;
				case 1:
					num7 = 3666;
					break;
				case 3:
					num7 = 3667;
					break;
				case 7:
					num7 = 3668;
					break;
				case 8:
					num7 = 3669;
					break;
				case 9:
					num7 = 3670;
					break;
				case 10:
					num7 = 3671;
					break;
				case 11:
					num7 = 3672;
					break;
				case 12:
					num7 = 3673;
					break;
				case 13:
					num7 = 3674;
					break;
				case 14:
					num7 = 3675;
					break;
				case 15:
					num7 = 3676;
					break;
				case 16:
					num7 = 3677;
					break;
				case 17:
					num7 = 3678;
					break;
				case 18:
					num7 = 3679;
					break;
				case 19:
					num7 = 3680;
					break;
				case 20:
					num7 = 3681;
					break;
				case 21:
					num7 = 3682;
					break;
				case 22:
					num7 = 3683;
					break;
				case 28:
					num7 = 3684;
					break;
				case 29:
					num7 = 3685;
					break;
				case 30:
					num7 = 3686;
					break;
				case 31:
					num7 = 3687;
					break;
				case 32:
					num7 = 3688;
					break;
				case 33:
					num7 = 3689;
					break;
				case 34:
					num7 = 3690;
					break;
				case 35:
					num7 = 3691;
					break;
				case 37:
					num7 = 3692;
					break;
				case 39:
					num7 = 3693;
					break;
				case 41:
					num7 = 3694;
					break;
				case 42:
					num7 = 3695;
					break;
				case 43:
					num7 = 3696;
					break;
				case 44:
					num7 = 3697;
					break;
				case 45:
					num7 = 3698;
					break;
				case 46:
					num7 = 3699;
					break;
				case 47:
					num7 = 3700;
					break;
				case 48:
					num7 = 3701;
					break;
				case 49:
					num7 = 3702;
					break;
				case 50:
					num7 = 3703;
					break;
				case 51:
					num7 = 3704;
					break;
				}
				if (num7 != -1)
				{
					Item.NewItem(i * 16, j * 16, 32, 32, num7);
				}
				break;
			}
			case 468:
			{
				int num6 = -1;
				switch (num4)
				{
				case 0:
					num6 = 3886;
					break;
				case 1:
					num6 = 3887;
					break;
				case 2:
					num6 = 3950;
					break;
				case 3:
					num6 = 3976;
					break;
				case 4:
					num6 = -1;
					break;
				case 5:
					num6 = 4164;
					break;
				case 6:
					num6 = 4185;
					break;
				case 7:
					num6 = 4206;
					break;
				case 8:
					num6 = 4227;
					break;
				case 9:
					num6 = 4266;
					break;
				case 10:
					num6 = 4268;
					break;
				case 11:
					num6 = 4585;
					break;
				case 12:
					num6 = 4713;
					break;
				}
				if (num6 != -1)
				{
					Item.NewItem(i * 16, j * 16, 32, 32, num6);
				}
				break;
			}
			}
			destroyObject = false;
			for (int num8 = num3 - 1; num8 < num3 + 3; num8++)
			{
				for (int num9 = num - 1; num9 < num + 3; num9++)
				{
					TileFrame(num8, num9);
				}
			}
		}

		public static void PlacePumpkin(int x, int superY)
		{
			ushort type = 254;
			int num = genRand.Next(6) * 36;
			if (x < 5 || x > Main.maxTilesX - 5 || superY < 5 || superY > Main.maxTilesY - 5)
			{
				return;
			}
			bool flag = true;
			for (int i = x - 1; i < x + 1; i++)
			{
				for (int j = superY - 1; j < superY + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active() && Main.tile[i, j].type != 3 && Main.tile[i, j].type != 73 && Main.tile[i, j].type != 113 && Main.tile[i, j].type != 110 && (Main.tile[i, j].type != 185 || Main.tile[i, j].frameY != 0))
					{
						flag = false;
					}
					if (Main.tile[i, j].liquid > 0)
					{
						flag = false;
					}
				}
				if (!SolidTile(i, superY + 1) || (Main.tile[i, superY + 1].type != 2 && Main.tile[i, superY + 1].type != 109))
				{
					flag = false;
				}
			}
			if (flag)
			{
				Main.tile[x - 1, superY - 1].active(active: true);
				Main.tile[x - 1, superY - 1].frameY = (short)num;
				Main.tile[x - 1, superY - 1].frameX = 0;
				Main.tile[x - 1, superY - 1].type = type;
				Main.tile[x, superY - 1].active(active: true);
				Main.tile[x, superY - 1].frameY = (short)num;
				Main.tile[x, superY - 1].frameX = 18;
				Main.tile[x, superY - 1].type = type;
				Main.tile[x - 1, superY].active(active: true);
				Main.tile[x - 1, superY].frameY = (short)(num + 18);
				Main.tile[x - 1, superY].frameX = 0;
				Main.tile[x - 1, superY].type = type;
				Main.tile[x, superY].active(active: true);
				Main.tile[x, superY].frameY = (short)(num + 18);
				Main.tile[x, superY].frameX = 18;
				Main.tile[x, superY].type = type;
			}
		}

		public static void GrowPumpkin(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = j;
			int num2;
			for (num2 = Main.tile[i, j].frameY / 18; num2 > 1; num2 -= 2)
			{
			}
			num -= num2;
			int num3 = Main.tile[i, j].frameX / 18;
			int num4 = 0;
			while (num3 > 1)
			{
				num3 -= 2;
				num4++;
			}
			num3 = i - num3;
			int num5 = num4 * 36;
			if (num4 >= 4)
			{
				return;
			}
			for (int k = num3; k < num3 + 2; k++)
			{
				for (int l = num; l < num + 2; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num3) * 18 + num5)
					{
						flag = true;
					}
				}
				if (!SolidTile(k, num + 2) || (Main.tile[k, num + 2].type != 2 && Main.tile[k, num + 2].type != 477 && Main.tile[k, num + 2].type != 492 && Main.tile[k, num + 2].type != 109))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				for (int m = num3; m < num3 + 2; m++)
				{
					for (int n = num; n < num + 2; n++)
					{
						if (Main.tile[m, n] == null)
						{
							Main.tile[m, n] = new Tile();
						}
						if (Main.tile[m, n].type == type && Main.tile[m, n].active())
						{
							Main.tile[m, n].frameX += 36;
						}
					}
				}
			}
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, num3, num, 4);
			}
		}

		public static void FixHearts()
		{
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				for (int j = 0; j < Main.maxTilesY; j++)
				{
					Tile tile = Main.tile[i, j];
					if (tile.active() && tile.type == 12 && tile.frameX == 0 && tile.frameY == 0)
					{
						FixHeart(i, j);
					}
				}
			}
		}

		public static void DestroyHeart(int i, int j)
		{
			destroyObject = true;
			for (int k = i; k < i + 2; k++)
			{
				for (int l = j; l < j + 2; l++)
				{
					if (k < Main.maxTilesX && l < Main.maxTilesY)
					{
						Tile tile = Main.tile[k, l];
						if (tile.active() && tile.type == 12)
						{
							KillTile(k, l);
						}
					}
				}
			}
			destroyObject = false;
		}

		public static void FixHeart(int i, int j)
		{
			if (i < 40 || i >= Main.maxTilesX - 40 || j < 40 || j >= Main.maxTilesY - 40)
			{
				DestroyHeart(i, j);
				return;
			}
			Tile tile = Main.tile[i, j + 2];
			Tile tile2 = Main.tile[i + 1, j + 2];
			if (tile.active() && !Main.tileSolid[tile.type] && Main.tileCut[tile.type])
			{
				KillTile(i, j + 2);
			}
			if (tile2.active() && !Main.tileSolid[tile2.type] && Main.tileCut[tile2.type])
			{
				KillTile(i + 1, j + 2);
			}
			if (!tile.active())
			{
				if (!tile2.active())
				{
					DestroyHeart(i, j);
					return;
				}
				if (Main.tileSolid[tile2.type])
				{
					tile.type = tile2.type;
					tile.active(active: true);
				}
			}
			if (!tile2.active() && Main.tileSolid[tile.type])
			{
				tile2.type = tile.type;
				tile2.active(active: true);
			}
			if (!tile.nactive() || !Main.tileSolid[tile.type] || !tile2.nactive() || !Main.tileSolid[tile2.type])
			{
				DestroyHeart(i, j);
				return;
			}
			if (tile.blockType() != 0)
			{
				tile.slope(0);
				tile.halfBrick(halfBrick: false);
			}
			if (tile2.blockType() != 0)
			{
				tile2.slope(0);
				tile2.halfBrick(halfBrick: false);
			}
		}

		public static void FixChands()
		{
			for (int i = 5; i < Main.maxTilesX - 5; i++)
			{
				for (int j = 5; j < Main.maxTilesY - 5; j++)
				{
					if (Main.tile[i, j].active())
					{
						int type = Main.tile[i, j].type;
						if (Main.tile[i, j].active() && (type == 35 || type == 36 || type == 170 || type == 171 || type == 172))
						{
							FixChand(i, j);
						}
					}
				}
			}
		}

		public static void FixChand(int i, int j)
		{
			int num = 0;
			int type = Main.tile[i, j].type;
			if (Main.tile[i, j].active())
			{
				if (type == 35)
				{
					num = 1;
				}
				if (type == 36)
				{
					num = 2;
				}
				if (type == 170)
				{
					num = 3;
				}
				if (type == 171)
				{
					num = 4;
				}
				if (type == 172)
				{
					num = 5;
				}
			}
			if (num <= 0)
			{
				return;
			}
			int num2 = i;
			int num3 = j;
			for (num2 = Main.tile[i, j].frameX / 18; num2 >= 3; num2 -= 3)
			{
			}
			if (num2 >= 3)
			{
				num2 -= 3;
			}
			num2 = i - num2;
			num3 += Main.tile[i, j].frameY / 18 * -1;
			for (int k = num2; k < num2 + 3; k++)
			{
				for (int l = num3; l < num3 + 3; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (Main.tile[k, l].active() && Main.tile[k, l].type == type)
					{
						Main.tile[k, l].type = 34;
						Main.tile[k, l].frameY = (short)(Main.tile[k, l].frameY + num * 54);
					}
				}
			}
		}

		public static void PlaceChand(int x, int y, ushort type, int style = 0)
		{
			bool flag = true;
			int num = 0;
			for (int i = x - 1; i < x + 2; i++)
			{
				for (int j = y; j < y + 3; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active())
					{
						flag = false;
					}
				}
			}
			if (Main.tile[x, y - 1] == null)
			{
				Main.tile[x, y - 1] = new Tile();
			}
			if (!Main.tile[x, y - 1].nactive() || !Main.tileSolid[Main.tile[x, y - 1].type] || Main.tileSolidTop[Main.tile[x, y - 1].type])
			{
				flag = false;
			}
			if (flag)
			{
				int num2 = style / 36 * 18 * 6;
				int num3 = style * 18 * 3;
				Main.tile[x - 1, y + num].active(active: true);
				Main.tile[x - 1, y + num].frameY = (short)num3;
				Main.tile[x - 1, y + num].frameX = (short)num2;
				Main.tile[x - 1, y + num].type = type;
				Main.tile[x, y + num].active(active: true);
				Main.tile[x, y + num].frameY = (short)num3;
				Main.tile[x, y + num].frameX = (short)(num2 + 18);
				Main.tile[x, y + num].type = type;
				Main.tile[x + 1, y + num].active(active: true);
				Main.tile[x + 1, y + num].frameY = (short)num3;
				Main.tile[x + 1, y + num].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y + num].type = type;
				Main.tile[x - 1, y + 1 + num].active(active: true);
				Main.tile[x - 1, y + 1 + num].frameY = (short)(num3 + 18);
				Main.tile[x - 1, y + 1 + num].frameX = (short)num2;
				Main.tile[x - 1, y + 1 + num].type = type;
				Main.tile[x, y + 1 + num].active(active: true);
				Main.tile[x, y + 1 + num].frameY = (short)(num3 + 18);
				Main.tile[x, y + 1 + num].frameX = (short)(num2 + 18);
				Main.tile[x, y + 1 + num].type = type;
				Main.tile[x + 1, y + 1 + num].active(active: true);
				Main.tile[x + 1, y + 1 + num].frameY = (short)(num3 + 18);
				Main.tile[x + 1, y + 1 + num].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y + 1 + num].type = type;
				Main.tile[x - 1, y + 2 + num].active(active: true);
				Main.tile[x - 1, y + 2 + num].frameY = (short)(num3 + 36);
				Main.tile[x - 1, y + 2 + num].frameX = (short)num2;
				Main.tile[x - 1, y + 2 + num].type = type;
				Main.tile[x, y + 2 + num].active(active: true);
				Main.tile[x, y + 2 + num].frameY = (short)(num3 + 36);
				Main.tile[x, y + 2 + num].frameX = (short)(num2 + 18);
				Main.tile[x, y + 2 + num].type = type;
				Main.tile[x + 1, y + 2 + num].active(active: true);
				Main.tile[x + 1, y + 2 + num].frameY = (short)(num3 + 36);
				Main.tile[x + 1, y + 2 + num].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y + 2 + num].type = type;
			}
		}

		public static void CheckChand(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = i;
			int num2 = j;
			int num3 = 3;
			if (type == 454)
			{
				num3 = 4;
			}
			num = Main.tile[i, j].frameX / 18;
			int num4 = 0;
			while (num >= num3)
			{
				num4++;
				num -= num3;
			}
			int num5 = i - num;
			int num6 = 18 * num3 * num4;
			if (num >= num3)
			{
				num -= num3;
			}
			num = i - num;
			num2 = Main.tile[i, j].frameY / 18;
			int num7 = 0;
			while (num2 >= 3)
			{
				num7++;
				num2 -= 3;
			}
			if (num6 >= 108)
			{
				num7 += 37 * (num6 / 108);
			}
			int num8 = 54 * num7;
			if (num6 >= 108)
			{
				num8 -= 54 * (num6 / 108) * 37;
			}
			if (num2 >= 3)
			{
				num2 -= 3;
			}
			num2 = j - num2;
			for (int k = num; k < num + num3; k++)
			{
				for (int l = num2; l < num2 + 3; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num5) * 18 + num6 || Main.tile[k, l].frameY != (l - num2) * 18 + num8)
					{
						flag = true;
					}
				}
			}
			if (Main.tile[num + 1, num2 - 1] == null)
			{
				Main.tile[num + 1, num2 - 1] = new Tile();
			}
			if (!Main.tile[num + 1, num2 - 1].nactive() || !Main.tileSolid[Main.tile[num + 1, num2 - 1].type] || Main.tileSolidTop[Main.tile[num + 1, num2 - 1].type])
			{
				flag = true;
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int m = num; m < num + num3; m++)
			{
				for (int n = num2; n < num2 + 3; n++)
				{
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
					{
						KillTile(m, n);
					}
				}
			}
			if (type == 454)
			{
				switch (Main.rand.Next(9))
				{
				case 2:
				case 3:
				case 4:
				{
					int num13 = Main.rand.Next(10, 31);
					while (num13 > 0)
					{
						int num14 = Main.rand.Next(2, 11);
						if (num14 > num13)
						{
							num14 = num13;
						}
						num13 -= num14;
						Item.NewItem(i * 16, j * 16, 32, 32, 72, num14);
					}
					break;
				}
				case 5:
				case 6:
				{
					int num17 = Main.rand.Next(60, 80);
					while (num17 > 0)
					{
						int num18 = Main.rand.Next(3, 16);
						if (num18 > num17)
						{
							num18 = num17;
						}
						num17 -= num18;
						Item.NewItem(i * 16 - 10, j * 16 - 10, 52, 52, 72, num18);
					}
					Item.NewItem(i * 16, j * 16, 32, 32, 1358);
					break;
				}
				case 7:
				{
					int num15 = Main.rand.Next(10, 31);
					while (num15 > 0)
					{
						int num16 = Main.rand.Next(2, 9);
						if (num16 > num15)
						{
							num16 = num15;
						}
						num15 -= num16;
						Item.NewItem(i * 16 - 10, j * 16 - 10, 52, 52, 72, num16);
					}
					if (Main.rand.Next(8) == 0)
					{
						Item.NewItem(i * 16, j * 16, 32, 32, 3532);
					}
					if (Main.rand.Next(8) == 0)
					{
						Item.NewItem(i * 16, j * 16, 32, 32, 3532);
					}
					Item.NewItem(i * 16, j * 16, 32, 32, 73);
					break;
				}
				case 8:
				{
					int num9 = 100;
					while (num9 > 0)
					{
						int num10 = Main.rand.Next(3, 16);
						if (num10 > num9)
						{
							num10 = num9;
						}
						num9 -= num10;
						Item.NewItem(i * 16 - 10, j * 16 - 10, 52, 52, 72, num10);
					}
					int num11 = Main.rand.Next(30, 91);
					while (num11 > 0)
					{
						int num12 = Main.rand.Next(7, 14);
						if (num12 > num11)
						{
							num12 = num11;
						}
						num11 -= num12;
						Item.NewItem(i * 16 - 10, j * 16 - 10, 52, 52, 1349, num12);
					}
					Item.NewItem(i * 16, j * 16, 32, 32, 1358);
					Item.NewItem(i * 16, j * 16, 32, 32, 73);
					break;
				}
				}
			}
			if (type == 34)
			{
				int type2;
				switch (num7)
				{
				case 1:
					type2 = 107;
					break;
				case 2:
					type2 = 108;
					break;
				case 3:
					type2 = 710;
					break;
				case 4:
					type2 = 711;
					break;
				case 5:
					type2 = 712;
					break;
				case 6:
					type2 = 1812;
					break;
				case 7:
				case 8:
				case 9:
				case 10:
				case 11:
				case 12:
				case 13:
				case 14:
				case 15:
				case 16:
				case 17:
					type2 = 2055 + num7 - 7;
					break;
				default:
					type2 = ((num7 >= 18 && num7 <= 21) ? (2141 + num7 - 18) : (num7 switch
					{
						22 => 2224, 
						23 => 2525, 
						24 => 2543, 
						25 => 2558, 
						26 => 2573, 
						27 => 2652, 
						28 => 2653, 
						29 => 2654, 
						30 => 2655, 
						31 => 2656, 
						32 => 2657, 
						33 => 2813, 
						34 => 3177, 
						35 => 3179, 
						36 => 3178, 
						37 => 3894, 
						38 => 3938, 
						39 => 3964, 
						40 => 4152, 
						41 => 4173, 
						42 => 4194, 
						43 => 4215, 
						44 => 4305, 
						45 => 4573, 
						_ => 106, 
					}));
					break;
				}
				Item.NewItem(i * 16, j * 16, 32, 32, type2);
			}
			destroyObject = false;
			for (int num19 = num - 1; num19 < num + num3 + 1; num19++)
			{
				for (int num20 = num2 - 1; num20 < num2 + 4; num20++)
				{
					TileFrame(num19, num20);
				}
			}
		}

		public static void Check3x3(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = i;
			int num2 = j;
			num = Main.tile[i, j].frameX / 18;
			int num3 = 0;
			while (num >= 3)
			{
				num3++;
				num -= 3;
			}
			int num4 = i - num;
			int num5 = 54 * num3;
			int num6 = Main.tile[i, j].frameY / 54;
			int num7 = Main.tile[i, j].frameY % 54 / 18;
			if (num >= 3)
			{
				num -= 3;
			}
			num = i - num;
			num2 -= num7;
			for (int k = num; k < num + 3; k++)
			{
				for (int l = num2; l < num2 + 3; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num4) * 18 + num5 || Main.tile[k, l].frameY != (l - num2) * 18 + num6 * 54)
					{
						flag = true;
					}
				}
			}
			if (type == 106 || type == 212 || type == 219 || type == 220 || type == 228 || type == 231 || type == 243 || type == 247 || type == 283 || (type >= 300 && type <= 308) || type == 354 || type == 355 || type == 499 || type == 406 || type == 412 || type == 452 || type == 455 || type == 491)
			{
				for (int m = num; m < num + 3; m++)
				{
					if (Main.tile[m, num2 + 3] == null)
					{
						Main.tile[m, num2 + 3] = new Tile();
					}
					if (!SolidTileAllowBottomSlope(m, num2 + 3))
					{
						flag = true;
						break;
					}
				}
			}
			else
			{
				if (Main.tile[num + 1, num2 - 1] == null)
				{
					Main.tile[num + 1, num2 - 1] = new Tile();
				}
				if (!Main.tile[num + 1, num2 - 1].nactive() || !Main.tileSolid[Main.tile[num + 1, num2 - 1].type] || Main.tileSolidTop[Main.tile[num + 1, num2 - 1].type])
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int n = num; n < num + 3; n++)
			{
				for (int num8 = num2; num8 < num2 + 3; num8++)
				{
					if (Main.tile[n, num8].type == type && Main.tile[n, num8].active())
					{
						KillTile(n, num8);
					}
				}
			}
			switch (type)
			{
			case 106:
				Item.NewItem(i * 16, j * 16, 32, 32, 363);
				break;
			case 243:
				Item.NewItem(i * 16, j * 16, 32, 32, 1430);
				break;
			case 212:
				Item.NewItem(i * 16, j * 16, 32, 32, 951);
				break;
			case 219:
				Item.NewItem(i * 16, j * 16, 32, 32, 997);
				break;
			case 220:
				Item.NewItem(i * 16, j * 16, 32, 32, 998);
				break;
			case 228:
				Item.NewItem(i * 16, j * 16, 32, 32, 1120);
				break;
			case 247:
				Item.NewItem(i * 16, j * 16, 32, 32, 1551);
				break;
			case 283:
				Item.NewItem(i * 16, j * 16, 32, 32, 2172);
				break;
			case 300:
			case 301:
			case 302:
			case 303:
			case 304:
			case 305:
			case 306:
				Item.NewItem(i * 16, j * 16, 32, 32, 2192 + type - 300);
				break;
			default:
				switch (type)
				{
				case 307:
					Item.NewItem(i * 16, j * 16, 32, 32, 2203);
					break;
				case 308:
					Item.NewItem(i * 16, j * 16, 32, 32, 2204);
					break;
				case 406:
					Item.NewItem(i * 16, j * 16, 32, 32, 3365);
					break;
				case 452:
					Item.NewItem(i * 16, j * 16, 32, 32, 3742);
					break;
				case 354:
					Item.NewItem(i * 16, j * 16, 32, 32, 2999);
					break;
				case 355:
					Item.NewItem(i * 16, j * 16, 32, 32, 3000);
					break;
				case 499:
					Item.NewItem(i * 16, j * 16, 32, 32, 4142);
					break;
				case 412:
					Item.NewItem(i * 16, j * 16, 32, 32, 3549);
					break;
				case 455:
					Item.NewItem(i * 16, j * 16, 32, 32, 3747);
					break;
				case 491:
					Item.NewItem(i * 16, j * 16, 32, 32, 4076);
					break;
				case 231:
				{
					int num9 = (i + 1) * 16 + 8;
					int num10 = j * 16;
					Gore.NewGore(new Vector2(num9, num10), default(Vector2), 300);
					Gore.NewGore(new Vector2(num9, num10 + 8), default(Vector2), 301);
					Gore.NewGore(new Vector2(num9, num10 + 16), default(Vector2), 302);
					float num11 = i * 16;
					float num12 = j * 16;
					float num13 = -1f;
					int plr = 0;
					for (int num14 = 0; num14 < 255; num14++)
					{
						if (Main.player[num14].active && !Main.player[num14].dead)
						{
							float num15 = Math.Abs(Main.player[num14].position.X - num11) + Math.Abs(Main.player[num14].position.Y - num12);
							if (num15 < num13 || num13 == -1f)
							{
								plr = num14;
								num13 = num15;
							}
						}
					}
					if (num13 < 4800f)
					{
						NPC.SpawnOnPlayer(plr, 222);
					}
					break;
				}
				}
				break;
			}
			destroyObject = false;
			for (int num16 = num - 1; num16 < num + 4; num16++)
			{
				for (int num17 = num2 - 1; num17 < num2 + 4; num17++)
				{
					TileFrame(num16, num17);
				}
			}
		}

		public static void Check2x5(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = i;
			int num2 = j;
			num = Main.tile[i, j].frameX / 18;
			int num3 = 0;
			while (num >= 2)
			{
				num3++;
				num -= 2;
			}
			int num4 = i - num;
			int num5 = 36 * num3;
			int num6 = Main.tile[i, j].frameY % 80 / 18;
			if (num >= 3)
			{
				num -= 2;
			}
			num = i - num;
			num2 -= num6;
			for (int k = num; k < num + 2; k++)
			{
				for (int l = num2; l < num2 + 5; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num4) * 18 + num5 || Main.tile[k, l].frameY != (l - num2) * 18)
					{
						flag = true;
					}
				}
			}
			for (int m = num; m < num + 2; m++)
			{
				if (Main.tile[m, num2 + 5] == null)
				{
					Main.tile[m, num2 + 5] = new Tile();
				}
				if (!SolidTileAllowBottomSlope(m, num2 + 5))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int n = num; n < num + 2; n++)
			{
				for (int num7 = num2; num7 < num2 + 5; num7++)
				{
					if (Main.tile[n, num7].type == type && Main.tile[n, num7].active())
					{
						KillTile(n, num7);
					}
				}
			}
			if (type == 547)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4430 + num3);
			}
			destroyObject = false;
			for (int num8 = num - 1; num8 < num + 3; num8++)
			{
				for (int num9 = num2 - 1; num9 < num2 + 6; num9++)
				{
					TileFrame(num8, num9);
				}
			}
		}

		public static void Check3x5(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = i;
			int num2 = j;
			num = Main.tile[i, j].frameX / 18;
			int num3 = 0;
			while (num >= 3)
			{
				num3++;
				num -= 3;
			}
			int num4 = i - num;
			int num5 = 54 * num3;
			int num6 = Main.tile[i, j].frameY % 90 / 18;
			if (num >= 4)
			{
				num -= 3;
			}
			num = i - num;
			num2 -= num6;
			for (int k = num; k < num + 3; k++)
			{
				for (int l = num2; l < num2 + 5; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num4) * 18 + num5 || Main.tile[k, l].frameY != (l - num2) * 18)
					{
						flag = true;
					}
				}
			}
			for (int m = num; m < num + 3; m++)
			{
				if (Main.tile[m, num2 + 5] == null)
				{
					Main.tile[m, num2 + 5] = new Tile();
				}
				if (!SolidTileAllowBottomSlope(m, num2 + 5))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int n = num; n < num + 3; n++)
			{
				for (int num7 = num2; num7 < num2 + 5; num7++)
				{
					if (Main.tile[n, num7].type == type && Main.tile[n, num7].active())
					{
						KillTile(n, num7);
					}
				}
			}
			if (type == 613)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4904 + num3);
			}
			destroyObject = false;
			for (int num8 = num - 1; num8 < num + 4; num8++)
			{
				for (int num9 = num2 - 1; num9 < num2 + 6; num9++)
				{
					TileFrame(num8, num9);
				}
			}
		}

		public static void Check3x6(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = i;
			int num2 = j;
			num = Main.tile[i, j].frameX / 18;
			int num3 = 0;
			while (num >= 3)
			{
				num3++;
				num -= 3;
			}
			int num4 = i - num;
			int num5 = 54 * num3;
			int num6 = Main.tile[i, j].frameY % 96 / 18;
			if (num >= 4)
			{
				num -= 3;
			}
			num = i - num;
			num2 -= num6;
			for (int k = num; k < num + 3; k++)
			{
				for (int l = num2; l < num2 + 6; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num4) * 18 + num5 || Main.tile[k, l].frameY != (l - num2) * 18)
					{
						flag = true;
					}
				}
			}
			for (int m = num; m < num + 3; m++)
			{
				if (Main.tile[m, num2 + 6] == null)
				{
					Main.tile[m, num2 + 6] = new Tile();
				}
				if (!SolidTileAllowBottomSlope(m, num2 + 6))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int n = num; n < num + 3; n++)
			{
				for (int num7 = num2; num7 < num2 + 6; num7++)
				{
					if (Main.tile[n, num7].type == type && Main.tile[n, num7].active())
					{
						KillTile(n, num7);
					}
				}
			}
			if (type == 548)
			{
				if (num3 >= 7)
				{
					Item.NewItem(i * 16, j * 16, 32, 32, 4902 + num3 - 7);
				}
				else
				{
					Item.NewItem(i * 16, j * 16, 32, 32, 4435 + num3);
				}
			}
			if (type == 614)
			{
				Item.NewItem(i * 16, j * 16, 32, 32, 4906);
			}
			destroyObject = false;
			for (int num8 = num - 1; num8 < num + 4; num8++)
			{
				for (int num9 = num2 - 1; num9 < num2 + 7; num9++)
				{
					TileFrame(num8, num9);
				}
			}
		}

		public static void Place3x3(int x, int y, ushort type, int style = 0)
		{
			bool flag = true;
			int num = 0;
			if (type == 106 || type == 212 || type == 219 || type == 220 || type == 228 || type == 231 || type == 243 || type == 247 || type == 283 || (type >= 300 && type <= 308) || type == 354 || type == 355)
			{
				num = -2;
				for (int i = x - 1; i < x + 2; i++)
				{
					for (int j = y - 2; j < y + 1; j++)
					{
						if (Main.tile[i, j] == null)
						{
							Main.tile[i, j] = new Tile();
						}
						if (Main.tile[i, j].active())
						{
							flag = false;
						}
					}
				}
				for (int k = x - 1; k < x + 2; k++)
				{
					if (Main.tile[k, y + 1] == null)
					{
						Main.tile[k, y + 1] = new Tile();
					}
					if (!SolidTile2(k, y + 1))
					{
						flag = false;
						break;
					}
				}
			}
			else
			{
				for (int l = x - 1; l < x + 2; l++)
				{
					for (int m = y; m < y + 3; m++)
					{
						if (Main.tile[l, m] == null)
						{
							Main.tile[l, m] = new Tile();
						}
						if (Main.tile[l, m].active())
						{
							flag = false;
						}
					}
				}
				if (Main.tile[x, y - 1] == null)
				{
					Main.tile[x, y - 1] = new Tile();
				}
				if (!Main.tile[x, y - 1].nactive() || !Main.tileSolid[Main.tile[x, y - 1].type] || Main.tileSolidTop[Main.tile[x, y - 1].type])
				{
					flag = false;
				}
			}
			if (flag)
			{
				int num2 = style * 18 * 3;
				Main.tile[x - 1, y + num].active(active: true);
				Main.tile[x - 1, y + num].frameY = 0;
				Main.tile[x - 1, y + num].frameX = (short)num2;
				Main.tile[x - 1, y + num].type = type;
				Main.tile[x, y + num].active(active: true);
				Main.tile[x, y + num].frameY = 0;
				Main.tile[x, y + num].frameX = (short)(num2 + 18);
				Main.tile[x, y + num].type = type;
				Main.tile[x + 1, y + num].active(active: true);
				Main.tile[x + 1, y + num].frameY = 0;
				Main.tile[x + 1, y + num].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y + num].type = type;
				Main.tile[x - 1, y + 1 + num].active(active: true);
				Main.tile[x - 1, y + 1 + num].frameY = 18;
				Main.tile[x - 1, y + 1 + num].frameX = (short)num2;
				Main.tile[x - 1, y + 1 + num].type = type;
				Main.tile[x, y + 1 + num].active(active: true);
				Main.tile[x, y + 1 + num].frameY = 18;
				Main.tile[x, y + 1 + num].frameX = (short)(num2 + 18);
				Main.tile[x, y + 1 + num].type = type;
				Main.tile[x + 1, y + 1 + num].active(active: true);
				Main.tile[x + 1, y + 1 + num].frameY = 18;
				Main.tile[x + 1, y + 1 + num].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y + 1 + num].type = type;
				Main.tile[x - 1, y + 2 + num].active(active: true);
				Main.tile[x - 1, y + 2 + num].frameY = 36;
				Main.tile[x - 1, y + 2 + num].frameX = (short)num2;
				Main.tile[x - 1, y + 2 + num].type = type;
				Main.tile[x, y + 2 + num].active(active: true);
				Main.tile[x, y + 2 + num].frameY = 36;
				Main.tile[x, y + 2 + num].frameX = (short)(num2 + 18);
				Main.tile[x, y + 2 + num].type = type;
				Main.tile[x + 1, y + 2 + num].active(active: true);
				Main.tile[x + 1, y + 2 + num].frameY = 36;
				Main.tile[x + 1, y + 2 + num].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y + 2 + num].type = type;
			}
		}

		public static void PlaceSunflower(int x, int y, ushort type = 27)
		{
			if ((double)y > Main.worldSurface - 1.0)
			{
				return;
			}
			bool flag = true;
			for (int i = x; i < x + 2; i++)
			{
				for (int j = y - 3; j < y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active() || Main.tile[i, j].wall > 0)
					{
						flag = false;
					}
				}
				if (Main.tile[i, y + 1] == null)
				{
					Main.tile[i, y + 1] = new Tile();
				}
				if (!Main.tile[i, y + 1].nactive() || Main.tile[i, y + 1].halfBrick() || Main.tile[i, y + 1].slope() != 0 || (Main.tile[i, y + 1].type != 2 && Main.tile[i, y + 1].type != 109))
				{
					flag = false;
				}
			}
			if (!flag)
			{
				return;
			}
			int num = genRand.Next(3);
			for (int k = 0; k < 2; k++)
			{
				for (int l = -3; l < 1; l++)
				{
					int num2 = k * 18 + genRand.Next(3) * 36;
					if (l <= -2)
					{
						num2 = k * 18 + num * 36;
					}
					int num3 = (l + 3) * 18;
					Main.tile[x + k, y + l].active(active: true);
					Main.tile[x + k, y + l].frameX = (short)num2;
					Main.tile[x + k, y + l].frameY = (short)num3;
					Main.tile[x + k, y + l].type = type;
				}
			}
		}

		public static void FixSunflowers()
		{
			for (int i = 5; i < Main.maxTilesX - 5; i++)
			{
				for (int j = 5; (double)j < Main.worldSurface; j++)
				{
					if (Main.tile[i, j].active() && Main.tile[i, j].type == 27)
					{
						FixSunflower(i, j);
					}
				}
			}
		}

		public static void FixSunflower(int i, int j)
		{
			if (Main.tile[i, j].type != 27)
			{
				return;
			}
			int num = 0;
			int num2 = j;
			num += Main.tile[i, j].frameX / 18;
			num2 += Main.tile[i, j].frameY / 18 * -1;
			while (num > 1)
			{
				num -= 2;
			}
			num *= -1;
			num += i;
			int num3 = genRand.Next(3) * 36;
			int num4 = 0;
			for (int k = num; k < num + 2; k++)
			{
				for (int l = num2; l < num2 + 4; l++)
				{
					Main.tile[k, l].frameX = (short)(num4 + num3);
				}
				num4 += 18;
			}
		}

		public static void CheckSunflower(int i, int j, int type = 27)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = 0;
			int num2 = j;
			num += Main.tile[i, j].frameX / 18;
			num2 += Main.tile[i, j].frameY / 18 * -1;
			while (num > 1)
			{
				num -= 2;
			}
			num *= -1;
			num += i;
			for (int k = num; k < num + 2; k++)
			{
				for (int l = num2; l < num2 + 4; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					int num3;
					for (num3 = Main.tile[k, l].frameX / 18; num3 > 1; num3 -= 2)
					{
					}
					if (!Main.tile[k, l].nactive() || Main.tile[k, l].type != type || num3 != k - num || Main.tile[k, l].frameY != (l - num2) * 18)
					{
						flag = true;
					}
				}
				if (Main.tile[k, num2 + 4] == null)
				{
					Main.tile[k, num2 + 4] = new Tile();
				}
				if (!Main.tile[k, num2 + 4].nactive() || (Main.tile[k, num2 + 4].type != 2 && Main.tile[k, num2 + 4].type != 477 && Main.tile[k, num2 + 4].type != 492 && Main.tile[k, num2 + 4].type != 109 && Main.tile[k, num2 + 4].type != 60))
				{
					flag = true;
				}
				if (!SolidTile(k, num2 + 4))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int m = num; m < num + 2; m++)
			{
				for (int n = num2; n < num2 + 4; n++)
				{
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
					{
						KillTile(m, n);
					}
				}
			}
			Item.NewItem(i * 16, j * 16, 32, 32, 63);
			destroyObject = false;
		}

		public static void CheckDye(int x, int y)
		{
			switch (Main.tile[x, y].frameX / 34)
			{
			case 7:
				if (!SolidTile(x, y - 1))
				{
					KillTile(x, y);
				}
				break;
			case 6:
				if (!Main.tile[x, y + 1].nactive() || Main.tile[x, y + 1].type != 80)
				{
					KillTile(x, y);
				}
				break;
			default:
				if (!SolidTile(x, y + 1))
				{
					KillTile(x, y);
				}
				break;
			}
		}

		public static void CheckRockGolemHead(int x, int y)
		{
			if (!SolidTileAllowBottomSlope(x, y + 1))
			{
				KillTile(x, y);
			}
		}

		public static void CheckGnome(int x, int j)
		{
			if (destroyObject)
			{
				return;
			}
			int num = 567;
			int num2 = j;
			bool flag = true;
			Tile tileSafely = Framing.GetTileSafely(x, num2);
			Tile tileSafely2 = Framing.GetTileSafely(x, num2 + 1);
			if (tileSafely.frameY > 0)
			{
				num2--;
				tileSafely = Framing.GetTileSafely(x, num2);
				tileSafely2 = Framing.GetTileSafely(x, num2 + 1);
			}
			_ = tileSafely.frameX / 28;
			if (tileSafely.frameY == 0 && tileSafely2.frameY == 20 && tileSafely.type == num && tileSafely2.type == num)
			{
				flag = false;
			}
			if (Main.tile[x, num2 + 2] == null)
			{
				Main.tile[x, num2 + 2] = new Tile();
			}
			if (!SolidTileAllowBottomSlope(x, num2 + 2) && !TileID.Sets.Platforms[Main.tile[x, num2 + 2].type])
			{
				flag = true;
			}
			if (flag)
			{
				destroyObject = true;
				if (tileSafely.type == num)
				{
					KillTile(x, num2);
				}
				if (tileSafely2.type == num)
				{
					KillTile(x, num2 + 1);
				}
				Item.NewItem(x * 16, num2 * 16, 16, 32, 4609);
				destroyObject = false;
			}
		}

		public static void PlaceGnome(int x, int y, int style)
		{
			PlaceObject(x, y, 567, mute: false, style);
		}

		public static void PlaceDye(int x, int y, int style)
		{
			bool flag = false;
			if (Main.tile[x, y + 1] == null || Main.tile[x, y - 1] == null)
			{
				return;
			}
			if (style == 7)
			{
				if (Main.tile[x, y + 1].active() && Main.tile[x, y + 1].type != 3 && Main.tile[x, y + 1].type != 51 && Main.tile[x, y + 1].type != 61 && Main.tile[x, y + 1].type != 73 && Main.tile[x, y + 1].type != 74 && Main.tile[x, y + 1].type != 184)
				{
					return;
				}
				if (SolidTile(x, y - 1) && !Main.tile[x, y + 1].active())
				{
					flag = true;
				}
			}
			else
			{
				if (Main.tile[x, y - 1].active() && Main.tile[x, y - 1].type != 3 && Main.tile[x, y - 1].type != 51 && Main.tile[x, y - 1].type != 61 && Main.tile[x, y - 1].type != 73 && Main.tile[x, y - 1].type != 74 && Main.tile[x, y - 1].type != 184)
				{
					return;
				}
				if (style == 6)
				{
					if (Main.tile[x, y + 1].nactive() && Main.tile[x, y + 1].type == 80 && !Main.tile[x - 1, y + 1].active() && !Main.tile[x + 1, y + 1].active())
					{
						flag = true;
					}
				}
				else if (SolidTile(x, y + 1) && !Main.tile[x, y - 1].active())
				{
					switch (style)
					{
					case 5:
						if (Main.tile[x, y].liquid == byte.MaxValue)
						{
							flag = true;
						}
						break;
					case 8:
					case 9:
					case 10:
					case 11:
						flag = true;
						break;
					default:
						if (Main.tile[x, y].liquid != 0)
						{
							break;
						}
						if (style == 3 || style == 4)
						{
							if (Main.tile[x, y].wall == 0)
							{
								flag = true;
							}
						}
						else
						{
							flag = true;
						}
						break;
					}
				}
			}
			if (flag)
			{
				Main.tile[x, y].type = 227;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].halfBrick(halfBrick: false);
				Main.tile[x, y].slope(0);
				Main.tile[x, y].frameY = 0;
				Main.tile[x, y].frameX = (short)(34 * style);
			}
		}

		public static bool PlacePot(int x, int y, ushort type = 28, int style = 0)
		{
			bool flag = true;
			for (int i = x; i < x + 2; i++)
			{
				for (int j = y - 1; j < y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active())
					{
						flag = false;
					}
				}
				if (Main.tile[i, y + 1] == null)
				{
					Main.tile[i, y + 1] = new Tile();
				}
				if (!Main.tile[i, y + 1].nactive() || Main.tile[i, y + 1].halfBrick() || Main.tile[i, y + 1].slope() != 0 || !Main.tileSolid[Main.tile[i, y + 1].type])
				{
					flag = false;
				}
			}
			if (flag)
			{
				int num = genRand.Next(3) * 36;
				for (int k = 0; k < 2; k++)
				{
					for (int l = -1; l < 1; l++)
					{
						int num2 = k * 18 + num;
						int num3 = (l + 1) * 18;
						Main.tile[x + k, y + l].active(active: true);
						Main.tile[x + k, y + l].frameX = (short)num2;
						Main.tile[x + k, y + l].frameY = (short)(num3 + style * 36);
						Main.tile[x + k, y + l].type = type;
						Main.tile[x + k, y + l].halfBrick(halfBrick: false);
					}
				}
				return true;
			}
			return false;
		}

		public static bool CheckCactus(int i, int j)
		{
			int num = j;
			int num2 = i;
			while (Main.tile[num2, num] != null && Main.tile[num2, num].active() && Main.tile[num2, num].type == 80)
			{
				num++;
				if (Main.tile[num2, num] == null)
				{
					return false;
				}
				if (!Main.tile[num2, num].active() || Main.tile[num2, num].type != 80)
				{
					if (Main.tile[num2 - 1, num] != null && Main.tile[num2 - 1, num].active() && Main.tile[num2 - 1, num].type == 80 && Main.tile[num2 - 1, num - 1] != null && Main.tile[num2 - 1, num - 1].active() && Main.tile[num2 - 1, num - 1].type == 80 && num2 >= i)
					{
						num2--;
					}
					if (Main.tile[num2 + 1, num] != null && Main.tile[num2 + 1, num].active() && Main.tile[num2 + 1, num].type == 80 && Main.tile[num2 + 1, num - 1] != null && Main.tile[num2 + 1, num - 1].active() && Main.tile[num2 + 1, num - 1].type == 80 && num2 <= i)
					{
						num2++;
					}
				}
			}
			if (!Main.tile[num2, num].nactive() || Main.tile[num2, num].halfBrick() || Main.tile[num2, num].slope() != 0 || (Main.tile[num2, num].type != 53 && Main.tile[num2, num].type != 112 && Main.tile[num2, num].type != 116 && Main.tile[num2, num].type != 234))
			{
				KillTile(i, j);
				return true;
			}
			if (i != num2)
			{
				if ((!Main.tile[i, j + 1].active() || Main.tile[i, j + 1].type != 80) && (!Main.tile[i - 1, j].active() || Main.tile[i - 1, j].type != 80) && (!Main.tile[i + 1, j].active() || Main.tile[i + 1, j].type != 80))
				{
					KillTile(i, j);
					return true;
				}
			}
			else if (i == num2 && (!Main.tile[i, j + 1].active() || (Main.tile[i, j + 1].type != 80 && Main.tile[i, j + 1].type != 53 && Main.tile[i, j + 1].type != 112 && Main.tile[i, j + 1].type != 116 && Main.tile[i, j + 1].type != 234)))
			{
				KillTile(i, j);
				return true;
			}
			return false;
		}

		public static void PlantCactus(int i, int j)
		{
			GrowCactus(i, j);
			for (int k = 0; k < 150; k++)
			{
				int i2 = genRand.Next(i - 1, i + 2);
				int j2 = genRand.Next(j - 10, j + 2);
				GrowCactus(i2, j2);
			}
		}

		public static void CheckOrb(int i, int j, int type)
		{
			short frameX = Main.tile[i, j].frameX;
			bool flag = false;
			if (frameX >= 36)
			{
				flag = true;
			}
			if (destroyObject)
			{
				return;
			}
			int num = i;
			int num2 = j;
			num = ((Main.tile[i, j].frameX != 0 && Main.tile[i, j].frameX != 36) ? (i - 1) : i);
			num2 = ((Main.tile[i, j].frameY != 0) ? (j - 1) : j);
			for (int k = 0; k < 2; k++)
			{
				for (int l = 0; l < 2; l++)
				{
					Tile tile = Main.tile[num + k, num2 + l];
					if (tile != null && (!tile.nactive() || tile.type != type))
					{
						destroyObject = true;
						break;
					}
				}
				if (destroyObject)
				{
					break;
				}
				if (type == 12)
				{
					Tile tile = Main.tile[num + k, num2 + 2];
					if (tile != null && (!tile.nactive() || !Main.tileSolid[tile.type] || tile.blockType() != 0))
					{
						destroyObject = true;
						break;
					}
				}
			}
			if (!destroyObject)
			{
				return;
			}
			for (int m = num; m < num + 2; m++)
			{
				for (int n = num2; n < num2 + 2; n++)
				{
					if (Main.tile[m, n].type == type)
					{
						KillTile(m, n);
					}
				}
			}
			if (Main.netMode != 1 && !noTileActions)
			{
				switch (type)
				{
				case 12:
					Item.NewItem(num * 16, num2 * 16, 32, 32, 29);
					break;
				case 31:
					if (flag)
					{
						int num3 = Main.rand.Next(5);
						if (!shadowOrbSmashed)
						{
							num3 = 0;
						}
						switch (num3)
						{
						case 0:
						{
							Item.NewItem(num * 16, num2 * 16, 32, 32, 800, 1, noBroadcast: false, -1);
							int stack = genRand.Next(100, 101);
							Item.NewItem(num * 16, num2 * 16, 32, 32, 97, stack);
							break;
						}
						case 1:
							Item.NewItem(num * 16, num2 * 16, 32, 32, 1256, 1, noBroadcast: false, -1);
							break;
						case 2:
							Item.NewItem(num * 16, num2 * 16, 32, 32, 802, 1, noBroadcast: false, -1);
							break;
						case 3:
							Item.NewItem(num * 16, num2 * 16, 32, 32, 3062, 1, noBroadcast: false, -1);
							break;
						case 4:
							Item.NewItem(num * 16, num2 * 16, 32, 32, 1290, 1, noBroadcast: false, -1);
							break;
						}
					}
					else
					{
						int num4 = Main.rand.Next(5);
						if (!shadowOrbSmashed)
						{
							num4 = 0;
						}
						switch (num4)
						{
						case 0:
						{
							Item.NewItem(num * 16, num2 * 16, 32, 32, 96, 1, noBroadcast: false, -1);
							int stack2 = genRand.Next(100, 101);
							Item.NewItem(num * 16, num2 * 16, 32, 32, 97, stack2);
							break;
						}
						case 1:
							Item.NewItem(num * 16, num2 * 16, 32, 32, 64, 1, noBroadcast: false, -1);
							break;
						case 2:
							Item.NewItem(num * 16, num2 * 16, 32, 32, 162, 1, noBroadcast: false, -1);
							break;
						case 3:
							Item.NewItem(num * 16, num2 * 16, 32, 32, 115, 1, noBroadcast: false, -1);
							break;
						case 4:
							Item.NewItem(num * 16, num2 * 16, 32, 32, 111, 1, noBroadcast: false, -1);
							break;
						}
					}
					shadowOrbSmashed = true;
					shadowOrbCount++;
					if (shadowOrbCount >= 3)
					{
						if (!(NPC.AnyNPCs(266) && flag) && (!NPC.AnyNPCs(13) || flag))
						{
							shadowOrbCount = 0;
							float num5 = num * 16;
							float num6 = num2 * 16;
							float num7 = -1f;
							int plr = 0;
							for (int num8 = 0; num8 < 255; num8++)
							{
								float num9 = Math.Abs(Main.player[num8].position.X - num5) + Math.Abs(Main.player[num8].position.Y - num6);
								if (num9 < num7 || num7 == -1f)
								{
									plr = num8;
									num7 = num9;
								}
							}
							if (flag)
							{
								NPC.SpawnOnPlayer(plr, 266);
							}
							else
							{
								NPC.SpawnOnPlayer(plr, 13);
							}
						}
					}
					else
					{
						LocalizedText localizedText = Lang.misc[10];
						if (shadowOrbCount == 2)
						{
							localizedText = Lang.misc[11];
						}
						if (Main.netMode == 0)
						{
							Main.NewText(localizedText.ToString(), 50, byte.MaxValue, 130);
						}
						else if (Main.netMode == 2)
						{
							ChatHelper.BroadcastChatMessage(NetworkText.FromKey(localizedText.Key), new Color(50, 255, 130));
						}
					}
					AchievementsHelper.NotifyProgressionEvent(7);
					break;
				}
			}
			if (flag)
			{
				SoundEngine.PlaySound(4, i * 16, j * 16);
			}
			else
			{
				SoundEngine.PlaySound(13, i * 16, j * 16);
			}
			destroyObject = false;
		}

		public static void CheckPalmTree(int i, int j)
		{
			int num = -1;
			int num2 = -1;
			int type = Main.tile[i, j].type;
			int frameX = Main.tile[i, j].frameX;
			int frameY = Main.tile[i, j].frameY;
			if (Main.tile[i, j - 1] != null && Main.tile[i, j - 1].active())
			{
				num = Main.tile[i, j - 1].type;
			}
			if (Main.tile[i, j + 1] != null && Main.tile[i, j + 1].active())
			{
				num2 = Main.tile[i, j + 1].type;
			}
			if (num2 == 53)
			{
				num2 = 53;
			}
			if (num2 == 234)
			{
				num2 = 53;
			}
			if (num2 == 116)
			{
				num2 = 53;
			}
			if (num2 == 112)
			{
				num2 = 53;
			}
			if (num2 != 53 && num2 != type)
			{
				KillTile(i, j);
			}
			if ((Main.tile[i, j].frameX == 66 || Main.tile[i, j].frameX == 220) && num2 != 53)
			{
				KillTile(i, j);
			}
			if (num != type && Main.tile[i, j].frameX <= 44)
			{
				Main.tile[i, j].frameX = (short)(genRand.Next(7, 10) * 22);
			}
			else if (num != type && Main.tile[i, j].frameX == 66)
			{
				Main.tile[i, j].frameX = 220;
			}
			if (Main.tile[i, j].frameX != frameX && Main.tile[i, j].frameY != frameY && frameX >= 0 && frameY >= 0)
			{
				TileFrame(i - 1, j);
				TileFrame(i + 1, j);
				TileFrame(i, j - 1);
				TileFrame(i, j + 1);
			}
		}

		public static void CheckTreeWithSettings(int x, int y, CheckTreeSettings settings)
		{
			int num = -1;
			int num2 = -1;
			int num3 = -1;
			int num4 = -1;
			Tile tile = Main.tile[x, y];
			int type = tile.type;
			int frameX = tile.frameX;
			int frameY = tile.frameY;
			if (Main.tile[x - 1, y] != null && Main.tile[x - 1, y].active())
			{
				num2 = Main.tile[x - 1, y].type;
			}
			if (Main.tile[x + 1, y] != null && Main.tile[x + 1, y].active())
			{
				num3 = Main.tile[x + 1, y].type;
			}
			if (Main.tile[x, y - 1] != null && Main.tile[x, y - 1].active())
			{
				num = Main.tile[x, y - 1].type;
			}
			if (Main.tile[x, y + 1] != null && Main.tile[x, y + 1].active())
			{
				num4 = Main.tile[x, y + 1].type;
			}
			bool flag = settings.IsGroundValid(num4);
			bool flag2 = num3 == type;
			bool flag3 = num2 == type;
			if (!flag && num4 != type && ((tile.frameX == 0 && tile.frameY <= 130) || (tile.frameX == 22 && tile.frameY <= 130) || (tile.frameX == 44 && tile.frameY <= 130)))
			{
				KillTile(x, y);
			}
			if (tile.frameX >= 22 && tile.frameX <= 44 && tile.frameY >= 132 && tile.frameY <= 176)
			{
				if (!flag)
				{
					KillTile(x, y);
				}
				else if (!(tile.frameX == 22 && flag3) && !(tile.frameX == 44 && flag2))
				{
					KillTile(x, y);
				}
			}
			else if ((tile.frameX == 88 && tile.frameY >= 0 && tile.frameY <= 44) || (tile.frameX == 66 && tile.frameY >= 66 && tile.frameY <= 130) || (tile.frameX == 110 && tile.frameY >= 66 && tile.frameY <= 110) || (tile.frameX == 132 && tile.frameY >= 0 && tile.frameY <= 176))
			{
				if (flag3 && flag2)
				{
					if (tile.frameNumber() == 0)
					{
						tile.frameX = 110;
						tile.frameY = 66;
					}
					if (tile.frameNumber() == 1)
					{
						tile.frameX = 110;
						tile.frameY = 88;
					}
					if (tile.frameNumber() == 2)
					{
						tile.frameX = 110;
						tile.frameY = 110;
					}
				}
				else if (flag3)
				{
					if (tile.frameNumber() == 0)
					{
						tile.frameX = 88;
						tile.frameY = 0;
					}
					if (tile.frameNumber() == 1)
					{
						tile.frameX = 88;
						tile.frameY = 22;
					}
					if (tile.frameNumber() == 2)
					{
						tile.frameX = 88;
						tile.frameY = 44;
					}
				}
				else if (flag2)
				{
					if (tile.frameNumber() == 0)
					{
						tile.frameX = 66;
						tile.frameY = 66;
					}
					if (tile.frameNumber() == 1)
					{
						tile.frameX = 66;
						tile.frameY = 88;
					}
					if (tile.frameNumber() == 2)
					{
						tile.frameX = 66;
						tile.frameY = 110;
					}
				}
				else
				{
					if (tile.frameNumber() == 0)
					{
						tile.frameX = 0;
						tile.frameY = 0;
					}
					if (tile.frameNumber() == 1)
					{
						tile.frameX = 0;
						tile.frameY = 22;
					}
					if (tile.frameNumber() == 2)
					{
						tile.frameX = 0;
						tile.frameY = 44;
					}
				}
			}
			if (tile.frameY >= 132 && tile.frameY <= 176 && (tile.frameX == 0 || tile.frameX == 66 || tile.frameX == 88))
			{
				if (!flag)
				{
					KillTile(x, y);
				}
				if (!flag3 && !flag2)
				{
					if (tile.frameNumber() == 0)
					{
						tile.frameX = 0;
						tile.frameY = 0;
					}
					if (tile.frameNumber() == 1)
					{
						tile.frameX = 0;
						tile.frameY = 22;
					}
					if (tile.frameNumber() == 2)
					{
						tile.frameX = 0;
						tile.frameY = 44;
					}
				}
				else if (!flag3)
				{
					if (tile.frameNumber() == 0)
					{
						tile.frameX = 0;
						tile.frameY = 132;
					}
					if (tile.frameNumber() == 1)
					{
						tile.frameX = 0;
						tile.frameY = 154;
					}
					if (tile.frameNumber() == 2)
					{
						tile.frameX = 0;
						tile.frameY = 176;
					}
				}
				else if (!flag2)
				{
					if (tile.frameNumber() == 0)
					{
						tile.frameX = 66;
						tile.frameY = 132;
					}
					if (tile.frameNumber() == 1)
					{
						tile.frameX = 66;
						tile.frameY = 154;
					}
					if (tile.frameNumber() == 2)
					{
						tile.frameX = 66;
						tile.frameY = 176;
					}
				}
				else
				{
					if (tile.frameNumber() == 0)
					{
						tile.frameX = 88;
						tile.frameY = 132;
					}
					if (tile.frameNumber() == 1)
					{
						tile.frameX = 88;
						tile.frameY = 154;
					}
					if (tile.frameNumber() == 2)
					{
						tile.frameX = 88;
						tile.frameY = 176;
					}
				}
			}
			if ((tile.frameX == 66 && (tile.frameY == 0 || tile.frameY == 22 || tile.frameY == 44)) || (tile.frameX == 44 && (tile.frameY == 198 || tile.frameY == 220 || tile.frameY == 242)))
			{
				if (!flag2)
				{
					KillTile(x, y);
				}
			}
			else if ((tile.frameX == 88 && (tile.frameY == 66 || tile.frameY == 88 || tile.frameY == 110)) || (tile.frameX == 66 && (tile.frameY == 198 || tile.frameY == 220 || tile.frameY == 242)))
			{
				if (!flag3)
				{
					KillTile(x, y);
				}
			}
			else if (num4 == -1)
			{
				KillTile(x, y);
			}
			else if (num != type && tile.frameY < 198 && ((tile.frameX != 22 && tile.frameX != 44) || tile.frameY < 132))
			{
				if (flag3 || flag2)
				{
					if (num4 == type)
					{
						if (flag3 && flag2)
						{
							if (tile.frameNumber() == 0)
							{
								tile.frameX = 132;
								tile.frameY = 132;
							}
							if (tile.frameNumber() == 1)
							{
								tile.frameX = 132;
								tile.frameY = 154;
							}
							if (tile.frameNumber() == 2)
							{
								tile.frameX = 132;
								tile.frameY = 176;
							}
						}
						else if (flag3)
						{
							if (tile.frameNumber() == 0)
							{
								tile.frameX = 132;
								tile.frameY = 0;
							}
							if (tile.frameNumber() == 1)
							{
								tile.frameX = 132;
								tile.frameY = 22;
							}
							if (tile.frameNumber() == 2)
							{
								tile.frameX = 132;
								tile.frameY = 44;
							}
						}
						else if (flag2)
						{
							if (tile.frameNumber() == 0)
							{
								tile.frameX = 132;
								tile.frameY = 66;
							}
							if (tile.frameNumber() == 1)
							{
								tile.frameX = 132;
								tile.frameY = 88;
							}
							if (tile.frameNumber() == 2)
							{
								tile.frameX = 132;
								tile.frameY = 110;
							}
						}
					}
					else if (flag3 && flag2)
					{
						if (tile.frameNumber() == 0)
						{
							tile.frameX = 154;
							tile.frameY = 132;
						}
						if (tile.frameNumber() == 1)
						{
							tile.frameX = 154;
							tile.frameY = 154;
						}
						if (tile.frameNumber() == 2)
						{
							tile.frameX = 154;
							tile.frameY = 176;
						}
					}
					else if (flag3)
					{
						if (tile.frameNumber() == 0)
						{
							tile.frameX = 154;
							tile.frameY = 0;
						}
						if (tile.frameNumber() == 1)
						{
							tile.frameX = 154;
							tile.frameY = 22;
						}
						if (tile.frameNumber() == 2)
						{
							tile.frameX = 154;
							tile.frameY = 44;
						}
					}
					else if (flag2)
					{
						if (tile.frameNumber() == 0)
						{
							tile.frameX = 154;
							tile.frameY = 66;
						}
						if (tile.frameNumber() == 1)
						{
							tile.frameX = 154;
							tile.frameY = 88;
						}
						if (tile.frameNumber() == 2)
						{
							tile.frameX = 154;
							tile.frameY = 110;
						}
					}
				}
				else
				{
					if (tile.frameNumber() == 0)
					{
						tile.frameX = 110;
						tile.frameY = 0;
					}
					if (tile.frameNumber() == 1)
					{
						tile.frameX = 110;
						tile.frameY = 22;
					}
					if (tile.frameNumber() == 2)
					{
						tile.frameX = 110;
						tile.frameY = 44;
					}
				}
			}
			if (tile.frameX != frameX && tile.frameY != frameY && frameX >= 0 && frameY >= 0)
			{
				TileFrame(x - 1, y);
				TileFrame(x + 1, y);
				TileFrame(x, y - 1);
				TileFrame(x, y + 1);
			}
		}

		public static void CheckTree(int i, int j)
		{
			int num = -1;
			int num2 = -1;
			int num3 = -1;
			int num4 = -1;
			int type = Main.tile[i, j].type;
			int frameX = Main.tile[i, j].frameX;
			int frameY = Main.tile[i, j].frameY;
			if (Main.tile[i - 1, j] != null && Main.tile[i - 1, j].active())
			{
				num2 = Main.tile[i - 1, j].type;
			}
			if (Main.tile[i + 1, j] != null && Main.tile[i + 1, j].active())
			{
				num3 = Main.tile[i + 1, j].type;
			}
			if (Main.tile[i, j - 1] != null && Main.tile[i, j - 1].active())
			{
				num = Main.tile[i, j - 1].type;
			}
			if (Main.tile[i, j + 1] != null && Main.tile[i, j + 1].active())
			{
				num4 = Main.tile[i, j + 1].type;
			}
			if (Main.tile[i - 1, j - 1] != null && Main.tile[i - 1, j - 1].active())
			{
				_ = Main.tile[i - 1, j - 1].type;
			}
			if (Main.tile[i + 1, j - 1] != null && Main.tile[i + 1, j - 1].active())
			{
				_ = Main.tile[i + 1, j - 1].type;
			}
			if (Main.tile[i - 1, j + 1] != null && Main.tile[i - 1, j + 1].active())
			{
				_ = Main.tile[i - 1, j + 1].type;
			}
			if (Main.tile[i + 1, j + 1] != null && Main.tile[i + 1, j + 1].active())
			{
				_ = Main.tile[i + 1, j + 1].type;
			}
			if (num4 == 23)
			{
				num4 = 2;
			}
			if (num4 == 477)
			{
				num4 = 2;
			}
			if (num4 == 60)
			{
				num4 = 2;
			}
			if (num4 == 70)
			{
				num4 = 2;
			}
			if (num4 == 109)
			{
				num4 = 2;
			}
			if (num4 == 147)
			{
				num4 = 2;
			}
			if (num4 == 199)
			{
				num4 = 2;
			}
			if (num4 == 492)
			{
				num4 = 2;
			}
			if (num4 != 2 && num4 != type && ((Main.tile[i, j].frameX == 0 && Main.tile[i, j].frameY <= 130) || (Main.tile[i, j].frameX == 22 && Main.tile[i, j].frameY <= 130) || (Main.tile[i, j].frameX == 44 && Main.tile[i, j].frameY <= 130)))
			{
				KillTile(i, j);
			}
			if (Main.tile[i, j].frameX >= 22 && Main.tile[i, j].frameX <= 44 && Main.tile[i, j].frameY >= 132 && Main.tile[i, j].frameY <= 176)
			{
				if (num4 != 2)
				{
					KillTile(i, j);
				}
				else if ((Main.tile[i, j].frameX != 22 || num2 != type) && (Main.tile[i, j].frameX != 44 || num3 != type))
				{
					KillTile(i, j);
				}
			}
			else if ((Main.tile[i, j].frameX == 88 && Main.tile[i, j].frameY >= 0 && Main.tile[i, j].frameY <= 44) || (Main.tile[i, j].frameX == 66 && Main.tile[i, j].frameY >= 66 && Main.tile[i, j].frameY <= 130) || (Main.tile[i, j].frameX == 110 && Main.tile[i, j].frameY >= 66 && Main.tile[i, j].frameY <= 110) || (Main.tile[i, j].frameX == 132 && Main.tile[i, j].frameY >= 0 && Main.tile[i, j].frameY <= 176))
			{
				if (num2 == type && num3 == type)
				{
					if (Main.tile[i, j].frameNumber() == 0)
					{
						Main.tile[i, j].frameX = 110;
						Main.tile[i, j].frameY = 66;
					}
					if (Main.tile[i, j].frameNumber() == 1)
					{
						Main.tile[i, j].frameX = 110;
						Main.tile[i, j].frameY = 88;
					}
					if (Main.tile[i, j].frameNumber() == 2)
					{
						Main.tile[i, j].frameX = 110;
						Main.tile[i, j].frameY = 110;
					}
				}
				else if (num2 == type)
				{
					if (Main.tile[i, j].frameNumber() == 0)
					{
						Main.tile[i, j].frameX = 88;
						Main.tile[i, j].frameY = 0;
					}
					if (Main.tile[i, j].frameNumber() == 1)
					{
						Main.tile[i, j].frameX = 88;
						Main.tile[i, j].frameY = 22;
					}
					if (Main.tile[i, j].frameNumber() == 2)
					{
						Main.tile[i, j].frameX = 88;
						Main.tile[i, j].frameY = 44;
					}
				}
				else if (num3 == type)
				{
					if (Main.tile[i, j].frameNumber() == 0)
					{
						Main.tile[i, j].frameX = 66;
						Main.tile[i, j].frameY = 66;
					}
					if (Main.tile[i, j].frameNumber() == 1)
					{
						Main.tile[i, j].frameX = 66;
						Main.tile[i, j].frameY = 88;
					}
					if (Main.tile[i, j].frameNumber() == 2)
					{
						Main.tile[i, j].frameX = 66;
						Main.tile[i, j].frameY = 110;
					}
				}
				else
				{
					if (Main.tile[i, j].frameNumber() == 0)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 0;
					}
					if (Main.tile[i, j].frameNumber() == 1)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 22;
					}
					if (Main.tile[i, j].frameNumber() == 2)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 44;
					}
				}
			}
			if (Main.tile[i, j].frameY >= 132 && Main.tile[i, j].frameY <= 176 && (Main.tile[i, j].frameX == 0 || Main.tile[i, j].frameX == 66 || Main.tile[i, j].frameX == 88))
			{
				if (num4 != 2)
				{
					KillTile(i, j);
				}
				if (num2 != type && num3 != type)
				{
					if (Main.tile[i, j].frameNumber() == 0)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 0;
					}
					if (Main.tile[i, j].frameNumber() == 1)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 22;
					}
					if (Main.tile[i, j].frameNumber() == 2)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 44;
					}
				}
				else if (num2 != type)
				{
					if (Main.tile[i, j].frameNumber() == 0)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 132;
					}
					if (Main.tile[i, j].frameNumber() == 1)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 154;
					}
					if (Main.tile[i, j].frameNumber() == 2)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 176;
					}
				}
				else if (num3 != type)
				{
					if (Main.tile[i, j].frameNumber() == 0)
					{
						Main.tile[i, j].frameX = 66;
						Main.tile[i, j].frameY = 132;
					}
					if (Main.tile[i, j].frameNumber() == 1)
					{
						Main.tile[i, j].frameX = 66;
						Main.tile[i, j].frameY = 154;
					}
					if (Main.tile[i, j].frameNumber() == 2)
					{
						Main.tile[i, j].frameX = 66;
						Main.tile[i, j].frameY = 176;
					}
				}
				else
				{
					if (Main.tile[i, j].frameNumber() == 0)
					{
						Main.tile[i, j].frameX = 88;
						Main.tile[i, j].frameY = 132;
					}
					if (Main.tile[i, j].frameNumber() == 1)
					{
						Main.tile[i, j].frameX = 88;
						Main.tile[i, j].frameY = 154;
					}
					if (Main.tile[i, j].frameNumber() == 2)
					{
						Main.tile[i, j].frameX = 88;
						Main.tile[i, j].frameY = 176;
					}
				}
			}
			if ((Main.tile[i, j].frameX == 66 && (Main.tile[i, j].frameY == 0 || Main.tile[i, j].frameY == 22 || Main.tile[i, j].frameY == 44)) || (Main.tile[i, j].frameX == 44 && (Main.tile[i, j].frameY == 198 || Main.tile[i, j].frameY == 220 || Main.tile[i, j].frameY == 242)))
			{
				if (num3 != type)
				{
					KillTile(i, j);
				}
			}
			else if ((Main.tile[i, j].frameX == 88 && (Main.tile[i, j].frameY == 66 || Main.tile[i, j].frameY == 88 || Main.tile[i, j].frameY == 110)) || (Main.tile[i, j].frameX == 66 && (Main.tile[i, j].frameY == 198 || Main.tile[i, j].frameY == 220 || Main.tile[i, j].frameY == 242)))
			{
				if (num2 != type)
				{
					KillTile(i, j);
				}
			}
			else if (num4 == -1 || num4 == 23)
			{
				KillTile(i, j);
			}
			else if (num != type && Main.tile[i, j].frameY < 198 && ((Main.tile[i, j].frameX != 22 && Main.tile[i, j].frameX != 44) || Main.tile[i, j].frameY < 132))
			{
				if (num2 == type || num3 == type)
				{
					if (num4 == type)
					{
						if (num2 == type && num3 == type)
						{
							if (Main.tile[i, j].frameNumber() == 0)
							{
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 132;
							}
							if (Main.tile[i, j].frameNumber() == 1)
							{
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 154;
							}
							if (Main.tile[i, j].frameNumber() == 2)
							{
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 176;
							}
						}
						else if (num2 == type)
						{
							if (Main.tile[i, j].frameNumber() == 0)
							{
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 0;
							}
							if (Main.tile[i, j].frameNumber() == 1)
							{
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 22;
							}
							if (Main.tile[i, j].frameNumber() == 2)
							{
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 44;
							}
						}
						else if (num3 == type)
						{
							if (Main.tile[i, j].frameNumber() == 0)
							{
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 66;
							}
							if (Main.tile[i, j].frameNumber() == 1)
							{
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 88;
							}
							if (Main.tile[i, j].frameNumber() == 2)
							{
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 110;
							}
						}
					}
					else if (num2 == type && num3 == type)
					{
						if (Main.tile[i, j].frameNumber() == 0)
						{
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 132;
						}
						if (Main.tile[i, j].frameNumber() == 1)
						{
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 154;
						}
						if (Main.tile[i, j].frameNumber() == 2)
						{
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 176;
						}
					}
					else if (num2 == type)
					{
						if (Main.tile[i, j].frameNumber() == 0)
						{
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 0;
						}
						if (Main.tile[i, j].frameNumber() == 1)
						{
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 22;
						}
						if (Main.tile[i, j].frameNumber() == 2)
						{
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 44;
						}
					}
					else if (num3 == type)
					{
						if (Main.tile[i, j].frameNumber() == 0)
						{
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 66;
						}
						if (Main.tile[i, j].frameNumber() == 1)
						{
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 88;
						}
						if (Main.tile[i, j].frameNumber() == 2)
						{
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 110;
						}
					}
				}
				else
				{
					if (Main.tile[i, j].frameNumber() == 0)
					{
						Main.tile[i, j].frameX = 110;
						Main.tile[i, j].frameY = 0;
					}
					if (Main.tile[i, j].frameNumber() == 1)
					{
						Main.tile[i, j].frameX = 110;
						Main.tile[i, j].frameY = 22;
					}
					if (Main.tile[i, j].frameNumber() == 2)
					{
						Main.tile[i, j].frameX = 110;
						Main.tile[i, j].frameY = 44;
					}
				}
			}
			if (Main.tile[i, j].frameX != frameX && Main.tile[i, j].frameY != frameY && frameX >= 0 && frameY >= 0)
			{
				TileFrame(i - 1, j);
				TileFrame(i + 1, j);
				TileFrame(i, j - 1);
				TileFrame(i, j + 1);
			}
		}

		public static void Convert(int i, int j, int conversionType, int size = 4)
		{
			for (int k = i - size; k <= i + size; k++)
			{
				for (int l = j - size; l <= j + size; l++)
				{
					if (!InWorld(k, l, 1) || Math.Abs(k - i) + Math.Abs(l - j) >= 6)
					{
						continue;
					}
					int type = Main.tile[k, l].type;
					int wall = Main.tile[k, l].wall;
					switch (conversionType)
					{
					case 4:
						if (type <= 623 && wall <= 316)
						{
							if (WallID.Sets.Conversion.Grass[wall] && wall != 81)
							{
								Main.tile[k, l].wall = 81;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (WallID.Sets.Conversion.Stone[wall] && wall != 83)
							{
								Main.tile[k, l].wall = 83;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 218)
							{
								Main.tile[k, l].wall = 218;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 221)
							{
								Main.tile[k, l].wall = 221;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 192)
							{
								Main.tile[k, l].wall = 192;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 193)
							{
								Main.tile[k, l].wall = 193;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 194)
							{
								Main.tile[k, l].wall = 194;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 195)
							{
								Main.tile[k, l].wall = 195;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type]) && type != 203)
							{
								Main.tile[k, l].type = 203;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (TileID.Sets.Conversion.Grass[type] && type != 199)
							{
								Main.tile[k, l].type = 199;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (TileID.Sets.Conversion.Ice[type] && type != 200)
							{
								Main.tile[k, l].type = 200;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (TileID.Sets.Conversion.Sand[type] && type != 234)
							{
								Main.tile[k, l].type = 234;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (TileID.Sets.Conversion.HardenedSand[type] && type != 399)
							{
								Main.tile[k, l].type = 399;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (TileID.Sets.Conversion.Sandstone[type] && type != 401)
							{
								Main.tile[k, l].type = 401;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (TileID.Sets.Conversion.Thorn[type] && type != 352)
							{
								Main.tile[k, l].type = 352;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							if (type == 59 && (Main.tile[k - 1, l].type == 199 || Main.tile[k + 1, l].type == 199 || Main.tile[k, l - 1].type == 199 || Main.tile[k, l + 1].type == 199))
							{
								Main.tile[k, l].type = 0;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
						}
						continue;
					case 2:
						if (type > 623 || wall > 316)
						{
							continue;
						}
						if (WallID.Sets.Conversion.Grass[wall] && wall != 70)
						{
							Main.tile[k, l].wall = 70;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l, 1);
						}
						else if (WallID.Sets.Conversion.Stone[wall] && wall != 28)
						{
							Main.tile[k, l].wall = 28;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l, 1);
						}
						else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 219)
						{
							Main.tile[k, l].wall = 219;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l, 1);
						}
						else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 222)
						{
							Main.tile[k, l].wall = 222;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l, 1);
						}
						else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 200)
						{
							Main.tile[k, l].wall = 200;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l, 1);
						}
						else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 201)
						{
							Main.tile[k, l].wall = 201;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l, 1);
						}
						else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 202)
						{
							Main.tile[k, l].wall = 202;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l, 1);
						}
						else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 203)
						{
							Main.tile[k, l].wall = 203;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l, 1);
						}
						if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type]) && type != 117)
						{
							Main.tile[k, l].type = 117;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l, 1);
						}
						else if (TileID.Sets.Conversion.GolfGrass[type] && type != 492)
						{
							Main.tile[k, l].type = 492;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l, 1);
						}
						else if (TileID.Sets.Conversion.Grass[type] && type != 109 && type != 492)
						{
							Main.tile[k, l].type = 109;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l, 1);
						}
						else if (TileID.Sets.Conversion.Ice[type] && type != 164)
						{
							Main.tile[k, l].type = 164;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l, 1);
						}
						else if (TileID.Sets.Conversion.Sand[type] && type != 116)
						{
							Main.tile[k, l].type = 116;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l, 1);
						}
						else if (TileID.Sets.Conversion.HardenedSand[type] && type != 402)
						{
							Main.tile[k, l].type = 402;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l, 1);
						}
						else if (TileID.Sets.Conversion.Sandstone[type] && type != 403)
						{
							Main.tile[k, l].type = 403;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l, 1);
						}
						else if (TileID.Sets.Conversion.Thorn[type])
						{
							KillTile(k, l);
							if (Main.netMode == 1)
							{
								NetMessage.SendData(17, -1, -1, null, 0, k, l);
							}
						}
						if (type == 59 && (Main.tile[k - 1, l].type == 109 || Main.tile[k + 1, l].type == 109 || Main.tile[k, l - 1].type == 109 || Main.tile[k, l + 1].type == 109))
						{
							Main.tile[k, l].type = 0;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l, 1);
						}
						continue;
					case 1:
						if (type <= 623 && wall <= 316)
						{
							if (WallID.Sets.Conversion.Grass[wall] && wall != 69)
							{
								Main.tile[k, l].wall = 69;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (WallID.Sets.Conversion.Stone[wall] && wall != 3)
							{
								Main.tile[k, l].wall = 3;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 217)
							{
								Main.tile[k, l].wall = 217;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 220)
							{
								Main.tile[k, l].wall = 220;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 188)
							{
								Main.tile[k, l].wall = 188;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 189)
							{
								Main.tile[k, l].wall = 189;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 190)
							{
								Main.tile[k, l].wall = 190;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 191)
							{
								Main.tile[k, l].wall = 191;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type]) && type != 25)
							{
								Main.tile[k, l].type = 25;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (TileID.Sets.Conversion.Grass[type] && type != 23)
							{
								Main.tile[k, l].type = 23;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (TileID.Sets.Conversion.Ice[type] && type != 163)
							{
								Main.tile[k, l].type = 163;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (TileID.Sets.Conversion.Sand[type] && type != 112)
							{
								Main.tile[k, l].type = 112;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (TileID.Sets.Conversion.HardenedSand[type] && type != 398)
							{
								Main.tile[k, l].type = 398;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (TileID.Sets.Conversion.Sandstone[type] && type != 400)
							{
								Main.tile[k, l].type = 400;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							else if (TileID.Sets.Conversion.Thorn[type] && type != 32)
							{
								Main.tile[k, l].type = 32;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
							if (type == 59 && (Main.tile[k - 1, l].type == 23 || Main.tile[k + 1, l].type == 23 || Main.tile[k, l - 1].type == 23 || Main.tile[k, l + 1].type == 23))
							{
								Main.tile[k, l].type = 0;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l, 1);
							}
						}
						continue;
					case 3:
						if (WallID.Sets.CanBeConvertedToGlowingMushroom[wall])
						{
							Main.tile[k, l].wall = 80;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l, 3);
						}
						if (Main.tile[k, l].type == 60)
						{
							Main.tile[k, l].type = 70;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l, 3);
						}
						else if (TileID.Sets.Conversion.Thorn[type])
						{
							KillTile(k, l);
							if (Main.netMode == 1)
							{
								NetMessage.SendData(17, -1, -1, null, 0, k, l);
							}
						}
						continue;
					}
					if (Main.tile[k, l].wall == 69 || Main.tile[k, l].wall == 70 || Main.tile[k, l].wall == 81)
					{
						if ((double)l < Main.worldSurface)
						{
							if (genRand.Next(10) == 0)
							{
								Main.tile[k, l].wall = 65;
							}
							else
							{
								Main.tile[k, l].wall = 63;
							}
						}
						else
						{
							Main.tile[k, l].wall = 64;
						}
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (WallID.Sets.Conversion.Stone[wall] && wall != 1 && wall != 262 && wall != 274 && wall != 61 && wall != 185)
					{
						Main.tile[k, l].wall = 1;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (WallID.Sets.Conversion.Stone[wall] && wall == 262)
					{
						Main.tile[k, l].wall = 61;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (WallID.Sets.Conversion.Stone[wall] && wall == 274)
					{
						Main.tile[k, l].wall = 185;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					if (WallID.Sets.Conversion.NewWall1[wall] && wall != 212)
					{
						Main.tile[k, l].wall = 212;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 213)
					{
						Main.tile[k, l].wall = 213;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 214)
					{
						Main.tile[k, l].wall = 214;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 215)
					{
						Main.tile[k, l].wall = 215;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (Main.tile[k, l].wall == 80)
					{
						if ((double)l < Main.worldSurface + 4.0 + (double)genRand.Next(3) || (double)l > ((double)Main.maxTilesY + Main.rockLayer) / 2.0 - 3.0 + (double)genRand.Next(3))
						{
							Main.tile[k, l].wall = 15;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l, 3);
						}
						else
						{
							Main.tile[k, l].wall = 64;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l, 3);
						}
					}
					else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 216)
					{
						Main.tile[k, l].wall = 216;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 187)
					{
						Main.tile[k, l].wall = 187;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					if (Main.tile[k, l].type == 492)
					{
						Main.tile[k, l].type = 477;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (type != 60 && TileID.Sets.Conversion.Grass[type] && type != 2 && type != 477)
					{
						Main.tile[k, l].type = 2;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (TileID.Sets.Conversion.Stone[type] && type != 1)
					{
						Main.tile[k, l].type = 1;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (TileID.Sets.Conversion.Sand[type] && type != 53)
					{
						Main.tile[k, l].type = 53;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (TileID.Sets.Conversion.HardenedSand[type] && type != 397)
					{
						Main.tile[k, l].type = 397;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (TileID.Sets.Conversion.Sandstone[type] && type != 396)
					{
						Main.tile[k, l].type = 396;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (TileID.Sets.Conversion.Ice[type] && type != 161)
					{
						Main.tile[k, l].type = 161;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (Main.tile[k, l].type == 70)
					{
						Main.tile[k, l].type = 60;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l, 1);
					}
					else if (Main.tile[k, l].type == 32 || Main.tile[k, l].type == 352)
					{
						KillTile(k, l);
						if (Main.netMode == 1)
						{
							NetMessage.SendData(17, -1, -1, null, 0, k, l);
						}
					}
				}
			}
		}

		public static void CactusFrame(int i, int j)
		{
			try
			{
				int num = j;
				int num2 = i;
				if (CheckCactus(i, j))
				{
					return;
				}
				while (Main.tile[num2, num].active() && Main.tile[num2, num].type == 80)
				{
					num++;
					if (Main.tile[num2, num] == null)
					{
						return;
					}
					if (!Main.tile[num2, num].active() || Main.tile[num2, num].type != 80)
					{
						if (Main.tile[num2 - 1, num] != null && Main.tile[num2 - 1, num].active() && Main.tile[num2 - 1, num].type == 80 && Main.tile[num2 - 1, num - 1].active() && Main.tile[num2 - 1, num - 1].type == 80 && num2 >= i)
						{
							num2--;
						}
						if (Main.tile[num2 + 1, num] != null && Main.tile[num2 + 1, num].active() && Main.tile[num2 + 1, num].type == 80 && Main.tile[num2 + 1, num - 1].active() && Main.tile[num2 + 1, num - 1].type == 80 && num2 <= i)
						{
							num2++;
						}
					}
				}
				num--;
				int num3 = i - num2;
				num2 = i;
				num = j;
				if (Main.tile[i - 2, j] == null)
				{
					return;
				}
				int type = Main.tile[i - 2, j].type;
				if (Main.tile[i - 1, j] == null)
				{
					return;
				}
				int num4 = Main.tile[i - 1, j].type;
				if (Main.tile[i + 1, j] == null)
				{
					return;
				}
				int num5 = Main.tile[i + 1, j].type;
				if (Main.tile[i, j - 1] == null)
				{
					return;
				}
				int num6 = Main.tile[i, j - 1].type;
				if (num6 == 227)
				{
					num6 = 80;
				}
				int num7 = Main.tile[i, j + 1].type;
				int num8 = Main.tile[i - 1, j + 1].type;
				int num9 = Main.tile[i + 1, j + 1].type;
				if (!Main.tile[i - 1, j].active())
				{
					num4 = -1;
				}
				if (!Main.tile[i + 1, j].active())
				{
					num5 = -1;
				}
				if (!Main.tile[i, j - 1].active())
				{
					num6 = -1;
				}
				if (!Main.tile[i, j + 1].active())
				{
					num7 = -1;
				}
				if (!Main.tile[i - 1, j + 1].active())
				{
					num8 = -1;
				}
				if (!Main.tile[i + 1, j + 1].active())
				{
					num9 = -1;
				}
				short num10 = Main.tile[i, j].frameX;
				short num11 = Main.tile[i, j].frameY;
				switch (num3)
				{
				case 0:
					if (num6 != 80)
					{
						if (num4 == 80 && num5 == 80 && num8 != 80 && num9 != 80 && type != 80)
						{
							num10 = 90;
							num11 = 0;
						}
						else if (num4 == 80 && num8 != 80 && type != 80)
						{
							num10 = 72;
							num11 = 0;
						}
						else if (num5 == 80 && num9 != 80)
						{
							num10 = 18;
							num11 = 0;
						}
						else
						{
							num10 = 0;
							num11 = 0;
						}
					}
					else if (num4 == 80 && num5 == 80 && num8 != 80 && num9 != 80 && type != 80)
					{
						num10 = 90;
						num11 = 36;
					}
					else if (num4 == 80 && num8 != 80 && type != 80)
					{
						num10 = 72;
						num11 = 36;
					}
					else if (num5 == 80 && num9 != 80)
					{
						num10 = 18;
						num11 = 36;
					}
					else if (num7 >= 0 && Main.tileSolid[num7])
					{
						num10 = 0;
						num11 = 36;
					}
					else
					{
						num10 = 0;
						num11 = 18;
					}
					break;
				case -1:
					if (num5 == 80)
					{
						if (num6 != 80 && num7 != 80)
						{
							num10 = 108;
							num11 = 36;
						}
						else if (num7 != 80)
						{
							num10 = 54;
							num11 = 36;
						}
						else if (num6 != 80)
						{
							num10 = 54;
							num11 = 0;
						}
						else
						{
							num10 = 54;
							num11 = 18;
						}
					}
					else if (num6 != 80)
					{
						num10 = 54;
						num11 = 0;
					}
					else
					{
						num10 = 54;
						num11 = 18;
					}
					break;
				case 1:
					if (num4 == 80)
					{
						if (num6 != 80 && num7 != 80)
						{
							num10 = 108;
							num11 = 18;
						}
						else if (num7 != 80)
						{
							num10 = 36;
							num11 = 36;
						}
						else if (num6 != 80)
						{
							num10 = 36;
							num11 = 0;
						}
						else
						{
							num10 = 36;
							num11 = 18;
						}
					}
					else if (num6 != 80)
					{
						num10 = 36;
						num11 = 0;
					}
					else
					{
						num10 = 36;
						num11 = 18;
					}
					break;
				}
				if (num10 != Main.tile[i, j].frameX || num11 != Main.tile[i, j].frameY)
				{
					Main.tile[i, j].frameX = num10;
					Main.tile[i, j].frameY = num11;
					DiamondTileFrame(i, j);
				}
			}
			catch
			{
				Main.tile[i, j].frameX = 0;
				Main.tile[i, j].frameY = 0;
			}
		}

		public static void GrowCactus(int i, int j)
		{
			int num = j;
			int num2 = i;
			if (!Main.tile[i, j].nactive() || Main.tile[i, j].halfBrick() || (!gen && Main.tile[i, j].slope() != 0) || Main.tile[i, j - 1].liquid > 0 || (Main.tile[i, j].type != 53 && Main.tile[i, j].type != 80 && Main.tile[i, j].type != 234 && Main.tile[i, j].type != 112 && Main.tile[i, j].type != 116))
			{
				return;
			}
			int num3 = 0;
			for (int k = i - cactusWaterWidth; k < i + cactusWaterWidth; k++)
			{
				for (int l = j - cactusWaterHeight; l < j + cactusWaterHeight; l++)
				{
					num3 += Main.tile[k, l].liquid;
				}
			}
			if (num3 / 255 > cactusWaterLimit)
			{
				return;
			}
			if (Main.tile[i, j].type == 53 || Main.tile[i, j].type == 112 || Main.tile[i, j].type == 116 || Main.tile[i, j].type == 234)
			{
				if (Main.tile[i, j - 1].active() || Main.tile[i - 1, j - 1].active() || Main.tile[i + 1, j - 1].active())
				{
					return;
				}
				int num4 = 0;
				int num5 = 0;
				for (int m = i - 6; m <= i + 6; m++)
				{
					for (int n = j - 3; n <= j + 1; n++)
					{
						try
						{
							if (!Main.tile[m, n].active())
							{
								continue;
							}
							if (Main.tile[m, n].type == 80)
							{
								num4++;
								if (num4 >= 4)
								{
									return;
								}
							}
							if (Main.tile[m, n].type == 53 || Main.tile[m, n].type == 112 || Main.tile[m, n].type == 116 || Main.tile[m, n].type == 234)
							{
								num5++;
							}
						}
						catch
						{
						}
					}
				}
				if (num5 > 10)
				{
					if (gen && genRand.Next(2) == 0)
					{
						Main.tile[i, j].slope(0);
					}
					Main.tile[i, j - 1].active(active: true);
					Main.tile[i, j - 1].type = 80;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, j - 1, 1);
					}
					SquareTileFrame(num2, num - 1);
				}
			}
			else
			{
				if (Main.tile[i, j].type != 80)
				{
					return;
				}
				while (Main.tile[num2, num].active() && Main.tile[num2, num].type == 80)
				{
					num++;
					if (!Main.tile[num2, num].active() || Main.tile[num2, num].type != 80)
					{
						if (Main.tile[num2 - 1, num].active() && Main.tile[num2 - 1, num].type == 80 && Main.tile[num2 - 1, num - 1].active() && Main.tile[num2 - 1, num - 1].type == 80 && num2 >= i)
						{
							num2--;
						}
						if (Main.tile[num2 + 1, num].active() && Main.tile[num2 + 1, num].type == 80 && Main.tile[num2 + 1, num - 1].active() && Main.tile[num2 + 1, num - 1].type == 80 && num2 <= i)
						{
							num2++;
						}
					}
				}
				num--;
				int num6 = num - j;
				int num7 = i - num2;
				num2 = i - num7;
				num = j;
				int num8 = 11 - num6;
				int num9 = 0;
				for (int num10 = num2 - 2; num10 <= num2 + 2; num10++)
				{
					for (int num11 = num - num8; num11 <= num + num6; num11++)
					{
						if (Main.tile[num10, num11].active() && Main.tile[num10, num11].type == 80)
						{
							num9++;
						}
					}
				}
				if (Main.drunkWorld)
				{
					if (num9 >= genRand.Next(11, 20))
					{
						return;
					}
				}
				else if (num9 >= genRand.Next(11, 13))
				{
					return;
				}
				num2 = i;
				num = j;
				if (num7 == 0)
				{
					if (num6 == 0)
					{
						if (!Main.tile[num2, num - 1].active())
						{
							Main.tile[num2, num - 1].active(active: true);
							Main.tile[num2, num - 1].type = 80;
							SquareTileFrame(num2, num - 1);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, num2, num - 1, 1);
							}
						}
						return;
					}
					bool flag = false;
					bool flag2 = false;
					if (Main.tile[num2, num - 1].active() && Main.tile[num2, num - 1].type == 80)
					{
						if (!Main.tile[num2 - 1, num].active() && !Main.tile[num2 - 2, num + 1].active() && !Main.tile[num2 - 1, num - 1].active() && !Main.tile[num2 - 1, num + 1].active() && !Main.tile[num2 - 2, num].active())
						{
							flag = true;
						}
						if (!Main.tile[num2 + 1, num].active() && !Main.tile[num2 + 2, num + 1].active() && !Main.tile[num2 + 1, num - 1].active() && !Main.tile[num2 + 1, num + 1].active() && !Main.tile[num2 + 2, num].active())
						{
							flag2 = true;
						}
					}
					int num12 = genRand.Next(3);
					if (num12 == 0 && flag)
					{
						Main.tile[num2 - 1, num].active(active: true);
						Main.tile[num2 - 1, num].type = 80;
						SquareTileFrame(num2 - 1, num);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num2 - 1, num, 1);
						}
					}
					else if (num12 == 1 && flag2)
					{
						Main.tile[num2 + 1, num].active(active: true);
						Main.tile[num2 + 1, num].type = 80;
						SquareTileFrame(num2 + 1, num);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num2 + 1, num, 1);
						}
					}
					else
					{
						if (num6 >= genRand.Next(2, 8))
						{
							return;
						}
						if (Main.tile[num2 - 1, num - 1].active())
						{
							_ = Main.tile[num2 - 1, num - 1].type;
							_ = 80;
						}
						if ((!Main.tile[num2 + 1, num - 1].active() || Main.tile[num2 + 1, num - 1].type != 80) && !Main.tile[num2, num - 1].active())
						{
							Main.tile[num2, num - 1].active(active: true);
							Main.tile[num2, num - 1].type = 80;
							SquareTileFrame(num2, num - 1);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, num2, num - 1, 1);
							}
						}
					}
				}
				else if (!Main.tile[num2, num - 1].active() && !Main.tile[num2, num - 2].active() && !Main.tile[num2 + num7, num - 1].active() && Main.tile[num2 - num7, num - 1].active() && Main.tile[num2 - num7, num - 1].type == 80)
				{
					Main.tile[num2, num - 1].active(active: true);
					Main.tile[num2, num - 1].type = 80;
					SquareTileFrame(num2, num - 1);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, num2, num - 1, 1);
					}
				}
			}
		}

		public static void CheckPot(int i, int j, int type = 28)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = 0;
			int num2 = j;
			for (num += Main.tile[i, j].frameX / 18; num > 1; num -= 2)
			{
			}
			num *= -1;
			num += i;
			int num3 = Main.tile[i, j].frameY / 18;
			int num4 = 0;
			while (num3 > 1)
			{
				num3 -= 2;
				num4++;
			}
			num2 -= num3;
			for (int k = num; k < num + 2; k++)
			{
				for (int l = num2; l < num2 + 2; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					int num5;
					for (num5 = Main.tile[k, l].frameX / 18; num5 > 1; num5 -= 2)
					{
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || num5 != k - num || Main.tile[k, l].frameY != (l - num2) * 18 + num4 * 36)
					{
						flag = true;
					}
				}
				if (Main.tile[k, num2 + 2] == null)
				{
					Main.tile[k, num2 + 2] = new Tile();
				}
				if (!SolidTile2(k, num2 + 2))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			if (num4 >= 7 && num4 <= 9)
			{
				SoundEngine.PlaySound(6, i * 16, j * 16);
			}
			else if (num4 >= 16 && num4 <= 24)
			{
				SoundEngine.PlaySound(4, i * 16, j * 16);
			}
			else
			{
				SoundEngine.PlaySound(13, i * 16, j * 16);
			}
			for (int m = num; m < num + 2; m++)
			{
				for (int n = num2; n < num2 + 2; n++)
				{
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
					{
						KillTile(m, n);
					}
				}
			}
			float num6 = 1f;
			bool flag2 = false;
			switch (num4)
			{
			case 0:
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 51);
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 52);
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 53);
				break;
			case 1:
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 166);
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 167);
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 168);
				break;
			case 2:
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 169);
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 170);
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 171);
				break;
			case 3:
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 172);
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 173);
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 174);
				break;
			case 4:
			case 5:
			case 6:
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 197);
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 198);
				num6 = 1.25f;
				break;
			default:
				if (num4 >= 7 && num4 <= 9)
				{
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 199);
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 200);
					num6 = 1.75f;
				}
				else if (num4 >= 10 && num4 <= 12)
				{
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 201);
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 202);
					num6 = 1.9f;
				}
				else if (num4 >= 13 && num4 <= 15)
				{
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 203);
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 204);
					num6 = 2.1f;
				}
				else if (num4 >= 16 && num4 <= 18)
				{
					num6 = 1.6f;
				}
				else if (num4 >= 19 && num4 <= 21)
				{
					num6 = 3.5f;
				}
				else if (num4 >= 22 && num4 <= 24)
				{
					num6 = 1.6f;
				}
				else if (num4 >= 25 && num4 <= 27)
				{
					num6 = 10f;
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), genRand.Next(217, 220));
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), genRand.Next(217, 220));
				}
				else if (num4 >= 28 && num4 <= 30)
				{
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), genRand.Next(315, 317));
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), genRand.Next(315, 317));
					if (Main.hardMode)
					{
						num6 = 4f;
					}
				}
				else if (num4 >= 31 && num4 <= 33)
				{
					int num7 = genRand.Next(2, 5);
					for (int num8 = 0; num8 < num7; num8++)
					{
						Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 698 + genRand.Next(6));
					}
					num6 = 2f;
				}
				else if (num4 >= 34 && num4 <= 36)
				{
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 1122);
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 1123);
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 1124);
					num6 = 1.25f;
					flag2 = true;
				}
				break;
			}
			num6 = (num6 * 2f + 1f) / 3f;
			int range = (int)(500f / ((num6 + 1f) / 2f));
			if (!gen)
			{
				if (Player.GetClosestRollLuck(i, j, range) == 0f)
				{
					if (Main.netMode != 1)
					{
						Projectile.NewProjectile(i * 16 + 16, j * 16 + 16, 0f, -12f, 518, 0, 0f, Main.myPlayer);
					}
				}
				else if (genRand.Next(35) == 0 && Main.wallDungeon[Main.tile[i, j].wall] && (double)j > Main.worldSurface)
				{
					Item.NewItem(i * 16, j * 16, 16, 16, 327);
				}
				else if (Main.getGoodWorld && genRand.Next(4) == 0)
				{
					Projectile.NewProjectile(i * 16 + 16, j * 16 + 8, (float)Main.rand.Next(-100, 101) * 0.002f, 0f, 28, 0, 0f, Player.FindClosest(new Vector2(i * 16, j * 16), 16, 16));
				}
				else if (genRand.Next(45) == 0 || (Main.rand.Next(45) == 0 && Main.expertMode))
				{
					if ((double)j < Main.worldSurface)
					{
						int num9 = genRand.Next(10);
						if (num9 == 0)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 292);
						}
						if (num9 == 1)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 298);
						}
						if (num9 == 2)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 299);
						}
						if (num9 == 3)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 290);
						}
						if (num9 == 4)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 2322);
						}
						if (num9 == 5)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 2324);
						}
						if (num9 == 6)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 2325);
						}
						if (num9 >= 7)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 2350, genRand.Next(1, 3));
						}
					}
					else if ((double)j < Main.rockLayer)
					{
						int num10 = genRand.Next(11);
						if (num10 == 0)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 289);
						}
						if (num10 == 1)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 298);
						}
						if (num10 == 2)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 299);
						}
						if (num10 == 3)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 290);
						}
						if (num10 == 4)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 303);
						}
						if (num10 == 5)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 291);
						}
						if (num10 == 6)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 304);
						}
						if (num10 == 7)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 2322);
						}
						if (num10 == 8)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 2329);
						}
						if (num10 >= 7)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 2350, genRand.Next(1, 3));
						}
					}
					else if (j < Main.UnderworldLayer)
					{
						int num11 = genRand.Next(15);
						if (num11 == 0)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 296);
						}
						if (num11 == 1)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 295);
						}
						if (num11 == 2)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 299);
						}
						if (num11 == 3)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 302);
						}
						if (num11 == 4)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 303);
						}
						if (num11 == 5)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 305);
						}
						if (num11 == 6)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 301);
						}
						if (num11 == 7)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 302);
						}
						if (num11 == 8)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 297);
						}
						if (num11 == 9)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 304);
						}
						if (num11 == 10)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 2322);
						}
						if (num11 == 11)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 2323);
						}
						if (num11 == 12)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 2327);
						}
						if (num11 == 13)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 2329);
						}
						if (num11 >= 7)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 2350, genRand.Next(1, 3));
						}
					}
					else
					{
						int num12 = genRand.Next(14);
						if (num12 == 0)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 296);
						}
						if (num12 == 1)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 295);
						}
						if (num12 == 2)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 293);
						}
						if (num12 == 3)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 288);
						}
						if (num12 == 4)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 294);
						}
						if (num12 == 5)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 297);
						}
						if (num12 == 6)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 304);
						}
						if (num12 == 7)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 305);
						}
						if (num12 == 8)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 301);
						}
						if (num12 == 9)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 302);
						}
						if (num12 == 10)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 288);
						}
						if (num12 == 11)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 300);
						}
						if (num12 == 12)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 2323);
						}
						if (num12 == 13)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 2326);
						}
						if (genRand.Next(5) == 0)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 4870);
						}
					}
				}
				else if (Main.netMode == 2 && Main.rand.Next(30) == 0)
				{
					Item.NewItem(i * 16, j * 16, 16, 16, 2997);
				}
				else
				{
					int num13 = Main.rand.Next(7);
					if (Main.expertMode)
					{
						num13--;
					}
					Player player = Main.player[Player.FindClosest(new Vector2(i * 16, j * 16), 16, 16)];
					if (num13 == 0 && player.statLife < player.statLifeMax2)
					{
						Item.NewItem(i * 16, j * 16, 16, 16, 58);
						if (Main.rand.Next(2) == 0)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, 58);
						}
						if (Main.expertMode)
						{
							if (Main.rand.Next(2) == 0)
							{
								Item.NewItem(i * 16, j * 16, 16, 16, 58);
							}
							if (Main.rand.Next(2) == 0)
							{
								Item.NewItem(i * 16, j * 16, 16, 16, 58);
							}
						}
					}
					else if (num13 == 1)
					{
						int num14 = Main.rand.Next(2, 7);
						if (Main.expertMode)
						{
							num14 += Main.rand.Next(1, 7);
						}
						int type2 = 8;
						int type3 = 282;
						if (player.ZoneHallow)
						{
							num14 += Main.rand.Next(2, 7);
							type2 = 4387;
						}
						else if ((num4 >= 22 && num4 <= 24) || player.ZoneCrimson)
						{
							num14 += Main.rand.Next(2, 7);
							type2 = 4386;
						}
						else if ((num4 >= 16 && num4 <= 18) || player.ZoneCorrupt)
						{
							num14 += Main.rand.Next(2, 7);
							type2 = 4385;
						}
						else if (num4 >= 7 && num4 <= 9)
						{
							num14 += Main.rand.Next(2, 7);
							type2 = 4388;
						}
						else if (num4 >= 4 && num4 <= 6)
						{
							type2 = 974;
							type3 = 286;
						}
						else if (num4 >= 34 && num4 <= 36)
						{
							num14 += Main.rand.Next(2, 7);
							type2 = 4383;
						}
						if (Main.tile[i, j].liquid > 0)
						{
							Item.NewItem(i * 16, j * 16, 16, 16, type3, num14);
						}
						else
						{
							Item.NewItem(i * 16, j * 16, 16, 16, type2, num14);
						}
					}
					else if (num13 == 2)
					{
						int stack = Main.rand.Next(10, 21);
						int type4 = 40;
						if ((double)j < Main.rockLayer && genRand.Next(2) == 0)
						{
							type4 = ((!Main.hardMode) ? 42 : 168);
						}
						if (j > Main.UnderworldLayer)
						{
							type4 = 265;
						}
						else if (Main.hardMode)
						{
							type4 = ((Main.rand.Next(2) != 0) ? 47 : ((SavedOreTiers.Silver != 168) ? 278 : 4915));
						}
						Item.NewItem(i * 16, j * 16, 16, 16, type4, stack);
					}
					else if (num13 == 3)
					{
						int type5 = 28;
						if (j > Main.UnderworldLayer || Main.hardMode)
						{
							type5 = 188;
						}
						int num15 = 1;
						if (Main.expertMode && Main.rand.Next(3) != 0)
						{
							num15++;
						}
						Item.NewItem(i * 16, j * 16, 16, 16, type5, num15);
					}
					else if (num13 == 4 && (flag2 || (double)j > Main.rockLayer))
					{
						int type6 = 166;
						if (flag2)
						{
							type6 = 4423;
						}
						int num16 = Main.rand.Next(4) + 1;
						if (Main.expertMode)
						{
							num16 += Main.rand.Next(4);
						}
						Item.NewItem(i * 16, j * 16, 16, 16, type6, num16);
					}
					else if ((num13 == 4 || num13 == 5) && j < Main.UnderworldLayer && !Main.hardMode)
					{
						int stack2 = Main.rand.Next(20, 41);
						Item.NewItem(i * 16, j * 16, 16, 16, 965, stack2);
					}
					else
					{
						float num17 = 200 + genRand.Next(-100, 101);
						if ((double)j < Main.worldSurface)
						{
							num17 *= 0.5f;
						}
						else if ((double)j < Main.rockLayer)
						{
							num17 *= 0.75f;
						}
						else if (j > Main.maxTilesY - 250)
						{
							num17 *= 1.25f;
						}
						num17 *= 1f + (float)Main.rand.Next(-20, 21) * 0.01f;
						if (Main.rand.Next(4) == 0)
						{
							num17 *= 1f + (float)Main.rand.Next(5, 11) * 0.01f;
						}
						if (Main.rand.Next(8) == 0)
						{
							num17 *= 1f + (float)Main.rand.Next(10, 21) * 0.01f;
						}
						if (Main.rand.Next(12) == 0)
						{
							num17 *= 1f + (float)Main.rand.Next(20, 41) * 0.01f;
						}
						if (Main.rand.Next(16) == 0)
						{
							num17 *= 1f + (float)Main.rand.Next(40, 81) * 0.01f;
						}
						if (Main.rand.Next(20) == 0)
						{
							num17 *= 1f + (float)Main.rand.Next(50, 101) * 0.01f;
						}
						if (Main.expertMode)
						{
							num17 *= 2.5f;
						}
						if (Main.expertMode && Main.rand.Next(2) == 0)
						{
							num17 *= 1.25f;
						}
						if (Main.expertMode && Main.rand.Next(3) == 0)
						{
							num17 *= 1.5f;
						}
						if (Main.expertMode && Main.rand.Next(4) == 0)
						{
							num17 *= 1.75f;
						}
						num17 *= num6;
						if (NPC.downedBoss1)
						{
							num17 *= 1.1f;
						}
						if (NPC.downedBoss2)
						{
							num17 *= 1.1f;
						}
						if (NPC.downedBoss3)
						{
							num17 *= 1.1f;
						}
						if (NPC.downedMechBoss1)
						{
							num17 *= 1.1f;
						}
						if (NPC.downedMechBoss2)
						{
							num17 *= 1.1f;
						}
						if (NPC.downedMechBoss3)
						{
							num17 *= 1.1f;
						}
						if (NPC.downedPlantBoss)
						{
							num17 *= 1.1f;
						}
						if (NPC.downedQueenBee)
						{
							num17 *= 1.1f;
						}
						if (NPC.downedGolemBoss)
						{
							num17 *= 1.1f;
						}
						if (NPC.downedPirates)
						{
							num17 *= 1.1f;
						}
						if (NPC.downedGoblins)
						{
							num17 *= 1.1f;
						}
						if (NPC.downedFrost)
						{
							num17 *= 1.1f;
						}
						while ((int)num17 > 0)
						{
							if (num17 > 1000000f)
							{
								int num18 = (int)(num17 / 1000000f);
								if (num18 > 50 && Main.rand.Next(2) == 0)
								{
									num18 /= Main.rand.Next(3) + 1;
								}
								if (Main.rand.Next(2) == 0)
								{
									num18 /= Main.rand.Next(3) + 1;
								}
								num17 -= (float)(1000000 * num18);
								Item.NewItem(i * 16, j * 16, 16, 16, 74, num18);
								continue;
							}
							if (num17 > 10000f)
							{
								int num19 = (int)(num17 / 10000f);
								if (num19 > 50 && Main.rand.Next(2) == 0)
								{
									num19 /= Main.rand.Next(3) + 1;
								}
								if (Main.rand.Next(2) == 0)
								{
									num19 /= Main.rand.Next(3) + 1;
								}
								num17 -= (float)(10000 * num19);
								Item.NewItem(i * 16, j * 16, 16, 16, 73, num19);
								continue;
							}
							if (num17 > 100f)
							{
								int num20 = (int)(num17 / 100f);
								if (num20 > 50 && Main.rand.Next(2) == 0)
								{
									num20 /= Main.rand.Next(3) + 1;
								}
								if (Main.rand.Next(2) == 0)
								{
									num20 /= Main.rand.Next(3) + 1;
								}
								num17 -= (float)(100 * num20);
								Item.NewItem(i * 16, j * 16, 16, 16, 72, num20);
								continue;
							}
							int num21 = (int)num17;
							if (num21 > 50 && Main.rand.Next(2) == 0)
							{
								num21 /= Main.rand.Next(3) + 1;
							}
							if (Main.rand.Next(2) == 0)
							{
								num21 /= Main.rand.Next(4) + 1;
							}
							if (num21 < 1)
							{
								num21 = 1;
							}
							num17 -= (float)num21;
							Item.NewItem(i * 16, j * 16, 16, 16, 71, num21);
						}
					}
				}
			}
			destroyObject = false;
		}

		public static int PlaceChest(int x, int y, ushort type = 21, bool notNearOtherChests = false, int style = 0)
		{
			int num = -1;
			if (TileID.Sets.Boulders[Main.tile[x, y + 1].type] || TileID.Sets.Boulders[Main.tile[x + 1, y + 1].type])
			{
				return -1;
			}
			if (TileObject.CanPlace(x, y, type, style, 1, out var objectData))
			{
				bool flag = true;
				if (notNearOtherChests && Chest.NearOtherChests(x - 1, y - 1))
				{
					flag = false;
				}
				if (flag)
				{
					TileObject.Place(objectData);
					num = Chest.CreateChest(objectData.xCoord, objectData.yCoord);
				}
			}
			else
			{
				num = -1;
			}
			if (num != -1 && Main.netMode == 1 && type == 21)
			{
				NetMessage.SendData(34, -1, -1, null, 0, x, y, style);
			}
			if (num != -1 && Main.netMode == 1 && type == 467)
			{
				NetMessage.SendData(34, -1, -1, null, 4, x, y, style);
			}
			return num;
		}

		public static void PlaceChestDirect(int x, int y, ushort type, int style, int id)
		{
			Chest.CreateChest(x, y - 1, id);
			for (int i = 0; i <= 1; i++)
			{
				for (int j = -1; j <= 0; j++)
				{
					if (Main.tile[x + i, y + j] == null)
					{
						Main.tile[x + i, y + j] = new Tile();
					}
				}
			}
			Main.tile[x, y - 1].active(active: true);
			Main.tile[x, y - 1].frameY = 0;
			Main.tile[x, y - 1].frameX = (short)(36 * style);
			Main.tile[x, y - 1].type = type;
			Main.tile[x, y - 1].halfBrick(halfBrick: false);
			Main.tile[x + 1, y - 1].active(active: true);
			Main.tile[x + 1, y - 1].frameY = 0;
			Main.tile[x + 1, y - 1].frameX = (short)(18 + 36 * style);
			Main.tile[x + 1, y - 1].type = type;
			Main.tile[x + 1, y - 1].halfBrick(halfBrick: false);
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].frameY = 18;
			Main.tile[x, y].frameX = (short)(36 * style);
			Main.tile[x, y].type = type;
			Main.tile[x, y].halfBrick(halfBrick: false);
			Main.tile[x + 1, y].active(active: true);
			Main.tile[x + 1, y].frameY = 18;
			Main.tile[x + 1, y].frameX = (short)(18 + 36 * style);
			Main.tile[x + 1, y].type = type;
			Main.tile[x + 1, y].halfBrick(halfBrick: false);
		}

		public static void PlaceDresserDirect(int x, int y, ushort type, int style, int id)
		{
			Chest.CreateChest(x - 1, y - 1, id);
			for (int i = -1; i <= 1; i++)
			{
				for (int j = -1; j <= 0; j++)
				{
					if (Main.tile[x + i, y + j] == null)
					{
						Main.tile[x + i, y + j] = new Tile();
					}
				}
			}
			short num = (short)(style * 54);
			Main.tile[x - 1, y - 1].active(active: true);
			Main.tile[x - 1, y - 1].frameY = 0;
			Main.tile[x - 1, y - 1].frameX = num;
			Main.tile[x - 1, y - 1].type = type;
			Main.tile[x, y - 1].active(active: true);
			Main.tile[x, y - 1].frameY = 0;
			Main.tile[x, y - 1].frameX = (short)(num + 18);
			Main.tile[x, y - 1].type = type;
			Main.tile[x + 1, y - 1].active(active: true);
			Main.tile[x + 1, y - 1].frameY = 0;
			Main.tile[x + 1, y - 1].frameX = (short)(num + 36);
			Main.tile[x + 1, y - 1].type = type;
			Main.tile[x - 1, y].active(active: true);
			Main.tile[x - 1, y].frameY = 18;
			Main.tile[x - 1, y].frameX = num;
			Main.tile[x - 1, y].type = type;
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].frameY = 18;
			Main.tile[x, y].frameX = (short)(num + 18);
			Main.tile[x, y].type = type;
			Main.tile[x + 1, y].active(active: true);
			Main.tile[x + 1, y].frameY = 18;
			Main.tile[x + 1, y].frameX = (short)(num + 36);
			Main.tile[x + 1, y].type = type;
		}

		public static void CheckChest(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = 0;
			int num2 = j;
			num += Main.tile[i, j].frameX / 18;
			num2 += Main.tile[i, j].frameY / 18 * -1;
			while (num > 1)
			{
				num -= 2;
			}
			num *= -1;
			num += i;
			for (int k = num; k < num + 2; k++)
			{
				for (int l = num2; l < num2 + 2; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					int num3;
					for (num3 = Main.tile[k, l].frameX / 18; num3 > 1; num3 -= 2)
					{
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || num3 != k - num || Main.tile[k, l].frameY != (l - num2) * 18)
					{
						flag = true;
					}
				}
				if (Main.tile[k, num2 + 2] == null)
				{
					Main.tile[k, num2 + 2] = new Tile();
				}
				if ((!Main.tile[k, num2 + 2].active() || !Main.tileSolid[Main.tile[k, num2 + 2].type]) && Chest.CanDestroyChest(num, num2))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			int chestItemDrop = GetChestItemDrop(i, j, type);
			destroyObject = true;
			for (int m = num; m < num + 2; m++)
			{
				for (int n = num2; n < num2 + 3; n++)
				{
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
					{
						Chest.DestroyChest(m, n);
						KillTile(m, n);
					}
				}
			}
			Item.NewItem(i * 16, j * 16, 32, 32, chestItemDrop);
			destroyObject = false;
		}

		private static int GetChestItemDrop(int x, int y, int type)
		{
			int num = Main.tile[x, y].frameX / 36;
			if (type == 467)
			{
				return Chest.chestItemSpawn2[num];
			}
			return Chest.chestItemSpawn[num];
		}

		public static bool PlaceActuator(int i, int j)
		{
			if (!Main.tile[i, j].actuator())
			{
				SoundEngine.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].actuator(actuator: true);
				return true;
			}
			return false;
		}

		public static bool KillActuator(int i, int j)
		{
			if (Main.tile[i, j].actuator())
			{
				SoundEngine.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].actuator(actuator: false);
				if (Main.netMode != 1)
				{
					Item.NewItem(i * 16, j * 16, 16, 16, 849);
				}
				for (int k = 0; k < 5; k++)
				{
					Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 50);
				}
				return true;
			}
			return false;
		}

		public static bool PlaceWire(int i, int j)
		{
			if (!Main.tile[i, j].wire())
			{
				SoundEngine.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].wire(wire: true);
				return true;
			}
			return false;
		}

		public static bool KillWire(int i, int j)
		{
			if (Main.tile[i, j].wire())
			{
				SoundEngine.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].wire(wire: false);
				if (Main.netMode != 1)
				{
					Item.NewItem(i * 16, j * 16, 16, 16, 530);
				}
				for (int k = 0; k < 5; k++)
				{
					Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 50);
				}
				return true;
			}
			return false;
		}

		public static bool PlaceWire2(int i, int j)
		{
			if (!Main.tile[i, j].wire2())
			{
				SoundEngine.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].wire2(wire2: true);
				return true;
			}
			return false;
		}

		public static bool KillWire2(int i, int j)
		{
			if (Main.tile[i, j].wire2())
			{
				SoundEngine.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].wire2(wire2: false);
				if (Main.netMode != 1)
				{
					Item.NewItem(i * 16, j * 16, 16, 16, 530);
				}
				for (int k = 0; k < 5; k++)
				{
					Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 50);
				}
				return true;
			}
			return false;
		}

		public static bool PlaceWire3(int i, int j)
		{
			if (!Main.tile[i, j].wire3())
			{
				SoundEngine.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].wire3(wire3: true);
				return true;
			}
			return false;
		}

		public static bool KillWire3(int i, int j)
		{
			if (Main.tile[i, j].wire3())
			{
				SoundEngine.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].wire3(wire3: false);
				if (Main.netMode != 1)
				{
					Item.NewItem(i * 16, j * 16, 16, 16, 530);
				}
				for (int k = 0; k < 5; k++)
				{
					Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 50);
				}
				return true;
			}
			return false;
		}

		public static bool PlaceWire4(int i, int j)
		{
			if (!Main.tile[i, j].wire4())
			{
				SoundEngine.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].wire4(wire4: true);
				return true;
			}
			return false;
		}

		public static bool KillWire4(int i, int j)
		{
			if (Main.tile[i, j].wire4())
			{
				SoundEngine.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].wire4(wire4: false);
				if (Main.netMode != 1)
				{
					Item.NewItem(i * 16, j * 16, 16, 16, 530);
				}
				for (int k = 0; k < 5; k++)
				{
					Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 50);
				}
				return true;
			}
			return false;
		}

		public static bool IsFitToPlaceFlowerIn(int x, int y, int typeAttemptedToPlace)
		{
			if (y < 1 || y > Main.maxTilesY - 1)
			{
				return false;
			}
			Tile tile = Main.tile[x, y + 1];
			if (tile.active() && tile.slope() == 0 && !tile.halfBrick())
			{
				if (((tile.type != 2 && tile.type != 78 && tile.type != 380 && tile.type != 477 && tile.type != 579) || typeAttemptedToPlace != 3) && (tile.type != 23 || typeAttemptedToPlace != 24) && ((tile.type != 109 && tile.type != 492) || typeAttemptedToPlace != 110))
				{
					if (tile.type == 199)
					{
						return typeAttemptedToPlace == 201;
					}
					return false;
				}
				return true;
			}
			return false;
		}

		private static bool SeaOatWaterCheck(int x, int y)
		{
			int num = 45;
			int num2 = 20;
			int num3 = 20;
			int num4 = -1;
			int num5 = num + 1;
			int num6 = 0;
			bool flag = false;
			if (x <= beachDistance || x >= Main.maxTilesX - beachDistance)
			{
				flag = true;
				num4 = 40;
				num = 65;
				num2 += 5;
			}
			for (int i = x - num; i <= x + num; i++)
			{
				for (int j = y - num2; j <= y + num2; j++)
				{
					if (InWorld(i, j) && !SolidTile(i, j) && Main.tile[i, j].liquid > 0)
					{
						num6 += Main.tile[i, j].liquid;
						int num7 = Math.Abs(i - x);
						if (num7 < num5)
						{
							num5 = num7;
						}
					}
				}
			}
			if (num6 / 255 >= num3)
			{
				if (flag)
				{
					return false;
				}
				return true;
			}
			if (flag)
			{
				return true;
			}
			return false;
		}

		private static bool PlantSeaOat(int x, int y)
		{
			if (Main.tile[x, y].wall > 0 || Main.tile[x, y].active() || Main.tile[x, y].liquid > 0 || !SolidTileAllowBottomSlope(x, y + 1) || !TileID.Sets.Conversion.Sand[Main.tile[x, y + 1].type])
			{
				return false;
			}
			if (!SeaOatWaterCheck(x, y))
			{
				return false;
			}
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].slope(0);
			Main.tile[x, y].halfBrick(halfBrick: false);
			Main.tile[x, y].type = 529;
			Main.tile[x, y].frameX = (short)(genRand.Next(5) * 18);
			int num = 0;
			Main.tile[x, y].frameY = (short)(num * 34);
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, x, y, 1);
			}
			return true;
		}

		private static bool CheckSeaOat(int x, int y)
		{
			if (!SeaOatWaterCheck(x, y))
			{
				KillTile(x, y);
				if (Main.netMode == 2)
				{
					NetMessage.SendData(17, -1, -1, null, 0, x, y);
				}
				return false;
			}
			return true;
		}

		private static bool GrowSeaOat(int x, int y)
		{
			if (Main.tile[x, y].frameX < 180)
			{
				Main.tile[x, y].frameX += 90;
			}
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, x, y, 1);
			}
			return false;
		}

		private static int GetWaterDepth(int x, int y)
		{
			int num = y;
			while (!SolidTile(x, num))
			{
				num++;
				if (num > Main.maxTilesY - 1)
				{
					return 0;
				}
			}
			num--;
			int num2 = num;
			while (Main.tile[x, num2].liquid > 0 && !SolidTile(x, num2))
			{
				num2--;
			}
			return num - num2;
		}

		private static int CountGrowingPlantTiles(int x, int y, int range, int type)
		{
			int num = 0;
			for (int i = x - range; i <= x + range; i++)
			{
				for (int j = y - range * 3; j <= y + range * 3; j++)
				{
					if (Main.tile[i, j].active() && Main.tile[i, j].type == type)
					{
						num++;
					}
				}
			}
			return num;
		}

		private static bool PlaceBamboo(int x, int y)
		{
			int num = 2;
			int num2 = 5;
			int num3 = genRand.Next(1, 21);
			if (Main.tile[x, y].wall > 0)
			{
				return false;
			}
			Tile tile = Main.tile[x, y + 1];
			if (tile.type == 571 || tile.type == 60)
			{
				int waterDepth = GetWaterDepth(x, y);
				if (waterDepth < num || waterDepth > num2)
				{
					return false;
				}
				int num4 = CountGrowingPlantTiles(x, y, 5, 571);
				int i = 1;
				if (tile.type == 571)
				{
					for (; !SolidTile(x, y + i); i++)
					{
					}
					if (i + num4 / genRand.Next(1, 21) > num3)
					{
						return false;
					}
				}
				else
				{
					num4 += 25;
				}
				num4 += i * 2;
				if (num4 > genRand.Next(40, 61))
				{
					return false;
				}
				Tile tile2 = Main.tile[x, y];
				tile2.active(active: true);
				tile2.type = 571;
				tile2.frameX = 0;
				tile2.frameY = 0;
				tile2.slope(0);
				tile2.halfBrick(halfBrick: false);
				SquareTileFrame(x, y);
				return true;
			}
			return false;
		}

		public static void CheckBamboo(int x, int y)
		{
			Tile tile = Main.tile[x, y + 1];
			if (tile == null)
			{
				return;
			}
			if (!tile.active() || (tile.type != 60 && tile.type != 571))
			{
				KillTile(x, y);
				if (Main.netMode == 2)
				{
					NetMessage.SendData(17, -1, -1, null, 0, x, y);
				}
				SquareTileFrame(x, y);
				return;
			}
			Tile tile2 = Main.tile[x, y - 1];
			if (tile2 == null)
			{
				return;
			}
			Tile tile3 = Main.tile[x, y];
			if (tile3 == null)
			{
				return;
			}
			bool num = tile2.active() && tile2.type == 571;
			bool flag = tile.active() && tile.type == 571;
			int num2 = tile3.frameX / 18;
			tile3.frameY = 0;
			if (num)
			{
				if (flag)
				{
					if (num2 < 5 || num2 > 14)
					{
						tile3.frameX = (short)(genRand.Next(5, 15) * 18);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, x, y, 1);
						}
					}
				}
				else if (num2 < 1 || num2 > 4)
				{
					tile3.frameX = (short)(genRand.Next(1, 5) * 18);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y, 1);
					}
				}
			}
			else if (flag)
			{
				if (num2 < 15 || num2 > 19)
				{
					tile3.frameX = (short)(genRand.Next(15, 20) * 18);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y, 1);
					}
				}
			}
			else if (num2 != 0)
			{
				tile3.frameX = 0;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y, 1);
				}
			}
		}

		public static void PlaceUnderwaterPlant(ushort type, int x, int y)
		{
			if (CanUnderwaterPlantGrowHere(type, x, y, ignoreSelf: false))
			{
				Tile tileSafely = Framing.GetTileSafely(x, y + 1);
				tileSafely.slope(0);
				tileSafely.halfBrick(halfBrick: false);
				Tile tileSafely2 = Framing.GetTileSafely(x, y);
				tileSafely2.active(active: true);
				tileSafely2.type = type;
				tileSafely2.frameX = 0;
				tileSafely2.frameY = 0;
				tileSafely2.slope(0);
				tileSafely2.halfBrick(halfBrick: false);
				SquareTileFrame(x, y);
			}
		}

		public static bool CanUnderwaterPlantGrowHere(ushort type, int x, int y, bool ignoreSelf)
		{
			if (!InWorld(x, y, 50))
			{
				return false;
			}
			Tile tileSafely = Framing.GetTileSafely(x, y);
			if (!ignoreSelf && tileSafely.active())
			{
				return false;
			}
			for (int i = 0; i < 3; i++)
			{
				tileSafely = Framing.GetTileSafely(x, y - i);
				if (tileSafely.liquid == 0 || tileSafely.liquidType() != 0)
				{
					return false;
				}
			}
			Tile tileSafely2 = Framing.GetTileSafely(x, y + 1);
			if (!tileSafely2.nactive())
			{
				return false;
			}
			if (!TileID.Sets.Conversion.Sand[tileSafely2.type] && type != tileSafely2.type)
			{
				return false;
			}
			tileSafely = Framing.GetTileSafely(x, y);
			ushort wall = tileSafely.wall;
			if (wall != 0 && (uint)(wall - 63) > 6u && (uint)(wall - 80) > 1u)
			{
				return false;
			}
			return true;
		}

		public static void CheckUnderwaterPlant(ushort type, int x, int y)
		{
			if (!CanUnderwaterPlantGrowHere(type, x, y, ignoreSelf: true))
			{
				KillTile(x, y);
				if (Main.netMode == 2)
				{
					NetMessage.SendData(17, -1, -1, null, 0, x, y);
				}
				SquareTileFrame(x, y);
				return;
			}
			Tile tileSafely = Framing.GetTileSafely(x, y - 1);
			Tile tileSafely2 = Framing.GetTileSafely(x, y);
			Tile tileSafely3 = Framing.GetTileSafely(x, y + 1);
			bool num = tileSafely.active() && tileSafely.type == type;
			bool flag = tileSafely3.active() && tileSafely3.type == type;
			int num2 = tileSafely2.frameX / 18;
			tileSafely2.frameY = 0;
			if (num)
			{
				if (1 > num2 || num2 > 7)
				{
					tileSafely2.frameX = (short)(genRand.Next(1, 8) * 18);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y, 1);
					}
				}
			}
			else if (flag)
			{
				if (7 > num2 || num2 > 12)
				{
					tileSafely2.frameX = (short)(genRand.Next(7, 13) * 18);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y, 1);
					}
				}
			}
			else if (num2 != 0)
			{
				tileSafely2.frameX = 0;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y, 1);
				}
			}
		}

		public static Point PlaceCatTail(int x, int j)
		{
			int num = j;
			Point result = new Point(-1, -1);
			if (x < 50 || x > Main.maxTilesX - 50 || num < 50 || num > Main.maxTilesY - 50)
			{
				return result;
			}
			if ((Main.tile[x, num].active() && Main.tile[x, num].type != 71) || Main.tile[x, num].liquid == 0 || Main.tile[x, num].liquidType() != 0)
			{
				return result;
			}
			while (Main.tile[x, num].liquid > 0 && num > 50)
			{
				num--;
			}
			num++;
			if (Main.tile[x, num].active() || Main.tile[x, num - 1].active() || Main.tile[x, num].liquid == 0 || Main.tile[x, num].liquidType() != 0)
			{
				return result;
			}
			if (Main.tile[x, num].wall != 0 && Main.tile[x, num].wall != 80 && Main.tile[x, num].wall != 81 && Main.tile[x, num].wall != 69 && (Main.tile[x, num].wall < 63 || Main.tile[x, num].wall > 68))
			{
				return result;
			}
			int num2 = 7;
			int num3 = 0;
			for (int i = x - num2; i <= x + num2; i++)
			{
				for (int k = num - num2; k <= num + num2; k++)
				{
					if (Main.tile[i, k].active() && Main.tile[i, k].type == 519)
					{
						num3++;
						break;
					}
				}
			}
			if (num3 > 3)
			{
				return result;
			}
			int l;
			for (l = num; (!Main.tile[x, l].active() || !Main.tileSolid[Main.tile[x, l].type] || Main.tileSolidTop[Main.tile[x, l].type]) && l < Main.maxTilesY - 50; l++)
			{
				if (Main.tile[x, l].active() && Main.tile[x, l].type != 71)
				{
					return result;
				}
			}
			int num4 = catTailDistance - 1;
			if (l - num > num4)
			{
				return result;
			}
			if (l - num < 2)
			{
				return result;
			}
			int type = Main.tile[x, l].type;
			if (!Main.tile[x, l].nactive())
			{
				return result;
			}
			int num5 = -1;
			switch (type)
			{
			case 2:
			case 477:
				num5 = 0;
				break;
			case 53:
				if (x < beachDistance || x > Main.maxTilesX - beachDistance)
				{
					return result;
				}
				num5 = 18;
				break;
			case 199:
			case 234:
				num5 = 54;
				break;
			case 23:
			case 112:
				num5 = 72;
				break;
			case 70:
				num5 = 90;
				break;
			}
			if (num5 < 0)
			{
				return result;
			}
			if (Main.tile[x, l].topSlope() && gen && genRand.Next(3) != 0)
			{
				Main.tile[x, l].slope(0);
			}
			else if (Main.tile[x, l].topSlope() || Main.tile[x, l].halfBrick())
			{
				return result;
			}
			num = l - 1;
			Main.tile[x, num].active(active: true);
			Main.tile[x, num].type = 519;
			Main.tile[x, num].frameX = 0;
			Main.tile[x, num].frameY = (short)num5;
			Main.tile[x, num].halfBrick(halfBrick: false);
			Main.tile[x, num].slope(0);
			SquareTileFrame(x, num);
			return new Point(x, num);
		}

		public static void CheckCatTail(int x, int j)
		{
			if (Main.tile[x, j] == null)
			{
				return;
			}
			int num = j;
			bool flag = false;
			int num2 = num;
			while ((!Main.tile[x, num2].active() || !Main.tileSolid[Main.tile[x, num2].type] || Main.tileSolidTop[Main.tile[x, num2].type]) && num2 < Main.maxTilesY - 50)
			{
				if (Main.tile[x, num2].active() && Main.tile[x, num2].type != 519)
				{
					flag = true;
				}
				if (!Main.tile[x, num2].active())
				{
					break;
				}
				num2++;
				if (Main.tile[x, num2] == null)
				{
					return;
				}
			}
			num = num2 - 1;
			if (Main.tile[x, num] == null)
			{
				return;
			}
			while (Main.tile[x, num] != null && Main.tile[x, num].liquid > 0 && num > 50)
			{
				if ((Main.tile[x, num].active() && Main.tile[x, num].type != 519) || Main.tile[x, num].liquidType() != 0)
				{
					flag = true;
				}
				num--;
				if (Main.tile[x, num] == null)
				{
					return;
				}
			}
			num++;
			if (Main.tile[x, num] == null)
			{
				return;
			}
			int num3 = num;
			int num4 = catTailDistance;
			if (num2 - num3 > num4)
			{
				flag = true;
			}
			int type = Main.tile[x, num2].type;
			int num5 = -1;
			switch (type)
			{
			case 2:
			case 477:
				num5 = 0;
				break;
			case 53:
				num5 = 18;
				break;
			case 199:
			case 234:
				num5 = 54;
				break;
			case 23:
			case 112:
				num5 = 72;
				break;
			case 70:
				num5 = 90;
				break;
			}
			if (!Main.tile[x, num2].nactive())
			{
				flag = true;
			}
			if (num5 < 0)
			{
				flag = true;
			}
			num = num2 - 1;
			if (Main.tile[x, num] != null && !Main.tile[x, num].active())
			{
				for (int num6 = num; num6 >= num3; num6--)
				{
					if (Main.tile[x, num6] == null)
					{
						return;
					}
					if (Main.tile[x, num6].active() && Main.tile[x, num6].type == 519)
					{
						num = num6;
						break;
					}
				}
			}
			while (Main.tile[x, num] != null && Main.tile[x, num].active() && Main.tile[x, num].type == 519)
			{
				num--;
			}
			num++;
			if (Main.tile[x, num2 - 1] != null && Main.tile[x, num2 - 1].liquid < 127 && genRand.Next(4) == 0)
			{
				flag = true;
			}
			if (Main.tile[x, num] != null && Main.tile[x, num].frameX >= 180 && Main.tile[x, num].liquid > 127 && genRand.Next(4) == 0)
			{
				flag = true;
			}
			if (Main.tile[x, num] != null && Main.tile[x, num2 - 1] != null && Main.tile[x, num].frameX > 18)
			{
				if (Main.tile[x, num2 - 1].frameX < 36 || Main.tile[x, num2 - 1].frameX > 72)
				{
					flag = true;
				}
				else if (Main.tile[x, num].frameX < 90)
				{
					flag = true;
				}
				else if (Main.tile[x, num].frameX >= 108 && Main.tile[x, num].frameX <= 162)
				{
					Main.tile[x, num].frameX = 90;
				}
			}
			if (num2 > num + 4 && Main.tile[x, num + 4] != null && Main.tile[x, num + 3] != null && Main.tile[x, num + 4].liquid == 0 && Main.tile[x, num + 3].type == 519)
			{
				flag = true;
			}
			if (flag)
			{
				int num7 = num3;
				if (num < num3)
				{
					num7 = num;
				}
				num7 -= 4;
				for (int i = num7; i <= num2; i++)
				{
					if (Main.tile[x, i] != null && Main.tile[x, i].active() && Main.tile[x, i].type == 519)
					{
						KillTile(x, i);
						if (Main.netMode == 2)
						{
							NetMessage.SendData(17, -1, -1, null, 0, x, i);
						}
						SquareTileFrame(x, i);
					}
				}
			}
			else
			{
				if (num5 == Main.tile[x, num].frameY)
				{
					return;
				}
				for (int k = num; k < num2; k++)
				{
					if (Main.tile[x, k] != null && Main.tile[x, k].active() && Main.tile[x, k].type == 519)
					{
						Main.tile[x, k].frameY = (short)num5;
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, x, num, 2);
						}
					}
				}
			}
		}

		public static void GrowCheckSeaweed(int x, int y)
		{
			int maxValue = 1;
			if (Main.netMode == 1)
			{
				return;
			}
			if ((Main.tile[x, y].type == 549 && Main.tile[x, y].liquid < 200) || Main.tile[x, y - 1].liquid < 200)
			{
				if (Main.tile[x, y].active() && Main.tile[x, y].type == 549 && genRand.Next(2) == 0)
				{
					KillTile(x, y);
					if (Main.netMode == 2)
					{
						NetMessage.SendData(17, -1, -1, null, 0, x, y);
					}
				}
			}
			else
			{
				if (Main.tile[x, y - 1].active() || Main.tile[x, y - 2].active() || genRand.Next(maxValue) != 0 || Main.tile[x, y - 2].liquid != byte.MaxValue || Main.tile[x, y - 3].liquid != byte.MaxValue)
				{
					return;
				}
				int num = 17;
				int num2 = 4;
				int num3 = 30;
				int num4 = 0;
				for (int i = x - num2; i <= x + num2; i++)
				{
					for (int j = y; j <= y + num2 * 3; j++)
					{
						if (Main.tile[i, j].active() && Main.tile[i, j].type == 549)
						{
							num4++;
							if (num4 > num3)
							{
								return;
							}
						}
					}
				}
				int k;
				for (k = y; !SolidTile(x, k) && k < Main.maxTilesY - 50; k++)
				{
				}
				if (k - y < num - genRand.Next(20))
				{
					PlaceTile(x, y - 1, 549, mute: true);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y - 1, 2);
					}
				}
			}
		}

		public static void GrowCatTail(int x, int j)
		{
			if (Main.netMode == 1)
			{
				return;
			}
			int num = j;
			while (Main.tile[x, num].liquid > 0 && num > 50)
			{
				num--;
			}
			num++;
			int i;
			for (i = num; (!Main.tile[x, i].active() || !Main.tileSolid[Main.tile[x, i].type] || Main.tileSolidTop[Main.tile[x, i].type]) && i < Main.maxTilesY - 50; i++)
			{
			}
			num = i - 1;
			while (Main.tile[x, num].active() && Main.tile[x, num].type == 519)
			{
				num--;
			}
			num++;
			if (Main.tile[x, num].frameX == 90 && Main.tile[x, num - 1].active() && Main.tileCut[Main.tile[x, num - 1].type])
			{
				KillTile(x, num - 1);
				if (Main.netMode == 2)
				{
					NetMessage.SendData(17, -1, -1, null, 0, x, num - 1);
				}
			}
			if (Main.tile[x, num - 1].active())
			{
				return;
			}
			if (Main.tile[x, num].frameX == 0)
			{
				Main.tile[x, num].frameX = 18;
				SquareTileFrame(x, num);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, num, 2);
				}
			}
			else if (Main.tile[x, num].frameX == 18)
			{
				Main.tile[x, num].frameX = (short)(18 * genRand.Next(2, 5));
				Main.tile[x, num - 1].active(active: true);
				Main.tile[x, num - 1].type = 519;
				Main.tile[x, num - 1].frameX = 90;
				Main.tile[x, num - 1].frameY = Main.tile[x, num].frameY;
				Main.tile[x, num - 1].halfBrick(halfBrick: false);
				Main.tile[x, num - 1].slope(0);
				SquareTileFrame(x, num);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, num, 2);
				}
			}
			else if (Main.tile[x, num].frameX == 90)
			{
				if (Main.tile[x, num - 1].liquid == 0)
				{
					if (!Main.tile[x, num - 2].active() && (Main.tile[x, num].liquid > 0 || Main.tile[x, num + 1].liquid > 0 || Main.tile[x, num + 2].liquid > 0) && genRand.Next(3) == 0)
					{
						Main.tile[x, num].frameX = 108;
						Main.tile[x, num - 1].active(active: true);
						Main.tile[x, num - 1].type = 519;
						Main.tile[x, num - 1].frameX = 90;
						Main.tile[x, num - 1].frameY = Main.tile[x, num].frameY;
						Main.tile[x, num - 1].halfBrick(halfBrick: false);
						Main.tile[x, num - 1].slope(0);
						SquareTileFrame(x, num);
					}
					else
					{
						int num2 = genRand.Next(3);
						Main.tile[x, num].frameX = (short)(126 + num2 * 18);
						Main.tile[x, num - 1].active(active: true);
						Main.tile[x, num - 1].type = 519;
						Main.tile[x, num - 1].frameX = (short)(180 + num2 * 18);
						Main.tile[x, num - 1].frameY = Main.tile[x, num].frameY;
						Main.tile[x, num - 1].halfBrick(halfBrick: false);
						Main.tile[x, num - 1].slope(0);
						SquareTileFrame(x, num);
					}
				}
				else
				{
					Main.tile[x, num].frameX = 108;
					Main.tile[x, num - 1].active(active: true);
					Main.tile[x, num - 1].type = 519;
					Main.tile[x, num - 1].frameX = 90;
					Main.tile[x, num - 1].frameY = Main.tile[x, num].frameY;
					Main.tile[x, num - 1].halfBrick(halfBrick: false);
					Main.tile[x, num - 1].slope(0);
					SquareTileFrame(x, num);
				}
			}
			SquareTileFrame(x, num - 1, resetFrame: false);
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, x, num, 2);
			}
		}

		public static bool PlaceLilyPad(int x, int j)
		{
			int num = j;
			if (x < 50 || x > Main.maxTilesX - 50 || num < 50 || num > Main.maxTilesY - 50)
			{
				return false;
			}
			if (Main.tile[x, num].active() || Main.tile[x, num].liquid == 0 || Main.tile[x, num].liquidType() != 0)
			{
				return false;
			}
			while (Main.tile[x, num].liquid > 0 && num > 50)
			{
				num--;
			}
			num++;
			if (Main.tile[x, num].active() || Main.tile[x, num - 1].active() || Main.tile[x, num].liquid == 0 || Main.tile[x, num].liquidType() != 0)
			{
				return false;
			}
			if (Main.tile[x, num].wall != 0 && Main.tile[x, num].wall != 15 && Main.tile[x, num].wall != 70 && (Main.tile[x, num].wall < 63 || Main.tile[x, num].wall > 68))
			{
				return false;
			}
			int num2 = 5;
			int num3 = 0;
			for (int i = x - num2; i <= x + num2; i++)
			{
				for (int k = num - num2; k <= num + num2; k++)
				{
					if (Main.tile[i, k].active() && Main.tile[i, k].type == 518)
					{
						num3++;
					}
				}
			}
			if (num3 > 3)
			{
				return false;
			}
			int l;
			for (l = num; (!Main.tile[x, l].active() || !Main.tileSolid[Main.tile[x, l].type] || Main.tileSolidTop[Main.tile[x, l].type]) && l < Main.maxTilesY - 50; l++)
			{
				if (Main.tile[x, l].active() && Main.tile[x, l].type == 519)
				{
					return false;
				}
			}
			int num4 = 12;
			if (l - num > num4)
			{
				return false;
			}
			if (l - num < 3)
			{
				return false;
			}
			int type = Main.tile[x, l].type;
			int num5 = -1;
			if (type == 2 || type == 477)
			{
				num5 = 0;
			}
			if (type == 109 || type == 109 || type == 116)
			{
				num5 = 18;
			}
			if (type == 60)
			{
				num5 = 36;
			}
			if (num5 < 0)
			{
				return false;
			}
			Main.tile[x, num].active(active: true);
			Main.tile[x, num].type = 518;
			if (genRand.Next(2) == 0)
			{
				Main.tile[x, num].frameX = (short)(18 * genRand.Next(3));
			}
			else if (genRand.Next(15) == 0)
			{
				Main.tile[x, num].frameX = (short)(18 * genRand.Next(18));
			}
			else
			{
				int num6 = Main.maxTilesX / 5;
				if (x < num6)
				{
					Main.tile[x, num].frameX = (short)(18 * genRand.Next(6, 9));
				}
				else if (x < num6 * 2)
				{
					Main.tile[x, num].frameX = (short)(18 * genRand.Next(9, 12));
				}
				else if (x < num6 * 3)
				{
					Main.tile[x, num].frameX = (short)(18 * genRand.Next(3, 6));
				}
				else if (x < num6 * 4)
				{
					Main.tile[x, num].frameX = (short)(18 * genRand.Next(15, 18));
				}
				else
				{
					Main.tile[x, num].frameX = (short)(18 * genRand.Next(12, 15));
				}
			}
			Main.tile[x, num].frameY = (short)num5;
			Main.tile[x, num].halfBrick(halfBrick: false);
			Main.tile[x, num].slope(0);
			SquareTileFrame(x, num);
			return true;
		}

		public static void CheckLilyPad(int x, int y)
		{
			if (Main.netMode == 1)
			{
				return;
			}
			if (Main.tile[x, y].liquidType() != 0)
			{
				KillTile(x, y);
				if (Main.netMode == 2)
				{
					NetMessage.SendData(17, -1, -1, null, 0, x, y);
				}
				return;
			}
			int num = y;
			while ((!Main.tile[x, num].active() || !Main.tileSolid[Main.tile[x, num].type] || Main.tileSolidTop[Main.tile[x, num].type]) && num < Main.maxTilesY - 50)
			{
				num++;
				if (Main.tile[x, num] == null)
				{
					return;
				}
			}
			int type = Main.tile[x, num].type;
			int num2 = -1;
			if (type == 2 || type == 477)
			{
				num2 = 0;
			}
			if (type == 109 || type == 109 || type == 116)
			{
				num2 = 18;
			}
			if (type == 60)
			{
				num2 = 36;
			}
			if (num2 >= 0)
			{
				if (num2 != Main.tile[x, y].frameY)
				{
					Main.tile[x, y].frameY = (short)num2;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y, 2);
					}
				}
				if (Main.tile[x, y - 1].liquid > 0 && !Main.tile[x, y - 1].active())
				{
					Main.tile[x, y - 1].active(active: true);
					Main.tile[x, y - 1].type = 518;
					Main.tile[x, y - 1].frameX = Main.tile[x, y].frameX;
					Main.tile[x, y - 1].frameY = Main.tile[x, y].frameY;
					Main.tile[x, y - 1].halfBrick(halfBrick: false);
					Main.tile[x, y - 1].slope(0);
					Main.tile[x, y].active(active: false);
					Main.tile[x, y].type = 0;
					SquareTileFrame(x, y - 1, resetFrame: false);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y - 1, 3);
					}
				}
				else
				{
					if (Main.tile[x, y].liquid != 0)
					{
						return;
					}
					Tile tileSafely = Framing.GetTileSafely(x, y + 1);
					if (!tileSafely.active())
					{
						Main.tile[x, y + 1].active(active: true);
						Main.tile[x, y + 1].type = 518;
						Main.tile[x, y + 1].frameX = Main.tile[x, y].frameX;
						Main.tile[x, y + 1].frameY = Main.tile[x, y].frameY;
						Main.tile[x, y + 1].halfBrick(halfBrick: false);
						Main.tile[x, y + 1].slope(0);
						Main.tile[x, y].active(active: false);
						Main.tile[x, y].type = 0;
						SquareTileFrame(x, y + 1, resetFrame: false);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, x, y, 3);
						}
					}
					else if (tileSafely.active() && !TileID.Sets.Platforms[tileSafely.type] && (!Main.tileSolid[tileSafely.type] || Main.tileSolidTop[tileSafely.type]))
					{
						KillTile(x, y);
						if (Main.netMode == 2)
						{
							NetMessage.SendData(17, -1, -1, null, 0, x, y);
						}
					}
				}
			}
			else
			{
				KillTile(x, y);
				if (Main.netMode == 2)
				{
					NetMessage.SendData(17, -1, -1, null, 0, x, y);
				}
			}
		}

		public static bool PlaceTile(int i, int j, int Type, bool mute = false, bool forced = false, int plr = -1, int style = 0)
		{
			int num = Type;
			if (gen && Main.tile[i, j].active() && Main.tile[i, j].type == 488)
			{
				return false;
			}
			if (num >= 623)
			{
				return false;
			}
			bool result = false;
			if (i >= 0 && j >= 0 && i < Main.maxTilesX && j < Main.maxTilesY)
			{
				Tile tile = Main.tile[i, j];
				if (tile == null)
				{
					tile = new Tile();
					Main.tile[i, j] = tile;
				}
				if (forced || Collision.EmptyTile(i, j) || !Main.tileSolid[num] || (num == 23 && tile.type == 0 && tile.active()) || (num == 199 && tile.type == 0 && tile.active()) || (num == 2 && tile.type == 0 && tile.active()) || (num == 109 && tile.type == 0 && tile.active()) || (num == 60 && tile.type == 59 && tile.active()) || (num == 70 && tile.type == 59 && tile.active()) || (Main.tileMoss[num] && (tile.type == 1 || tile.type == 38) && tile.active()))
				{
					if (num == 23 && (tile.type != 0 || !tile.active()))
					{
						return false;
					}
					if (num == 199 && (tile.type != 0 || !tile.active()))
					{
						return false;
					}
					if (num == 2 && (tile.type != 0 || !tile.active()))
					{
						return false;
					}
					if (num == 109 && (tile.type != 0 || !tile.active()))
					{
						return false;
					}
					if (num == 60 && (tile.type != 59 || !tile.active()))
					{
						return false;
					}
					if (num == 70 && (tile.type != 59 || !tile.active()))
					{
						return false;
					}
					if (Main.tileMoss[num])
					{
						if ((tile.type != 1 && tile.type != 38) || !tile.active())
						{
							return false;
						}
						if (tile.type == 38)
						{
							num = num switch
							{
								381 => 517, 
								534 => 535, 
								536 => 537, 
								539 => 540, 
								_ => 512 + num - 179, 
							};
						}
					}
					if (num == 81)
					{
						if (Main.tile[i, j - 1] == null)
						{
							Main.tile[i, j - 1] = new Tile();
						}
						if (Main.tile[i, j + 1] == null)
						{
							Main.tile[i, j + 1] = new Tile();
						}
						if (Main.tile[i, j - 1].active())
						{
							return false;
						}
						if (!Main.tile[i, j + 1].active() || !Main.tileSolid[Main.tile[i, j + 1].type] || Main.tile[i, j + 1].halfBrick() || Main.tile[i, j + 1].slope() != 0)
						{
							return false;
						}
					}
					if ((num == 373 || num == 375 || num == 374 || num == 461) && (Main.tile[i, j - 1] == null || Main.tile[i, j - 1].bottomSlope()))
					{
						return false;
					}
					if (tile.liquid > 0 || tile.checkingLiquid())
					{
						switch (num)
						{
						case 4:
							if (style != 8 && style != 11 && style != 17)
							{
								return false;
							}
							break;
						case 3:
						case 20:
						case 24:
						case 27:
						case 32:
						case 51:
						case 69:
						case 72:
						case 201:
						case 352:
						case 529:
							return false;
						}
					}
					if (TileID.Sets.ResetsHalfBrickPlacementAttempt[num] && (!tile.active() || !Main.tileFrameImportant[tile.type]))
					{
						tile.halfBrick(halfBrick: false);
						tile.frameY = 0;
						tile.frameX = 0;
					}
					if (num == 3 || num == 24 || num == 110 || num == 201)
					{
						if (IsFitToPlaceFlowerIn(i, j, num))
						{
							if (num == 24 && genRand.Next(13) == 0)
							{
								tile.active(active: true);
								tile.type = 32;
								SquareTileFrame(i, j);
							}
							else if (num == 201 && genRand.Next(13) == 0)
							{
								tile.active(active: true);
								tile.type = 352;
								SquareTileFrame(i, j);
							}
							else if (Main.tile[i, j + 1].type == 78 || Main.tile[i, j + 1].type == 380 || Main.tile[i, j + 1].type == 579)
							{
								tile.active(active: true);
								tile.type = (ushort)num;
								int num2 = genRand.NextFromList<int>(6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 24, 27, 30, 33, 36, 39, 42);
								switch (num2)
								{
								case 21:
								case 24:
								case 27:
								case 30:
								case 33:
								case 36:
								case 39:
								case 42:
									num2 += genRand.Next(3);
									break;
								}
								tile.frameX = (short)(num2 * 18);
							}
							else if ((tile.wall == 0 || tile.wall == 106 || tile.wall == 107 || (tile.wall >= 63 && tile.wall <= 70)) && (Main.tile[i, j + 1].wall == 0 || Main.tile[i, j + 1].wall == 106 || Main.tile[i, j + 1].wall == 107 || (Main.tile[i, j + 1].wall >= 63 && Main.tile[i, j + 1].wall <= 70)))
							{
								if (genRand.Next(50) == 0 || ((num == 24 || num == 201) && genRand.Next(40) == 0))
								{
									tile.active(active: true);
									tile.type = (ushort)num;
									if (num == 201)
									{
										tile.frameX = 270;
									}
									else
									{
										tile.frameX = 144;
									}
								}
								else if (genRand.Next(35) == 0 || (Main.tile[i, j].wall >= 63 && Main.tile[i, j].wall <= 70))
								{
									tile.active(active: true);
									tile.type = (ushort)num;
									int num3 = genRand.NextFromList<int>(6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20);
									if (num == 201)
									{
										num3 = genRand.NextFromList<int>(6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 18, 19, 20, 21, 22);
									}
									tile.frameX = (short)(num3 * 18);
								}
								else
								{
									tile.active(active: true);
									tile.type = (ushort)num;
									tile.frameX = (short)(genRand.Next(6) * 18);
								}
							}
						}
					}
					else if (num == 61)
					{
						if (j + 1 < Main.maxTilesY && Main.tile[i, j + 1].active() && Main.tile[i, j + 1].slope() == 0 && !Main.tile[i, j + 1].halfBrick() && Main.tile[i, j + 1].type == 60)
						{
							if (genRand.Next(16) == 0 && (double)j > Main.worldSurface)
							{
								tile.active(active: true);
								tile.type = 69;
								SquareTileFrame(i, j);
							}
							else if (genRand.Next(60) == 0 && (double)j > Main.rockLayer)
							{
								tile.active(active: true);
								tile.type = (ushort)num;
								tile.frameX = 144;
							}
							else if (genRand.Next(230) == 0 && (double)j > Main.rockLayer)
							{
								tile.active(active: true);
								tile.type = (ushort)num;
								tile.frameX = 162;
							}
							else if (genRand.Next(15) == 0)
							{
								tile.active(active: true);
								tile.type = (ushort)num;
								if (genRand.Next(3) != 0)
								{
									tile.frameX = (short)(genRand.Next(2) * 18 + 108);
								}
								else
								{
									tile.frameX = (short)(genRand.Next(13) * 18 + 180);
								}
							}
							else
							{
								tile.active(active: true);
								tile.type = (ushort)num;
								tile.frameX = (short)(genRand.Next(6) * 18);
							}
						}
					}
					else if (num == 518)
					{
						PlaceLilyPad(i, j);
					}
					else if (num == 519)
					{
						PlaceCatTail(i, j);
					}
					else if (num == 529)
					{
						PlantSeaOat(i, j);
					}
					else if (num == 571)
					{
						PlaceBamboo(i, j);
					}
					else if (num == 549)
					{
						PlaceUnderwaterPlant(549, i, j);
					}
					else if (num == 71)
					{
						if (j + 1 < Main.maxTilesY && Main.tile[i, j + 1].active() && Main.tile[i, j + 1].slope() == 0 && !Main.tile[i, j + 1].halfBrick() && Main.tile[i, j + 1].type == 70)
						{
							Point point = new Point(-1, -1);
							if ((double)j > Main.worldSurface)
							{
								point = PlaceCatTail(i, j);
							}
							if (InWorld(point.X, point.Y))
							{
								if (gen)
								{
									int num4 = genRand.Next(14);
									for (int k = 0; k < num4; k++)
									{
										GrowCatTail(point.X, point.Y);
									}
									SquareTileFrame(point.X, point.Y);
								}
							}
							else
							{
								tile.active(active: true);
								tile.type = (ushort)num;
								tile.frameX = (short)(genRand.Next(5) * 18);
							}
						}
					}
					else if (num == 129)
					{
						if (SolidTile(i - 1, j) || SolidTile(i + 1, j) || SolidTile(i, j - 1) || SolidTile(i, j + 1))
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							tile.frameX = (short)(genRand.Next(18) * 18);
							if (plr <= -1 && genRand.Next(50) == 0)
							{
								tile.frameX = (short)((18 + genRand.Next(6)) * 18);
							}
							SquareTileFrame(i, j);
						}
					}
					else if (num == 178)
					{
						if (SolidTile(i - 1, j, noDoors: true) || SolidTile(i + 1, j, noDoors: true) || SolidTile(i, j - 1) || SolidTile(i, j + 1))
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							tile.frameX = (short)(style * 18);
							tile.frameY = (short)(genRand.Next(3) * 18);
							SquareTileFrame(i, j);
						}
					}
					else if (num == 184)
					{
						if ((Main.tileMoss[Main.tile[i - 1, j].type] && SolidTile(i - 1, j)) || (Main.tileMoss[Main.tile[i + 1, j].type] && SolidTile(i + 1, j)) || (Main.tileMoss[Main.tile[i, j - 1].type] && SolidTile(i, j - 1)) || (Main.tileMoss[Main.tile[i, j + 1].type] && SolidTile(i, j + 1)))
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							tile.frameX = (short)(style * 18);
							tile.frameY = (short)(genRand.Next(3) * 18);
							SquareTileFrame(i, j);
						}
						if ((TileID.Sets.tileMossBrick[Main.tile[i - 1, j].type] && SolidTile(i - 1, j)) || (TileID.Sets.tileMossBrick[Main.tile[i + 1, j].type] && SolidTile(i + 1, j)) || (TileID.Sets.tileMossBrick[Main.tile[i, j - 1].type] && SolidTile(i, j - 1)) || (TileID.Sets.tileMossBrick[Main.tile[i, j + 1].type] && SolidTile(i, j + 1)))
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							tile.frameX = (short)(style * 18);
							tile.frameY = (short)(genRand.Next(3) * 18);
							SquareTileFrame(i, j);
						}
					}
					else if (num == 485)
					{
						PlaceObject(i, j, num, mute: false, style);
					}
					else if (num == 171)
					{
						PlaceXmasTree(i, j, 171);
					}
					else if (num == 254)
					{
						Place2x2Style(i, j, (ushort)num, style);
					}
					else if (num == 335 || num == 564 || num == 594)
					{
						Place2x2(i, j, (ushort)num, 0);
					}
					else if (num == 319 || num == 132 || num == 484 || num == 138 || num == 142 || num == 143 || num == 282 || (num >= 288 && num <= 295) || (num >= 316 && num <= 318))
					{
						Place2x2(i, j, (ushort)num, 0);
					}
					else if (num == 411)
					{
						Place2x2(i, j, (ushort)num, 0);
					}
					else if (num == 457)
					{
						Place2x2Horizontal(i, j, 457, style);
					}
					else if (num == 137)
					{
						tile.active(active: true);
						tile.type = (ushort)num;
						tile.frameY = (short)(18 * style);
					}
					else if (num == 136)
					{
						if (Main.tile[i - 1, j] == null)
						{
							Main.tile[i - 1, j] = new Tile();
						}
						if (Main.tile[i + 1, j] == null)
						{
							Main.tile[i + 1, j] = new Tile();
						}
						if (Main.tile[i, j + 1] == null)
						{
							Main.tile[i, j + 1] = new Tile();
						}
						if ((Main.tile[i - 1, j].nactive() && !Main.tile[i - 1, j].halfBrick() && !TileID.Sets.NotReallySolid[Main.tile[i - 1, j].type] && Main.tile[i - 1, j].slope() == 0 && (SolidTile(i - 1, j) || TileID.Sets.IsBeam[Main.tile[i - 1, j].type] || (Main.tile[i - 1, j].type == 5 && Main.tile[i - 1, j - 1].type == 5 && Main.tile[i - 1, j + 1].type == 5))) || (Main.tile[i + 1, j].nactive() && !Main.tile[i + 1, j].halfBrick() && !TileID.Sets.NotReallySolid[Main.tile[i + 1, j].type] && Main.tile[i + 1, j].slope() == 0 && (SolidTile(i + 1, j) || TileID.Sets.IsBeam[Main.tile[i + 1, j].type] || (Main.tile[i + 1, j].type == 5 && Main.tile[i + 1, j - 1].type == 5 && Main.tile[i + 1, j + 1].type == 5))) || (Main.tile[i, j + 1].nactive() && !Main.tile[i, j + 1].halfBrick() && SolidTile(i, j + 1) && Main.tile[i, j + 1].slope() == 0) || tile.wall > 0)
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							SquareTileFrame(i, j);
						}
					}
					else if (num == 442)
					{
						if (Main.tile[i - 1, j] == null)
						{
							Main.tile[i - 1, j] = new Tile();
						}
						if (Main.tile[i + 1, j] == null)
						{
							Main.tile[i + 1, j] = new Tile();
						}
						if (Main.tile[i, j + 1] == null)
						{
							Main.tile[i, j + 1] = new Tile();
						}
						if ((Main.tile[i - 1, j].nactive() && !Main.tile[i - 1, j].halfBrick() && !TileID.Sets.NotReallySolid[Main.tile[i - 1, j].type] && Main.tile[i - 1, j].slope() == 0 && (SolidTile(i - 1, j) || TileID.Sets.IsBeam[Main.tile[i - 1, j].type] || (Main.tile[i - 1, j].type == 5 && Main.tile[i - 1, j - 1].type == 5 && Main.tile[i - 1, j + 1].type == 5))) || (Main.tile[i + 1, j].nactive() && !Main.tile[i + 1, j].halfBrick() && !TileID.Sets.NotReallySolid[Main.tile[i + 1, j].type] && Main.tile[i + 1, j].slope() == 0 && (SolidTile(i + 1, j) || TileID.Sets.IsBeam[Main.tile[i + 1, j].type] || (Main.tile[i + 1, j].type == 5 && Main.tile[i + 1, j - 1].type == 5 && Main.tile[i + 1, j + 1].type == 5))) || (Main.tile[i, j + 1].nactive() && !Main.tile[i, j + 1].halfBrick() && SolidTile(i, j + 1) && Main.tile[i, j + 1].slope() == 0))
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							SquareTileFrame(i, j);
						}
					}
					else if (num == 4)
					{
						if (Main.tile[i - 1, j] == null)
						{
							Main.tile[i - 1, j] = new Tile();
						}
						if (Main.tile[i + 1, j] == null)
						{
							Main.tile[i + 1, j] = new Tile();
						}
						if (Main.tile[i, j + 1] == null)
						{
							Main.tile[i, j + 1] = new Tile();
						}
						Tile tile2 = Main.tile[i - 1, j];
						Tile tile3 = Main.tile[i + 1, j];
						Tile tile4 = Main.tile[i, j + 1];
						if (tile.wall > 0 || (tile2.active() && (tile2.slope() == 0 || (int)tile2.slope() % 2 != 1) && ((Main.tileSolid[tile2.type] && !Main.tileSolidTop[tile2.type] && !TileID.Sets.NotReallySolid[tile2.type]) || TileID.Sets.IsBeam[tile2.type] || (IsTreeType(tile2.type) && IsTreeType(Main.tile[i - 1, j - 1].type) && IsTreeType(Main.tile[i - 1, j + 1].type)))) || (tile3.active() && (tile3.slope() == 0 || (int)tile3.slope() % 2 != 0) && ((Main.tileSolid[tile3.type] && !Main.tileSolidTop[tile3.type] && !TileID.Sets.NotReallySolid[tile3.type]) || TileID.Sets.IsBeam[tile3.type] || (IsTreeType(tile3.type) && IsTreeType(Main.tile[i + 1, j - 1].type) && IsTreeType(Main.tile[i + 1, j + 1].type)))) || (tile4.active() && Main.tileSolid[tile4.type] && ((TileID.Sets.Platforms[tile4.type] && TopEdgeCanBeAttachedTo(i, j + 1)) || ((!Main.tileSolidTop[tile4.type] || (tile4.type == 380 && tile4.slope() == 0)) && !TileID.Sets.NotReallySolid[tile4.type] && !tile4.halfBrick() && tile4.slope() == 0))))
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							tile.frameY = (short)(22 * style);
							SquareTileFrame(i, j);
						}
					}
					else if (num == 10)
					{
						if (Main.tile[i, j - 1] == null)
						{
							Main.tile[i, j - 1] = new Tile();
						}
						if (Main.tile[i, j - 2] == null)
						{
							Main.tile[i, j - 2] = new Tile();
						}
						if (Main.tile[i, j - 3] == null)
						{
							Main.tile[i, j - 3] = new Tile();
						}
						if (Main.tile[i, j + 1] == null)
						{
							Main.tile[i, j + 1] = new Tile();
						}
						if (Main.tile[i, j + 2] == null)
						{
							Main.tile[i, j + 2] = new Tile();
						}
						if (Main.tile[i, j + 3] == null)
						{
							Main.tile[i, j + 3] = new Tile();
						}
						if (!Main.tile[i, j - 1].active() && !Main.tile[i, j - 2].active() && Main.tile[i, j - 3].active() && Main.tileSolid[Main.tile[i, j - 3].type])
						{
							PlaceDoor(i, j - 1, num, style);
							SquareTileFrame(i, j);
						}
						else
						{
							if (Main.tile[i, j + 1].active() || Main.tile[i, j + 2].active() || !Main.tile[i, j + 3].active() || !Main.tileSolid[Main.tile[i, j + 3].type])
							{
								return false;
							}
							PlaceDoor(i, j + 1, num, style);
							SquareTileFrame(i, j);
						}
					}
					else if ((num >= 275 && num <= 281) || num == 296 || num == 297 || num == 309 || num == 358 || num == 359 || num == 413 || num == 414 || num == 542)
					{
						Place6x3(i, j, (ushort)num);
					}
					else if (num == 237 || num == 244 || num == 285 || num == 286 || num == 298 || num == 299 || num == 310 || num == 339 || num == 538 || (num >= 361 && num <= 364) || num == 532 || num == 533 || num == 486 || num == 488 || num == 544 || num == 582 || num == 619)
					{
						Place3x2(i, j, (ushort)num);
					}
					else if (num == 128)
					{
						PlaceMan(i, j, style);
						SquareTileFrame(i, j);
					}
					else if (num == 269)
					{
						PlaceWoman(i, j, style);
						SquareTileFrame(i, j);
					}
					else if (num == 334)
					{
						int style2 = 0;
						if (style == -1)
						{
							style2 = 1;
						}
						Place3x3Wall(i, j, 334, style2);
						SquareTileFrame(i, j);
					}
					else if (num == 149)
					{
						if (SolidTile(i - 1, j) || SolidTile(i + 1, j) || SolidTile(i, j - 1) || SolidTile(i, j + 1))
						{
							tile.frameX = (short)(18 * style);
							tile.active(active: true);
							tile.type = (ushort)num;
							SquareTileFrame(i, j);
						}
					}
					else if (num == 139 || num == 35)
					{
						PlaceMB(i, j, (ushort)num, style);
						SquareTileFrame(i, j);
					}
					else if (num == 165)
					{
						PlaceTight(i, j);
						SquareTileFrame(i, j);
					}
					else if (num == 235)
					{
						Place3x1(i, j, (ushort)num);
						SquareTileFrame(i, j);
					}
					else if (num == 240)
					{
						Place3x3Wall(i, j, (ushort)num, style);
					}
					else if (num == 440)
					{
						Place3x3Wall(i, j, (ushort)num, style);
					}
					else if (num == 245)
					{
						Place2x3Wall(i, j, (ushort)num, style);
					}
					else if (num == 246)
					{
						Place3x2Wall(i, j, (ushort)num, style);
					}
					else if (num == 241)
					{
						Place4x3Wall(i, j, (ushort)num, style);
					}
					else if (num == 242)
					{
						Place6x4Wall(i, j, (ushort)num, style);
					}
					else if (num == 34)
					{
						PlaceChand(i, j, (ushort)num, style);
						SquareTileFrame(i, j);
					}
					else if (num == 106 || num == 212 || num == 219 || num == 220 || num == 228 || num == 231 || num == 243 || num == 247 || num == 283 || (num >= 300 && num <= 308) || num == 354 || num == 355 || num == 491)
					{
						Place3x3(i, j, (ushort)num, style);
						SquareTileFrame(i, j);
					}
					else
					{
						switch (num)
						{
						case 13:
						case 33:
						case 49:
						case 50:
						case 78:
						case 174:
						case 372:
							PlaceOnTable1x1(i, j, num, style);
							SquareTileFrame(i, j);
							break;
						case 14:
						case 26:
						case 86:
						case 87:
						case 88:
						case 89:
						case 114:
						case 186:
						case 187:
						case 215:
						case 217:
						case 218:
						case 377:
						case 469:
							Place3x2(i, j, (ushort)num, style);
							SquareTileFrame(i, j);
							break;
						case 236:
							PlaceJunglePlant(i, j, (ushort)num, genRand.Next(3), 0);
							SquareTileFrame(i, j);
							break;
						case 238:
							PlaceJunglePlant(i, j, (ushort)num, 0, 0);
							SquareTileFrame(i, j);
							break;
						case 20:
						{
							if (Main.tile[i, j + 1] == null)
							{
								Main.tile[i, j + 1] = new Tile();
							}
							int type = Main.tile[i, j + 1].type;
							if (Main.tile[i, j + 1].active() && (type == 2 || type == 109 || type == 147 || type == 60 || type == 23 || type == 199 || type == 53 || type == 234 || type == 116 || type == 112))
							{
								Place1x2(i, j, (ushort)num, style);
								SquareTileFrame(i, j);
							}
							break;
						}
						case 15:
						case 216:
						case 338:
						case 390:
							if (Main.tile[i, j - 1] == null)
							{
								Main.tile[i, j - 1] = new Tile();
							}
							if (Main.tile[i, j] == null)
							{
								Main.tile[i, j] = new Tile();
							}
							Place1x2(i, j, (ushort)num, style);
							SquareTileFrame(i, j);
							break;
						case 227:
							PlaceDye(i, j, style);
							SquareTileFrame(i, j);
							break;
						case 567:
							PlaceGnome(i, j, style);
							SquareTileFrame(i, j);
							break;
						case 16:
						case 18:
						case 29:
						case 103:
						case 134:
						case 462:
							Place2x1(i, j, (ushort)num, style);
							SquareTileFrame(i, j);
							break;
						case 92:
						case 93:
						case 453:
							Place1xX(i, j, (ushort)num, style);
							SquareTileFrame(i, j);
							break;
						case 104:
						case 105:
						case 320:
						case 337:
						case 349:
						case 356:
						case 378:
						case 456:
						case 506:
						case 545:
							Place2xX(i, j, (ushort)num, style);
							SquareTileFrame(i, j);
							break;
						case 17:
						case 77:
						case 133:
							Place3x2(i, j, (ushort)num, style);
							SquareTileFrame(i, j);
							break;
						case 207:
							Place2xX(i, j, (ushort)num, style);
							SquareTileFrame(i, j);
							break;
						case 410:
						case 480:
						case 509:
							Place2xX(i, j, (ushort)num, style);
							SquareTileFrame(i, j);
							break;
						case 465:
						case 531:
						case 591:
						case 592:
							Place2xX(i, j, (ushort)num, style);
							SquareTileFrame(i, j);
							break;
						default:
							if (TileID.Sets.BasicChest[num])
							{
								PlaceChest(i, j, (ushort)num, notNearOtherChests: false, style);
								SquareTileFrame(i, j);
								break;
							}
							switch (num)
							{
							case 91:
								PlaceBanner(i, j, (ushort)num, style);
								SquareTileFrame(i, j);
								break;
							case 419:
							case 420:
							case 423:
							case 424:
							case 429:
							case 445:
								PlaceLogicTiles(i, j, num, style);
								SquareTileFrame(i, j);
								break;
							case 36:
							case 135:
							case 141:
							case 144:
							case 210:
							case 239:
							case 324:
							case 476:
							case 494:
								Place1x1(i, j, num, style);
								SquareTileFrame(i, j);
								break;
							case 101:
							case 102:
							case 463:
								Place3x4(i, j, (ushort)num, style);
								SquareTileFrame(i, j);
								break;
							case 464:
							case 466:
								Place5x4(i, j, (ushort)num, style);
								SquareTileFrame(i, j);
								break;
							case 27:
								PlaceSunflower(i, j, 27);
								SquareTileFrame(i, j);
								break;
							case 28:
								PlacePot(i, j, 28, genRand.Next(4));
								SquareTileFrame(i, j);
								break;
							case 42:
							case 270:
							case 271:
								Place1x2Top(i, j, (ushort)num, style);
								SquareTileFrame(i, j);
								break;
							case 55:
							case 425:
							case 510:
							case 511:
								PlaceSign(i, j, (ushort)num, style);
								break;
							case 85:
							case 376:
								Place2x2Horizontal(i, j, (ushort)num, style);
								break;
							default:
								if (Main.tileAlch[num])
								{
									PlaceAlch(i, j, style);
									break;
								}
								switch (num)
								{
								case 94:
								case 95:
								case 97:
								case 98:
								case 99:
								case 100:
								case 125:
								case 126:
								case 172:
								case 173:
								case 287:
									Place2x2(i, j, (ushort)num, style);
									break;
								case 96:
									Place2x2Style(i, j, (ushort)num, style);
									break;
								case 79:
								case 90:
								{
									int direction = 1;
									if (plr > -1)
									{
										direction = Main.player[plr].direction;
									}
									Place4x2(i, j, (ushort)num, direction, style);
									break;
								}
								case 209:
									PlaceCannon(i, j, (ushort)num, style);
									break;
								case 81:
									tile.frameX = (short)(26 * genRand.Next(6));
									tile.active(active: true);
									tile.type = (ushort)num;
									break;
								case 19:
									tile.frameY = (short)(18 * style);
									tile.active(active: true);
									tile.type = (ushort)num;
									break;
								case 380:
									tile.frameY = (short)(18 * style);
									tile.active(active: true);
									tile.type = (ushort)num;
									break;
								case 314:
									Minecart.PlaceTrack(tile, style);
									break;
								default:
									tile.active(active: true);
									tile.type = (ushort)num;
									break;
								}
								break;
							}
							break;
						}
					}
					if (tile.active())
					{
						if (TileID.Sets.BlocksWaterDrawingBehindSelf[tile.type])
						{
							SquareWallFrame(i, j);
						}
						SquareTileFrame(i, j);
						result = true;
						if (!mute)
						{
							switch (num)
							{
							case 127:
								SoundEngine.PlaySound(SoundID.Item30, i * 16, j * 16);
								break;
							case 314:
								SoundEngine.PlaySound(SoundID.Item52, i * 16, j * 16);
								break;
							case 330:
							case 331:
							case 332:
							case 333:
								SoundEngine.PlaySound(18, i * 16, j * 16);
								break;
							default:
								SoundEngine.PlaySound(0, i * 16, j * 16);
								break;
							}
							if (num == 22 || num == 140)
							{
								for (int l = 0; l < 3; l++)
								{
									Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 14);
								}
							}
						}
					}
				}
			}
			return result;
		}

		public static void KillWall(int i, int j, bool fail = false)
		{
			if (i < 0 || j < 0 || i >= Main.maxTilesX || j >= Main.maxTilesY)
			{
				return;
			}
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				tile = new Tile();
				Main.tile[i, j] = tile;
			}
			if (tile.wall <= 0)
			{
				return;
			}
			fail = KillWall_CheckFailure(fail, tile);
			KillWall_PlaySounds(i, j, tile);
			int num = 10;
			if (fail)
			{
				num = 3;
			}
			for (int k = 0; k < num; k++)
			{
				KillWall_MakeWallDust(i, j, tile);
			}
			if (fail)
			{
				SquareWallFrame(i, j);
				return;
			}
			KillWall_DropItems(i, j, tile);
			tile.wall = 0;
			tile.wallColor(0);
			SquareWallFrame(i, j);
			if (tile.type >= 0 && tile.type < 623 && TileID.Sets.FramesOnKillWall[tile.type])
			{
				TileFrame(i, j);
			}
		}

		private static bool KillWall_CheckFailure(bool fail, Tile tileCache)
		{
			if (Main.wallDungeon[tileCache.wall] && !NPC.downedBoss3)
			{
				fail = true;
			}
			if (tileCache.wall == 87 && !NPC.downedGolemBoss)
			{
				fail = true;
			}
			return fail;
		}

		private static void KillWall_PlaySounds(int i, int j, Tile tileCache)
		{
			if (tileCache.wall == 241 || (tileCache.wall >= 88 && tileCache.wall <= 93) || tileCache.wall == 21 || tileCache.wall == 186 || tileCache.wall == 136 || tileCache.wall == 137 || tileCache.wall == 168 || tileCache.wall == 169 || tileCache.wall == 172 || tileCache.wall == 226 || tileCache.wall == 227 || tileCache.wall == 242 || tileCache.wall == 243)
			{
				SoundEngine.PlaySound(13, i * 16, j * 16);
			}
			else if ((tileCache.wall >= 63 && tileCache.wall <= 70) || tileCache.wall == 264 || tileCache.wall == 268 || tileCache.wall == 265)
			{
				SoundEngine.PlaySound(6, i * 16, j * 16);
			}
			else
			{
				SoundEngine.PlaySound(0, i * 16, j * 16);
			}
		}

		private static void KillWall_DropItems(int i, int j, Tile tileCache)
		{
			int num = KillWall_GetItemDrops(tileCache);
			if (num > 0)
			{
				Item.NewItem(i * 16, j * 16, 16, 16, num);
			}
		}

		private static int KillWall_GetItemDrops(Tile tileCache)
		{
			switch (tileCache.wall)
			{
			case 237:
				return 4233;
			case 238:
				return 4234;
			case 239:
				return 4235;
			case 240:
				return 4236;
			case 246:
				return 4486;
			case 247:
				return 4487;
			case 248:
				return 4488;
			case 249:
				return 4489;
			case 250:
				return 4490;
			case 251:
				return 4491;
			case 252:
				return 4492;
			case 253:
				return 4493;
			case 254:
				return 4494;
			case 255:
				return 4495;
			case 314:
				return 4647;
			case 256:
				return 4496;
			case 257:
				return 4497;
			case 258:
				return 4498;
			case 259:
				return 4499;
			case 260:
				return 4500;
			case 261:
				return 4501;
			case 262:
				return 4502;
			case 263:
				return 4503;
			case 264:
				return 4504;
			case 265:
				return 4505;
			case 266:
				return 4506;
			case 267:
				return 4507;
			case 268:
				return 4508;
			case 269:
				return 4509;
			case 270:
				return 4510;
			case 271:
				return 4511;
			case 274:
				return 4512;
			case 275:
				return 3273;
			case 276:
				return 4513;
			case 277:
				return 4514;
			case 278:
				return 4515;
			case 279:
				return 4516;
			case 280:
				return 4517;
			case 281:
				return 4518;
			case 282:
				return 4519;
			case 283:
				return 4520;
			case 284:
				return 4521;
			case 285:
				return 4522;
			case 286:
				return 4523;
			case 287:
				return 4524;
			case 288:
				return 4525;
			case 289:
				return 4526;
			case 290:
				return 4527;
			case 291:
				return 4528;
			case 292:
				return 4529;
			case 293:
				return 4530;
			case 294:
				return 4531;
			case 295:
				return 4532;
			case 296:
				return 4533;
			case 297:
				return 4534;
			case 298:
				return 4535;
			case 299:
				return 4536;
			case 300:
				return 4537;
			case 301:
				return 4538;
			case 302:
				return 4539;
			case 303:
				return 4540;
			case 304:
				return 3340;
			case 305:
				return 3341;
			case 306:
				return 3342;
			case 307:
				return 3343;
			case 308:
				return 3344;
			case 309:
				return 3345;
			case 310:
				return 3346;
			case 311:
				return 3348;
			default:
			{
				int result = 0;
				if (tileCache.wall == 168)
				{
					result = 2696;
				}
				if (tileCache.wall == 169)
				{
					result = 2698;
				}
				if (tileCache.wall == 226)
				{
					result = 3752;
				}
				if (tileCache.wall == 227)
				{
					result = 3753;
				}
				if (tileCache.wall == 228)
				{
					result = 3760;
				}
				if (tileCache.wall == 229)
				{
					result = 3761;
				}
				if (tileCache.wall == 230)
				{
					result = 3762;
				}
				if (tileCache.wall == 142)
				{
					result = 2263;
				}
				if (tileCache.wall == 143)
				{
					result = 2264;
				}
				if (tileCache.wall == 144)
				{
					result = 2271;
				}
				if (tileCache.wall == 149)
				{
					result = 2505;
				}
				if (tileCache.wall == 150)
				{
					result = 2507;
				}
				if (tileCache.wall == 151)
				{
					result = 2506;
				}
				if (tileCache.wall == 152)
				{
					result = 2508;
				}
				if (tileCache.wall == 245)
				{
					result = 4424;
				}
				if (tileCache.wall == 315)
				{
					result = 4667;
				}
				if (tileCache.wall == 1)
				{
					result = 26;
				}
				if (tileCache.wall == 4)
				{
					result = 93;
				}
				if (tileCache.wall == 5)
				{
					result = 130;
				}
				if (tileCache.wall == 6)
				{
					result = 132;
				}
				if (tileCache.wall == 7)
				{
					result = 135;
				}
				if (tileCache.wall == 8)
				{
					result = 138;
				}
				if (tileCache.wall == 9)
				{
					result = 140;
				}
				if (tileCache.wall == 10)
				{
					result = 142;
				}
				if (tileCache.wall == 11)
				{
					result = 144;
				}
				if (tileCache.wall == 12)
				{
					result = 146;
				}
				if (tileCache.wall == 14)
				{
					result = 330;
				}
				if (tileCache.wall == 224)
				{
					result = 3472;
				}
				if (tileCache.wall == 177)
				{
					result = 3067;
				}
				if (tileCache.wall == 167)
				{
					result = 2691;
				}
				if (tileCache.wall == 60)
				{
					result = 3584;
				}
				if (tileCache.wall == 231)
				{
					result = 3952;
				}
				if (tileCache.wall == 232)
				{
					result = 3954;
				}
				if (tileCache.wall == 225)
				{
					result = 3751;
				}
				if (tileCache.wall == 233)
				{
					result = 3956;
				}
				if (tileCache.wall == 234)
				{
					result = 4052;
				}
				if (tileCache.wall == 235)
				{
					result = 4053;
				}
				if (tileCache.wall == 236)
				{
					result = 4140;
				}
				if (tileCache.wall == 312)
				{
					result = 4565;
				}
				if (tileCache.wall == 313)
				{
					result = 4548;
				}
				if (tileCache.wall == 179)
				{
					result = 3083;
				}
				if (tileCache.wall == 183)
				{
					result = 3082;
				}
				if (tileCache.wall == 181)
				{
					result = 3089;
				}
				if (tileCache.wall == 184)
				{
					result = 3088;
				}
				if (tileCache.wall == 186)
				{
					result = 3238;
				}
				if (tileCache.wall >= 153 && tileCache.wall <= 166)
				{
					switch (tileCache.wall)
					{
					case 154:
						result = 2679;
						break;
					case 158:
						result = 2680;
						break;
					case 166:
						result = 2689;
						break;
					case 163:
						result = 2690;
						break;
					case 165:
						result = 2687;
						break;
					case 162:
						result = 2688;
						break;
					case 156:
						result = 2683;
						break;
					case 160:
						result = 2684;
						break;
					case 164:
						result = 2685;
						break;
					case 161:
						result = 2686;
						break;
					case 155:
						result = 2681;
						break;
					case 159:
						result = 2682;
						break;
					case 153:
						result = 2677;
						break;
					case 157:
						result = 2678;
						break;
					}
				}
				if (tileCache.wall == 136)
				{
					result = 2169;
				}
				if (tileCache.wall == 137)
				{
					result = 2170;
				}
				if (tileCache.wall == 172)
				{
					result = 2788;
				}
				if (tileCache.wall == 242)
				{
					result = 4279;
				}
				if (tileCache.wall == 243)
				{
					result = 4280;
				}
				if (tileCache.wall == 145)
				{
					result = 2333;
				}
				if (tileCache.wall == 16)
				{
					result = 30;
				}
				if (tileCache.wall == 17)
				{
					result = 135;
				}
				if (tileCache.wall == 18)
				{
					result = 138;
				}
				if (tileCache.wall == 19)
				{
					result = 140;
				}
				if (tileCache.wall == 20)
				{
					result = 330;
				}
				if (tileCache.wall == 21)
				{
					result = 392;
				}
				if (tileCache.wall == 86 || tileCache.wall == 108)
				{
					result = 1126;
				}
				if (tileCache.wall == 173)
				{
					result = 2789;
				}
				if (tileCache.wall == 174)
				{
					result = 2790;
				}
				if (tileCache.wall == 175)
				{
					result = 2791;
				}
				if (tileCache.wall == 176)
				{
					result = 2861;
				}
				if (tileCache.wall == 182)
				{
					result = 3101;
				}
				if (tileCache.wall == 133)
				{
					result = 2158;
				}
				if (tileCache.wall == 134)
				{
					result = 2159;
				}
				if (tileCache.wall == 135)
				{
					result = 2160;
				}
				else if (tileCache.wall == 113)
				{
					result = 1726;
				}
				else if (tileCache.wall == 114)
				{
					result = 1728;
				}
				else if (tileCache.wall == 115)
				{
					result = 1730;
				}
				else if (tileCache.wall == 146)
				{
					result = 2432;
				}
				else if (tileCache.wall == 147)
				{
					result = 2433;
				}
				else if (tileCache.wall == 148)
				{
					result = 2434;
				}
				if (tileCache.wall >= 116 && tileCache.wall <= 125)
				{
					result = 1948 + tileCache.wall - 116;
				}
				if (tileCache.wall >= 126 && tileCache.wall <= 132)
				{
					result = 2008 + tileCache.wall - 126;
				}
				if (tileCache.wall == 22)
				{
					result = 417;
				}
				if (tileCache.wall == 23)
				{
					result = 418;
				}
				if (tileCache.wall == 24)
				{
					result = 419;
				}
				if (tileCache.wall == 25)
				{
					result = 420;
				}
				if (tileCache.wall == 26)
				{
					result = 421;
				}
				if (tileCache.wall == 29)
				{
					result = 587;
				}
				if (tileCache.wall == 30)
				{
					result = 592;
				}
				if (tileCache.wall == 31)
				{
					result = 595;
				}
				if (tileCache.wall == 32)
				{
					result = 605;
				}
				if (tileCache.wall == 33)
				{
					result = 606;
				}
				if (tileCache.wall == 34)
				{
					result = 608;
				}
				if (tileCache.wall == 35)
				{
					result = 610;
				}
				if (tileCache.wall == 36)
				{
					result = 615;
				}
				if (tileCache.wall == 37)
				{
					result = 616;
				}
				if (tileCache.wall == 38)
				{
					result = 617;
				}
				if (tileCache.wall == 39)
				{
					result = 618;
				}
				if (tileCache.wall == 41)
				{
					result = 622;
				}
				if (tileCache.wall == 42)
				{
					result = 623;
				}
				if (tileCache.wall == 43)
				{
					result = 624;
				}
				if (tileCache.wall == 44)
				{
					result = 663;
				}
				if (tileCache.wall == 45)
				{
					result = 720;
				}
				if (tileCache.wall == 46)
				{
					result = 721;
				}
				if (tileCache.wall == 47)
				{
					result = 722;
				}
				if (tileCache.wall == 66)
				{
					result = 745;
				}
				if (tileCache.wall == 67)
				{
					result = 746;
				}
				if (tileCache.wall == 68)
				{
					result = 747;
				}
				if (tileCache.wall == 84)
				{
					result = 884;
				}
				if (tileCache.wall == 72)
				{
					result = 750;
				}
				if (tileCache.wall == 73)
				{
					result = 752;
				}
				if (tileCache.wall == 74)
				{
					result = 764;
				}
				if (tileCache.wall == 85)
				{
					result = 927;
				}
				if (tileCache.wall == 75)
				{
					result = 768;
				}
				if (tileCache.wall == 76)
				{
					result = 769;
				}
				if (tileCache.wall == 77)
				{
					result = 770;
				}
				if (tileCache.wall == 82)
				{
					result = 825;
				}
				if (tileCache.wall == 27)
				{
					result = 479;
				}
				if (tileCache.wall == 106)
				{
					result = 1447;
				}
				if (tileCache.wall == 107)
				{
					result = 1448;
				}
				if (tileCache.wall == 109)
				{
					result = 1590;
				}
				if (tileCache.wall == 110)
				{
					result = 1592;
				}
				if (tileCache.wall == 111)
				{
					result = 1594;
				}
				if (tileCache.wall == 78)
				{
					result = 1723;
				}
				if (tileCache.wall == 87 || tileCache.wall == 112)
				{
					result = 1102;
				}
				if (tileCache.wall == 94 || tileCache.wall == 100)
				{
					result = 1378;
				}
				if (tileCache.wall == 95 || tileCache.wall == 101)
				{
					result = 1379;
				}
				if (tileCache.wall == 96 || tileCache.wall == 102)
				{
					result = 1380;
				}
				if (tileCache.wall == 97 || tileCache.wall == 103)
				{
					result = 1381;
				}
				if (tileCache.wall == 98 || tileCache.wall == 104)
				{
					result = 1382;
				}
				if (tileCache.wall == 99 || tileCache.wall == 105)
				{
					result = 1383;
				}
				if (tileCache.wall == 241)
				{
					result = 4260;
				}
				if (tileCache.wall >= 88 && tileCache.wall <= 93)
				{
					result = 1267 + tileCache.wall - 88;
				}
				if (tileCache.wall >= 138 && tileCache.wall <= 141)
				{
					result = 2210 + tileCache.wall - 138;
				}
				return result;
			}
			}
		}

		private static void KillWall_MakeWallDust(int i, int j, Tile tileCache)
		{
			int num = 0;
			switch (tileCache.wall)
			{
			case 7:
			case 17:
			case 94:
			case 95:
			case 100:
			case 101:
				num = 275;
				break;
			case 8:
			case 18:
			case 98:
			case 99:
			case 104:
			case 105:
				num = 276;
				break;
			case 9:
			case 19:
			case 96:
			case 97:
			case 102:
			case 103:
				num = 277;
				break;
			case 232:
				num = 82;
				break;
			case 231:
				num = 8;
				break;
			case 233:
				num = 18;
				break;
			case 237:
				num = 6;
				break;
			case 238:
				num = 61;
				break;
			case 239:
				num = 242;
				break;
			case 240:
				num = 135;
				break;
			case 3:
			case 246:
				num = ((genRand.Next(2) != 0) ? 1 : 14);
				break;
			case 15:
			case 247:
				num = 38;
				break;
			case 22:
			case 28:
			case 248:
				num = 51;
				break;
			case 40:
			case 249:
				num = 51;
				break;
			case 48:
			case 49:
			case 50:
			case 51:
			case 52:
			case 53:
			case 54:
			case 55:
			case 56:
			case 57:
			case 58:
			case 185:
			case 250:
			case 251:
			case 252:
			case 253:
			case 254:
			case 255:
			case 256:
			case 257:
			case 258:
			case 259:
			case 260:
			case 274:
			case 314:
				num = 1;
				break;
			case 59:
			case 61:
			case 261:
			case 262:
				num = 0;
				break;
			case 62:
			case 263:
				num = 0;
				break;
			case 69:
			case 264:
				num = ((genRand.Next(2) != 0) ? 17 : 14);
				break;
			case 70:
			case 265:
				num = 47;
				break;
			case 71:
			case 266:
				num = 80;
				break;
			case 79:
			case 267:
				num = 37;
				break;
			case 81:
			case 268:
				num = 123;
				break;
			case 83:
			case 234:
			case 269:
				num = ((genRand.Next(2) == 0) ? 1 : 117);
				break;
			case 170:
			case 171:
			case 270:
			case 271:
				num = 0;
				break;
			case 187:
			case 275:
				num = 0;
				break;
			case 188:
			case 189:
			case 190:
			case 191:
			case 276:
			case 277:
			case 278:
			case 279:
				num = 37;
				break;
			case 192:
			case 193:
			case 194:
			case 195:
			case 280:
			case 281:
			case 282:
			case 283:
				num = 117;
				break;
			case 196:
			case 197:
			case 198:
			case 199:
			case 284:
			case 285:
			case 286:
			case 287:
				num = 0;
				break;
			case 200:
			case 202:
			case 288:
			case 290:
				num = ((genRand.Next(2) != 0) ? 70 : 69);
				break;
			case 201:
			case 289:
				num = 17;
				break;
			case 203:
			case 291:
				num = ((genRand.Next(2) != 0) ? 68 : 69);
				break;
			case 204:
			case 205:
			case 207:
			case 292:
			case 293:
			case 295:
				num = 0;
				break;
			case 206:
			case 294:
				num = 1;
				break;
			case 208:
			case 209:
			case 210:
			case 211:
			case 296:
			case 297:
			case 298:
			case 299:
				num = ((genRand.Next(2) != 0) ? 125 : 155);
				break;
			case 212:
			case 213:
			case 214:
			case 215:
			case 300:
			case 301:
			case 302:
			case 303:
				num = 1;
				break;
			case 216:
			case 304:
				num = 0;
				break;
			case 217:
			case 305:
				num = 37;
				break;
			case 218:
			case 306:
				num = 155;
				break;
			case 219:
			case 307:
				num = 17;
				break;
			case 220:
			case 308:
				num = 37;
				break;
			case 221:
			case 309:
				num = 155;
				break;
			case 222:
			case 310:
				num = 37;
				break;
			case 223:
			case 311:
				num = 0;
				break;
			case 312:
			case 313:
			case 315:
				num = -1;
				break;
			}
			if (tileCache.wall == 148)
			{
				num = -1;
			}
			if (tileCache.wall == 1 || tileCache.wall == 5 || tileCache.wall == 6 || tileCache.wall == 107)
			{
				num = 1;
			}
			if (tileCache.wall == 35)
			{
				num = 37;
			}
			if (tileCache.wall == 4 || tileCache.wall == 106)
			{
				num = 7;
			}
			if (tileCache.wall == 12)
			{
				num = 9;
			}
			if (tileCache.wall == 10)
			{
				num = 10;
			}
			if (tileCache.wall == 11)
			{
				num = 11;
			}
			if (tileCache.wall == 21)
			{
				num = 13;
			}
			if (tileCache.wall == 34)
			{
				num = 32;
			}
			if (tileCache.wall == 225)
			{
				num = 1;
			}
			if (tileCache.wall == 145)
			{
				num = 8;
			}
			if (tileCache.wall == 23)
			{
				num = 38;
			}
			if (tileCache.wall == 24)
			{
				num = 36;
			}
			if (tileCache.wall == 25)
			{
				num = 48;
			}
			if (tileCache.wall == 179 || tileCache.wall == 178 || tileCache.wall == 183)
			{
				num = 236;
			}
			if (tileCache.wall == 181 || tileCache.wall == 180 || tileCache.wall == 184)
			{
				num = 240;
			}
			if (tileCache.wall == 113)
			{
				num = 189;
			}
			if (tileCache.wall == 114)
			{
				num = 190;
			}
			if (tileCache.wall == 115)
			{
				num = 191;
			}
			if (tileCache.wall == 177 || tileCache.wall == 13)
			{
				num = 25;
			}
			if (tileCache.wall == 186)
			{
				num = genRand.Next(68, 71);
			}
			if (tileCache.wall == 142)
			{
				num = 210;
			}
			if (tileCache.wall == 143)
			{
				num = 210;
			}
			if (tileCache.wall == 224)
			{
				num = 265;
			}
			if (tileCache.wall == 173)
			{
				num = 128;
			}
			if (tileCache.wall == 174)
			{
				num = 117;
			}
			if (tileCache.wall == 175)
			{
				num = 42;
			}
			if (tileCache.wall == 176)
			{
				num = 226;
			}
			if (tileCache.wall == 182)
			{
				num = ((genRand.Next(2) != 0) ? 23 : 6);
			}
			if (tileCache.wall >= 153 && tileCache.wall <= 166)
			{
				switch (tileCache.wall)
				{
				case 154:
				case 158:
					num = 86;
					break;
				case 163:
				case 166:
					num = 87;
					break;
				case 162:
				case 165:
					num = 88;
					break;
				case 156:
				case 160:
					num = 89;
					break;
				case 161:
				case 164:
					num = 90;
					break;
				case 155:
				case 159:
					num = 91;
					break;
				case 153:
				case 157:
					num = 138;
					break;
				}
			}
			if (tileCache.wall == 26 || tileCache.wall == 30)
			{
				num = 49;
			}
			if (tileCache.wall == 29 || tileCache.wall == 32)
			{
				num = 50;
			}
			if (tileCache.wall == 31)
			{
				num = 51;
			}
			if (tileCache.wall == 14 || tileCache.wall == 20)
			{
				num = 109;
			}
			if (tileCache.wall == 241)
			{
				num = 286;
			}
			if (tileCache.wall >= 88 && tileCache.wall <= 93)
			{
				num = 86 + tileCache.wall - 88;
				if (tileCache.wall == 93)
				{
					num = genRand.Next(88, 94);
				}
			}
			if (tileCache.wall == 33)
			{
				num = 14;
			}
			if (tileCache.wall == 41)
			{
				num = 77;
			}
			if (tileCache.wall == 42)
			{
				num = 78;
			}
			if (tileCache.wall == 43)
			{
				num = 78;
			}
			if (tileCache.wall == 36)
			{
				num = 26;
			}
			if (tileCache.wall == 37)
			{
				num = 32;
			}
			if (tileCache.wall == 38)
			{
				num = 2;
			}
			if (tileCache.wall == 39)
			{
				num = 1;
			}
			if (tileCache.wall == 45)
			{
				num = 81;
			}
			if (tileCache.wall == 46)
			{
				num = 83;
			}
			if (tileCache.wall == 47)
			{
				num = 84;
			}
			if (tileCache.wall == 85)
			{
				num = 126;
			}
			if (tileCache.wall == 63)
			{
				num = 3;
			}
			if (tileCache.wall == 65)
			{
				num = 3;
			}
			if (tileCache.wall == 66)
			{
				num = 3;
			}
			if (tileCache.wall == 68)
			{
				num = 3;
			}
			if (tileCache.wall == 64)
			{
				num = 40;
			}
			if (tileCache.wall == 67)
			{
				num = 40;
			}
			if (tileCache.wall == 84)
			{
				num = 80;
			}
			if (tileCache.wall == 60)
			{
				num = 3;
			}
			if (tileCache.wall == 167)
			{
				num = 81;
			}
			if (tileCache.wall == 147)
			{
				num = 51;
			}
			if (tileCache.wall == 146)
			{
				num = 9;
			}
			if (tileCache.wall == 109)
			{
				num = 144;
			}
			if (tileCache.wall == 110)
			{
				num = 145;
			}
			if (tileCache.wall == 111)
			{
				num = 146;
			}
			if (tileCache.wall == 86 || tileCache.wall == 108)
			{
				num = 147;
			}
			if (tileCache.wall == 87)
			{
				num = 148;
			}
			if (tileCache.wall == 136)
			{
				num = 13;
			}
			if (tileCache.wall == 137)
			{
				num = 13;
			}
			if (tileCache.wall == 168)
			{
				num = 13;
			}
			if (tileCache.wall == 169)
			{
				num = 13;
			}
			if (tileCache.wall == 172)
			{
				num = 13;
			}
			if (tileCache.wall == 226)
			{
				num = 13;
			}
			if (tileCache.wall == 227)
			{
				num = 13;
			}
			if (tileCache.wall == 242)
			{
				num = 13;
			}
			if (tileCache.wall == 243)
			{
				num = 13;
			}
			if (tileCache.wall == 72)
			{
				num = 40;
			}
			if (tileCache.wall == 73)
			{
				num = 16;
			}
			if (tileCache.wall == 74 || tileCache.wall == 80)
			{
				num = 26;
			}
			if (tileCache.wall == 144)
			{
				num = ((genRand.Next(2) != 0) ? 118 : 10);
			}
			if (tileCache.wall == 75)
			{
				num = 26;
			}
			if (tileCache.wall == 76)
			{
				num = 4;
			}
			if (tileCache.wall == 77 || tileCache.wall == 81)
			{
				num = 5;
			}
			if (tileCache.wall == 78 || tileCache.wall == 244)
			{
				num = 7;
			}
			if (tileCache.wall == 82)
			{
				num = 36;
			}
			if (tileCache.wall == 27)
			{
				num = ((genRand.Next(2) != 0) ? 1 : 7);
			}
			if (tileCache.wall == 138)
			{
				num = 77;
			}
			if (tileCache.wall == 139)
			{
				num = 78;
			}
			if (tileCache.wall == 140)
			{
				num = 79;
			}
			if (tileCache.wall == 141)
			{
				num = 126;
			}
			if (tileCache.wall == 149 || tileCache.wall == 150)
			{
				num = 214;
			}
			if (tileCache.wall == 151 || tileCache.wall == 152)
			{
				num = 215;
			}
			if (tileCache.wall == 245)
			{
				num = 195;
			}
			if (tileCache.wall == 44)
			{
				int num2 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 66, 0f, 0f, 100, new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB), 0.75f);
				Main.dust[num2].noGravity = true;
			}
			else if ((tileCache.wall < 133 || tileCache.wall > 135) && (tileCache.wall < 116 || tileCache.wall > 125) && (tileCache.wall < 126 || tileCache.wall > 132))
			{
				if (tileCache.wall == 76)
				{
					Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 75, new Color(0, 80, 255, 100), 0.75f);
				}
				else if (num >= 0)
				{
					Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num);
				}
			}
		}

		public static void LaunchRocket(int x, int y)
		{
			int num = Main.tile[x, y].frameY;
			int num2 = 0;
			while (num >= 40)
			{
				num -= 40;
				num2++;
			}
			if (num == 18)
			{
				y--;
			}
			Vector2 vector = new Vector2(x * 16 + 8, y * 16 + 4);
			int type = 167 + num2;
			int damage = 150;
			int num3 = 7;
			int num4 = Projectile.NewProjectile(vector.X, vector.Y + 2f, 0f, -8f, type, damage, num3, Main.myPlayer);
			Main.projectile[num4].originatedFromActivableTile = true;
			Main.tile[x, y].active(active: false);
			Main.tile[x, y + 1].active(active: false);
			NetMessage.SendTileSquare(-1, x - 1, y, 3);
		}

		public static void LaunchRocketSmall(int x, int y)
		{
			if (Main.tile[x, y].frameX == 18)
			{
				x--;
			}
			if (Main.tile[x, y].frameY == 18)
			{
				y--;
			}
			Vector2 vector = new Vector2(x * 16 + 16, y * 16);
			int type = 415 + Main.rand.Next(4);
			int damage = 0;
			int num = 0;
			int num2 = Projectile.NewProjectile(vector.X, vector.Y + 2f, 0f, -8f, type, damage, num, Main.myPlayer);
			Main.projectile[num2].originatedFromActivableTile = true;
		}

		public static bool CanKillTile(int i, int j, SpecialKillTileContext context)
		{
			if (context == SpecialKillTileContext.MowingTheGrass)
			{
				Tile tile = Main.tile[i, j];
				if (tile == null)
				{
					return false;
				}
				if (tile.type == 2 || tile.type == 109)
				{
					return true;
				}
			}
			return CanKillTile(i, j);
		}

		public static bool CanKillTile(int i, int j)
		{
			bool blockDamaged;
			return CanKillTile(i, j, out blockDamaged);
		}

		public static bool CanKillTile(int i, int j, out bool blockDamaged)
		{
			blockDamaged = false;
			if (i < 0 || j < 0 || i >= Main.maxTilesX || j >= Main.maxTilesY)
			{
				return false;
			}
			Tile tile = Main.tile[i, j];
			Tile tile2 = null;
			if (tile == null)
			{
				return false;
			}
			if (!tile.active())
			{
				return false;
			}
			if (j >= 1)
			{
				tile2 = Main.tile[i, j - 1];
			}
			if (tile2 != null && tile2.active())
			{
				int type = tile2.type;
				if (TileID.Sets.IsATreeTrunk[type] && tile.type != type && (tile2.frameX != 66 || tile2.frameY < 0 || tile2.frameY > 44) && (tile2.frameX != 88 || tile2.frameY < 66 || tile2.frameY > 110) && tile2.frameY < 198)
				{
					return false;
				}
				switch (type)
				{
				case 323:
					if (tile.type != type && (tile2.frameX == 66 || tile2.frameX == 220))
					{
						return false;
					}
					break;
				case 21:
				case 26:
				case 72:
				case 77:
				case 88:
				case 467:
				case 488:
					if (tile.type != type)
					{
						return false;
					}
					break;
				case 80:
					if (tile.type != type)
					{
						int num = tile2.frameX / 18;
						if ((uint)num <= 1u || (uint)(num - 4) <= 1u)
						{
							return false;
						}
					}
					break;
				}
			}
			switch (tile.type)
			{
			case 10:
				if (IsLockedDoor(tile))
				{
					blockDamaged = true;
					return false;
				}
				break;
			case 138:
				if (CheckBoulderChest(i, j))
				{
					blockDamaged = true;
					return false;
				}
				break;
			case 235:
			{
				int num2 = i - tile.frameX % 54 / 18;
				for (int k = 0; k < 3; k++)
				{
					Tile tile3 = Main.tile[num2 + k, j - 1];
					if (tile3.active() && IsAContainer(tile3))
					{
						blockDamaged = true;
						return false;
					}
				}
				break;
			}
			case 21:
			case 467:
				if (!Chest.CanDestroyChest(i - tile.frameX / 18 % 2, j - tile.frameY / 18))
				{
					return false;
				}
				break;
			case 88:
				if (!Chest.CanDestroyChest(i - tile.frameX / 18 % 3, j - tile.frameY / 18))
				{
					return false;
				}
				break;
			}
			return true;
		}

		public static bool IsTileReplacable(int x, int y)
		{
			Tile tile = Main.tile[x, y];
			if (y >= 1)
			{
				Tile tile2 = Main.tile[x, y - 1];
				if (tile == null || tile2 == null)
				{
					return false;
				}
				if (tile2.active())
				{
					if (tile2.type == 80)
					{
						return false;
					}
					if (tile2.type == 488)
					{
						return false;
					}
					if (TileID.Sets.PreventsTileReplaceIfOnTopOfIt[tile2.type] && tile.type != tile2.type)
					{
						if (TileID.Sets.IsATreeTrunk[tile2.type])
						{
							if ((tile2.frameX == 66 && tile2.frameY >= 0 && tile2.frameY <= 44) || (tile2.frameX == 88 && tile2.frameY >= 66 && tile2.frameY <= 110) || tile2.frameY >= 198)
							{
								return true;
							}
							return false;
						}
						if (tile2.type == 323)
						{
							if (tile2.frameX == 66 || tile2.frameX == 220)
							{
								return false;
							}
							return true;
						}
						return false;
					}
				}
			}
			return true;
		}

		public static int CheckTileBreakability(int x, int y)
		{
			Tile tile = Main.tile[x, y];
			if (y >= 1 && y <= Main.maxTilesY - 1)
			{
				Tile tile2 = Main.tile[x, y - 1];
				Tile tile3 = Main.tile[x, y + 1];
				if (tile3 != null && tile3.active() && IsLockedDoor(x, y + 1))
				{
					return 2;
				}
				if (!Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type])
				{
					return 0;
				}
				if (tile2.active())
				{
					if ((TileID.Sets.PreventsTileRemovalIfOnTopOfIt[tile2.type] && tile.type != tile2.type) | IsLockedDoor(x, y - 1) | (tile2.type == 77 && tile.type != 77 && !Main.hardMode) | (IsAContainer(tile2) && !IsAContainer(tile)))
					{
						if (TileID.Sets.IsATreeTrunk[tile2.type])
						{
							if ((tile2.frameX == 66 && tile2.frameY >= 0 && tile2.frameY <= 44) || (tile2.frameX == 88 && tile2.frameY >= 66 && tile2.frameY <= 110) || tile2.frameY >= 198)
							{
								return 0;
							}
							return 2;
						}
						if (tile2.type == 323)
						{
							if (tile2.frameX == 66 || tile2.frameX == 220)
							{
								return 2;
							}
							return 0;
						}
						return 2;
					}
					if (tile2.type == 80 && tile2.type != tile.type)
					{
						int num = tile2.frameX / 18;
						if ((uint)num <= 1u || (uint)(num - 4) <= 1u)
						{
							return 2;
						}
					}
					if (tile.type == 10 && tile.frameY >= 594 && tile.frameY <= 646)
					{
						return 1;
					}
					if (tile.type == 138 || tile.type == 484)
					{
						if (CheckBoulderChest(x, y))
						{
							return 1;
						}
						return 0;
					}
				}
				if (tile.type == 235)
				{
					int frameX = tile.frameX;
					int num2 = x - frameX % 54 / 18;
					for (int i = 0; i < 3; i++)
					{
						if (Main.tile[num2 + i, y - 1].active() && IsAContainer(Main.tile[num2 + i, y - 1]))
						{
							return 2;
						}
					}
				}
			}
			return 0;
		}

		public static bool CheckTileBreakability2_ShouldTileSurvive(int x, int y)
		{
			if (Main.netMode == 1)
			{
				return false;
			}
			Tile tile = Main.tile[x, y];
			if (TileID.Sets.BasicChest[tile.type])
			{
				int num = tile.frameX / 18;
				int y2 = y - tile.frameY / 18;
				while (num > 1)
				{
					num -= 2;
				}
				num = x - num;
				if (!Chest.DestroyChest(num, y2))
				{
					return true;
				}
			}
			if (tile.type == 88)
			{
				int num2 = tile.frameX / 18;
				int y3 = y - tile.frameY / 18;
				num2 %= 3;
				num2 = x - num2;
				if (!Chest.DestroyChest(num2, y3))
				{
					return true;
				}
			}
			if (tile.type == 470)
			{
				return !TEDisplayDoll.IsBreakable(x, y);
			}
			if (tile.type == 475)
			{
				return !TEHatRack.IsBreakable(x, y);
			}
			return false;
		}

		public static bool ReplaceWall(int x, int y, ushort targetWall)
		{
			if (targetWall >= 316)
			{
				return false;
			}
			Tile tile = Main.tile[x, y];
			if (tile.wall == 0 || targetWall == 0)
			{
				return false;
			}
			if (KillWall_CheckFailure(fail: false, tile))
			{
				return false;
			}
			int num = 10;
			for (int i = 0; i < num; i++)
			{
				KillWall_MakeWallDust(x, y, tile);
			}
			KillWall_PlaySounds(x, y, tile);
			KillWall_DropItems(x, y, tile);
			tile.wall = targetWall;
			tile.wallColor(0);
			SquareWallFrame(x, y);
			return true;
		}

		public static bool ReplaceTile(int x, int y, ushort targetType, int targetStyle)
		{
			Tile tileSafely = Framing.GetTileSafely(x, y);
			if (!WouldTileReplacementWork(targetType, x, y))
			{
				return false;
			}
			if (!IsTileReplacable(x, y))
			{
				return false;
			}
			MoveReplaceTileAnchor(x, y, targetType, tileSafely);
			int num = KillTile_GetTileDustAmount(fail: false, tileSafely);
			for (int i = 0; i < num; i++)
			{
				KillTile_MakeTileDust(x, y, tileSafely);
			}
			KillTile_PlaySounds(x, y, fail: false, tileSafely);
			KillTile_DropItems(x, y, tileSafely, includeLargeObjectDrops: true);
			AttemptFossilShattering(x, y, tileSafely, fail: false);
			ReplaceTIle_DoActualReplacement(targetType, targetStyle, x, y, tileSafely);
			return true;
		}

		private static void ReplaceTIle_DoActualReplacement(ushort targetType, int targetStyle, int topLeftX, int topLeftY, Tile t)
		{
			if (TileID.Sets.BasicChest[targetType])
			{
				if (IsChestRigged(topLeftX, topLeftY) && Main.netMode != 1)
				{
					Wiring.HitSwitch(topLeftX, topLeftY);
					NetMessage.SendData(59, -1, -1, null, topLeftX, topLeftY);
				}
				ReplaceTile_DoActualReplacement_Area(targetType, targetStyle, topLeftX, topLeftY, 2, 2);
			}
			else if (TileID.Sets.BasicDresser[targetType])
			{
				ReplaceTile_DoActualReplacement_Area(targetType, targetStyle, topLeftX, topLeftY, 3, 2);
			}
			else
			{
				ReplaceTile_DoActualReplacement_Single(targetType, targetStyle, topLeftX, topLeftY, t);
			}
		}

		private static void ReplaceTile_DoActualReplacement_Single(ushort targetType, int targetStyle, int topLeftX, int topLeftY, Tile t)
		{
			ReplaceTile_EliminateNaturalExtras(topLeftX, topLeftY);
			int type = t.type;
			t.type = targetType;
			if (TileID.Sets.Platforms[t.type])
			{
				t.frameY = (short)(targetStyle * 18);
			}
			t.color(0);
			bool flag = !CanPoundTile(topLeftX, topLeftY);
			if (TileID.Sets.Platforms[type] && TileID.Sets.Platforms[t.type])
			{
				flag = false;
			}
			if (flag)
			{
				t.slope(0);
				t.halfBrick(halfBrick: false);
			}
			SquareTileFrame(topLeftX, topLeftY);
		}

		private static void ReplaceTile_EliminateNaturalExtras(int x, int y)
		{
			if (InWorld(x, y, 2))
			{
				if (Main.tile[x, y - 1] != null && Main.tile[x, y - 1].active() && (TileID.Sets.ReplaceTileBreakUp[Main.tile[x, y - 1].type] || (Main.tile[x, y - 1].type == 165 && (Main.tile[x, y - 1].frameY == 36 || Main.tile[x, y - 1].frameY == 54 || Main.tile[x, y - 1].frameY == 90))))
				{
					KillTile(x, y - 1);
				}
				if (Main.tile[x, y + 1] != null && Main.tile[x, y + 1].active() && (TileID.Sets.ReplaceTileBreakDown[Main.tile[x, y + 1].type] || (Main.tile[x, y + 1].type == 165 && (Main.tile[x, y + 1].frameY == 0 || Main.tile[x, y + 1].frameY == 18 || Main.tile[x, y + 1].frameY == 72))))
				{
					KillTile(x, y + 1);
				}
			}
		}

		private static void ReplaceTile_DoActualReplacement_Area(ushort targetType, int targetStyle, int topLeftX, int topLeftY, int areaSizeX, int areaSizeY)
		{
			for (int i = 0; i < areaSizeX; i++)
			{
				for (int j = 0; j < areaSizeY; j++)
				{
					Tile tile = Main.tile[topLeftX + i, topLeftY + j];
					tile.type = targetType;
					tile.frameX = (short)(targetStyle * (areaSizeX * 18) + i * 18);
					tile.frameY = (short)(j * 18);
					tile.color(0);
				}
			}
			for (int k = 0; k < areaSizeX; k++)
			{
				for (int l = 0; l < areaSizeY; l++)
				{
					SquareTileFrame(topLeftX + k, topLeftY + l);
				}
			}
		}

		private static void MoveReplaceTileAnchor(int x, int y, ushort targetType, Tile t)
		{
			if (TileID.Sets.BasicChest[t.type])
			{
				x -= t.frameX % 36 / 18;
				y -= t.frameY % 36 / 18;
			}
			if (TileID.Sets.BasicDresser[t.type])
			{
				x -= t.frameX % 54 / 18;
				y -= t.frameY % 36 / 18;
			}
		}

		public static bool WouldTileReplacementBeBlockedByLiquid(int x, int y, int liquidType)
		{
			if ((Main.tile[x - 1, y].liquid <= 0 || Main.tile[x - 1, y].liquidType() != liquidType) && (Main.tile[x + 1, y].liquid <= 0 || Main.tile[x + 1, y].liquidType() != liquidType))
			{
				if (Main.tile[x, y - 1].liquid > 0)
				{
					return Main.tile[x, y - 1].liquidType() == liquidType;
				}
				return false;
			}
			return true;
		}

		public static bool WouldTileReplacementWork(ushort attemptingToReplaceWith, int x, int y)
		{
			Tile tile = Main.tile[x, y];
			if (attemptingToReplaceWith >= 623)
			{
				return false;
			}
			if (TileID.Sets.Conversion.Grass[attemptingToReplaceWith])
			{
				return false;
			}
			bool flag = !ReplaceTile_IsValidSolid(attemptingToReplaceWith) || !ReplaceTile_IsValidSolid(tile.type);
			bool num = !ReplaceTile_IsValidPlatform(attemptingToReplaceWith) || !ReplaceTile_IsValidPlatform(tile.type);
			bool flag2 = (!ReplaceTile_IsValidSolid(attemptingToReplaceWith) && !ReplaceTile_IsValidPlatform(attemptingToReplaceWith)) || (!ReplaceTile_IsValidSolid(tile.type) && !ReplaceTile_IsValidPlatform(tile.type));
			bool flag3 = !ReplaceTile_IsValidChest(attemptingToReplaceWith) || !ReplaceTile_IsValidChest(tile.type) || Chest.IsLocked(tile);
			bool flag4 = !ReplaceTile_IsValidDresser(attemptingToReplaceWith) || !ReplaceTile_IsValidDresser(tile.type);
			return !(num && flag && flag2 && flag3 && flag4);
		}

		private static bool ReplaceTile_IsValidSolid(int type)
		{
			if (Main.tileSolid[type] && !Main.tileSolidTop[type])
			{
				return !Main.tileFrameImportant[type];
			}
			return false;
		}

		private static bool ReplaceTile_IsValidChest(int type)
		{
			return TileID.Sets.BasicChest[type];
		}

		private static bool ReplaceTile_IsValidDresser(int type)
		{
			return TileID.Sets.BasicDresser[type];
		}

		private static bool ReplaceTile_IsValidPlatform(int type)
		{
			return TileID.Sets.Platforms[type];
		}

		public static bool GetVanityTreeFoliageData(int i, int j, int xoffset, int treeFrame, int treeStyle, out int floorY, out int topTextureFrameWidth, out int topTextureFrameHeight)
		{
			Tile tile = Main.tile[i, j];
			int num = i + xoffset;
			topTextureFrameWidth = 114;
			topTextureFrameHeight = 96;
			floorY = j;
			for (int k = 0; k < 100; k++)
			{
				floorY = j + k;
				Tile tile2 = Main.tile[num, floorY];
				if (tile2 == null)
				{
					return false;
				}
				if (TileID.Sets.Conversion.Grass[tile2.type])
				{
					switch (tile.type)
					{
					case 596:
						treeStyle = 29;
						return true;
					case 616:
						treeStyle = 30;
						return true;
					}
				}
			}
			return false;
		}

		public static bool GetGemTreeFoliageData(int i, int j, int xoffset, int treeFrame, int treeStyle, out int floorY, out int topTextureFrameWidth, out int topTextureFrameHeight)
		{
			Tile tile = Main.tile[i, j];
			int num = i + xoffset;
			topTextureFrameWidth = 114;
			topTextureFrameHeight = 96;
			floorY = j;
			for (int k = 0; k < 100; k++)
			{
				floorY = j + k;
				Tile tile2 = Main.tile[num, floorY];
				if (tile2 == null)
				{
					return false;
				}
				if (TileID.Sets.Conversion.Stone[tile2.type])
				{
					switch (tile.type)
					{
					case 583:
						treeStyle = 22;
						return true;
					case 584:
						treeStyle = 23;
						return true;
					case 585:
						treeStyle = 24;
						return true;
					case 586:
						treeStyle = 25;
						return true;
					case 587:
						treeStyle = 26;
						return true;
					case 588:
						treeStyle = 27;
						return true;
					case 589:
						treeStyle = 28;
						return true;
					}
				}
			}
			return false;
		}

		public static bool GetCommonTreeFoliageData(int i, int j, int xoffset, int treeFrame, int treeStyle, out int floorY, out int topTextureFrameWidth, out int topTextureFrameHeight)
		{
			_ = Main.tile[i, j];
			int num = i + xoffset;
			topTextureFrameWidth = 80;
			topTextureFrameHeight = 80;
			floorY = j;
			int num2 = 0;
			for (int k = 0; k < 100; k++)
			{
				floorY = j + k;
				Tile tile = Main.tile[num, floorY];
				if (tile == null)
				{
					return false;
				}
				switch (tile.type)
				{
				case 2:
				case 477:
				{
					int num4 = 0;
					num4 = ((num <= Main.treeX[0]) ? TreeTops.GetTreeStyle(0) : ((num <= Main.treeX[1]) ? TreeTops.GetTreeStyle(1) : ((num > Main.treeX[2]) ? TreeTops.GetTreeStyle(3) : TreeTops.GetTreeStyle(2))));
					switch (num4)
					{
					case 0:
						treeStyle = 0;
						break;
					case 5:
						treeStyle = 10;
						break;
					default:
						treeStyle = 5 + num4;
						break;
					}
					return true;
				}
				case 23:
					treeStyle = 1;
					return true;
				case 70:
					treeStyle = 14;
					return true;
				case 199:
					treeStyle = 5;
					return true;
				case 60:
					topTextureFrameHeight = 96;
					topTextureFrameWidth = 114;
					treeStyle = 2;
					num2 = TreeTops.GetTreeStyle(5);
					if (num2 == 1)
					{
						treeStyle = 11;
					}
					if ((double)floorY > Main.worldSurface)
					{
						treeStyle = 13;
					}
					return true;
				case 147:
					treeStyle = 4;
					num2 = TreeTops.GetTreeStyle(6);
					if (num2 == 0)
					{
						treeStyle = 12;
						if (i % 10 == 0)
						{
							treeStyle = 18;
						}
					}
					if (num2 == 2 || num2 == 3 || num2 == 32 || num2 == 4 || num2 == 42 || num2 == 5 || num2 == 7)
					{
						if (num2 % 2 == 0)
						{
							if (i < Main.maxTilesX / 2)
							{
								treeStyle = 16;
							}
							else
							{
								treeStyle = 17;
							}
						}
						else if (i > Main.maxTilesX / 2)
						{
							treeStyle = 16;
						}
						else
						{
							treeStyle = 17;
						}
					}
					return true;
				case 109:
				case 492:
				{
					topTextureFrameHeight = 140;
					int num3 = (treeStyle = GetHollowTreeFoliageStyle());
					if (num3 == 19)
					{
						topTextureFrameWidth = 114;
					}
					if (num3 == 20)
					{
						treeStyle = 20;
						if (i % 6 == 1)
						{
							treeFrame += 3;
						}
						else if (i % 6 == 2)
						{
							treeFrame += 6;
						}
						else if (i % 6 == 3)
						{
							treeFrame += 9;
						}
						else if (i % 6 == 4)
						{
							treeFrame += 12;
						}
						else if (i % 6 == 5)
						{
							treeFrame += 15;
						}
					}
					else if (i % 3 == 1)
					{
						treeFrame += 3;
					}
					else if (i % 3 == 2)
					{
						treeFrame += 6;
					}
					return true;
				}
				}
			}
			return false;
		}

		public static int GetHollowTreeFoliageStyle()
		{
			TreeTops.GetTreeStyle(7);
			switch (hallowBG)
			{
			default:
				return 3;
			case 4:
				return 19;
			case 2:
			case 3:
				return 20;
			}
		}

		public static int GetTreeFrame(Tile t)
		{
			if (t.frameY == 220)
			{
				return 1;
			}
			if (t.frameY == 242)
			{
				return 2;
			}
			return 0;
		}

		public static TreeTypes GetTreeType(int tileType)
		{
			switch (tileType)
			{
			case 2:
			case 477:
				return TreeTypes.Forest;
			case 23:
				return TreeTypes.Corrupt;
			case 70:
				return TreeTypes.Mushroom;
			case 199:
				return TreeTypes.Crimson;
			case 60:
				return TreeTypes.Jungle;
			case 147:
				return TreeTypes.Snow;
			case 109:
			case 492:
				return TreeTypes.Hallowed;
			case 53:
				return TreeTypes.Palm;
			case 112:
				return TreeTypes.PalmCorrupt;
			case 234:
				return TreeTypes.PalmCrimson;
			case 116:
				return TreeTypes.PalmHallowed;
			default:
				return TreeTypes.None;
			}
		}

		public static bool IsThisAMushroomTree(int i, int j)
		{
			GetTreeBottom(i, j, out var x, out var y);
			if (GetTreeType(Main.tile[x, y].type) == TreeTypes.Mushroom)
			{
				return true;
			}
			return false;
		}

		private static void ShakeTree(int i, int j)
		{
			if (numTreeShakes == maxTreeShakes)
			{
				return;
			}
			GetTreeBottom(i, j, out var x, out var y);
			int num = y;
			TreeTypes treeType = GetTreeType(Main.tile[x, y].type);
			if (treeType == TreeTypes.None)
			{
				return;
			}
			for (int k = 0; k < numTreeShakes; k++)
			{
				if (treeShakeX[k] == x && treeShakeY[k] == y)
				{
					return;
				}
			}
			treeShakeX[numTreeShakes] = x;
			treeShakeY[numTreeShakes] = y;
			numTreeShakes++;
			y--;
			while (y > 10 && Main.tile[x, y].active() && TileID.Sets.IsShakeable[Main.tile[x, y].type])
			{
				y--;
			}
			y++;
			if (!IsTileALeafyTreeTop(x, y) || Collision.SolidTiles(x - 2, x + 2, y - 2, y + 2))
			{
				return;
			}
			bool flag = false;
			if (Main.getGoodWorld && genRand.Next(15) == 0)
			{
				Projectile.NewProjectile(x * 16, y * 16, (float)Main.rand.Next(-100, 101) * 0.002f, 0f, 28, 0, 0f, Player.FindClosest(new Vector2(x * 16, y * 16), 16, 16));
			}
			else if (genRand.Next(1000) == 0 && treeType == TreeTypes.Forest)
			{
				flag = true;
				Item.NewItem(x * 16, y * 16, 16, 16, 4366);
			}
			else if (genRand.Next(7) == 0 && (treeType == TreeTypes.Forest || treeType == TreeTypes.Snow || treeType == TreeTypes.Hallowed))
			{
				flag = true;
				Item.NewItem(x * 16, y * 16, 16, 16, 27, genRand.Next(1, 3));
			}
			else if (genRand.Next(8) == 0 && treeType == TreeTypes.Mushroom)
			{
				flag = true;
				Item.NewItem(x * 16, y * 16, 16, 16, 194, genRand.Next(1, 2));
			}
			else if (genRand.Next(35) == 0 && Main.halloween)
			{
				flag = true;
				Item.NewItem(x * 16, y * 16, 16, 16, 1809, genRand.Next(1, 3));
			}
			else if (genRand.Next(12) == 0)
			{
				flag = true;
				int dropItem = 0;
				KillTile_GetItemDrops(i, j, Main.tile[i, j], out dropItem, out var _, out var _, out var _);
				Item.NewItem(x * 16, y * 16, 16, 16, dropItem, genRand.Next(1, 4));
			}
			else if (genRand.Next(20) == 0)
			{
				flag = true;
				int type = 71;
				int num2 = genRand.Next(50, 100);
				if (genRand.Next(30) == 0)
				{
					type = 73;
					num2 = 1;
					if (genRand.Next(5) == 0)
					{
						num2++;
					}
					if (genRand.Next(10) == 0)
					{
						num2++;
					}
				}
				else if (genRand.Next(10) == 0)
				{
					type = 72;
					num2 = genRand.Next(1, 21);
					if (genRand.Next(3) == 0)
					{
						num2 += genRand.Next(1, 21);
					}
					if (genRand.Next(4) == 0)
					{
						num2 += genRand.Next(1, 21);
					}
				}
				Item.NewItem(x * 16, y * 16, 16, 16, type, num2);
			}
			else if (genRand.Next(15) == 0 && (treeType == TreeTypes.Forest || treeType == TreeTypes.Hallowed))
			{
				flag = true;
				int type2 = genRand.Next(5) switch
				{
					0 => 74, 
					1 => 297, 
					2 => 298, 
					3 => 299, 
					_ => 538, 
				};
				if (Player.GetClosestRollLuck(x, y, NPC.goldCritterChance) == 0f)
				{
					type2 = ((genRand.Next(2) != 0) ? 539 : 442);
				}
				NPC.NewNPC(x * 16, y * 16, type2);
			}
			else if (genRand.Next(50) == 0 && treeType == TreeTypes.Hallowed && !Main.dayTime)
			{
				flag = true;
				NPC.NewNPC(x * 16, y * 16, Main.rand.NextFromList(new short[3]
				{
					583,
					584,
					585
				}));
			}
			else if (genRand.Next(50) == 0 && treeType == TreeTypes.Forest && !Main.dayTime)
			{
				flag = true;
				NPC obj = Main.npc[NPC.NewNPC(x * 16, y * 16, 611)];
				obj.velocity.Y = 1f;
				obj.netUpdate = true;
			}
			else if (genRand.Next(40) == 0 && treeType == TreeTypes.Forest && !Main.dayTime && Main.halloween)
			{
				flag = true;
				NPC.NewNPC(x * 16, y * 16, 301);
			}
			else if (genRand.Next(50) == 0 && (treeType == TreeTypes.Forest || treeType == TreeTypes.Hallowed))
			{
				flag = true;
				for (int l = 0; l < 5; l++)
				{
					Point point = new Point(x + Main.rand.Next(-2, 2), y - 1 + Main.rand.Next(-2, 2));
					int type3 = ((Player.GetClosestRollLuck(x, y, NPC.goldCritterChance) != 0f) ? Main.rand.NextFromList(new short[3]
					{
						74,
						297,
						298
					}) : 442);
					NPC obj2 = Main.npc[NPC.NewNPC(point.X * 16, point.Y * 16, type3)];
					obj2.velocity = Main.rand.NextVector2CircularEdge(3f, 3f);
					obj2.netUpdate = true;
				}
			}
			else if (genRand.Next(40) == 0 && treeType == TreeTypes.Jungle)
			{
				flag = true;
				for (int m = 0; m < 5; m++)
				{
					Point point2 = new Point(x + Main.rand.Next(-2, 2), y - 1 + Main.rand.Next(-2, 2));
					NPC obj3 = Main.npc[NPC.NewNPC(point2.X * 16, point2.Y * 16, Main.rand.NextFromList(new short[2]
					{
						210,
						211
					}))];
					obj3.ai[1] = 65f;
					obj3.netUpdate = true;
				}
			}
			else if (genRand.Next(20) == 0 && (treeType == TreeTypes.Palm || treeType == TreeTypes.PalmCorrupt || treeType == TreeTypes.PalmCrimson || treeType == TreeTypes.PalmHallowed) && !IsPalmOasisTree(x))
			{
				flag = true;
				NPC.NewNPC(x * 16, y * 16, 603);
			}
			else if (genRand.Next(30) == 0 && (treeType == TreeTypes.Crimson || treeType == TreeTypes.PalmCrimson))
			{
				flag = true;
				NPC.NewNPC(x * 16 + 8, (y - 1) * 16, -22);
			}
			else if (genRand.Next(30) == 0 && (treeType == TreeTypes.Corrupt || treeType == TreeTypes.PalmCorrupt))
			{
				flag = true;
				NPC.NewNPC(x * 16 + 8, (y - 1) * 16, -11);
			}
			else if (genRand.Next(30) == 0 && treeType == TreeTypes.Jungle && !Main.dayTime)
			{
				flag = true;
				NPC.NewNPC(x * 16, y * 16, 51);
			}
			else if (genRand.Next(40) == 0 && treeType == TreeTypes.Jungle)
			{
				flag = true;
				Projectile.NewProjectile(x * 16 + 8, (y - 1) * 16, 0f, 0f, 655, 0, 0f, Main.myPlayer);
			}
			else if (genRand.Next(20) == 0 && (treeType == TreeTypes.Forest || treeType == TreeTypes.Hallowed) && !Main.raining && !NPC.TooWindyForButterflies && Main.dayTime)
			{
				flag = true;
				int type4 = 356;
				if (Player.GetClosestRollLuck(x, y, NPC.goldCritterChance) == 0f)
				{
					type4 = 444;
				}
				NPC.NewNPC(x * 16, y * 16, type4);
			}
			else if (genRand.Next(15) == 0 && treeType == TreeTypes.Forest)
			{
				flag = true;
				int num3 = genRand.Next(5);
				Item.NewItem(x * 16, y * 16, 16, 16, num3 switch
				{
					0 => 4009, 
					1 => 4293, 
					2 => 4282, 
					3 => 4290, 
					_ => 4291, 
				});
			}
			else if (genRand.Next(15) == 0 && treeType == TreeTypes.Snow)
			{
				flag = true;
				Item.NewItem(Type: (genRand.Next(2) != 0) ? 4295 : 4286, X: x * 16, Y: y * 16, Width: 16, Height: 16);
			}
			else if (genRand.Next(15) == 0 && treeType == TreeTypes.Jungle)
			{
				flag = true;
				Item.NewItem(Type: (genRand.Next(2) != 0) ? 4292 : 4294, X: x * 16, Y: y * 16, Width: 16, Height: 16);
			}
			else if (genRand.Next(15) == 0 && (treeType == TreeTypes.Palm || treeType == TreeTypes.PalmCorrupt || treeType == TreeTypes.PalmCrimson || treeType == TreeTypes.PalmHallowed) && !IsPalmOasisTree(x))
			{
				flag = true;
				Item.NewItem(Type: (genRand.Next(2) != 0) ? 4287 : 4283, X: x * 16, Y: y * 16, Width: 16, Height: 16);
			}
			else if (genRand.Next(15) == 0 && (treeType == TreeTypes.Corrupt || treeType == TreeTypes.PalmCorrupt))
			{
				flag = true;
				Item.NewItem(Type: (genRand.Next(2) != 0) ? 4289 : 4284, X: x * 16, Y: y * 16, Width: 16, Height: 16);
			}
			else if (genRand.Next(15) == 0 && (treeType == TreeTypes.Hallowed || treeType == TreeTypes.PalmHallowed))
			{
				flag = true;
				Item.NewItem(Type: (genRand.Next(2) != 0) ? 4288 : 4297, X: x * 16, Y: y * 16, Width: 16, Height: 16);
			}
			else if (genRand.Next(15) == 0 && (treeType == TreeTypes.Crimson || treeType == TreeTypes.PalmCrimson))
			{
				flag = true;
				Item.NewItem(Type: (genRand.Next(2) != 0) ? 4285 : 4296, X: x * 16, Y: y * 16, Width: 16, Height: 16);
			}
			if (flag)
			{
				int treeHeight = 0;
				int treeFrame = 0;
				int passStyle = 0;
				GetTreeLeaf(x, Main.tile[x, y], Main.tile[x, num], treeHeight, out treeFrame, out passStyle);
				if (Main.netMode == 2)
				{
					NetMessage.SendData(112, -1, -1, null, 1, x, y, 1f, passStyle);
				}
				if (Main.netMode == 0)
				{
					TreeGrowFX(x, y, 1, passStyle, hitTree: true);
				}
			}
		}

		private static void GetTreeBottom(int i, int j, out int x, out int y)
		{
			x = i;
			y = j;
			Tile tileSafely = Framing.GetTileSafely(x, y);
			if (tileSafely.type == 323)
			{
				while (y < Main.maxTilesY - 50 && (!tileSafely.active() || tileSafely.type == 323))
				{
					y++;
					tileSafely = Framing.GetTileSafely(x, y);
				}
				return;
			}
			int num = tileSafely.frameX / 22;
			int num2 = tileSafely.frameY / 22;
			if (num == 3 && num2 <= 2)
			{
				x++;
			}
			else if (num == 4 && num2 >= 3 && num2 <= 5)
			{
				x--;
			}
			else if (num == 1 && num2 >= 6 && num2 <= 8)
			{
				x--;
			}
			else if (num == 2 && num2 >= 6 && num2 <= 8)
			{
				x++;
			}
			else if (num == 2 && num2 >= 9)
			{
				x++;
			}
			else if (num == 3 && num2 >= 9)
			{
				x--;
			}
			tileSafely = Framing.GetTileSafely(x, y);
			while (y < Main.maxTilesY - 50 && (!tileSafely.active() || TileID.Sets.IsATreeTrunk[tileSafely.type] || tileSafely.type == 72))
			{
				y++;
				tileSafely = Framing.GetTileSafely(x, y);
			}
		}

		private static void AttemptFossilShattering(int i, int j, Tile tileCache, bool fail)
		{
			if (tileCache.type != 404 || Main.netMode == 1 || fossilBreak)
			{
				return;
			}
			fossilBreak = true;
			for (int k = i - 1; k <= i + 1; k++)
			{
				for (int l = j - 1; l <= j + 1; l++)
				{
					int maxValue = 15;
					if (!SolidTile(k, l + 1))
					{
						maxValue = 4;
					}
					else if (k == i && l == j - 1 && !fail)
					{
						maxValue = 4;
					}
					if ((k != i || l != j) && Main.tile[k, l].active() && Main.tile[k, l].type == 404 && genRand.Next(maxValue) == 0)
					{
						KillTile(k, l, fail: false, effectOnly: false, noItem: true);
						if (Main.netMode == 2)
						{
							NetMessage.SendData(17, -1, -1, null, 0, k, l);
						}
					}
				}
			}
			fossilBreak = false;
		}

		public static void KillTile(int i, int j, bool fail = false, bool effectOnly = false, bool noItem = false)
		{
			if (i < 0 || j < 0 || i >= Main.maxTilesX || j >= Main.maxTilesY)
			{
				return;
			}
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				tile = new Tile();
				Main.tile[i, j] = tile;
			}
			if (!tile.active())
			{
				return;
			}
			if (j >= 1 && Main.tile[i, j - 1] == null)
			{
				Main.tile[i, j - 1] = new Tile();
			}
			int num = CheckTileBreakability(i, j);
			if (num == 1)
			{
				fail = true;
			}
			if (num == 2)
			{
				return;
			}
			if (gen)
			{
				noItem = true;
			}
			if (!effectOnly && !stopDrops)
			{
				if (!noItem && FixExploitManEaters.SpotProtected(i, j))
				{
					return;
				}
				if (!gen && !Main.gameMenu)
				{
					KillTile_PlaySounds(i, j, fail, tile);
				}
			}
			if (tile.type == 128 || tile.type == 269)
			{
				int num2 = i;
				int num3 = tile.frameX;
				int num4;
				for (num4 = tile.frameX; num4 >= 100; num4 -= 100)
				{
				}
				while (num4 >= 36)
				{
					num4 -= 36;
				}
				if (num4 == 18)
				{
					num3 = Main.tile[i - 1, j].frameX;
					num2--;
				}
				if (num3 >= 100)
				{
					int num5 = 0;
					while (num3 >= 100)
					{
						num3 -= 100;
						num5++;
					}
					int num6 = Main.tile[num2, j].frameY / 18;
					if (num6 == 0)
					{
						Item.NewItem(i * 16, j * 16, 16, 16, Item.headType[num5]);
					}
					if (num6 == 1)
					{
						Item.NewItem(i * 16, j * 16, 16, 16, Item.bodyType[num5]);
					}
					if (num6 == 2)
					{
						Item.NewItem(i * 16, j * 16, 16, 16, Item.legType[num5]);
					}
					for (num3 = Main.tile[num2, j].frameX; num3 >= 100; num3 -= 100)
					{
					}
					Main.tile[num2, j].frameX = (short)num3;
				}
			}
			if (tile.type == 334)
			{
				int num7 = i;
				int frameX = tile.frameX;
				int num8 = tile.frameX;
				int num9 = 0;
				while (num8 >= 5000)
				{
					num8 -= 5000;
					num9++;
				}
				if (num9 != 0)
				{
					num8 = (num9 - 1) * 18;
				}
				num8 %= 54;
				if (num8 == 18)
				{
					frameX = Main.tile[i - 1, j].frameX;
					num7--;
				}
				if (num8 == 36)
				{
					frameX = Main.tile[i - 2, j].frameX;
					num7 -= 2;
				}
				if (frameX >= 5000)
				{
					int num10 = frameX % 5000;
					num10 -= 100;
					int frameX2 = Main.tile[num7 + 1, j].frameX;
					frameX2 = ((frameX2 < 25000) ? (frameX2 - 10000) : (frameX2 - 25000));
					if (Main.netMode != 1)
					{
						Item item = new Item();
						item.netDefaults(num10);
						item.Prefix(frameX2);
						int num11 = Item.NewItem(i * 16, j * 16, 16, 16, num10, 1, noBroadcast: true);
						item.position = Main.item[num11].position;
						Main.item[num11] = item;
						NetMessage.SendData(21, -1, -1, null, num11);
					}
					frameX = Main.tile[num7, j].frameX;
					int num12 = 0;
					while (frameX >= 5000)
					{
						frameX -= 5000;
						num12++;
					}
					if (num12 != 0)
					{
						frameX = (num12 - 1) * 18;
					}
					Main.tile[num7, j].frameX = (short)frameX;
					Main.tile[num7 + 1, j].frameX = (short)(frameX + 18);
				}
			}
			if (tile.type == 395)
			{
				int num13 = TEItemFrame.Find(i - tile.frameX % 36 / 18, j - tile.frameY % 36 / 18);
				if (num13 != -1 && ((TEItemFrame)TileEntity.ByID[num13]).item.stack > 0)
				{
					((TEItemFrame)TileEntity.ByID[num13]).DropItem();
					if (Main.netMode != 2)
					{
						Main.LocalPlayer.InterruptItemUsageIfOverTile(395);
					}
					return;
				}
			}
			if (tile.type == 520)
			{
				int num14 = TEFoodPlatter.Find(i, j);
				if (num14 != -1 && ((TEFoodPlatter)TileEntity.ByID[num14]).item.stack > 0)
				{
					((TEFoodPlatter)TileEntity.ByID[num14]).DropItem();
					if (Main.netMode != 2)
					{
						Main.LocalPlayer.InterruptItemUsageIfOverTile(520);
					}
					return;
				}
			}
			if ((tile.type == 471 && TEWeaponsRack.KillTileDropItem(tile, i, j)) || (tile.type == 470 && (CheckTileBreakability2_ShouldTileSurvive(i, j) || fail)) || (tile.type == 475 && (CheckTileBreakability2_ShouldTileSurvive(i, j) || fail)))
			{
				return;
			}
			int num15 = KillTile_GetTileDustAmount(fail, tile);
			for (int k = 0; k < num15; k++)
			{
				KillTile_MakeTileDust(i, j, tile);
			}
			if (effectOnly)
			{
				return;
			}
			AttemptFossilShattering(i, j, tile, fail);
			if (fail)
			{
				if (Main.netMode != 1 && TileID.Sets.IsShakeable[tile.type])
				{
					ShakeTree(i, j);
				}
				if (tile.type == 2 || tile.type == 23 || tile.type == 109 || tile.type == 199 || tile.type == 477 || tile.type == 492)
				{
					tile.type = 0;
				}
				if (tile.type == 60 || tile.type == 70)
				{
					tile.type = 59;
				}
				if (Main.tileMoss[tile.type])
				{
					tile.type = 1;
				}
				if (TileID.Sets.tileMossBrick[tile.type])
				{
					tile.type = 38;
				}
				SquareTileFrame(i, j);
				return;
			}
			if (Main.getGoodWorld && Main.netMode != 1 && tile.type == 57)
			{
				for (int l = 0; l < 8; l++)
				{
					int maxValue = 2;
					int num16 = i;
					int num17 = j;
					switch (l)
					{
					case 0:
						num16--;
						break;
					case 1:
						num16++;
						break;
					case 2:
						num17--;
						break;
					case 3:
						num17++;
						break;
					case 4:
						num16--;
						num17--;
						break;
					case 5:
						num16++;
						num17--;
						break;
					case 6:
						num16--;
						num17++;
						break;
					case 7:
						num16++;
						num17++;
						break;
					}
					Tile tile2 = Main.tile[num16, num17];
					if (tile2.active() && genRand.Next(maxValue) == 0 && tile2.type == 57 && !SolidTile(num16, num17 + 1))
					{
						KillTile(num16, num17, fail: false, effectOnly: false, noItem: true);
						int num18 = Projectile.NewProjectile(num16 * 16 + 8, num17 * 16 + 8, 0f, 0.41f, 40, 15, 0f, Main.myPlayer);
						Main.projectile[num18].netUpdate = true;
					}
				}
			}
			if (Main.netMode != 1 && tile.type >= 481 && tile.type <= 483)
			{
				for (int m = 0; m < 8; m++)
				{
					int num19 = 6;
					int num20 = i;
					int num21 = j;
					switch (m)
					{
					case 0:
						num20--;
						break;
					case 1:
						num20++;
						break;
					case 2:
						num21--;
						num19 /= 2;
						break;
					case 3:
						num21++;
						break;
					case 4:
						num20--;
						num21--;
						break;
					case 5:
						num20++;
						num21--;
						break;
					case 6:
						num20--;
						num21++;
						break;
					case 7:
						num20++;
						num21++;
						break;
					}
					Tile tile3 = Main.tile[num20, num21];
					if (tile3.active() && genRand.Next(num19) == 0 && tile3.type >= 481 && tile3.type <= 483)
					{
						tile.active(active: false);
						KillTile(num20, num21, fail: false, effectOnly: false, noItem: true);
					}
				}
				int type = tile.type - 481 + 736;
				int damage = 20;
				if (Main.netMode == 0)
				{
					Projectile.NewProjectile(i * 16 + 8, j * 16 + 8, 0f, 0.41f, type, damage, 0f, Main.myPlayer);
				}
				else if (Main.netMode == 2)
				{
					int num22 = Projectile.NewProjectile(i * 16 + 8, j * 16 + 8, 0f, 0.41f, type, damage, 0f, Main.myPlayer);
					Main.projectile[num22].netUpdate = true;
				}
			}
			if (!CheckTileBreakability2_ShouldTileSurvive(i, j))
			{
				if (tile.type == 51 && tile.wall == 62 && genRand.Next(4) != 0)
				{
					noItem = true;
				}
				if (!noItem && !stopDrops && Main.netMode != 1)
				{
					KillTile_DropBait(i, j, tile);
					KillTile_DropItems(i, j, tile);
				}
				if (Main.netMode != 2)
				{
					AchievementsHelper.NotifyTileDestroyed(Main.player[Main.myPlayer], tile.type);
				}
				tile.active(active: false);
				tile.halfBrick(halfBrick: false);
				tile.frameX = -1;
				tile.frameY = -1;
				tile.color(0);
				tile.frameNumber(0);
				if (tile.type == 58 && j > Main.UnderworldLayer)
				{
					tile.lava(lava: true);
					tile.liquid = 128;
				}
				else if (tile.type == 419)
				{
					Wiring.PokeLogicGate(i, j + 1);
				}
				else if (TileID.Sets.BlocksWaterDrawingBehindSelf[tile.type])
				{
					SquareWallFrame(i, j);
				}
				tile.type = 0;
				tile.inActive(inActive: false);
				SquareTileFrame(i, j);
			}
		}

		private static Player GetPlayerForTile(int x, int y)
		{
			return Main.player[Player.FindClosest(new Vector2(x, y) * 16f, 16, 16)];
		}

		private static void KillTile_DropItems(int x, int y, Tile tileCache, bool includeLargeObjectDrops = false)
		{
			KillTile_GetItemDrops(x, y, tileCache, out var dropItem, out var dropItemStack, out var secondaryItem, out var secondaryItemStack, includeLargeObjectDrops);
			if (!Main.getGoodWorld || tileCache.active())
			{
				if (dropItem > 0)
				{
					int num = Item.NewItem(x * 16, y * 16, 16, 16, dropItem, dropItemStack, noBroadcast: false, -1);
					Main.item[num].TryCombiningIntoNearbyItems(num);
				}
				if (secondaryItem > 0)
				{
					int num2 = Item.NewItem(x * 16, y * 16, 16, 16, secondaryItem, secondaryItemStack, noBroadcast: false, -1);
					Main.item[num2].TryCombiningIntoNearbyItems(num2);
				}
			}
		}

		public static void KillTile_GetItemDrops(int x, int y, Tile tileCache, out int dropItem, out int dropItemStack, out int secondaryItem, out int secondaryItemStack, bool includeLargeObjectDrops = false)
		{
			dropItem = 0;
			dropItemStack = 1;
			secondaryItem = 0;
			secondaryItemStack = 1;
			int num = 0;
			if (includeLargeObjectDrops)
			{
				switch (tileCache.type)
				{
				case 21:
				case 467:
					dropItem = GetChestItemDrop(x, y, tileCache.type);
					break;
				case 88:
					num = tileCache.frameX / 54;
					dropItem = GetDresserItemDrop(num);
					break;
				}
			}
			switch (tileCache.type)
			{
			case 179:
			case 180:
			case 181:
			case 182:
			case 183:
			case 381:
			case 534:
			case 536:
			case 539:
				dropItem = 3;
				break;
			case 512:
			case 513:
			case 514:
			case 515:
			case 516:
			case 517:
			case 535:
			case 537:
			case 540:
				dropItem = 129;
				break;
			case 0:
			case 2:
			case 109:
			case 199:
			case 477:
			case 492:
				dropItem = 2;
				break;
			case 426:
				dropItem = 3621;
				break;
			case 430:
				dropItem = 3633;
				break;
			case 431:
				dropItem = 3634;
				break;
			case 432:
				dropItem = 3635;
				break;
			case 433:
				dropItem = 3636;
				break;
			case 434:
				dropItem = 3637;
				break;
			case 427:
				dropItem = 3622;
				break;
			case 435:
				dropItem = 3638;
				break;
			case 436:
				dropItem = 3639;
				break;
			case 437:
				dropItem = 3640;
				break;
			case 438:
				dropItem = 3641;
				break;
			case 439:
				dropItem = 3642;
				break;
			case 446:
				dropItem = 3736;
				break;
			case 447:
				dropItem = 3737;
				break;
			case 448:
				dropItem = 3738;
				break;
			case 449:
				dropItem = 3739;
				break;
			case 450:
				dropItem = 3740;
				break;
			case 451:
				dropItem = 3741;
				break;
			case 368:
				dropItem = 3086;
				break;
			case 369:
				dropItem = 3087;
				break;
			case 367:
				dropItem = 3081;
				break;
			case 379:
				dropItem = 3214;
				break;
			case 353:
				dropItem = 2996;
				break;
			case 365:
				dropItem = 3077;
				break;
			case 366:
				dropItem = 3078;
				break;
			case 357:
				dropItem = 3066;
				break;
			case 1:
				dropItem = 3;
				break;
			case 442:
				dropItem = 3707;
				break;
			case 383:
				dropItem = 620;
				break;
			case 315:
				dropItem = 2435;
				break;
			case 330:
				dropItem = 71;
				break;
			case 331:
				dropItem = 72;
				break;
			case 332:
				dropItem = 73;
				break;
			case 333:
				dropItem = 74;
				break;
			case 408:
				dropItem = 3460;
				break;
			case 409:
				dropItem = 3461;
				break;
			case 415:
				dropItem = 3573;
				break;
			case 416:
				dropItem = 3574;
				break;
			case 417:
				dropItem = 3575;
				break;
			case 418:
				dropItem = 3576;
				break;
			case 421:
				dropItem = 3609;
				break;
			case 422:
				dropItem = 3610;
				break;
			case 498:
				dropItem = 4139;
				break;
			case 424:
				dropItem = 3616;
				break;
			case 445:
				dropItem = 3725;
				break;
			case 429:
				dropItem = 3629;
				break;
			case 272:
				dropItem = 1344;
				break;
			case 273:
				dropItem = 2119;
				break;
			case 274:
				dropItem = 2120;
				break;
			case 618:
				dropItem = 4962;
				break;
			case 460:
				dropItem = 3756;
				break;
			case 541:
				dropItem = 4392;
				break;
			case 472:
				dropItem = 3951;
				break;
			case 473:
				dropItem = 3953;
				break;
			case 474:
				dropItem = 3955;
				break;
			case 478:
				dropItem = 4050;
				break;
			case 479:
				dropItem = 4051;
				break;
			case 496:
				dropItem = 4091;
				break;
			case 495:
				dropItem = 4090;
				break;
			case 346:
				dropItem = 2792;
				break;
			case 347:
				dropItem = 2793;
				break;
			case 348:
				dropItem = 2794;
				break;
			case 350:
				dropItem = 2860;
				break;
			case 336:
				dropItem = 2701;
				break;
			case 340:
				dropItem = 2751;
				break;
			case 341:
				dropItem = 2752;
				break;
			case 342:
				dropItem = 2753;
				break;
			case 343:
				dropItem = 2754;
				break;
			case 344:
				dropItem = 2755;
				break;
			case 351:
				dropItem = 2868;
				break;
			case 500:
				dropItem = 4229;
				break;
			case 501:
				dropItem = 4230;
				break;
			case 502:
				dropItem = 4231;
				break;
			case 503:
				dropItem = 4232;
				break;
			case 546:
			case 557:
				dropItem = 4422;
				break;
			case 561:
				dropItem = 4554;
				break;
			case 574:
				dropItem = 4717;
				break;
			case 575:
				dropItem = 4718;
				break;
			case 576:
				dropItem = 4719;
				break;
			case 577:
				dropItem = 4720;
				break;
			case 578:
				dropItem = 4721;
				break;
			case 562:
				dropItem = 4564;
				break;
			case 571:
				dropItem = 4564;
				dropItemStack = genRand.Next(1, 3);
				break;
			case 563:
				dropItem = 4547;
				break;
			case 251:
				dropItem = 1725;
				break;
			case 252:
				dropItem = 1727;
				break;
			case 253:
				dropItem = 1729;
				break;
			case 325:
				dropItem = 2692;
				break;
			case 370:
				dropItem = 3100;
				break;
			case 396:
				dropItem = 3271;
				break;
			case 400:
				dropItem = 3276;
				break;
			case 401:
				dropItem = 3277;
				break;
			case 403:
				dropItem = 3339;
				break;
			case 397:
				dropItem = 3272;
				break;
			case 398:
				dropItem = 3274;
				break;
			case 399:
				dropItem = 3275;
				break;
			case 402:
				dropItem = 3338;
				break;
			case 404:
				dropItem = 3347;
				break;
			case 407:
				dropItem = 3380;
				break;
			case 579:
				dropItem = 4761;
				break;
			case 593:
				dropItem = 4868;
				break;
			case 170:
				dropItem = 1872;
				break;
			case 284:
				dropItem = 2173;
				break;
			case 214:
				dropItem = 85;
				break;
			case 213:
				dropItem = 965;
				break;
			case 211:
				dropItem = 947;
				break;
			case 6:
				dropItem = 11;
				break;
			case 7:
				dropItem = 12;
				break;
			case 8:
				dropItem = 13;
				break;
			case 9:
				dropItem = 14;
				break;
			case 202:
				dropItem = 824;
				break;
			case 234:
				dropItem = 1246;
				break;
			case 226:
				dropItem = 1101;
				break;
			case 224:
				dropItem = 1103;
				break;
			case 36:
				dropItem = 1869;
				break;
			case 311:
				dropItem = 2260;
				break;
			case 312:
				dropItem = 2261;
				break;
			case 313:
				dropItem = 2262;
				break;
			case 229:
				dropItem = 1125;
				break;
			case 230:
				dropItem = 1127;
				break;
			case 221:
				dropItem = 1104;
				break;
			case 222:
				dropItem = 1105;
				break;
			case 223:
				dropItem = 1106;
				break;
			case 248:
				dropItem = 1589;
				break;
			case 249:
				dropItem = 1591;
				break;
			case 250:
				dropItem = 1593;
				break;
			case 191:
				dropItem = 9;
				break;
			case 203:
				dropItem = 836;
				break;
			case 204:
				dropItem = 880;
				break;
			case 166:
				dropItem = 699;
				break;
			case 167:
				dropItem = 700;
				break;
			case 168:
				dropItem = 701;
				break;
			case 169:
				dropItem = 702;
				break;
			case 123:
				dropItem = 424;
				break;
			case 124:
				dropItem = 480;
				break;
			case 157:
				dropItem = 619;
				break;
			case 158:
				dropItem = 620;
				break;
			case 159:
				dropItem = 621;
				break;
			case 161:
				dropItem = 664;
				break;
			case 206:
				dropItem = 883;
				break;
			case 232:
				dropItem = 1150;
				break;
			case 198:
				dropItem = 775;
				break;
			case 314:
				dropItem = Minecart.GetTrackItem(tileCache);
				break;
			case 189:
				dropItem = 751;
				break;
			case 195:
				dropItem = 763;
				break;
			case 194:
				dropItem = 154;
				break;
			case 193:
				dropItem = 762;
				break;
			case 196:
				dropItem = 765;
				break;
			case 197:
				dropItem = 767;
				break;
			case 22:
				dropItem = 56;
				break;
			case 140:
				dropItem = 577;
				break;
			case 23:
				dropItem = 2;
				break;
			case 25:
				dropItem = 61;
				break;
			case 30:
				dropItem = 9;
				break;
			case 208:
				dropItem = 911;
				break;
			case 372:
				dropItem = 3117;
				break;
			case 371:
				dropItem = 3113;
				break;
			case 174:
				dropItem = 713;
				break;
			case 37:
				dropItem = 116;
				break;
			case 38:
				dropItem = 129;
				break;
			case 39:
				dropItem = 131;
				break;
			case 40:
				dropItem = 133;
				break;
			case 41:
				dropItem = 134;
				break;
			case 43:
				dropItem = 137;
				break;
			case 44:
				dropItem = 139;
				break;
			case 45:
				dropItem = 141;
				break;
			case 46:
				dropItem = 143;
				break;
			case 47:
				dropItem = 145;
				break;
			case 48:
				dropItem = 147;
				break;
			case 49:
				dropItem = 148;
				break;
			case 51:
				dropItem = 150;
				break;
			case 53:
				dropItem = 169;
				break;
			case 151:
				dropItem = 607;
				break;
			case 152:
				dropItem = 609;
				break;
			case 56:
				dropItem = 173;
				break;
			case 57:
				dropItem = 172;
				break;
			case 58:
				dropItem = 174;
				break;
			case 70:
				dropItem = 176;
				break;
			case 75:
				dropItem = 192;
				break;
			case 76:
				dropItem = 214;
				break;
			case 78:
				dropItem = 222;
				break;
			case 81:
				dropItem = 275;
				break;
			case 80:
				dropItem = 276;
				break;
			case 188:
				dropItem = 276;
				break;
			case 107:
				dropItem = 364;
				break;
			case 108:
				dropItem = 365;
				break;
			case 111:
				dropItem = 366;
				break;
			case 150:
				dropItem = 604;
				break;
			case 112:
				dropItem = 370;
				break;
			case 116:
				dropItem = 408;
				break;
			case 117:
				dropItem = 409;
				break;
			case 118:
				dropItem = 412;
				break;
			case 119:
				dropItem = 413;
				break;
			case 120:
				dropItem = 414;
				break;
			case 121:
				dropItem = 415;
				break;
			case 122:
				dropItem = 416;
				break;
			case 136:
				dropItem = 538;
				break;
			case 385:
				dropItem = 3234;
				break;
			case 141:
				dropItem = 580;
				break;
			case 145:
				dropItem = 586;
				break;
			case 146:
				dropItem = 591;
				break;
			case 147:
				dropItem = 593;
				break;
			case 148:
				dropItem = 594;
				break;
			case 153:
				dropItem = 611;
				break;
			case 154:
				dropItem = 612;
				break;
			case 155:
				dropItem = 613;
				break;
			case 156:
				dropItem = 614;
				break;
			case 160:
				dropItem = 662;
				break;
			case 175:
				dropItem = 717;
				break;
			case 176:
				dropItem = 718;
				break;
			case 177:
				dropItem = 719;
				break;
			case 163:
				dropItem = 833;
				break;
			case 164:
				dropItem = 834;
				break;
			case 200:
				dropItem = 835;
				break;
			case 210:
				dropItem = 937;
				break;
			case 130:
				dropItem = 511;
				break;
			case 131:
				dropItem = 512;
				break;
			case 321:
				dropItem = 2503;
				break;
			case 322:
				dropItem = 2504;
				break;
			case 54:
				dropItem = 170;
				break;
			case 326:
				dropItem = 2693;
				break;
			case 327:
				dropItem = 2694;
				break;
			case 458:
				dropItem = 3754;
				break;
			case 459:
				dropItem = 3755;
				break;
			case 345:
				dropItem = 2787;
				break;
			case 328:
				dropItem = 2695;
				break;
			case 329:
				dropItem = 2697;
				break;
			case 507:
				dropItem = 4277;
				break;
			case 508:
				dropItem = 4278;
				break;
			case 255:
			case 256:
			case 257:
			case 258:
			case 259:
			case 260:
			case 261:
				dropItem = 1970 + tileCache.type - 255;
				break;
			case 262:
			case 263:
			case 264:
			case 265:
			case 266:
			case 267:
			case 268:
				dropItem = 1970 + tileCache.type - 262;
				break;
			case 59:
			case 60:
				dropItem = 176;
				break;
			case 190:
				dropItem = 183;
				break;
			case 63:
			case 64:
			case 65:
			case 66:
			case 67:
			case 68:
				dropItem = tileCache.type - 63 + 177;
				break;
			case 566:
				dropItem = 999;
				break;
			case 129:
				if (tileCache.frameX >= 324)
				{
					dropItem = 4988;
				}
				else
				{
					dropItem = 502;
				}
				break;
			case 3:
				if (tileCache.frameX == 144)
				{
					dropItem = 5;
				}
				else if (KillTile_ShouldDropSeeds(x, y))
				{
					dropItem = 283;
				}
				break;
			case 519:
				if (tileCache.frameY == 90 && genRand.Next(2) == 0)
				{
					dropItem = 183;
				}
				break;
			case 528:
				if (genRand.Next(2) == 0)
				{
					dropItem = 183;
				}
				break;
			case 110:
				if (tileCache.frameX == 144)
				{
					dropItem = 5;
				}
				break;
			case 24:
				if (tileCache.frameX == 144)
				{
					dropItem = 60;
				}
				break;
			case 201:
				if (tileCache.frameX == 270)
				{
					dropItem = 2887;
				}
				break;
			case 73:
				if (KillTile_ShouldDropSeeds(x, y))
				{
					dropItem = 283;
				}
				break;
			case 52:
			case 62:
			case 382:
				if (Main.rand.Next(2) == 0 && GetPlayerForTile(x, y).cordage)
				{
					dropItem = 2996;
				}
				break;
			case 227:
				num = tileCache.frameX / 34;
				dropItem = 1107 + num;
				if (num >= 8 && num <= 11)
				{
					dropItem = 3385 + num - 8;
				}
				break;
			case 4:
				num = tileCache.frameY / 22;
				switch (num)
				{
				case 0:
					dropItem = 8;
					break;
				case 8:
					dropItem = 523;
					break;
				case 9:
					dropItem = 974;
					break;
				case 10:
					dropItem = 1245;
					break;
				case 11:
					dropItem = 1333;
					break;
				case 12:
					dropItem = 2274;
					break;
				case 13:
					dropItem = 3004;
					break;
				case 14:
					dropItem = 3045;
					break;
				case 15:
					dropItem = 3114;
					break;
				case 16:
					dropItem = 4383;
					break;
				case 17:
					dropItem = 4384;
					break;
				case 18:
					dropItem = 4385;
					break;
				case 19:
					dropItem = 4386;
					break;
				case 20:
					dropItem = 4387;
					break;
				case 21:
					dropItem = 4388;
					break;
				default:
					dropItem = 426 + num;
					break;
				}
				break;
			case 239:
				num = tileCache.frameX / 18;
				if (num == 0)
				{
					dropItem = 20;
				}
				if (num == 1)
				{
					dropItem = 703;
				}
				if (num == 2)
				{
					dropItem = 22;
				}
				if (num == 3)
				{
					dropItem = 704;
				}
				if (num == 4)
				{
					dropItem = 21;
				}
				if (num == 5)
				{
					dropItem = 705;
				}
				if (num == 6)
				{
					dropItem = 19;
				}
				if (num == 7)
				{
					dropItem = 706;
				}
				if (num == 8)
				{
					dropItem = 57;
				}
				if (num == 9)
				{
					dropItem = 117;
				}
				if (num == 10)
				{
					dropItem = 175;
				}
				if (num == 11)
				{
					dropItem = 381;
				}
				if (num == 12)
				{
					dropItem = 1184;
				}
				if (num == 13)
				{
					dropItem = 382;
				}
				if (num == 14)
				{
					dropItem = 1191;
				}
				if (num == 15)
				{
					dropItem = 391;
				}
				if (num == 16)
				{
					dropItem = 1198;
				}
				if (num == 17)
				{
					dropItem = 1006;
				}
				if (num == 18)
				{
					dropItem = 1225;
				}
				if (num == 19)
				{
					dropItem = 1257;
				}
				if (num == 20)
				{
					dropItem = 1552;
				}
				if (num == 21)
				{
					dropItem = 3261;
				}
				if (num == 22)
				{
					dropItem = 3467;
				}
				break;
			case 380:
				num = tileCache.frameY / 18;
				dropItem = 3215 + num;
				break;
			case 5:
			case 596:
			case 616:
			{
				bool bonusWood = false;
				KillTile_GetTreeDrops(x, y, tileCache, bonusWood, dropItem, secondaryItem);
				if (bonusWood)
				{
					dropItemStack++;
				}
				break;
			}
			case 323:
			{
				dropItem = 2504;
				if (tileCache.frameX <= 132 && tileCache.frameX >= 88)
				{
					secondaryItem = 27;
				}
				int j;
				for (j = y; !Main.tile[x, j].active() || !Main.tileSolid[Main.tile[x, j].type]; j++)
				{
				}
				if (Main.tile[x, j].active())
				{
					switch (Main.tile[x, j].type)
					{
					case 234:
						dropItem = 911;
						break;
					case 116:
						dropItem = 621;
						break;
					case 112:
						dropItem = 619;
						break;
					}
				}
				break;
			}
			case 171:
				if (tileCache.frameX >= 10)
				{
					dropXmasTree(x, y, 0);
					dropXmasTree(x, y, 1);
					dropXmasTree(x, y, 2);
					dropXmasTree(x, y, 3);
				}
				break;
			case 324:
				switch (tileCache.frameY / 22)
				{
				case 0:
					dropItem = 2625;
					break;
				case 1:
					dropItem = 2626;
					break;
				case 2:
					dropItem = 4072;
					break;
				case 3:
					dropItem = 4073;
					break;
				case 4:
					dropItem = 4071;
					break;
				}
				break;
			case 419:
				switch (tileCache.frameX / 18)
				{
				case 0:
					dropItem = 3602;
					break;
				case 1:
					dropItem = 3618;
					break;
				case 2:
					dropItem = 3663;
					break;
				}
				break;
			case 428:
				switch (tileCache.frameY / 18)
				{
				case 0:
					dropItem = 3630;
					break;
				case 1:
					dropItem = 3632;
					break;
				case 2:
					dropItem = 3631;
					break;
				case 3:
					dropItem = 3626;
					break;
				}
				PressurePlateHelper.DestroyPlate(new Point(x, y));
				break;
			case 420:
				switch (tileCache.frameY / 18)
				{
				case 0:
					dropItem = 3603;
					break;
				case 1:
					dropItem = 3604;
					break;
				case 2:
					dropItem = 3605;
					break;
				case 3:
					dropItem = 3606;
					break;
				case 4:
					dropItem = 3607;
					break;
				case 5:
					dropItem = 3608;
					break;
				}
				break;
			case 476:
				dropItem = 4040;
				break;
			case 494:
				dropItem = 4089;
				break;
			case 423:
				TELogicSensor.Kill(x, y);
				switch (tileCache.frameY / 18)
				{
				case 0:
					dropItem = 3613;
					break;
				case 1:
					dropItem = 3614;
					break;
				case 2:
					dropItem = 3615;
					break;
				case 3:
					dropItem = 3726;
					break;
				case 4:
					dropItem = 3727;
					break;
				case 5:
					dropItem = 3728;
					break;
				case 6:
					dropItem = 3729;
					break;
				}
				break;
			case 520:
				dropItem = 4326;
				break;
			case 225:
				if (Main.rand.Next(3) == 0)
				{
					tileCache.honey(honey: true);
					tileCache.liquid = byte.MaxValue;
					break;
				}
				dropItem = 1124;
				if (Main.netMode != 1 && Main.rand.Next(2) == 0)
				{
					int num3 = 1;
					if (Main.rand.Next(3) == 0)
					{
						num3 = 2;
					}
					for (int i = 0; i < num3; i++)
					{
						int type = Main.rand.Next(210, 212);
						int num4 = NPC.NewNPC(x * 16 + 8, y * 16 + 15, type, 1);
						Main.npc[num4].velocity.X = (float)Main.rand.Next(-200, 201) * 0.002f;
						Main.npc[num4].velocity.Y = (float)Main.rand.Next(-200, 201) * 0.002f;
						Main.npc[num4].netUpdate = true;
					}
				}
				break;
			case 178:
				switch (tileCache.frameX / 18)
				{
				case 0:
					dropItem = 181;
					break;
				case 1:
					dropItem = 180;
					break;
				case 2:
					dropItem = 177;
					break;
				case 3:
					dropItem = 179;
					break;
				case 4:
					dropItem = 178;
					break;
				case 5:
					dropItem = 182;
					break;
				case 6:
					dropItem = 999;
					break;
				}
				break;
			case 149:
				if (tileCache.frameX == 0 || tileCache.frameX == 54)
				{
					dropItem = 596;
				}
				else if (tileCache.frameX == 18 || tileCache.frameX == 72)
				{
					dropItem = 597;
				}
				else if (tileCache.frameX == 36 || tileCache.frameX == 90)
				{
					dropItem = 598;
				}
				break;
			case 13:
				switch (tileCache.frameX / 18)
				{
				case 1:
					dropItem = 28;
					break;
				case 2:
					dropItem = 110;
					break;
				case 3:
					dropItem = 350;
					break;
				case 4:
					dropItem = 351;
					break;
				case 5:
					dropItem = 2234;
					break;
				case 6:
					dropItem = 2244;
					break;
				case 7:
					dropItem = 2257;
					break;
				case 8:
					dropItem = 2258;
					break;
				default:
					dropItem = 31;
					break;
				}
				break;
			case 19:
				num = tileCache.frameY / 18;
				switch (num)
				{
				case 0:
					dropItem = 94;
					break;
				case 1:
					dropItem = 631;
					break;
				case 2:
					dropItem = 632;
					break;
				case 3:
					dropItem = 633;
					break;
				case 4:
					dropItem = 634;
					break;
				case 5:
					dropItem = 913;
					break;
				case 6:
					dropItem = 1384;
					break;
				case 7:
					dropItem = 1385;
					break;
				case 8:
					dropItem = 1386;
					break;
				case 9:
					dropItem = 1387;
					break;
				case 10:
					dropItem = 1388;
					break;
				case 11:
					dropItem = 1389;
					break;
				case 12:
					dropItem = 1418;
					break;
				case 13:
					dropItem = 1457;
					break;
				case 14:
					dropItem = 1702;
					break;
				case 15:
					dropItem = 1796;
					break;
				case 16:
					dropItem = 1818;
					break;
				case 17:
					dropItem = 2518;
					break;
				case 18:
					dropItem = 2549;
					break;
				case 19:
					dropItem = 2566;
					break;
				case 20:
					dropItem = 2581;
					break;
				case 21:
					dropItem = 2627;
					break;
				case 22:
					dropItem = 2628;
					break;
				case 23:
					dropItem = 2629;
					break;
				case 24:
					dropItem = 2630;
					break;
				case 25:
					dropItem = 2744;
					break;
				case 26:
					dropItem = 2822;
					break;
				case 27:
					dropItem = 3144;
					break;
				case 28:
					dropItem = 3146;
					break;
				case 29:
					dropItem = 3145;
					break;
				case 30:
				case 31:
				case 32:
				case 33:
				case 34:
				case 35:
					dropItem = 3903 + num - 30;
					break;
				default:
					switch (num)
					{
					case 36:
						dropItem = 3945;
						break;
					case 37:
						dropItem = 3957;
						break;
					case 38:
						dropItem = 4159;
						break;
					case 39:
						dropItem = 4180;
						break;
					case 40:
						dropItem = 4201;
						break;
					case 41:
						dropItem = 4222;
						break;
					case 42:
						dropItem = 4311;
						break;
					case 43:
						dropItem = 4416;
						break;
					case 44:
						dropItem = 4580;
						break;
					}
					break;
				}
				break;
			case 33:
				num = tileCache.frameY / 22;
				dropItem = 105;
				switch (num)
				{
				case 1:
					dropItem = 1405;
					break;
				case 2:
					dropItem = 1406;
					break;
				case 3:
					dropItem = 1407;
					break;
				case 4:
				case 5:
				case 6:
				case 7:
				case 8:
				case 9:
				case 10:
				case 11:
				case 12:
				case 13:
					dropItem = 2045 + num - 4;
					break;
				default:
					if (num >= 14 && num <= 16)
					{
						dropItem = 2153 + num - 14;
						break;
					}
					switch (num)
					{
					case 17:
						dropItem = 2236;
						break;
					case 18:
						dropItem = 2523;
						break;
					case 19:
						dropItem = 2542;
						break;
					case 20:
						dropItem = 2556;
						break;
					case 21:
						dropItem = 2571;
						break;
					case 22:
						dropItem = 2648;
						break;
					case 23:
						dropItem = 2649;
						break;
					case 24:
						dropItem = 2650;
						break;
					case 25:
						dropItem = 2651;
						break;
					case 26:
						dropItem = 2818;
						break;
					case 27:
						dropItem = 3171;
						break;
					case 28:
						dropItem = 3173;
						break;
					case 29:
						dropItem = 3172;
						break;
					case 30:
						dropItem = 3890;
						break;
					case 31:
						dropItem = 3936;
						break;
					case 32:
						dropItem = 3962;
						break;
					case 33:
						dropItem = 4150;
						break;
					case 34:
						dropItem = 4171;
						break;
					case 35:
						dropItem = 4192;
						break;
					case 36:
						dropItem = 4213;
						break;
					case 37:
						dropItem = 4303;
						break;
					case 38:
						dropItem = 4571;
						break;
					}
					break;
				}
				break;
			case 137:
				num = tileCache.frameY / 18;
				if (num == 0)
				{
					dropItem = 539;
				}
				if (num == 1)
				{
					dropItem = 1146;
				}
				if (num == 2)
				{
					dropItem = 1147;
				}
				if (num == 3)
				{
					dropItem = 1148;
				}
				if (num == 4)
				{
					dropItem = 1149;
				}
				break;
			case 135:
				num = tileCache.frameY / 18;
				if (num == 0)
				{
					dropItem = 529;
				}
				if (num == 1)
				{
					dropItem = 541;
				}
				if (num == 2)
				{
					dropItem = 542;
				}
				if (num == 3)
				{
					dropItem = 543;
				}
				if (num == 4)
				{
					dropItem = 852;
				}
				if (num == 5)
				{
					dropItem = 853;
				}
				if (num == 6)
				{
					dropItem = 1151;
				}
				break;
			case 144:
				if (tileCache.frameX == 0)
				{
					dropItem = 583;
				}
				if (tileCache.frameX == 18)
				{
					dropItem = 584;
				}
				if (tileCache.frameX == 36)
				{
					dropItem = 585;
				}
				if (tileCache.frameX == 54)
				{
					dropItem = 4484;
				}
				if (tileCache.frameX == 72)
				{
					dropItem = 4485;
				}
				break;
			case 61:
			case 74:
				if (tileCache.frameX == 144 && tileCache.type == 61)
				{
					dropItem = 331;
					dropItemStack = Main.rand.Next(2, 4);
				}
				else if (tileCache.frameX == 162 && tileCache.type == 61)
				{
					dropItem = 223;
				}
				else if (tileCache.frameX >= 108 && tileCache.frameX <= 126 && tileCache.type == 61 && Main.rand.Next(20) == 0)
				{
					dropItem = 208;
				}
				else if (Main.rand.Next(100) == 0)
				{
					dropItem = 195;
				}
				break;
			case 71:
			case 72:
				if (Main.rand.Next(40) == 0)
				{
					dropItem = 194;
				}
				else if (Main.rand.Next(2) == 0)
				{
					dropItem = 183;
				}
				break;
			case 50:
				if (tileCache.frameX == 90)
				{
					dropItem = 165;
				}
				else
				{
					dropItem = 149;
				}
				break;
			case 83:
			case 84:
			{
				num = tileCache.frameX / 18;
				dropItem = 313 + num;
				int num2 = 307 + num;
				if (num == 6)
				{
					dropItem = 2358;
					num2 = 2357;
				}
				bool flag = IsHarvestableHerbWithSeed(tileCache.type, num);
				if (GetPlayerForTile(x, y).HeldItem.type == 213)
				{
					dropItemStack = Main.rand.Next(1, 3);
					secondaryItem = num2;
					secondaryItemStack = Main.rand.Next(1, 6);
				}
				else if (flag)
				{
					secondaryItem = num2;
					secondaryItemStack = Main.rand.Next(1, 4);
				}
				break;
			}
			case 589:
				SetGemTreeDrops(999, 4857, tileCache, dropItem, secondaryItem);
				if (dropItem == 3)
				{
					dropItemStack = Main.rand.Next(1, 3);
				}
				break;
			case 584:
				SetGemTreeDrops(181, 4852, tileCache, dropItem, secondaryItem);
				if (dropItem == 3)
				{
					dropItemStack = Main.rand.Next(1, 3);
				}
				break;
			case 583:
				SetGemTreeDrops(180, 4851, tileCache, dropItem, secondaryItem);
				if (dropItem == 3)
				{
					dropItemStack = Main.rand.Next(1, 3);
				}
				break;
			case 586:
				SetGemTreeDrops(179, 4854, tileCache, dropItem, secondaryItem);
				if (dropItem == 3)
				{
					dropItemStack = Main.rand.Next(1, 3);
				}
				break;
			case 585:
				SetGemTreeDrops(177, 4853, tileCache, dropItem, secondaryItem);
				if (dropItem == 3)
				{
					dropItemStack = Main.rand.Next(1, 3);
				}
				break;
			case 587:
				SetGemTreeDrops(178, 4855, tileCache, dropItem, secondaryItem);
				if (dropItem == 3)
				{
					dropItemStack = Main.rand.Next(1, 3);
				}
				break;
			case 588:
				SetGemTreeDrops(182, 4856, tileCache, dropItem, secondaryItem);
				if (dropItem == 3)
				{
					dropItemStack = Main.rand.Next(1, 3);
				}
				break;
			case 10:
			case 11:
			case 12:
			case 14:
			case 15:
			case 16:
			case 17:
			case 18:
			case 20:
			case 21:
			case 26:
			case 27:
			case 28:
			case 29:
			case 31:
			case 32:
			case 34:
			case 35:
			case 42:
			case 55:
			case 69:
			case 77:
			case 79:
			case 82:
			case 85:
			case 86:
			case 87:
			case 88:
			case 89:
			case 90:
			case 91:
			case 92:
			case 93:
			case 94:
			case 95:
			case 96:
			case 97:
			case 98:
			case 99:
			case 100:
			case 101:
			case 102:
			case 103:
			case 104:
			case 105:
			case 106:
			case 113:
			case 114:
			case 115:
			case 125:
			case 126:
			case 127:
			case 128:
			case 132:
			case 133:
			case 134:
			case 138:
			case 139:
			case 142:
			case 143:
			case 162:
			case 165:
			case 172:
			case 173:
			case 184:
			case 185:
			case 186:
			case 187:
			case 192:
			case 205:
			case 207:
			case 209:
			case 212:
			case 215:
			case 216:
			case 217:
			case 218:
			case 219:
			case 220:
			case 228:
			case 231:
			case 233:
			case 235:
			case 236:
			case 237:
			case 238:
			case 240:
			case 241:
			case 242:
			case 243:
			case 244:
			case 245:
			case 246:
			case 247:
			case 254:
			case 269:
			case 270:
			case 271:
			case 275:
			case 276:
			case 277:
			case 278:
			case 279:
			case 280:
			case 281:
			case 282:
			case 283:
			case 285:
			case 286:
			case 287:
			case 288:
			case 289:
			case 290:
			case 291:
			case 292:
			case 293:
			case 294:
			case 295:
			case 296:
			case 297:
			case 298:
			case 299:
			case 300:
			case 301:
			case 302:
			case 303:
			case 304:
			case 305:
			case 306:
			case 307:
			case 308:
			case 309:
			case 310:
			case 316:
			case 317:
			case 318:
			case 319:
			case 320:
			case 334:
			case 335:
			case 337:
			case 338:
			case 339:
			case 349:
			case 352:
			case 354:
			case 355:
			case 356:
			case 358:
			case 359:
			case 360:
			case 361:
			case 362:
			case 363:
			case 364:
			case 373:
			case 374:
			case 375:
			case 376:
			case 377:
			case 378:
			case 384:
			case 386:
			case 387:
			case 388:
			case 389:
			case 390:
			case 391:
			case 392:
			case 393:
			case 394:
			case 395:
			case 405:
			case 406:
			case 410:
			case 411:
			case 412:
			case 413:
			case 414:
			case 425:
			case 440:
			case 441:
			case 443:
			case 444:
			case 452:
			case 453:
			case 454:
			case 455:
			case 456:
			case 457:
			case 461:
			case 462:
			case 463:
			case 464:
			case 465:
			case 466:
			case 467:
			case 468:
			case 469:
			case 470:
			case 471:
			case 475:
			case 480:
			case 481:
			case 482:
			case 483:
			case 484:
			case 485:
			case 486:
			case 487:
			case 488:
			case 489:
			case 490:
			case 491:
			case 493:
			case 497:
			case 499:
			case 504:
			case 505:
			case 506:
			case 509:
			case 510:
			case 511:
			case 518:
			case 521:
			case 522:
			case 523:
			case 524:
			case 525:
			case 526:
			case 527:
			case 529:
			case 530:
			case 531:
			case 532:
			case 533:
			case 538:
			case 542:
			case 543:
			case 544:
			case 545:
			case 547:
			case 548:
			case 549:
			case 550:
			case 551:
			case 552:
			case 553:
			case 554:
			case 555:
			case 556:
			case 558:
			case 559:
			case 560:
			case 564:
			case 565:
			case 567:
			case 568:
			case 569:
			case 570:
			case 572:
			case 573:
			case 580:
			case 581:
			case 582:
			case 590:
			case 591:
			case 592:
			case 594:
			case 595:
			case 597:
			case 598:
			case 599:
			case 600:
			case 601:
			case 602:
			case 603:
			case 604:
			case 605:
			case 606:
			case 607:
			case 608:
			case 609:
			case 610:
			case 611:
			case 612:
			case 613:
			case 614:
			case 615:
			case 617:
				break;
			}
		}

		private static void SetGemTreeDrops(int gemType, int seedType, Tile tileCache, int dropItem, int secondaryItem)
		{
			if (Main.rand.Next(10) == 0)
			{
				dropItem = gemType;
			}
			else
			{
				dropItem = 3;
			}
			if (tileCache.frameX >= 22 && tileCache.frameY >= 198 && Main.rand.Next(2) == 0)
			{
				secondaryItem = seedType;
			}
		}

		private static void SetVanityTreeDrops(int dropType, Tile tileCache, int dropItem)
		{
			if (Main.rand.Next(2) == 0)
			{
				dropItem = dropType;
			}
		}

		public static bool IsHarvestableHerbWithSeed(int type, int style)
		{
			bool result = false;
			if (type == 84)
			{
				result = true;
			}
			if (style == 0 && Main.dayTime)
			{
				result = true;
			}
			if (style == 1 && !Main.dayTime)
			{
				result = true;
			}
			if (style == 3 && !Main.dayTime && (Main.bloodMoon || Main.moonPhase == 0))
			{
				result = true;
			}
			if (style == 4 && (Main.raining || Main.cloudAlpha > 0f))
			{
				result = true;
			}
			if (style == 5 && !Main.raining && Main.dayTime && Main.time > 40500.0)
			{
				result = true;
			}
			return result;
		}

		private static bool KillTile_ShouldDropSeeds(int x, int y)
		{
			if (Main.rand.Next(2) == 0)
			{
				if (!GetPlayerForTile(x, y).HasItem(281))
				{
					return GetPlayerForTile(x, y).HasItem(986);
				}
				return true;
			}
			return false;
		}

		private static void KillTile_GetTreeDrops(int i, int j, Tile tileCache, bool bonusWood, int dropItem, int secondaryItem)
		{
			if (tileCache.frameX >= 22 && tileCache.frameY >= 198)
			{
				if (Main.netMode != 1)
				{
					if (genRand.Next(2) == 0)
					{
						int k;
						for (k = j; Main.tile[i, k] != null && (!Main.tile[i, k].active() || !Main.tileSolid[Main.tile[i, k].type] || Main.tileSolidTop[Main.tile[i, k].type]); k++)
						{
						}
						if (Main.tile[i, k] != null)
						{
							Tile tile = Main.tile[i, k];
							if (tile.type == 2 || tile.type == 109 || tile.type == 477 || tile.type == 492 || tile.type == 147 || tile.type == 199 || tile.type == 23)
							{
								dropItem = 9;
								secondaryItem = 27;
							}
							else
							{
								dropItem = 9;
							}
						}
					}
					else
					{
						dropItem = 9;
					}
				}
			}
			else
			{
				dropItem = 9;
			}
			if (dropItem != 9)
			{
				return;
			}
			GetTreeBottom(i, j, out var x, out var y);
			if (Main.tile[x, y].active())
			{
				switch (Main.tile[x, y].type)
				{
				case 23:
					dropItem = 619;
					break;
				case 60:
					dropItem = 620;
					break;
				case 109:
				case 492:
					dropItem = 621;
					break;
				case 199:
					dropItem = 911;
					break;
				case 70:
					if (genRand.Next(2) == 0)
					{
						dropItem = 183;
					}
					else
					{
						dropItem = 0;
					}
					break;
				case 147:
					dropItem = 2503;
					break;
				}
			}
			int num = Player.FindClosest(new Vector2(x * 16, y * 16), 16, 16);
			int axe = Main.player[num].inventory[Main.player[num].selectedItem].axe;
			if (genRand.Next(100) < axe || Main.rand.Next(3) == 0)
			{
				bonusWood = true;
			}
		}

		private static void KillTile_DropBait(int i, int j, Tile tileCache)
		{
			int num = -1;
			int num2 = -1;
			int num3 = -1;
			int num4 = Player.FindClosest(new Vector2(i * 16, j * 16), 16, 16);
			if (tileCache.type == 3)
			{
				num = 400;
				num2 = 100;
				if (Main.player[num4].flowerBoots && tileCache.frameX >= 108)
				{
					num *= 10000;
					num2 *= 10000;
				}
			}
			if (tileCache.type == 73)
			{
				num = 200;
				num2 = 50;
				if (Main.player[num4].flowerBoots && tileCache.frameX >= 108)
				{
					num *= 10000;
					num2 *= 10000;
				}
			}
			if (tileCache.type == 61)
			{
				num3 = 80;
				if (Main.player[num4].flowerBoots && tileCache.frameX >= 108)
				{
					num3 *= 10000;
				}
			}
			if (tileCache.type == 74)
			{
				num3 = 40;
				if (Main.player[num4].flowerBoots && tileCache.frameX >= 108)
				{
					num3 *= 10000;
				}
			}
			if (tileCache.type == 62)
			{
				num3 = 250;
			}
			if (tileCache.type == 185)
			{
				if (tileCache.frameY == 0 && tileCache.frameX < 214)
				{
					num = 6;
				}
				if (tileCache.frameY == 18 && (tileCache.frameX < 214 || tileCache.frameX >= 1368))
				{
					num = 6;
				}
			}
			else if (tileCache.type == 186)
			{
				if (tileCache.frameX >= 378 && tileCache.frameX <= 700)
				{
					num = 6;
				}
			}
			else if (tileCache.type == 187)
			{
				if (tileCache.frameX >= 756 && tileCache.frameX <= 916)
				{
					num = 6;
				}
				if (tileCache.frameX <= 322)
				{
					num = 6;
				}
			}
			else if (tileCache.type == 233)
			{
				num3 = 10;
			}
			int num5 = 357;
			if (Main.player[num4].ZoneGraveyard)
			{
				num5 = 606;
			}
			if (num > 0 && NPC.CountNPCS(num5) < 5 && genRand.Next(num) == 0)
			{
				int type = num5;
				if (num5 == 357 && Player.GetClosestRollLuck(i, j, NPC.goldCritterChance) == 0f)
				{
					type = 448;
				}
				int num6 = NPC.NewNPC(i * 16 + 10, j * 16, type);
				Main.npc[num6].TargetClosest();
				Main.npc[num6].velocity.Y = (float)genRand.Next(-50, -21) * 0.1f;
				Main.npc[num6].velocity.X = (float)genRand.Next(0, 26) * 0.1f * (float)(-Main.npc[num6].direction);
				Main.npc[num6].direction *= -1;
				Main.npc[num6].netUpdate = true;
			}
			if (num2 > 0 && NPC.CountNPCS(377) < 5 && genRand.Next(num2) == 0)
			{
				int type2 = 377;
				if (Player.GetClosestRollLuck(i, j, NPC.goldCritterChance) == 0f)
				{
					type2 = 446;
				}
				int num7 = NPC.NewNPC(i * 16 + 10, j * 16, type2);
				Main.npc[num7].TargetClosest();
				Main.npc[num7].velocity.Y = (float)genRand.Next(-50, -21) * 0.1f;
				Main.npc[num7].velocity.X = (float)genRand.Next(0, 26) * 0.1f * (float)(-Main.npc[num7].direction);
				Main.npc[num7].direction *= -1;
				Main.npc[num7].netUpdate = true;
			}
			if (num3 > 0 && NPC.CountNPCS(485) + NPC.CountNPCS(486) + NPC.CountNPCS(487) < 8 && genRand.Next(num3) == 0)
			{
				int type3 = 485;
				if (genRand.Next(4) == 0)
				{
					type3 = 486;
				}
				if (genRand.Next(12) == 0)
				{
					type3 = 487;
				}
				int num8 = NPC.NewNPC(i * 16 + 10, j * 16, type3);
				Main.npc[num8].TargetClosest();
				Main.npc[num8].velocity.Y = (float)genRand.Next(-50, -21) * 0.1f;
				Main.npc[num8].velocity.X = (float)genRand.Next(0, 26) * 0.1f * (float)(-Main.npc[num8].direction);
				Main.npc[num8].direction *= -1;
				Main.npc[num8].netUpdate = true;
			}
		}

		public static void KillTile_PlaySounds(int i, int j, bool fail, Tile tileCache)
		{
			if (gen)
			{
				return;
			}
			int type = tileCache.type;
			if (type == 127)
			{
				SoundEngine.PlaySound(SoundID.Item27, i * 16, j * 16);
			}
			else if (type == 147 || type == 224)
			{
				if (genRand.Next(2) == 0)
				{
					SoundEngine.PlaySound(SoundID.Item48, i * 16, j * 16);
				}
				else
				{
					SoundEngine.PlaySound(SoundID.Item49, i * 16, j * 16);
				}
			}
			else if (type == 161 || type == 163 || type == 164 || type == 200 || type == 541)
			{
				SoundEngine.PlaySound(SoundID.Item50, i * 16, j * 16);
			}
			else if (type == 518 || type == 519 || type == 528 || type == 529 || type == 549)
			{
				SoundEngine.PlaySound(6, i * 16, j * 16);
			}
			else if (type == 530 && tileCache.frameX < 270)
			{
				SoundEngine.PlaySound(6, i * 16, j * 16);
			}
			else
			{
				switch (type)
				{
				case 3:
				case 110:
					SoundEngine.PlaySound(6, i * 16, j * 16);
					break;
				case 254:
					SoundEngine.PlaySound(6, i * 16, j * 16);
					break;
				case 24:
					SoundEngine.PlaySound(6, i * 16, j * 16);
					break;
				default:
					if (Main.tileAlch[type] || type == 384 || type == 227 || type == 32 || type == 51 || type == 52 || type == 61 || type == 62 || type == 69 || type == 71 || type == 73 || type == 74 || type == 113 || type == 115 || type == 184 || type == 192 || type == 205 || type == 233 || type == 352 || type == 382)
					{
						SoundEngine.PlaySound(6, i * 16, j * 16);
						break;
					}
					if (type == 485)
					{
						SoundEngine.PlaySound(4, i * 16, j * 16, 11);
						break;
					}
					if (type == 201)
					{
						SoundEngine.PlaySound(6, i * 16, j * 16);
						break;
					}
					if (type == 481 || type == 482 || type == 483)
					{
						SoundEngine.PlaySound(SoundID.Item127, i * 16, j * 16);
						break;
					}
					if (type == 1 || type == 6 || type == 7 || type == 8 || type == 9 || type == 22 || type == 140 || type == 25 || type == 37 || type == 38 || type == 39 || type == 41 || type == 43 || type == 44 || type == 45 || type == 46 || type == 47 || type == 48 || type == 56 || type == 58 || type == 63 || type == 64 || type == 65 || type == 66 || type == 67 || type == 68 || type == 75 || type == 76 || type == 107 || type == 108 || type == 111 || type == 117 || type == 118 || type == 119 || type == 120 || type == 121 || type == 122 || type == 150 || type == 151 || type == 152 || type == 153 || type == 154 || type == 155 || type == 156 || type == 160 || type == 161 || type == 166 || type == 167 || type == 168 || type == 169 || type == 175 || type == 176 || type == 177 || type == 203 || type == 202 || type == 204 || type == 206 || type == 211 || type == 221 || type == 222 || type == 223 || type == 226 || type == 248 || type == 249 || type == 250 || type == 272 || type == 273 || type == 274 || type == 478 || type == 284 || type == 325 || type == 346 || type == 347 || type == 348 || type == 350 || type == 367 || type == 357 || type == 368 || type == 369 || type == 370 || type == 407 || type == 472 || type == 473 || type == 500 || type == 501 || type == 502 || type == 503 || type == 546 || type == 557 || type == 566 || type == 618)
					{
						SoundEngine.PlaySound(21, i * 16, j * 16);
						break;
					}
					if (type == 231 || type == 195 || type == 474)
					{
						SoundEngine.PlaySound(4, i * 16, j * 16);
						break;
					}
					if (type == 26 && tileCache.frameX >= 54)
					{
						SoundEngine.PlaySound(4, i * 16, j * 16);
						break;
					}
					switch (type)
					{
					case 314:
						SoundEngine.PlaySound(SoundID.Item52, i * 16, j * 16);
						break;
					case 330:
					case 331:
					case 332:
					case 333:
						SoundEngine.PlaySound(18, i * 16, j * 16);
						break;
					default:
						if ((type == 162 || type == 385 || type == 129 || (type == 165 && tileCache.frameX < 54)) && !fail)
						{
							SoundEngine.PlaySound(SoundID.Item27, i * 16, j * 16);
						}
						else if (type != 138)
						{
							SoundEngine.PlaySound(0, i * 16, j * 16);
						}
						break;
					}
					break;
				}
			}
			if (!fail)
			{
				if (tileCache.type == 13)
				{
					SoundEngine.PlaySound(13, i * 16, j * 16);
				}
				else if (tileCache.type == 54)
				{
					SoundEngine.PlaySound(13, i * 16, j * 16);
				}
				else if (tileCache.type == 326)
				{
					SoundEngine.PlaySound(13, i * 16, j * 16);
				}
				else if (tileCache.type == 327)
				{
					SoundEngine.PlaySound(13, i * 16, j * 16);
				}
				else if (tileCache.type == 458)
				{
					SoundEngine.PlaySound(13, i * 16, j * 16);
				}
				else if (tileCache.type == 459)
				{
					SoundEngine.PlaySound(13, i * 16, j * 16);
				}
				else if (tileCache.type == 345)
				{
					SoundEngine.PlaySound(13, i * 16, j * 16);
				}
				else if (tileCache.type == 328)
				{
					SoundEngine.PlaySound(13, i * 16, j * 16);
				}
				else if (tileCache.type == 329)
				{
					SoundEngine.PlaySound(13, i * 16, j * 16);
				}
				else if (tileCache.type == 507)
				{
					SoundEngine.PlaySound(13, i * 16, j * 16);
				}
				else if (tileCache.type == 508)
				{
					SoundEngine.PlaySound(13, i * 16, j * 16);
				}
			}
		}

		public static Rectangle? GetTileVisualHitbox(int x, int y)
		{
			Tile tile = Main.tile[x, y];
			if (tile == null || !tile.nactive())
			{
				return null;
			}
			Rectangle value = new Rectangle(x * 16, y * 16, 16, 16);
			ushort type = tile.type;
			if (type == 323)
			{
				value.X += tile.frameY;
			}
			if (tile.halfBrick())
			{
				value.Y += 8;
				value.Height = 8;
			}
			return value;
		}

		public static int KillTile_GetTileDustAmount(bool fail, Tile tileCache)
		{
			switch (tileCache.type)
			{
			default:
				if (!fail)
				{
					return 10;
				}
				return 3;
			case 231:
				if (!fail)
				{
					return 6;
				}
				return 3;
			case 481:
			case 482:
			case 483:
				return 3;
			case 541:
				return 1;
			case 549:
				return 2;
			case 125:
			case 138:
			case 172:
			case 287:
			case 300:
			case 301:
			case 302:
			case 303:
			case 304:
			case 305:
			case 306:
			case 307:
			case 308:
			case 354:
			case 355:
			case 373:
			case 374:
			case 375:
			case 376:
			case 461:
			case 484:
			case 499:
			case 564:
			case 565:
			case 593:
			case 594:
			case 617:
				return 0;
			case 534:
			case 536:
			case 539:
				if (!fail)
				{
					return 5;
				}
				return 3;
			case 184:
				if (tileCache.frameX / 22 >= 5)
				{
					return 5;
				}
				if (!fail)
				{
					return 10;
				}
				return 3;
			}
		}

		public static int KillTile_MakeTileDust(int i, int j, Tile tileCache)
		{
			int num = 0;
			if (tileCache.type == 216)
			{
				num = -1;
			}
			if (tileCache.type == 324)
			{
				num = ((tileCache.frameY != 0) ? (281 + tileCache.frameX / 18) : 280);
			}
			if (tileCache.type == 216)
			{
				num = -1;
			}
			if (tileCache.type == 335)
			{
				num = -1;
			}
			if (tileCache.type == 338)
			{
				num = -1;
			}
			if (tileCache.type == 0)
			{
				num = 0;
			}
			if (tileCache.type == 192)
			{
				num = 3;
			}
			if (tileCache.type == 208)
			{
				num = 126;
			}
			else if (tileCache.type == 408 || tileCache.type == 409)
			{
				num = 265;
			}
			if (tileCache.type == 16)
			{
				num = 1;
				if (tileCache.frameX >= 36)
				{
					num = 82;
				}
			}
			else if (tileCache.type == 415 || tileCache.type == 500)
			{
				num = 6;
			}
			else if (tileCache.type == 416 || tileCache.type == 501)
			{
				num = 61;
			}
			else if (tileCache.type == 417 || tileCache.type == 502)
			{
				num = 242;
			}
			else if (tileCache.type == 418 || tileCache.type == 503)
			{
				num = 135;
			}
			else if (tileCache.type == 474)
			{
				num = 18;
			}
			if (tileCache.type == 1 || tileCache.type == 17 || tileCache.type == 38 || tileCache.type == 39 || tileCache.type == 41 || tileCache.type == 43 || tileCache.type == 44 || tileCache.type == 481 || tileCache.type == 482 || tileCache.type == 483 || tileCache.type == 48 || Main.tileStone[tileCache.type] || tileCache.type == 85 || tileCache.type == 90 || tileCache.type == 92 || tileCache.type == 96 || tileCache.type == 97 || tileCache.type == 99 || tileCache.type == 117 || tileCache.type == 130 || tileCache.type == 131 || tileCache.type == 132 || tileCache.type == 135 || tileCache.type == 135 || tileCache.type == 142 || tileCache.type == 143 || tileCache.type == 144 || tileCache.type == 210 || tileCache.type == 207 || tileCache.type == 235 || tileCache.type == 247 || tileCache.type == 272 || tileCache.type == 273 || tileCache.type == 283 || tileCache.type == 410 || tileCache.type == 480 || tileCache.type == 509 || tileCache.type == 618)
			{
				num = 1;
			}
			if (tileCache.type == 379)
			{
				num = 257;
			}
			if (tileCache.type == 311)
			{
				num = 207;
			}
			if (tileCache.type == 312)
			{
				num = 208;
			}
			if (tileCache.type == 313)
			{
				num = 209;
			}
			if (tileCache.type == 104)
			{
				num = -1;
			}
			if (tileCache.type == 95 || tileCache.type == 98 || tileCache.type == 100 || tileCache.type == 174 || tileCache.type == 173)
			{
				num = 6;
			}
			if (tileCache.type == 30 || tileCache.type == 86 || tileCache.type == 94 || tileCache.type == 106 || tileCache.type == 114 || tileCache.type == 124 || tileCache.type == 128 || tileCache.type == 269)
			{
				num = 7;
			}
			if (tileCache.type == 372)
			{
				num = 242;
			}
			if (tileCache.type == 371)
			{
				num = 243;
			}
			if (tileCache.type == 334)
			{
				num = 7;
			}
			switch (tileCache.type)
			{
			case 10:
			case 11:
			case 87:
			case 89:
			case 93:
			case 139:
			case 209:
			case 319:
			case 320:
			case 386:
			case 387:
			case 390:
			case 405:
			case 406:
			case 411:
			case 412:
			case 419:
			case 420:
			case 421:
			case 422:
			case 423:
			case 424:
			case 425:
			case 428:
			case 429:
			case 441:
			case 442:
			case 445:
			case 446:
			case 447:
			case 448:
			case 449:
			case 450:
			case 451:
			case 452:
			case 453:
			case 455:
			case 456:
			case 457:
			case 462:
			case 463:
			case 464:
			case 465:
			case 466:
			case 468:
			case 476:
			case 486:
			case 487:
			case 489:
			case 490:
			case 491:
			case 493:
			case 494:
			case 497:
			case 510:
			case 511:
			case 520:
			case 521:
			case 522:
			case 523:
			case 524:
			case 525:
			case 526:
			case 527:
			case 531:
			case 545:
			case 547:
			case 548:
			case 560:
			case 564:
			case 565:
			case 567:
			case 572:
			case 579:
			case 591:
			case 592:
			case 593:
			case 594:
			case 613:
			case 614:
			case 621:
			case 622:
				num = -1;
				break;
			case 407:
				num = 10;
				break;
			case 454:
				num = 139;
				break;
			case 41:
			case 481:
				num = 275;
				break;
			case 43:
			case 482:
				num = 276;
				break;
			case 44:
			case 483:
				num = 277;
				break;
			case 473:
				num = 82;
				break;
			case 472:
			case 546:
			case 557:
				num = 8;
				break;
			case 498:
				num = 30;
				break;
			case 517:
				num = 258;
				break;
			case 535:
				num = 299;
				break;
			case 537:
				num = 300;
				break;
			case 540:
				num = 301;
				break;
			case 184:
			{
				int num2 = tileCache.frameX / 22;
				num = num2 switch
				{
					5 => 258, 
					6 => 299, 
					7 => 300, 
					8 => 301, 
					_ => 93 + num2, 
				};
				break;
			}
			case 515:
				num = 96;
				break;
			case 516:
				num = 97;
				break;
			case 514:
				num = 95;
				break;
			case 513:
				num = 94;
				break;
			case 512:
				num = 93;
				break;
			case 541:
				num = 226;
				break;
			case 590:
				num = 1;
				break;
			case 583:
				num = ((genRand.Next(10) != 0) ? 1 : 87);
				break;
			case 584:
				num = ((genRand.Next(10) != 0) ? 1 : 86);
				break;
			case 585:
				num = ((genRand.Next(10) != 0) ? 1 : 88);
				break;
			case 586:
				num = ((genRand.Next(10) != 0) ? 1 : 89);
				break;
			case 587:
				num = ((genRand.Next(10) != 0) ? 1 : 90);
				break;
			case 588:
				num = ((genRand.Next(10) != 0) ? 1 : 91);
				break;
			case 589:
				num = ((genRand.Next(10) != 0) ? 1 : 138);
				break;
			case 595:
				num = 78;
				break;
			case 596:
				num = 78;
				break;
			case 615:
				num = 78;
				break;
			case 616:
				num = 78;
				break;
			}
			if (Main.tileMoss[tileCache.type])
			{
				num = ((tileCache.type == 381) ? 258 : ((tileCache.type == 534) ? 299 : ((tileCache.type == 536) ? 300 : ((tileCache.type != 539) ? (tileCache.type - 179 + 93) : 301))));
			}
			if (tileCache.type == 240)
			{
				int num3 = tileCache.frameX / 54;
				if (tileCache.frameY >= 54)
				{
					num3 += 36;
				}
				num = 7;
				if (num3 == 16 || num3 == 17)
				{
					num = 26;
				}
				if (num3 >= 46 && num3 <= 49)
				{
					num = -1;
				}
			}
			if (tileCache.type == 241)
			{
				num = 1;
			}
			if (tileCache.type == 242)
			{
				num = -1;
			}
			if (tileCache.type == 529)
			{
				num = Main.tile[i, j + 1].type switch
				{
					116 => num = 47, 
					234 => num = 125, 
					112 => num = 17, 
					_ => (i >= beachDistance && i <= Main.maxTilesX - beachDistance) ? 289 : 290, 
				};
			}
			if (tileCache.type == 356)
			{
				num = -1;
			}
			if (tileCache.type == 351)
			{
				num = -1;
			}
			if (tileCache.type == 246)
			{
				num = -1;
			}
			if (tileCache.type == 36)
			{
				num = -1;
			}
			if (tileCache.type == 365)
			{
				num = 239;
			}
			if (tileCache.type == 366)
			{
				num = 30;
			}
			if (tileCache.type == 504)
			{
				num = -1;
			}
			if (tileCache.type == 357 || tileCache.type == 367 || tileCache.type == 561)
			{
				num = 236;
			}
			if (tileCache.type == 368 || tileCache.type == 369 || tileCache.type == 576)
			{
				num = 240;
			}
			if (tileCache.type == 170)
			{
				num = 196;
			}
			if (tileCache.type == 315)
			{
				num = 225;
			}
			if (tileCache.type == 346)
			{
				num = 128;
			}
			if (tileCache.type == 347)
			{
				num = 117;
			}
			if (tileCache.type == 348)
			{
				num = 42;
			}
			if (tileCache.type == 350)
			{
				num = 226;
			}
			if (tileCache.type == 370)
			{
				num = ((genRand.Next(2) != 0) ? 23 : 6);
			}
			if (tileCache.type == 171)
			{
				num = ((genRand.Next(2) != 0) ? (-1) : 196);
			}
			if (tileCache.type == 326)
			{
				num = 13;
			}
			if (tileCache.type == 327)
			{
				num = 13;
			}
			if (tileCache.type == 345)
			{
				num = 13;
			}
			if (tileCache.type == 458)
			{
				num = 13;
			}
			if (tileCache.type == 459)
			{
				num = 13;
			}
			if (tileCache.type == 336)
			{
				num = 6;
			}
			if (tileCache.type == 340)
			{
				num = 75;
			}
			if (tileCache.type == 341)
			{
				num = 65;
			}
			if (tileCache.type == 342)
			{
				num = 135;
			}
			if (tileCache.type == 343)
			{
				num = 169;
			}
			if (tileCache.type == 344)
			{
				num = 156;
			}
			if (tileCache.type == 328)
			{
				num = 13;
			}
			if (tileCache.type == 329)
			{
				num = 13;
			}
			if (tileCache.type == 507)
			{
				num = 13;
			}
			if (tileCache.type == 508)
			{
				num = 13;
			}
			if (tileCache.type == 562)
			{
				num = -1;
			}
			if (tileCache.type == 571)
			{
				num = 40;
			}
			if (tileCache.type == 563)
			{
				num = -1;
			}
			if (tileCache.type == 330)
			{
				num = 9;
			}
			if (tileCache.type == 331)
			{
				num = 11;
			}
			if (tileCache.type == 332)
			{
				num = 19;
			}
			if (tileCache.type == 333)
			{
				num = 11;
			}
			if (tileCache.type == 101)
			{
				num = -1;
			}
			if (tileCache.type == 19)
			{
				num = (tileCache.frameY / 18) switch
				{
					0 => 7, 
					1 => 77, 
					2 => 78, 
					3 => 79, 
					4 => 26, 
					5 => 126, 
					6 => 275, 
					7 => 277, 
					8 => 276, 
					9 => 1, 
					10 => 214, 
					11 => 214, 
					12 => 214, 
					13 => 109, 
					14 => 13, 
					15 => 189, 
					16 => 191, 
					17 => 215, 
					18 => 26, 
					19 => 214, 
					20 => 4, 
					21 => 10, 
					22 => 32, 
					23 => 78, 
					24 => 147, 
					25 => 40, 
					26 => 226, 
					27 => 23, 
					28 => 240, 
					29 => 236, 
					30 => 68 + Main.rand.Next(3), 
					31 => 10, 
					32 => 78, 
					33 => 148, 
					34 => 5, 
					35 => 80, 
					37 => 18, 
					38 => 6, 
					39 => 61, 
					40 => 242, 
					41 => 135, 
					42 => 287, 
					44 => -1, 
					_ => 1, 
				};
			}
			if (tileCache.type == 79)
			{
				int num4 = tileCache.frameY / 36;
				num = ((num4 == 0) ? 7 : ((num4 == 1) ? 77 : ((num4 == 2) ? 78 : ((num4 == 3) ? 79 : ((num4 == 4) ? 126 : ((num4 == 8) ? 109 : ((num4 < 9) ? 1 : (-1))))))));
			}
			if (tileCache.type == 18)
			{
				switch (tileCache.frameX / 36)
				{
				case 0:
					num = 7;
					break;
				case 1:
					num = 77;
					break;
				case 2:
					num = 78;
					break;
				case 3:
					num = 79;
					break;
				case 4:
					num = 26;
					break;
				case 5:
					num = 40;
					break;
				case 6:
					num = 5;
					break;
				case 7:
					num = 26;
					break;
				case 8:
					num = 4;
					break;
				case 9:
					num = 126;
					break;
				case 10:
					num = 148;
					break;
				case 11:
				case 12:
				case 13:
					num = 1;
					break;
				case 14:
					num = 109;
					break;
				case 15:
					num = 126;
					break;
				default:
					num = -1;
					break;
				}
			}
			if (tileCache.type == 14 || tileCache.type == 87 || tileCache.type == 88 || tileCache.type == 469)
			{
				num = -1;
			}
			if (tileCache.type >= 255 && tileCache.type <= 261)
			{
				int num5 = tileCache.type - 255;
				num = 86 + num5;
				if (num5 == 6)
				{
					num = 138;
				}
			}
			if (tileCache.type >= 262 && tileCache.type <= 268)
			{
				int num6 = tileCache.type - 262;
				num = 86 + num6;
				if (num6 == 6)
				{
					num = 138;
				}
			}
			if (tileCache.type == 178)
			{
				int num7 = tileCache.frameX / 18;
				num = 86 + num7;
				if (num7 == 6)
				{
					num = 138;
				}
			}
			if (tileCache.type == 440)
			{
				num = (tileCache.frameX / 54) switch
				{
					0 => 90, 
					1 => 88, 
					2 => 89, 
					3 => 87, 
					4 => 86, 
					5 => 91, 
					6 => 138, 
					_ => -1, 
				};
				if (tileCache.frameY < 54)
				{
					num = -1;
				}
			}
			switch (tileCache.type)
			{
			case 426:
			case 427:
				num = 90;
				break;
			case 430:
			case 435:
				num = 89;
				break;
			case 431:
			case 436:
				num = 88;
				break;
			case 432:
			case 437:
				num = 87;
				break;
			case 433:
			case 438:
				num = 86;
				break;
			case 434:
			case 439:
				num = 91;
				break;
			case 496:
				num = 109;
				break;
			case 549:
				num = 3;
				break;
			case 552:
				num = 32;
				break;
			}
			if (tileCache.type == 186)
			{
				num = ((tileCache.frameX <= 360) ? 26 : ((tileCache.frameX <= 846) ? 1 : ((tileCache.frameX <= 954) ? 9 : ((tileCache.frameX <= 1062) ? 11 : ((tileCache.frameX <= 1170) ? 10 : ((tileCache.frameX > 1332) ? ((tileCache.frameX > 1386) ? 80 : 10) : 0))))));
			}
			if (tileCache.type == 187)
			{
				if (tileCache.frameX <= 144)
				{
					num = 1;
				}
				else if (tileCache.frameX <= 306)
				{
					num = 38;
				}
				else if (tileCache.frameX <= 468)
				{
					num = 36;
				}
				else if (tileCache.frameX <= 738)
				{
					num = 30;
				}
				else if (tileCache.frameX <= 970)
				{
					num = 1;
				}
				else if (tileCache.frameX <= 1132)
				{
					num = 148;
				}
				else if (tileCache.frameX <= 1132)
				{
					num = 155;
				}
				else if (tileCache.frameX <= 1348)
				{
					num = 1;
				}
				else if (tileCache.frameX <= 1564)
				{
					num = 0;
				}
				else if (tileCache.frameX <= 1890)
				{
					num = 250;
				}
				else if (tileCache.frameX <= 2196)
				{
					num = 240;
				}
				else if (tileCache.frameX <= 2520)
				{
					num = 236;
				}
			}
			if (tileCache.type == 105)
			{
				num = 1;
				if (tileCache.frameX >= 1548 && tileCache.frameX <= 1654 && tileCache.frameY < 54)
				{
					num = 148;
				}
			}
			if (tileCache.type == 349)
			{
				num = 1;
			}
			if (tileCache.type == 337 || tileCache.type == 506)
			{
				num = 1;
			}
			if (tileCache.type == 239)
			{
				int num8 = tileCache.frameX / 18;
				if (num8 == 0)
				{
					num = 9;
				}
				if (num8 == 1)
				{
					num = 81;
				}
				if (num8 == 2)
				{
					num = 8;
				}
				if (num8 == 3)
				{
					num = 82;
				}
				if (num8 == 4)
				{
					num = 11;
				}
				if (num8 == 5)
				{
					num = 83;
				}
				if (num8 == 6)
				{
					num = 10;
				}
				if (num8 == 7)
				{
					num = 84;
				}
				if (num8 == 8)
				{
					num = 14;
				}
				if (num8 == 9)
				{
					num = 23;
				}
				if (num8 == 10)
				{
					num = 25;
				}
				if (num8 == 11)
				{
					num = 48;
				}
				if (num8 == 12)
				{
					num = 144;
				}
				if (num8 == 13)
				{
					num = 49;
				}
				if (num8 == 14)
				{
					num = 145;
				}
				if (num8 == 15)
				{
					num = 50;
				}
				if (num8 == 16)
				{
					num = 146;
				}
				if (num8 == 17)
				{
					num = 128;
				}
				if (num8 == 18)
				{
					num = 84;
				}
				if (num8 == 19)
				{
					num = 117;
				}
				if (num8 == 20)
				{
					num = 42;
				}
				if (num8 == 21)
				{
					num = -1;
				}
				if (num8 == 22)
				{
					num = 265;
				}
			}
			if (tileCache.type == 185)
			{
				if (tileCache.frameY == 18)
				{
					int num9 = tileCache.frameX / 36;
					if (num9 < 6)
					{
						num = 1;
					}
					else if (num9 < 16)
					{
						num = 26;
					}
					else if (num9 == 16)
					{
						num = 9;
					}
					else if (num9 == 17)
					{
						num = 11;
					}
					else if (num9 == 18)
					{
						num = 10;
					}
					else if (num9 == 19)
					{
						num = 86;
					}
					else if (num9 == 20)
					{
						num = 87;
					}
					else if (num9 == 21)
					{
						num = 88;
					}
					else if (num9 == 22)
					{
						num = 89;
					}
					else if (num9 == 23)
					{
						num = 90;
					}
					else if (num9 == 24)
					{
						num = 91;
					}
					else if (num9 < 31)
					{
						num = 80;
					}
					else if (num9 < 33)
					{
						num = 7;
					}
					else if (num9 < 34)
					{
						num = 8;
					}
					else if (num9 < 39)
					{
						num = 30;
					}
					else if (num9 < 42)
					{
						num = 1;
					}
					else if (num9 < 48)
					{
						num = 32;
					}
					else if (num9 < 54)
					{
						num = 240;
					}
					else if (num9 < 60)
					{
						num = 236;
					}
				}
				else
				{
					int num10 = tileCache.frameX / 18;
					if (num10 < 6)
					{
						num = 1;
					}
					else if (num10 < 12)
					{
						num = 0;
					}
					else if (num10 < 27)
					{
						num = 26;
					}
					else if (num10 < 32)
					{
						num = 1;
					}
					else if (num10 < 35)
					{
						num = 0;
					}
					else if (num10 < 46)
					{
						num = 80;
					}
					else if (num10 < 52)
					{
						num = 30;
					}
					else if (num10 < 58)
					{
						num = 32;
					}
					else if (num10 < 64)
					{
						num = 240;
					}
					else if (num10 < 70)
					{
						num = 236;
					}
				}
			}
			if (tileCache.type == 237)
			{
				num = 148;
			}
			if (tileCache.type == 157)
			{
				num = 77;
			}
			if (tileCache.type == 158 || tileCache.type == 232 || tileCache.type == 383 || tileCache.type == 575)
			{
				num = 78;
			}
			if (tileCache.type == 159)
			{
				num = 78;
			}
			if (tileCache.type == 15)
			{
				num = -1;
			}
			if (tileCache.type == 191)
			{
				num = 7;
			}
			if (tileCache.type == 5)
			{
				num = 7;
				if (i > 5 && i < Main.maxTilesX - 5)
				{
					int num11 = i;
					int k = j;
					if (tileCache.frameX == 66 && tileCache.frameY <= 45)
					{
						num11++;
					}
					if (tileCache.frameX == 88 && tileCache.frameY >= 66 && tileCache.frameY <= 110)
					{
						num11--;
					}
					if (tileCache.frameX == 22 && tileCache.frameY >= 132 && tileCache.frameY <= 176)
					{
						num11--;
					}
					if (tileCache.frameX == 44 && tileCache.frameY >= 132 && tileCache.frameY <= 176)
					{
						num11++;
					}
					if (tileCache.frameX == 44 && tileCache.frameY >= 132 && tileCache.frameY <= 176)
					{
						num11++;
					}
					if (tileCache.frameX == 44 && tileCache.frameY >= 198)
					{
						num11++;
					}
					if (tileCache.frameX == 66 && tileCache.frameY >= 198)
					{
						num11--;
					}
					for (; Main.tile[num11, k] != null && (!Main.tile[num11, k].active() || !Main.tileSolid[Main.tile[num11, k].type]); k++)
					{
					}
					if (Main.tile[num11, k] != null)
					{
						if (Main.tile[num11, k].active() && Main.tile[num11, k].type == 23)
						{
							num = 77;
						}
						if (Main.tile[num11, k].active() && Main.tile[num11, k].type == 60)
						{
							num = 78;
						}
						if (Main.tile[num11, k].active() && Main.tile[num11, k].type == 70)
						{
							num = 26;
						}
						if (Main.tile[num11, k].active() && Main.tile[num11, k].type == 109)
						{
							num = 79;
						}
						if (Main.tile[num11, k].active() && Main.tile[num11, k].type == 199)
						{
							num = 121;
						}
						if (Main.tile[num11, k].active() && Main.tile[num11, k].type == 147)
						{
							num = 122;
						}
					}
				}
			}
			if (tileCache.type == 323)
			{
				num = 215;
				if (i > 5 && i < Main.maxTilesX - 5)
				{
					int l;
					for (l = j; Main.tile[i, l] != null && (!Main.tile[i, l].active() || !Main.tileSolid[Main.tile[i, l].type]); l++)
					{
					}
					if (Main.tile[i, l] != null)
					{
						if (Main.tile[i, l].active() && Main.tile[i, l].type == 234)
						{
							num = 121;
						}
						if (Main.tile[i, l].active() && Main.tile[i, l].type == 116)
						{
							num = 79;
						}
						if (Main.tile[i, l].active() && Main.tile[i, l].type == 112)
						{
							num = 77;
						}
					}
				}
			}
			if (tileCache.type == 137)
			{
				num = 1;
				if (tileCache.frameY / 18 > 0)
				{
					num = 148;
				}
			}
			if (tileCache.type == 443)
			{
				num = 1;
			}
			if (tileCache.type == 444)
			{
				num = -1;
			}
			if (tileCache.type == 212)
			{
				num = -1;
			}
			if (tileCache.type == 213)
			{
				num = 129;
			}
			if (tileCache.type == 214)
			{
				num = 1;
			}
			if (tileCache.type == 215)
			{
				num = -6;
			}
			if (tileCache.type == 325)
			{
				num = 81;
			}
			if (tileCache.type == 251)
			{
				num = 189;
			}
			if (tileCache.type == 252)
			{
				num = 190;
			}
			if (tileCache.type == 253)
			{
				num = 191;
			}
			if (tileCache.type == 254)
			{
				if (tileCache.frameX < 72)
				{
					num = 3;
				}
				else if (tileCache.frameX < 108)
				{
					num = 3;
					if (genRand.Next(3) == 0)
					{
						num = 189;
					}
				}
				else if (tileCache.frameX < 144)
				{
					num = 3;
					if (genRand.Next(2) == 0)
					{
						num = 189;
					}
				}
				else
				{
					num = 3;
					if (genRand.Next(4) != 0)
					{
						num = 189;
					}
				}
			}
			if (tileCache.type == 467)
			{
				num = -1;
			}
			if (tileCache.type == 21)
			{
				num = ((tileCache.frameX >= 1008) ? (-1) : ((tileCache.frameX >= 612) ? 11 : ((tileCache.frameX >= 576) ? 148 : ((tileCache.frameX >= 540) ? 26 : ((tileCache.frameX >= 504) ? 126 : ((tileCache.frameX >= 468) ? 116 : ((tileCache.frameX >= 432) ? 7 : ((tileCache.frameX >= 396) ? 11 : ((tileCache.frameX >= 360) ? 10 : ((tileCache.frameX >= 324) ? 79 : ((tileCache.frameX >= 288) ? 78 : ((tileCache.frameX >= 252) ? 77 : ((tileCache.frameX >= 216) ? 1 : ((tileCache.frameX >= 180) ? 7 : ((tileCache.frameX >= 108) ? 37 : ((tileCache.frameX < 36) ? 7 : 10))))))))))))))));
			}
			if (tileCache.type == 382)
			{
				num = 3;
			}
			if (tileCache.type == 2 || tileCache.type == 477)
			{
				num = ((genRand.Next(2) != 0) ? 2 : 0);
			}
			if (tileCache.type == 127)
			{
				num = 67;
			}
			if (tileCache.type == 91)
			{
				num = -1;
			}
			if (tileCache.type == 198)
			{
				num = 109;
			}
			if (tileCache.type == 26)
			{
				num = ((tileCache.frameX < 54) ? 8 : 5);
			}
			if (tileCache.type == 34)
			{
				num = -1;
			}
			if (tileCache.type == 6)
			{
				num = 8;
			}
			if (tileCache.type == 7 || tileCache.type == 47 || tileCache.type == 284)
			{
				num = 9;
			}
			if (tileCache.type == 8 || tileCache.type == 45 || tileCache.type == 102)
			{
				num = 10;
			}
			if (tileCache.type == 9 || tileCache.type == 42 || tileCache.type == 46 || tileCache.type == 126 || tileCache.type == 136)
			{
				num = 11;
			}
			if (tileCache.type == 166 || tileCache.type == 175)
			{
				num = 81;
			}
			if (tileCache.type == 167)
			{
				num = 82;
			}
			if (tileCache.type == 168 || tileCache.type == 176)
			{
				num = 83;
			}
			if (tileCache.type == 169 || tileCache.type == 177)
			{
				num = 84;
			}
			if (tileCache.type == 199)
			{
				num = 117;
			}
			if (tileCache.type == 205)
			{
				num = 125;
			}
			if (tileCache.type == 201)
			{
				num = 125;
			}
			if (tileCache.type == 211)
			{
				num = 128;
			}
			if (tileCache.type == 227)
			{
				switch (tileCache.frameX / 34)
				{
				case 0:
				case 1:
					num = 26;
					break;
				case 3:
					num = 3;
					break;
				case 2:
				case 4:
				case 5:
				case 6:
					num = 40;
					break;
				case 7:
					num = 117;
					break;
				case 8:
					num = 17;
					break;
				case 9:
					num = 6;
					break;
				case 10:
					num = 3;
					break;
				case 11:
					num = 26;
					break;
				}
			}
			if (tileCache.type == 204 || tileCache.type == 478)
			{
				num = 117;
				if (genRand.Next(2) == 0)
				{
					num = 1;
				}
			}
			if (tileCache.type == 203)
			{
				num = 117;
			}
			if (tileCache.type == 243)
			{
				num = ((genRand.Next(2) != 0) ? 13 : 7);
			}
			if (tileCache.type == 244)
			{
				num = ((genRand.Next(2) == 0) ? 1 : 13);
			}
			if (tileCache.type == 597)
			{
				num = -1;
			}
			else if ((tileCache.type >= 358 && tileCache.type <= 364) || (tileCache.type >= 275 && tileCache.type <= 282) || tileCache.type == 285 || tileCache.type == 286 || (tileCache.type >= 288 && tileCache.type <= 297) || (tileCache.type >= 316 && tileCache.type <= 318) || tileCache.type == 298 || tileCache.type == 299 || tileCache.type == 309 || tileCache.type == 310 || tileCache.type == 339 || tileCache.type == 538 || tileCache.type == 413 || tileCache.type == 414 || tileCache.type == 505 || tileCache.type == 521 || tileCache.type == 522 || tileCache.type == 523 || tileCache.type == 524 || tileCache.type == 525 || tileCache.type == 526 || tileCache.type == 527 || tileCache.type == 532 || tileCache.type == 543 || tileCache.type == 544 || tileCache.type == 550 || tileCache.type == 551 || tileCache.type == 533 || tileCache.type == 553 || tileCache.type == 554 || tileCache.type == 555 || tileCache.type == 556 || tileCache.type == 558 || tileCache.type == 559 || tileCache.type == 542 || tileCache.type == 391 || tileCache.type == 394 || tileCache.type == 392 || tileCache.type == 393 || tileCache.type == 568 || tileCache.type == 569 || tileCache.type == 570 || tileCache.type == 582 || tileCache.type == 580 || tileCache.type == 598 || tileCache.type == 599 || tileCache.type == 600 || tileCache.type == 601 || tileCache.type == 602 || tileCache.type == 603 || tileCache.type == 604 || tileCache.type == 605 || tileCache.type == 606 || tileCache.type == 607 || tileCache.type == 608 || tileCache.type == 609 || tileCache.type == 610 || tileCache.type == 611 || tileCache.type == 612 || tileCache.type == 619 || tileCache.type == 620)
			{
				num = 13;
				if (genRand.Next(3) != 0)
				{
					num = -1;
				}
			}
			if (tileCache.type == 13)
			{
				num = ((tileCache.frameX < 90) ? 13 : (-1));
			}
			if (tileCache.type == 189)
			{
				num = 16;
			}
			if (tileCache.type == 460)
			{
				num = 16;
			}
			if (tileCache.type == 530)
			{
				num = Main.tile[i, j + 2 - tileCache.frameY / 18].type switch
				{
					116 => 47, 
					234 => 125, 
					112 => 17, 
					_ => (tileCache.frameX >= 270) ? 291 : 40, 
				};
			}
			if (tileCache.type == 518)
			{
				if (tileCache.frameY == 0)
				{
					num = 3;
				}
				else if (tileCache.frameY == 18)
				{
					num = 47;
				}
				else if (tileCache.frameY == 36)
				{
					num = 40;
				}
			}
			else if (tileCache.type == 519)
			{
				if (tileCache.frameY == 0)
				{
					num = 3;
				}
				else if (tileCache.frameY == 18)
				{
					num = 40;
				}
				else if (tileCache.frameY == 36)
				{
					num = 47;
				}
				else if (tileCache.frameY == 54)
				{
					num = 125;
				}
				else if (tileCache.frameY == 72)
				{
					num = 17;
				}
				else if (tileCache.frameY == 90)
				{
					num = 26;
				}
			}
			else if (tileCache.type == 528)
			{
				num = 26;
			}
			if (tileCache.type == 12)
			{
				num = 12;
			}
			if (tileCache.type == 3 || tileCache.type == 73)
			{
				num = 3;
			}
			if (tileCache.type == 54)
			{
				num = 13;
			}
			if (tileCache.type == 22 || tileCache.type == 140)
			{
				num = 14;
			}
			if (tileCache.type == 78)
			{
				num = 22;
			}
			if (tileCache.type == 28)
			{
				num = 22;
				if (tileCache.frameY >= 72 && tileCache.frameY <= 90)
				{
					num = 1;
				}
				if (tileCache.frameY >= 144 && tileCache.frameY <= 234)
				{
					num = 48;
				}
				if (tileCache.frameY >= 252 && tileCache.frameY <= 358)
				{
					num = 85;
				}
				if (tileCache.frameY >= 360 && tileCache.frameY <= 466)
				{
					num = 26;
				}
				if (tileCache.frameY >= 468 && tileCache.frameY <= 574)
				{
					num = 36;
				}
				if (tileCache.frameY >= 576 && tileCache.frameY <= 790)
				{
					num = 18;
				}
				if (tileCache.frameY >= 792 && tileCache.frameY <= 898)
				{
					num = 5;
				}
				if (tileCache.frameY >= 900 && tileCache.frameY <= 1006)
				{
					num = 0;
				}
				if (tileCache.frameY >= 1008 && tileCache.frameY <= 1114)
				{
					num = 148;
				}
				if (tileCache.frameY >= 1116 && tileCache.frameY <= 1222)
				{
					num = 241;
				}
				if (tileCache.frameY >= 1224 && tileCache.frameY <= 1330)
				{
					num = 287;
				}
			}
			if (tileCache.type == 163)
			{
				num = 118;
			}
			if (tileCache.type == 164)
			{
				num = 119;
			}
			if (tileCache.type == 200)
			{
				num = 120;
			}
			if (tileCache.type == 221 || tileCache.type == 248)
			{
				num = 144;
			}
			if (tileCache.type == 222 || tileCache.type == 249)
			{
				num = 145;
			}
			if (tileCache.type == 223 || tileCache.type == 250)
			{
				num = 146;
			}
			if (tileCache.type == 224)
			{
				num = 149;
			}
			if (tileCache.type == 225)
			{
				num = 147;
			}
			if (tileCache.type == 229)
			{
				num = 153;
			}
			if (tileCache.type == 231)
			{
				num = 153;
				if (genRand.Next(3) == 0)
				{
					num = 26;
				}
			}
			if (tileCache.type == 226)
			{
				num = 148;
			}
			if (tileCache.type == 103)
			{
				num = -1;
			}
			if (tileCache.type == 29)
			{
				num = 23;
			}
			if (tileCache.type == 40)
			{
				num = 28;
			}
			if (tileCache.type == 49)
			{
				num = 29;
			}
			if (tileCache.type == 50)
			{
				num = 22;
			}
			if (tileCache.type == 51)
			{
				num = 30;
			}
			if (tileCache.type == 52 || tileCache.type == 353)
			{
				num = 3;
			}
			if (tileCache.type == 53 || tileCache.type == 81 || tileCache.type == 151 || tileCache.type == 202 || tileCache.type == 274 || tileCache.type == 495)
			{
				num = 32;
			}
			if (tileCache.type == 56 || tileCache.type == 152)
			{
				num = 37;
			}
			if (tileCache.type == 75)
			{
				num = 109;
			}
			if (tileCache.type == 57 || tileCache.type == 119 || tileCache.type == 141 || tileCache.type == 234)
			{
				num = 36;
			}
			if (tileCache.type == 59 || tileCache.type == 120)
			{
				num = 38;
			}
			if (tileCache.type == 61 || tileCache.type == 62 || tileCache.type == 74 || tileCache.type == 80 || tileCache.type == 188 || tileCache.type == 233 || tileCache.type == 236 || tileCache.type == 384)
			{
				num = 40;
			}
			if (tileCache.type == 485)
			{
				num = 32;
			}
			if (tileCache.type == 238)
			{
				num = ((genRand.Next(3) != 0) ? 166 : 167);
			}
			if (tileCache.type == 69)
			{
				num = 7;
			}
			if (tileCache.type == 71 || tileCache.type == 72 || tileCache.type == 190 || tileCache.type == 578)
			{
				num = 26;
			}
			if (tileCache.type == 70)
			{
				num = 17;
			}
			if (tileCache.type == 112)
			{
				num = 14;
			}
			if (tileCache.type == 123)
			{
				num = 53;
			}
			if (tileCache.type == 161)
			{
				num = 80;
			}
			if (tileCache.type == 206)
			{
				num = 80;
			}
			if (tileCache.type == 162)
			{
				num = 80;
			}
			if (tileCache.type == 165)
			{
				num = (tileCache.frameX / 54) switch
				{
					0 => 80, 
					1 => 1, 
					2 => 30, 
					3 => 147, 
					4 => 1, 
					5 => 14, 
					6 => 117, 
					7 => 250, 
					8 => 240, 
					9 => 236, 
					_ => 1, 
				};
			}
			if (tileCache.type == 193)
			{
				num = 4;
			}
			if (tileCache.type == 194)
			{
				num = 26;
			}
			if (tileCache.type == 195)
			{
				num = 5;
			}
			if (tileCache.type == 196)
			{
				num = 108;
			}
			if (tileCache.type == 460)
			{
				num = 108;
			}
			if (tileCache.type == 197)
			{
				num = 4;
			}
			if (tileCache.type == 153)
			{
				num = 26;
			}
			if (tileCache.type == 154)
			{
				num = 32;
			}
			if (tileCache.type == 155)
			{
				num = 2;
			}
			if (tileCache.type == 156)
			{
				num = 1;
			}
			if (tileCache.type == 116 || tileCache.type == 118 || tileCache.type == 147 || tileCache.type == 148)
			{
				num = 51;
			}
			if (tileCache.type == 109 || tileCache.type == 492)
			{
				num = ((genRand.Next(2) != 0) ? 47 : 0);
			}
			if (tileCache.type == 110 || tileCache.type == 113 || tileCache.type == 115)
			{
				num = 47;
			}
			if (tileCache.type == 107 || tileCache.type == 121)
			{
				num = 48;
			}
			if (tileCache.type == 108 || tileCache.type == 122 || tileCache.type == 146)
			{
				num = 49;
			}
			if (tileCache.type == 111 || tileCache.type == 145 || tileCache.type == 150)
			{
				num = 50;
			}
			if (tileCache.type == 133)
			{
				num = 50;
				if (tileCache.frameX >= 54)
				{
					num = 146;
				}
			}
			if (tileCache.type == 134)
			{
				num = 49;
				if (tileCache.frameX >= 36)
				{
					num = 145;
				}
			}
			if (tileCache.type == 149)
			{
				num = 49;
			}
			if (Main.tileAlch[tileCache.type])
			{
				int num12 = tileCache.frameX / 18;
				if (num12 == 0)
				{
					num = 3;
				}
				if (num12 == 1)
				{
					num = 3;
				}
				if (num12 == 2)
				{
					num = 7;
				}
				if (num12 == 3)
				{
					num = 17;
				}
				if (num12 == 4)
				{
					num = 289;
				}
				if (num12 == 5)
				{
					num = 6;
				}
				if (num12 == 6)
				{
					num = 224;
				}
			}
			if (tileCache.type == 58 || tileCache.type == 76 || tileCache.type == 77)
			{
				num = ((genRand.Next(2) != 0) ? 25 : 6);
			}
			if (tileCache.type == 37)
			{
				num = ((genRand.Next(2) != 0) ? 23 : 6);
			}
			if (tileCache.type == 32)
			{
				num = ((genRand.Next(2) != 0) ? 24 : 14);
			}
			if (tileCache.type == 352)
			{
				num = ((genRand.Next(3) != 0) ? 125 : 5);
			}
			if (tileCache.type == 23 || tileCache.type == 24)
			{
				num = ((genRand.Next(2) != 0) ? 17 : 14);
			}
			if (tileCache.type == 25 || tileCache.type == 31)
			{
				num = ((tileCache.type == 31 && tileCache.frameX >= 36) ? 5 : ((genRand.Next(2) != 0) ? 1 : 14));
			}
			if (tileCache.type == 20)
			{
				num = (tileCache.frameX / 54) switch
				{
					1 => 122, 
					2 => 78, 
					3 => 77, 
					4 => 121, 
					5 => 79, 
					_ => 7, 
				};
			}
			if (tileCache.type == 27)
			{
				num = ((genRand.Next(2) != 0) ? 19 : 3);
			}
			if (tileCache.type == 129)
			{
				if (tileCache.frameX >= 324)
				{
					num = 69;
				}
				num = ((tileCache.frameX != 0 && tileCache.frameX != 54 && tileCache.frameX != 108) ? ((tileCache.frameX != 18 && tileCache.frameX != 72 && tileCache.frameX != 126) ? 70 : 69) : 68);
			}
			if (tileCache.type == 385)
			{
				num = genRand.Next(68, 71);
			}
			if (tileCache.type == 4)
			{
				int num13 = tileCache.frameY / 22;
				num = TorchID.Dust[num13];
			}
			if (tileCache.type == 35)
			{
				num = 189;
				if (tileCache.frameX < 36 && genRand.Next(2) == 0)
				{
					num = 6;
				}
			}
			if ((tileCache.type == 34 || tileCache.type == 42) && genRand.Next(2) == 0)
			{
				num = 6;
			}
			if (tileCache.type == 270)
			{
				num = -1;
			}
			if (tileCache.type == 271)
			{
				num = -1;
			}
			if (tileCache.type == 581)
			{
				num = -1;
			}
			if (tileCache.type == 79 || tileCache.type == 90 || tileCache.type == 101)
			{
				num = -1;
			}
			if (tileCache.type == 33 || tileCache.type == 34 || tileCache.type == 42 || tileCache.type == 93 || tileCache.type == 100)
			{
				num = -1;
			}
			if (tileCache.type == 321 || tileCache.type == 574)
			{
				num = 214;
			}
			if (tileCache.type == 322)
			{
				num = 215;
			}
			bool flag = tileCache.type == 178 || tileCache.type == 440;
			ushort type = tileCache.type;
			if (type == 178 || (uint)(type - 426) <= 1u || (uint)(type - 430) <= 10u)
			{
				flag = true;
			}
			if (num >= 0)
			{
				if (tileCache.type == 518)
				{
					int num14 = (int)tileCache.liquid / 16;
					num14 -= 3;
					if (SolidTile(i, j - 1) && num14 > 8)
					{
						num14 = 8;
					}
					return Dust.NewDust(new Vector2(i * 16, j * 16 - num14), 16, 16, num);
				}
				if (tileCache.type == 352 && num == 5)
				{
					int num15 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 5, 0f, 0f, 100);
					Main.dust[num15].scale = 1.5f;
					Main.dust[num15].noGravity = true;
					Main.dust[num15].velocity *= 1.65f;
					Main.dust[num15].fadeIn = 1.6f;
					return num15;
				}
				if (tileCache.type == 160)
				{
					int num16 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 66, 0f, 0f, 100, new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB), 0.75f);
					Main.dust[num16].noGravity = true;
					return num16;
				}
				if (tileCache.type == 323)
				{
					int frameY = tileCache.frameY;
					return Dust.NewDust(new Vector2(i * 16 + frameY, j * 16), 16, 16, num);
				}
				if (tileCache.type == 314)
				{
					int num17 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 213, genRand.Next(-2, 3), genRand.Next(-2, 3));
					Main.dust[num17].noGravity = true;
					Main.dust[num17].fadeIn = Main.dust[num17].scale + 1f + 0.01f * (float)genRand.Next(0, 51);
					Main.dust[num17].noGravity = true;
					return num17;
				}
				if (flag)
				{
					int num18 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 75, default(Color), 0.75f);
					Main.dust[num18].noLight = true;
					return num18;
				}
				if (tileCache.type == 193 || (tileCache.type == 18 && num == 4) || (tileCache.type == 19 && num == 4))
				{
					return Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 75, new Color(0, 80, 255, 100), 0.75f);
				}
				if (tileCache.type == 197)
				{
					return Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 75, new Color(97, 200, 255, 100), 0.75f);
				}
				if (tileCache.type == 185 && num >= 86 && num <= 91)
				{
					int num19 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 75, default(Color), 0.75f);
					Main.dust[num19].noLight = true;
					return num19;
				}
				if (tileCache.type == 4 && num == 66)
				{
					int num20 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 0, new Color((float)Main.DiscoR / 255f, (float)Main.DiscoG / 255f, (float)Main.DiscoB / 255f));
					Main.dust[num20].noGravity = true;
					return num20;
				}
				if (num == 139)
				{
					int type2 = num + Main.rand.Next(4);
					return Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, type2);
				}
				return Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num);
			}
			return 6000;
		}

		public static bool IsOpenDoorAnchorFrame(int x, int y)
		{
			Tile tile = Main.tile[x, y];
			if (!tile.active() || tile.type != 11)
			{
				return false;
			}
			int num = tile.frameX % 72;
			if (num >= 18)
			{
				return num >= 54;
			}
			return true;
		}

		public static bool IsLockedDoor(int x, int y)
		{
			return IsLockedDoor(Main.tile[x, y]);
		}

		public static bool IsLockedDoor(Tile t)
		{
			if (t.type == 10 && t.frameY >= 594 && t.frameY <= 646)
			{
				return t.frameX < 54;
			}
			return false;
		}

		public static void DropDoorItem(int x, int y, int doorStyle)
		{
			int num = 0;
			switch (doorStyle)
			{
			case 0:
				num = 25;
				break;
			case 9:
				num = 837;
				break;
			case 10:
				num = 912;
				break;
			case 12:
				num = 1137;
				break;
			case 13:
				num = 1138;
				break;
			case 14:
				num = 1139;
				break;
			case 15:
				num = 1140;
				break;
			case 16:
				num = 1411;
				break;
			case 17:
				num = 1412;
				break;
			case 18:
				num = 1413;
				break;
			case 19:
				num = 1458;
				break;
			case 20:
			case 21:
			case 22:
			case 23:
				num = 1709 + doorStyle - 20;
				break;
			default:
				switch (doorStyle)
				{
				case 24:
					num = 1793;
					break;
				case 25:
					num = 1815;
					break;
				case 26:
					num = 1924;
					break;
				case 27:
					num = 2044;
					break;
				case 28:
					num = 2265;
					break;
				case 29:
					num = 2528;
					break;
				case 30:
					num = 2561;
					break;
				case 31:
					num = 2576;
					break;
				case 32:
					num = 2815;
					break;
				case 33:
					num = 3129;
					break;
				case 34:
					num = 3131;
					break;
				case 35:
					num = 3130;
					break;
				case 36:
					num = 3888;
					break;
				case 37:
					num = 3941;
					break;
				case 38:
					num = 3967;
					break;
				case 39:
					num = 4155;
					break;
				case 40:
					num = 4176;
					break;
				case 41:
					num = 4197;
					break;
				case 42:
					num = 4218;
					break;
				case 43:
					num = 4307;
					break;
				case 44:
					num = 4415;
					break;
				case 45:
					num = 4576;
					break;
				case 4:
				case 5:
				case 6:
				case 7:
				case 8:
					num = 812 + doorStyle;
					break;
				default:
					if (doorStyle != 11)
					{
						num = 649 + doorStyle;
					}
					break;
				}
				break;
			}
			if (num != 0)
			{
				Item.NewItem(x * 16, y * 16, 16, 16, num);
			}
		}

		public static bool PlayerLOS(int x, int y)
		{
			Rectangle rectangle = new Rectangle(x * 16, y * 16, 16, 16);
			for (int i = 0; i < 255; i++)
			{
				if (Main.player[i].active)
				{
					Rectangle value = new Rectangle((int)((double)Main.player[i].position.X + (double)Main.player[i].width * 0.5 - (double)NPC.sWidth * 0.6), (int)((double)Main.player[i].position.Y + (double)Main.player[i].height * 0.5 - (double)NPC.sHeight * 0.6), (int)((double)NPC.sWidth * 1.2), (int)((double)NPC.sHeight * 1.2));
					if (rectangle.Intersects(value))
					{
						return true;
					}
				}
			}
			return false;
		}

		public static bool Chlorophyte(int i, int j)
		{
			int num = 40;
			int num2 = 130;
			int num3 = 35;
			int num4 = 85;
			if ((double)j < Main.rockLayer)
			{
				num /= 2;
				num2 /= 2;
				num3 = (int)((double)num3 * 1.5);
				num4 = (int)((double)num4 * 1.5);
			}
			int num5 = 0;
			for (int k = i - num3; k < i + num3; k++)
			{
				for (int l = j - num3; l < j + num3; l++)
				{
					if (InWorld(k, l) && Main.tile[k, l].active() && Main.tile[k, l].type == 211)
					{
						num5++;
					}
				}
			}
			if (num5 > num)
			{
				return false;
			}
			num5 = 0;
			for (int m = i - num4; m < i + num4; m++)
			{
				for (int n = j - num4; n < j + num4; n++)
				{
					if (InWorld(m, n) && Main.tile[m, n].active() && Main.tile[m, n].type == 211)
					{
						num5++;
					}
				}
			}
			if (num5 > num2)
			{
				return false;
			}
			return true;
		}

		private static bool nearbyChlorophyte(int i, int j)
		{
			float num = 0f;
			int num2 = 5;
			if (i <= num2 + 5 || i >= Main.maxTilesX - num2 - 5)
			{
				return false;
			}
			if (j <= num2 + 5 || j >= Main.maxTilesY - num2 - 5)
			{
				return false;
			}
			for (int k = i - num2; k <= i + num2; k++)
			{
				for (int l = j - num2; l <= j + num2; l++)
				{
					if (Main.tile[k, l].active() && (Main.tile[k, l].type == 211 || Main.tile[k, l].type == 346))
					{
						num += 1f;
						if (num >= 4f)
						{
							return true;
						}
					}
				}
			}
			if (num > 0f && (float)genRand.Next(5) < num)
			{
				return true;
			}
			return false;
		}

		private static int CountNearBlocksTypes(int i, int j, int radius, int cap = 0, params int[] tiletypes)
		{
			if (tiletypes.Length == 0)
			{
				return 0;
			}
			int value = i - radius;
			int value2 = i + radius;
			int value3 = j - radius;
			int value4 = j + radius;
			int num = Utils.Clamp(value, 0, Main.maxTilesX - 1);
			value2 = Utils.Clamp(value2, 0, Main.maxTilesX - 1);
			value3 = Utils.Clamp(value3, 0, Main.maxTilesY - 1);
			value4 = Utils.Clamp(value4, 0, Main.maxTilesY - 1);
			int num2 = 0;
			for (int k = num; k <= value2; k++)
			{
				for (int l = value3; l <= value4; l++)
				{
					if (!Main.tile[k, l].active())
					{
						continue;
					}
					for (int m = 0; m < tiletypes.Length; m++)
					{
						if (tiletypes[m] == Main.tile[k, l].type)
						{
							num2++;
							if (cap <= 0 || num2 < cap)
							{
								break;
							}
							return num2;
						}
					}
				}
			}
			return num2;
		}

		public static void hardUpdateWorld(int i, int j)
		{
			if (!Main.hardMode || Main.tile[i, j].inActive())
			{
				return;
			}
			int type = Main.tile[i, j].type;
			if ((type == 117 || type == 164) && (double)j > Main.rockLayer && genRand.Next(110) == 0)
			{
				int num = genRand.Next(4);
				int num2 = 0;
				int num3 = 0;
				switch (num)
				{
				case 0:
					num2 = -1;
					break;
				case 1:
					num2 = 1;
					break;
				default:
					num3 = ((num != 0) ? 1 : (-1));
					break;
				}
				if (!Main.tile[i + num2, j + num3].active())
				{
					int num4 = 0;
					int num5 = 6;
					for (int k = i - num5; k <= i + num5; k++)
					{
						for (int l = j - num5; l <= j + num5; l++)
						{
							if (Main.tile[k, l].active() && Main.tile[k, l].type == 129)
							{
								num4++;
							}
						}
					}
					if (num4 < 2)
					{
						PlaceTile(i + num2, j + num3, 129, mute: true);
						NetMessage.SendTileSquare(-1, i + num2, j + num3, 1);
					}
				}
			}
			if ((double)j > (Main.worldSurface + Main.rockLayer) / 2.0)
			{
				if (type == 60 && genRand.Next(300) == 0)
				{
					int num6 = i + genRand.Next(-10, 11);
					int num7 = j + genRand.Next(-10, 11);
					if (InWorld(num6, num7, 2) && Main.tile[num6, num7].active() && Main.tile[num6, num7].type == 59 && (!Main.tile[num6, num7 - 1].active() || (Main.tile[num6, num7 - 1].type != 5 && Main.tile[num6, num7 - 1].type != 236 && Main.tile[num6, num7 - 1].type != 238)) && Chlorophyte(num6, num7))
					{
						Main.tile[num6, num7].type = 211;
						SquareTileFrame(num6, num7);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num6, num7, 1);
						}
					}
				}
				if (type == 211 && genRand.Next(3) != 0)
				{
					int num8 = i;
					int num9 = j;
					int num10 = genRand.Next(4);
					if (num10 == 0)
					{
						num8++;
					}
					if (num10 == 1)
					{
						num8--;
					}
					if (num10 == 2)
					{
						num9++;
					}
					if (num10 == 3)
					{
						num9--;
					}
					if (InWorld(num8, num9, 2) && Main.tile[num8, num9].active() && (Main.tile[num8, num9].type == 59 || Main.tile[num8, num9].type == 60) && Chlorophyte(num8, num9))
					{
						Main.tile[num8, num9].type = 211;
						SquareTileFrame(num8, num9);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num8, num9, 1);
						}
					}
					bool flag = true;
					while (flag)
					{
						flag = false;
						num8 = i + Main.rand.Next(-6, 7);
						num9 = j + Main.rand.Next(-6, 7);
						if (!InWorld(num8, num9, 2) || !Main.tile[num8, num9].active())
						{
							continue;
						}
						if (Main.tile[num8, num9].type == 23 || Main.tile[num8, num9].type == 199 || Main.tile[num8, num9].type == 2 || Main.tile[num8, num9].type == 477 || Main.tile[num8, num9].type == 492 || Main.tile[num8, num9].type == 109)
						{
							Main.tile[num8, num9].type = 60;
							SquareTileFrame(num8, num9);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, num8, num9, 1);
							}
							flag = true;
						}
						else if (Main.tile[num8, num9].type == 0)
						{
							Main.tile[num8, num9].type = 59;
							SquareTileFrame(num8, num9);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, num8, num9, 1);
							}
							flag = true;
						}
					}
				}
			}
			if ((NPC.downedPlantBoss && genRand.Next(2) != 0) || !AllowedToSpreadInfections)
			{
				return;
			}
			if (type == 23 || type == 25 || type == 32 || type == 112 || type == 163 || type == 400 || type == 398)
			{
				bool flag2 = true;
				while (flag2)
				{
					flag2 = false;
					int num11 = i + genRand.Next(-3, 4);
					int num12 = j + genRand.Next(-3, 4);
					if (nearbyChlorophyte(num11, num12) || CountNearBlocksTypes(num11, num12, 2, 1, 27) > 0)
					{
						continue;
					}
					if (Main.tile[num11, num12].type == 2)
					{
						if (genRand.Next(2) == 0)
						{
							flag2 = true;
						}
						Main.tile[num11, num12].type = 23;
						SquareTileFrame(num11, num12);
						NetMessage.SendTileSquare(-1, num11, num12, 1);
					}
					else if (Main.tile[num11, num12].type == 1 || Main.tileMoss[Main.tile[num11, num12].type])
					{
						if (genRand.Next(2) == 0)
						{
							flag2 = true;
						}
						Main.tile[num11, num12].type = 25;
						SquareTileFrame(num11, num12);
						NetMessage.SendTileSquare(-1, num11, num12, 1);
					}
					else if (Main.tile[num11, num12].type == 53)
					{
						if (genRand.Next(2) == 0)
						{
							flag2 = true;
						}
						Main.tile[num11, num12].type = 112;
						SquareTileFrame(num11, num12);
						NetMessage.SendTileSquare(-1, num11, num12, 1);
					}
					else if (Main.tile[num11, num12].type == 396)
					{
						if (genRand.Next(2) == 0)
						{
							flag2 = true;
						}
						Main.tile[num11, num12].type = 400;
						SquareTileFrame(num11, num12);
						NetMessage.SendTileSquare(-1, num11, num12, 1);
					}
					else if (Main.tile[num11, num12].type == 397)
					{
						if (genRand.Next(2) == 0)
						{
							flag2 = true;
						}
						Main.tile[num11, num12].type = 398;
						SquareTileFrame(num11, num12);
						NetMessage.SendTileSquare(-1, num11, num12, 1);
					}
					else if (Main.tile[num11, num12].type == 59)
					{
						if (genRand.Next(2) == 0)
						{
							flag2 = true;
						}
						Main.tile[num11, num12].type = 0;
						SquareTileFrame(num11, num12);
						NetMessage.SendTileSquare(-1, num11, num12, 1);
					}
					else if (Main.tile[num11, num12].type == 60)
					{
						if (genRand.Next(2) == 0)
						{
							flag2 = true;
						}
						Main.tile[num11, num12].type = 23;
						SquareTileFrame(num11, num12);
						NetMessage.SendTileSquare(-1, num11, num12, 1);
					}
					else if (Main.tile[num11, num12].type == 69)
					{
						if (genRand.Next(2) == 0)
						{
							flag2 = true;
						}
						Main.tile[num11, num12].type = 32;
						SquareTileFrame(num11, num12);
						NetMessage.SendTileSquare(-1, num11, num12, 1);
					}
					else if (Main.tile[num11, num12].type == 161)
					{
						if (genRand.Next(2) == 0)
						{
							flag2 = true;
						}
						Main.tile[num11, num12].type = 163;
						SquareTileFrame(num11, num12);
						NetMessage.SendTileSquare(-1, num11, num12, 1);
					}
				}
			}
			if (type == 199 || type == 200 || type == 201 || type == 203 || type == 205 || type == 234 || type == 352 || type == 401 || type == 399)
			{
				bool flag3 = true;
				while (flag3)
				{
					flag3 = false;
					int num13 = i + genRand.Next(-3, 4);
					int num14 = j + genRand.Next(-3, 4);
					if (nearbyChlorophyte(num13, num14) || CountNearBlocksTypes(num13, num14, 2, 1, 27) > 0)
					{
						continue;
					}
					if (Main.tile[num13, num14].type == 2)
					{
						if (genRand.Next(2) == 0)
						{
							flag3 = true;
						}
						Main.tile[num13, num14].type = 199;
						SquareTileFrame(num13, num14);
						NetMessage.SendTileSquare(-1, num13, num14, 1);
					}
					else if (Main.tile[num13, num14].type == 1 || Main.tileMoss[Main.tile[num13, num14].type])
					{
						if (genRand.Next(2) == 0)
						{
							flag3 = true;
						}
						Main.tile[num13, num14].type = 203;
						SquareTileFrame(num13, num14);
						NetMessage.SendTileSquare(-1, num13, num14, 1);
					}
					else if (Main.tile[num13, num14].type == 53)
					{
						if (genRand.Next(2) == 0)
						{
							flag3 = true;
						}
						Main.tile[num13, num14].type = 234;
						SquareTileFrame(num13, num14);
						NetMessage.SendTileSquare(-1, num13, num14, 1);
					}
					else if (Main.tile[num13, num14].type == 396)
					{
						if (genRand.Next(2) == 0)
						{
							flag3 = true;
						}
						Main.tile[num13, num14].type = 401;
						SquareTileFrame(num13, num14);
						NetMessage.SendTileSquare(-1, num13, num14, 1);
					}
					else if (Main.tile[num13, num14].type == 397)
					{
						if (genRand.Next(2) == 0)
						{
							flag3 = true;
						}
						Main.tile[num13, num14].type = 399;
						SquareTileFrame(num13, num14);
						NetMessage.SendTileSquare(-1, num13, num14, 1);
					}
					else if (Main.tile[num13, num14].type == 59)
					{
						if (genRand.Next(2) == 0)
						{
							flag3 = true;
						}
						Main.tile[num13, num14].type = 0;
						SquareTileFrame(num13, num14);
						NetMessage.SendTileSquare(-1, num13, num14, 1);
					}
					else if (Main.tile[num13, num14].type == 60)
					{
						if (genRand.Next(2) == 0)
						{
							flag3 = true;
						}
						Main.tile[num13, num14].type = 199;
						SquareTileFrame(num13, num14);
						NetMessage.SendTileSquare(-1, num13, num14, 1);
					}
					else if (Main.tile[num13, num14].type == 69)
					{
						if (genRand.Next(2) == 0)
						{
							flag3 = true;
						}
						Main.tile[num13, num14].type = 352;
						SquareTileFrame(num13, num14);
						NetMessage.SendTileSquare(-1, num13, num14, 1);
					}
					else if (Main.tile[num13, num14].type == 161)
					{
						if (genRand.Next(2) == 0)
						{
							flag3 = true;
						}
						Main.tile[num13, num14].type = 200;
						SquareTileFrame(num13, num14);
						NetMessage.SendTileSquare(-1, num13, num14, 1);
					}
				}
			}
			if (type != 109 && type != 110 && type != 113 && type != 115 && type != 116 && type != 117 && type != 164 && type != 402 && type != 403 && type != 492)
			{
				return;
			}
			bool flag4 = true;
			while (flag4)
			{
				flag4 = false;
				int num15 = i + genRand.Next(-3, 4);
				int num16 = j + genRand.Next(-3, 4);
				if (CountNearBlocksTypes(num15, num16, 2, 1, 27) > 0)
				{
					continue;
				}
				if (Main.tile[num15, num16].type == 2)
				{
					if (genRand.Next(2) == 0)
					{
						flag4 = true;
					}
					Main.tile[num15, num16].type = 109;
					SquareTileFrame(num15, num16);
					NetMessage.SendTileSquare(-1, num15, num16, 1);
				}
				else if (Main.tile[num15, num16].type == 477)
				{
					if (genRand.Next(2) == 0)
					{
						flag4 = true;
					}
					Main.tile[num15, num16].type = 492;
					SquareTileFrame(num15, num16);
					NetMessage.SendTileSquare(-1, num15, num16, 1);
				}
				else if (Main.tile[num15, num16].type == 1 || Main.tileMoss[Main.tile[num15, num16].type])
				{
					if (genRand.Next(2) == 0)
					{
						flag4 = true;
					}
					Main.tile[num15, num16].type = 117;
					SquareTileFrame(num15, num16);
					NetMessage.SendTileSquare(-1, num15, num16, 1);
				}
				else if (Main.tile[num15, num16].type == 53)
				{
					if (genRand.Next(2) == 0)
					{
						flag4 = true;
					}
					Main.tile[num15, num16].type = 116;
					SquareTileFrame(num15, num16);
					NetMessage.SendTileSquare(-1, num15, num16, 1);
				}
				else if (Main.tile[num15, num16].type == 396)
				{
					if (genRand.Next(2) == 0)
					{
						flag4 = true;
					}
					Main.tile[num15, num16].type = 403;
					SquareTileFrame(num15, num16);
					NetMessage.SendTileSquare(-1, num15, num16, 1);
				}
				else if (Main.tile[num15, num16].type == 397)
				{
					if (genRand.Next(2) == 0)
					{
						flag4 = true;
					}
					Main.tile[num15, num16].type = 402;
					SquareTileFrame(num15, num16);
					NetMessage.SendTileSquare(-1, num15, num16, 1);
				}
				else if (Main.tile[num15, num16].type == 161)
				{
					if (genRand.Next(2) == 0)
					{
						flag4 = true;
					}
					Main.tile[num15, num16].type = 164;
					SquareTileFrame(num15, num16);
					NetMessage.SendTileSquare(-1, num15, num16, 1);
				}
			}
		}

		public static bool SolidTile(Tile testTile)
		{
			try
			{
				if (testTile == null)
				{
					return true;
				}
				if (testTile.active() && Main.tileSolid[testTile.type] && !Main.tileSolidTop[testTile.type] && !testTile.halfBrick() && testTile.slope() == 0 && !testTile.inActive())
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static bool TileEmpty(int i, int j)
		{
			if (Main.tile[i, j] != null && Main.tile[i, j].active())
			{
				return Main.tile[i, j].inActive();
			}
			return true;
		}

		public static bool SolidOrSlopedTile(Tile tile)
		{
			if (tile != null && tile.active() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type])
			{
				return !tile.inActive();
			}
			return false;
		}

		public static int TileType(int x, int y)
		{
			if (!Main.tile[x, y].active())
			{
				return -1;
			}
			return Main.tile[x, y].type;
		}

		public static bool SolidOrSlopedTile(int x, int y)
		{
			return SolidOrSlopedTile(Main.tile[x, y]);
		}

		public static bool SolidTile(Point p)
		{
			return SolidTile(p.X, p.Y);
		}

		public static bool SolidTile(int i, int j, bool noDoors = false)
		{
			try
			{
				if (Main.tile[i, j] == null)
				{
					return true;
				}
				if (Main.tile[i, j].active() && Main.tileSolid[Main.tile[i, j].type] && !Main.tileSolidTop[Main.tile[i, j].type] && !Main.tile[i, j].halfBrick() && Main.tile[i, j].slope() == 0 && !Main.tile[i, j].inActive())
				{
					if (noDoors && Main.tile[i, j].type == 10)
					{
						return false;
					}
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static bool SolidTile2(Tile testTile)
		{
			try
			{
				if (testTile == null)
				{
					return true;
				}
				if (testTile.active() && Main.tileSolid[testTile.type] && testTile.slope() == 0 && !testTile.halfBrick() && !testTile.inActive())
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static bool PlatformProperTopFrame(short frameX)
		{
			int num = frameX / TileObjectData.PlatformFrameWidth();
			if ((num < 0 || num > 7) && (num < 12 || num > 16))
			{
				if (num >= 25)
				{
					return num <= 26;
				}
				return false;
			}
			return true;
		}

		public static bool SolidTileAllowBottomSlope(int i, int j)
		{
			try
			{
				Tile tile = Main.tile[i, j];
				if (tile == null)
				{
					return true;
				}
				if (tile.active() && (Main.tileSolid[tile.type] || Main.tileSolidTop[tile.type]) && (!tile.topSlope() || (TileID.Sets.Platforms[tile.type] && PlatformProperTopFrame(tile.frameX))) && !tile.halfBrick() && !tile.inActive())
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static bool SolidTileAllowTopSlope(int i, int j)
		{
			try
			{
				Tile tile = Main.tile[i, j];
				if (tile == null)
				{
					return true;
				}
				if (tile.active() && Main.tileSolid[tile.type] && (!tile.bottomSlope() || (TileID.Sets.Platforms[tile.type] && tile.halfBrick())) && !tile.inActive())
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static bool TopEdgeCanBeAttachedTo(int i, int j)
		{
			try
			{
				Tile tile = Main.tile[i, j];
				if (tile == null)
				{
					return true;
				}
				if (tile.active() && (Main.tileSolid[tile.type] || Main.tileSolidTop[tile.type]) && (!tile.topSlope() || (TileID.Sets.Platforms[tile.type] && PlatformProperTopFrame(tile.frameX))) && !tile.halfBrick() && !tile.inActive())
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static bool RightEdgeCanBeAttachedTo(int i, int j)
		{
			try
			{
				Tile tile = Main.tile[i, j];
				if (tile == null)
				{
					return true;
				}
				if (tile.active() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type] && !tile.rightSlope() && !tile.halfBrick() && !tile.inActive() && !Main.tileNoAttach[tile.type])
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static bool LeftEdgeCanBeAttachedTo(int i, int j)
		{
			try
			{
				Tile tile = Main.tile[i, j];
				if (tile == null)
				{
					return true;
				}
				if (tile.active() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type] && !tile.leftSlope() && !tile.halfBrick() && !tile.inActive() && !Main.tileNoAttach[tile.type])
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static bool BottomEdgeCanBeAttachedTo(int i, int j)
		{
			try
			{
				Tile tile = Main.tile[i, j];
				if (tile == null)
				{
					return true;
				}
				if (tile.active() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type] && !tile.bottomSlope() && !tile.inActive() && !Main.tileNoAttach[tile.type])
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static bool SolidTile3(int i, int j)
		{
			if (!InWorld(i, j, 1))
			{
				return false;
			}
			return SolidTile3(Main.tile[i, j]);
		}

		public static bool SolidTile3(Tile t)
		{
			if (t == null)
			{
				return false;
			}
			if (t.active() && !t.inActive() && Main.tileSolid[t.type])
			{
				return !Main.tileSolidTop[t.type];
			}
			return false;
		}

		public static bool SolidTile2(int i, int j)
		{
			try
			{
				if (Main.tile[i, j] == null)
				{
					return true;
				}
				if (Main.tile[i, j].active() && Main.tileSolid[Main.tile[i, j].type] && ((TileID.Sets.Platforms[Main.tile[i, j].type] && (Main.tile[i, j].halfBrick() || Main.tile[i, j].topSlope())) || Main.tile[i, j].slope() == 0) && !Main.tile[i, j].halfBrick() && !Main.tile[i, j].inActive())
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static bool SolidTileNoAttach(int i, int j)
		{
			try
			{
				if (Main.tile[i, j] == null)
				{
					return true;
				}
				if (Main.tile[i, j].active() && Main.tileSolid[Main.tile[i, j].type] && !Main.tileNoAttach[Main.tile[i, j].type] && Main.tile[i, j].slope() == 0 && !Main.tile[i, j].halfBrick() && !Main.tile[i, j].inActive())
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static void MineHouse(int i, int j)
		{
			if (i < 50 || i > Main.maxTilesX - 50 || j < 50 || j > Main.maxTilesY - 50)
			{
				return;
			}
			int num = genRand.Next(6, 12);
			int num2 = genRand.Next(3, 6);
			int num3 = genRand.Next(15, 30);
			int num4 = genRand.Next(15, 30);
			if (SolidTile(i, j) || Main.tile[i, j].wall > 0)
			{
				return;
			}
			int num5 = j - num;
			int num6 = j + num2;
			for (int k = 0; k < 2; k++)
			{
				bool flag = true;
				int num7 = i;
				int num8 = j;
				int num9 = -1;
				int num10 = num3;
				if (k == 1)
				{
					num9 = 1;
					num10 = num4;
					num7++;
				}
				while (flag)
				{
					if (num8 - num < num5)
					{
						num5 = num8 - num;
					}
					if (num8 + num2 > num6)
					{
						num6 = num8 + num2;
					}
					for (int l = 0; l < 2; l++)
					{
						int num11 = num8;
						bool flag2 = true;
						int num12 = num;
						int num13 = -1;
						if (l == 1)
						{
							num11++;
							num12 = num2;
							num13 = 1;
						}
						while (flag2)
						{
							if (num7 != i && Main.tile[num7 - num9, num11].wall != 27 && (SolidTile(num7 - num9, num11) || !Main.tile[num7 - num9, num11].active() || Main.tile[num7 - num9, num11].halfBrick() || Main.tile[num7 - num9, num11].slope() != 0))
							{
								Main.tile[num7 - num9, num11].active(active: true);
								Main.tile[num7 - num9, num11].type = 30;
							}
							if (SolidTile(num7 - 1, num11) || Main.tile[num7 - 1, num11].halfBrick() || Main.tile[num7 - 1, num11].slope() != 0)
							{
								Main.tile[num7 - 1, num11].type = 30;
							}
							if (SolidTile(num7 + 1, num11) || Main.tile[num7 + 1, num11].halfBrick() || Main.tile[num7 + 1, num11].slope() != 0)
							{
								Main.tile[num7 + 1, num11].type = 30;
							}
							if (SolidTile(num7, num11) || Main.tile[num7, num11].halfBrick() || Main.tile[num7, num11].slope() != 0)
							{
								int num14 = 0;
								if (SolidTile(num7 - 1, num11))
								{
									num14++;
								}
								if (SolidTile(num7 + 1, num11))
								{
									num14++;
								}
								if (SolidTile(num7, num11 - 1))
								{
									num14++;
								}
								if (SolidTile(num7, num11 + 1))
								{
									num14++;
								}
								if (num14 < 2)
								{
									Main.tile[num7, num11].active(active: false);
								}
								else
								{
									flag2 = false;
									Main.tile[num7, num11].type = 30;
								}
							}
							else
							{
								Main.tile[num7, num11].wall = 27;
								Main.tile[num7, num11].liquid = 0;
								Main.tile[num7, num11].lava(lava: false);
							}
							num11 += num13;
							num12--;
							if (num12 <= 0)
							{
								if (!Main.tile[num7, num11].active())
								{
									Main.tile[num7, num11].active(active: true);
									Main.tile[num7, num11].type = 30;
								}
								flag2 = false;
							}
						}
					}
					num10--;
					num7 += num9;
					if (SolidTile(num7, num8))
					{
						int num15 = 0;
						int num16 = 0;
						int num17 = num8;
						bool flag3 = true;
						while (flag3)
						{
							num17--;
							num15++;
							if (SolidTile(num7 - num9, num17))
							{
								num15 = 999;
								flag3 = false;
							}
							else if (!SolidTile(num7, num17))
							{
								flag3 = false;
							}
						}
						num17 = num8;
						flag3 = true;
						while (flag3)
						{
							num17++;
							num16++;
							if (SolidTile(num7 - num9, num17))
							{
								num16 = 999;
								flag3 = false;
							}
							else if (!SolidTile(num7, num17))
							{
								flag3 = false;
							}
						}
						if (num16 <= num15)
						{
							if (num16 > num2)
							{
								num10 = 0;
							}
							else
							{
								num8 += num16 + 1;
							}
						}
						else if (num15 > num)
						{
							num10 = 0;
						}
						else
						{
							num8 -= num15 + 1;
						}
					}
					if (num10 <= 0)
					{
						flag = false;
					}
				}
			}
			int num18 = i - num3 - 1;
			int num19 = i + num4 + 2;
			int num20 = num5 - 1;
			int num21 = num6 + 2;
			for (int m = num18; m < num19; m++)
			{
				for (int n = num20; n < num21; n++)
				{
					if (Main.tile[m, n].wall == 27 && !Main.tile[m, n].active())
					{
						if (Main.tile[m - 1, n].wall != 27 && m < i && !SolidTile(m - 1, n))
						{
							PlaceTile(m, n, 30, mute: true);
							Main.tile[m, n].wall = 0;
						}
						if (Main.tile[m + 1, n].wall != 27 && m > i && !SolidTile(m + 1, n))
						{
							PlaceTile(m, n, 30, mute: true);
							Main.tile[m, n].wall = 0;
						}
						for (int num22 = m - 1; num22 <= m + 1; num22++)
						{
							for (int num23 = n - 1; num23 <= n + 1; num23++)
							{
								if (SolidTile(num22, num23))
								{
									Main.tile[num22, num23].type = 30;
								}
							}
						}
					}
					if (Main.tile[m, n].type == 30 && Main.tile[m - 1, n].wall == 27 && Main.tile[m + 1, n].wall == 27 && (Main.tile[m, n - 1].wall == 27 || Main.tile[m, n - 1].active()) && (Main.tile[m, n + 1].wall == 27 || Main.tile[m, n + 1].active()))
					{
						Main.tile[m, n].active(active: false);
						Main.tile[m, n].wall = 27;
					}
				}
			}
			for (int num24 = num18; num24 < num19; num24++)
			{
				for (int num25 = num20; num25 < num21; num25++)
				{
					if (Main.tile[num24, num25].type == 30)
					{
						if (Main.tile[num24 - 1, num25].wall == 27 && Main.tile[num24 + 1, num25].wall == 27 && !Main.tile[num24 - 1, num25].active() && !Main.tile[num24 + 1, num25].active())
						{
							Main.tile[num24, num25].active(active: false);
							Main.tile[num24, num25].wall = 27;
						}
						if (!TileID.Sets.BasicChest[Main.tile[num24, num25 - 1].type] && Main.tile[num24 - 1, num25].wall == 27 && Main.tile[num24 + 1, num25].type == 30 && Main.tile[num24 + 2, num25].wall == 27 && !Main.tile[num24 - 1, num25].active() && !Main.tile[num24 + 2, num25].active())
						{
							Main.tile[num24, num25].active(active: false);
							Main.tile[num24, num25].wall = 27;
							Main.tile[num24 + 1, num25].active(active: false);
							Main.tile[num24 + 1, num25].wall = 27;
						}
						if (Main.tile[num24, num25 - 1].wall == 27 && Main.tile[num24, num25 + 1].wall == 27 && !Main.tile[num24, num25 - 1].active() && !Main.tile[num24, num25 + 1].active())
						{
							Main.tile[num24, num25].active(active: false);
							Main.tile[num24, num25].wall = 27;
						}
					}
				}
			}
			for (int num26 = num18; num26 < num19; num26++)
			{
				for (int num27 = num21; num27 > num20; num27--)
				{
					bool flag4 = false;
					if (Main.tile[num26, num27].active() && Main.tile[num26, num27].type == 30)
					{
						int num28 = -1;
						for (int num29 = 0; num29 < 2; num29++)
						{
							if (!SolidTile(num26 + num28, num27) && Main.tile[num26 + num28, num27].wall == 0)
							{
								int num30 = 0;
								int num31 = num27;
								int num32 = num27;
								while (Main.tile[num26, num31].active() && Main.tile[num26, num31].type == 30 && !SolidTile(num26 + num28, num31) && Main.tile[num26 + num28, num31].wall == 0)
								{
									num31--;
									num30++;
								}
								num31++;
								int num33 = num31 + 1;
								if (num30 > 4)
								{
									if (genRand.Next(2) == 0)
									{
										num31 = num32 - 1;
										bool flag5 = true;
										for (int num34 = num26 - 2; num34 <= num26 + 2; num34++)
										{
											for (int num35 = num31 - 2; num35 <= num31; num35++)
											{
												if (num34 != num26 && Main.tile[num34, num35].active())
												{
													flag5 = false;
												}
											}
										}
										if (flag5)
										{
											Main.tile[num26, num31].active(active: false);
											Main.tile[num26, num31 - 1].active(active: false);
											Main.tile[num26, num31 - 2].active(active: false);
											PlaceTile(num26, num31, 10, mute: true);
											flag4 = true;
										}
									}
									if (!flag4)
									{
										for (int num36 = num33; num36 < num32; num36++)
										{
											Main.tile[num26, num36].type = 124;
										}
									}
								}
							}
							num28 = 1;
						}
					}
					if (flag4)
					{
						break;
					}
				}
			}
			int num37 = genRand.Next(1, 2);
			if (genRand.Next(4) == 0)
			{
				num37 = 0;
			}
			if (genRand.Next(6) == 0)
			{
				num37++;
			}
			if (genRand.Next(10) == 0)
			{
				num37++;
			}
			for (int num38 = 0; num38 < num37; num38++)
			{
				int num39 = 0;
				int num40 = genRand.Next(num18, num19);
				int num41 = genRand.Next(num20, num21);
				while (!Main.wallHouse[Main.tile[num40, num41].wall] || Main.tile[num40, num41].active())
				{
					num39++;
					if (num39 > 1000)
					{
						break;
					}
					num40 = genRand.Next(num18, num19);
					num41 = genRand.Next(num20, num21);
				}
				if (num39 > 1000)
				{
					break;
				}
				int num42 = num40;
				int num43 = num40;
				int num44 = num41;
				int num45 = num41;
				int num46 = 0;
				for (int num47 = 0; num47 < 2; num47++)
				{
					num42 = num40;
					num43 = num40;
					while (!Main.tile[num42, num41].active() && Main.wallHouse[Main.tile[num42, num41].wall])
					{
						num42--;
					}
					num42++;
					for (; !Main.tile[num43, num41].active() && Main.wallHouse[Main.tile[num43, num41].wall]; num43++)
					{
					}
					num43--;
					i = (num42 + num43) / 2;
					num44 = num41;
					num45 = num41;
					while (!Main.tile[num40, num44].active() && Main.wallHouse[Main.tile[num40, num44].wall])
					{
						num44--;
					}
					num44++;
					for (; !Main.tile[num40, num45].active() && Main.wallHouse[Main.tile[num40, num45].wall]; num45++)
					{
					}
					num45--;
					num41 = (num44 + num45) / 2;
				}
				num42 = num40;
				num43 = num40;
				while (!Main.tile[num42, num41].active() && !Main.tile[num42, num41 - 1].active() && !Main.tile[num42, num41 + 1].active())
				{
					num42--;
				}
				num42++;
				for (; !Main.tile[num43, num41].active() && !Main.tile[num43, num41 - 1].active() && !Main.tile[num43, num41 + 1].active(); num43++)
				{
				}
				num43--;
				num44 = num41;
				num45 = num41;
				while (!Main.tile[num40, num44].active() && !Main.tile[num40 - 1, num44].active() && !Main.tile[num40 + 1, num44].active())
				{
					num44--;
				}
				num44++;
				for (; !Main.tile[num40, num45].active() && !Main.tile[num40 - 1, num45].active() && !Main.tile[num40 + 1, num45].active(); num45++)
				{
				}
				num45--;
				num40 = (num42 + num43) / 2;
				num41 = (num44 + num45) / 2;
				int num48 = num43 - num42;
				num46 = num45 - num44;
				if (num48 <= 7 || num46 <= 5)
				{
					continue;
				}
				int num49 = 0;
				if (nearPicture2(i, num41))
				{
					num49 = -1;
				}
				if (num49 == 0)
				{
					Vector2 vector = randHousePicture();
					int type = (int)vector.X;
					int style = (int)vector.Y;
					if (!nearPicture(num40, num41))
					{
						PlaceTile(num40, num41, type, mute: true, forced: false, -1, style);
					}
				}
			}
			int num50;
			for (num50 = num18; num50 < num19; num50++)
			{
				bool flag6 = true;
				for (int num51 = num20; num51 < num21; num51++)
				{
					for (int num52 = num50 - 3; num52 <= num50 + 3; num52++)
					{
						if (Main.tile[num52, num51].active() && (!SolidTile(num52, num51) || Main.tile[num52, num51].type == 10))
						{
							flag6 = false;
						}
					}
				}
				if (flag6)
				{
					for (int num53 = num20; num53 < num21; num53++)
					{
						if (Main.tile[num50, num53].wall == 27 && !Main.tile[num50, num53].active())
						{
							PlaceTile(num50, num53, 124, mute: true);
						}
					}
				}
				num50 += genRand.Next(4);
			}
			for (int num54 = 0; num54 < 4; num54++)
			{
				int num55 = genRand.Next(num18 + 2, num19 - 1);
				int num56 = genRand.Next(num20 + 2, num21 - 1);
				while (Main.tile[num55, num56].wall != 27)
				{
					num55 = genRand.Next(num18 + 2, num19 - 1);
					num56 = genRand.Next(num20 + 2, num21 - 1);
				}
				while (Main.tile[num55, num56].active())
				{
					num56--;
				}
				for (; !Main.tile[num55, num56].active(); num56++)
				{
				}
				num56--;
				if (Main.tile[num55, num56].wall != 27)
				{
					continue;
				}
				if (genRand.Next(3) == 0)
				{
					int num57 = genRand.Next(9);
					if (num57 == 0)
					{
						num57 = 14;
					}
					if (num57 == 1)
					{
						num57 = 16;
					}
					if (num57 == 2)
					{
						num57 = 18;
					}
					if (num57 == 3)
					{
						num57 = 86;
					}
					if (num57 == 4)
					{
						num57 = 87;
					}
					if (num57 == 5)
					{
						num57 = 94;
					}
					if (num57 == 6)
					{
						num57 = 101;
					}
					if (num57 == 7)
					{
						num57 = 104;
					}
					if (num57 == 8)
					{
						num57 = 106;
					}
					PlaceTile(num55, num56, num57, mute: true);
				}
				else if (statueList != null)
				{
					int num58 = genRand.Next(2, statueList.Length);
					PlaceTile(num55, num56, statueList[num58].X, mute: true, forced: true, -1, statueList[num58].Y);
				}
			}
			for (int num59 = 0; num59 < 40; num59++)
			{
				int num60 = genRand.Next(num18 + 2, num19 - 1);
				int num61 = genRand.Next(num20 + 2, num21 - 1);
				while (Main.tile[num60, num61].wall != 27)
				{
					num60 = genRand.Next(num18 + 2, num19 - 1);
					num61 = genRand.Next(num20 + 2, num21 - 1);
				}
				while (Main.tile[num60, num61].active())
				{
					num61--;
				}
				for (; !Main.tile[num60, num61].active(); num61++)
				{
				}
				num61--;
				if (Main.tile[num60, num61].wall == 27 && genRand.Next(2) == 0)
				{
					int style2 = genRand.Next(22, 26);
					PlaceTile(num60, num61, 186, mute: true, forced: false, -1, style2);
				}
			}
			for (int num62 = 0; num62 < 20; num62++)
			{
				int num63 = genRand.Next(num18 + 2, num19 - 1);
				int num64 = genRand.Next(num20 + 2, num21 - 1);
				while (Main.tile[num63, num64].wall != 27)
				{
					num63 = genRand.Next(num18 + 2, num19 - 1);
					num64 = genRand.Next(num20 + 2, num21 - 1);
				}
				while (Main.tile[num63, num64].active())
				{
					num64--;
				}
				for (; !Main.tile[num63, num64].active(); num64++)
				{
				}
				num64--;
				if (Main.tile[num63, num64].wall == 27 && genRand.Next(2) == 0)
				{
					int x = genRand.Next(31, 34);
					PlaceSmallPile(num63, num64, x, 1, 185);
				}
			}
			for (int num65 = 0; num65 < 15; num65++)
			{
				int num66 = genRand.Next(num18 + 2, num19 - 1);
				int num67 = genRand.Next(num20 + 2, num21 - 1);
				while (Main.tile[num66, num67].wall != 27)
				{
					num66 = genRand.Next(num18 + 2, num19 - 1);
					num67 = genRand.Next(num20 + 2, num21 - 1);
				}
				while (Main.tile[num66, num67].active())
				{
					num67--;
				}
				while (num67 > 0 && !Main.tile[num66, num67 - 1].active())
				{
					num67--;
				}
				if (Main.tile[num66, num67].wall != 27)
				{
					continue;
				}
				int num68 = 4;
				int style3 = 0;
				if (genRand.Next(10) < 9)
				{
					num68 = -1;
				}
				else
				{
					num68 = 34;
					style3 = genRand.Next(6);
				}
				if (num68 <= 0)
				{
					continue;
				}
				PlaceTile(num66, num67, num68, mute: true, forced: false, -1, style3);
				if (Main.tile[num66, num67].type != num68)
				{
					continue;
				}
				if (num68 == 4)
				{
					Main.tile[num66, num67].frameX += 54;
					continue;
				}
				int num69 = num66;
				int num70 = num67;
				num67 = num70 - Main.tile[num69, num70].frameY % 54 / 18;
				num66 = Main.tile[num69, num70].frameX / 18;
				if (num66 > 2)
				{
					num66 -= 3;
				}
				num66 = num69 - num66;
				short num71 = 54;
				if (Main.tile[num66, num67].frameX > 0)
				{
					num71 = -54;
				}
				for (int num72 = num66; num72 < num66 + 3; num72++)
				{
					for (int num73 = num67; num73 < num67 + 3; num73++)
					{
						Main.tile[num72, num73].frameX += num71;
					}
				}
			}
		}

		public static void CountTiles(int X)
		{
			if (X == 0)
			{
				totalEvil = totalEvil2;
				totalBlood = totalBlood2;
				totalSolid = totalSolid2;
				totalGood = totalGood2;
				tGood = (byte)Math.Round((float)totalGood / (float)totalSolid * 100f);
				tEvil = (byte)Math.Round((float)totalEvil / (float)totalSolid * 100f);
				tBlood = (byte)Math.Round((float)totalBlood / (float)totalSolid * 100f);
				if (tGood == 0 && totalGood > 0)
				{
					tGood = 1;
				}
				if (tEvil == 0 && totalEvil > 0)
				{
					tEvil = 1;
				}
				if (tBlood == 0 && totalBlood > 0)
				{
					tBlood = 1;
				}
				if (Main.netMode == 2)
				{
					NetMessage.SendData(57);
				}
				totalEvil2 = 0;
				totalSolid2 = 0;
				totalGood2 = 0;
				totalBlood2 = 0;
			}
			ushort num = 0;
			ushort num2 = 0;
			int num3 = 0;
			int num4 = 0;
			int num5 = 0;
			do
			{
				int num6;
				int num7;
				if (num4 == 0)
				{
					num6 = 0;
					num5 = (int)(Main.worldSurface + 1.0);
					num7 = 5;
				}
				else
				{
					num6 = num5;
					num5 = Main.maxTilesY;
					num7 = 1;
				}
				for (int i = num6; i < num5; i++)
				{
					Tile tile = Main.tile[X, i];
					if (tile == null)
					{
						tile = (Main.tile[X, i] = new Tile());
					}
					num = tile.type;
					if (num != 0 || tile.active())
					{
						if (num == num2)
						{
							num3 += num7;
							continue;
						}
						tileCounts[num2] += num3;
						num2 = num;
						num3 = num7;
					}
				}
				tileCounts[num2] += num3;
				num3 = 0;
				num4++;
			}
			while (num4 < 2);
			AddUpAlignmentCounts();
		}

		public static void AddUpAlignmentCounts(bool clearCounts = false)
		{
			if (clearCounts)
			{
				totalEvil2 = 0;
				totalSolid2 = 0;
				totalGood2 = 0;
				totalBlood2 = 0;
			}
			totalGood2 += tileCounts[164] + tileCounts[109] + tileCounts[117] + tileCounts[116];
			totalEvil2 += tileCounts[23] + tileCounts[163] + tileCounts[112] + tileCounts[25];
			totalBlood2 += tileCounts[199] + tileCounts[234] + tileCounts[203] + tileCounts[200];
			totalSolid2 += tileCounts[2] + tileCounts[477] + tileCounts[1] + tileCounts[60] + tileCounts[53] + tileCounts[161];
			totalSolid2 += tileCounts[164] + tileCounts[109] + tileCounts[492] + tileCounts[117] + tileCounts[116];
			totalSolid2 += tileCounts[23] + tileCounts[163] + tileCounts[112] + tileCounts[25];
			totalSolid2 += tileCounts[199] + tileCounts[234] + tileCounts[203] + tileCounts[200];
			Array.Clear(tileCounts, 0, tileCounts.Length);
		}

		public static void plantDye(int i, int j, bool exoticPlant = false)
		{
			UnifiedRandom unifiedRandom = (gen ? genRand : Main.rand);
			if (!Main.tile[i, j].active() || i < 95 || i > Main.maxTilesX - 95 || j < 95 || j > Main.maxTilesY - 95)
			{
				return;
			}
			int num = 90;
			if (exoticPlant)
			{
				num = 240;
			}
			if ((double)j < Main.worldSurface)
			{
				if (Main.tile[i, j - 1].active() && Main.tile[i, j - 1].type != 3 && Main.tile[i, j - 1].type != 51 && Main.tile[i, j - 1].type != 61 && Main.tile[i, j - 1].type != 73 && Main.tile[i, j - 1].type != 74 && Main.tile[i, j - 1].type != 184)
				{
					return;
				}
				int num2 = Utils.Clamp(i - num, 1, Main.maxTilesX - 1 - 1);
				int num3 = Utils.Clamp(i + num, 1, Main.maxTilesX - 1 - 1);
				int num4 = Utils.Clamp(j - num, 1, Main.maxTilesY - 1 - 1);
				int num5 = Utils.Clamp(j + num, 1, Main.maxTilesY - 1 - 1);
				for (int k = num2; k < num3; k++)
				{
					for (int l = num4; l < num5; l++)
					{
						if (Main.tile[k, l].active() && Main.tile[k, l].type == 227 && (!exoticPlant || Main.tile[k, l].frameX >= 272) && (exoticPlant || Main.tile[k, l].frameX < 272))
						{
							return;
						}
					}
				}
				if (exoticPlant)
				{
					int type = Main.tile[i, j].type;
					bool flag = TileID.Sets.Conversion.Grass[type] || TileID.Sets.Conversion.Moss[type] || type == 0;
					if (Main.tile[i, j - 1].liquid > 0 && Main.tile[i, j - 1].lava())
					{
						flag = false;
					}
					if (flag)
					{
						PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, genRand.Next(8, 12));
					}
				}
				else if (Main.tile[i, j].type == 2 || Main.tile[i, j].type == 109)
				{
					if (unifiedRandom.Next(4) == 0)
					{
						PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 4);
					}
					else
					{
						PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 3);
					}
				}
				else if (Main.tile[i, j].type == 60)
				{
					if (unifiedRandom.Next(2) == 0)
					{
						PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 2);
					}
					else
					{
						PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 4);
					}
				}
				else if (Main.tile[i, j].type == 53 && Main.tile[i, j - 1].liquid == byte.MaxValue && Main.tile[i, j - 2].liquid == byte.MaxValue)
				{
					PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 2);
				}
				else
				{
					if (Main.tile[i, j].type != 80 || Main.tile[i - 1, j - 1].active() || Main.tile[i + 1, j - 1].active())
					{
						return;
					}
					try
					{
						bool flag2 = true;
						for (int m = i - 5; m <= i + 5; m++)
						{
							for (int n = j - 5; n <= j + 15; n++)
							{
								if (Main.tile[m, n].active() && (Main.tile[m, n].type == 112 || Main.tile[m, n].type == 234))
								{
									flag2 = false;
								}
							}
						}
						if (flag2)
						{
							PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 6);
						}
					}
					catch
					{
					}
				}
			}
			else
			{
				if (j >= Main.UnderworldLayer)
				{
					return;
				}
				if (!Main.tile[i, j - 1].active() || Main.tile[i, j - 1].type == 3 || Main.tile[i, j - 1].type == 51 || Main.tile[i, j - 1].type == 61 || Main.tile[i, j - 1].type == 73 || Main.tile[i, j - 1].type == 74 || Main.tile[i, j - 1].type == 184)
				{
					int num6 = Utils.Clamp(i - num, 1, Main.maxTilesX - 1 - 1);
					int num7 = Utils.Clamp(i + num, 1, Main.maxTilesX - 1 - 1);
					int num8 = Utils.Clamp(j - num, 1, Main.maxTilesY - 1 - 1);
					int num9 = Utils.Clamp(j + num, 1, Main.maxTilesY - 1 - 1);
					for (int num10 = num6; num10 < num7; num10++)
					{
						for (int num11 = num8; num11 < num9; num11++)
						{
							if (Main.tile[num10, num11].active() && Main.tile[num10, num11].type == 227 && (!exoticPlant || Main.tile[num10, num11].frameX >= 272) && (exoticPlant || Main.tile[num10, num11].frameX < 272))
							{
								return;
							}
						}
					}
					if (exoticPlant)
					{
						int type2 = Main.tile[i, j].type;
						if (TileID.Sets.Conversion.Grass[type2] || TileID.Sets.Conversion.Moss[type2] || type2 == 0)
						{
							PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, genRand.Next(8, 12));
						}
					}
					else if (Main.tile[i, j].type == 60)
					{
						if (unifiedRandom.Next(2) == 0)
						{
							PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 2);
						}
						else if (unifiedRandom.Next(2) == 0)
						{
							PlaceTile(i, j - 1, 227, mute: true);
						}
						else
						{
							PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 1);
						}
					}
					else if (Main.tile[i, j].type == 0 || Main.tile[i, j].type == 1 || Main.tile[i, j].type == 59)
					{
						if (unifiedRandom.Next(2) == 0)
						{
							PlaceTile(i, j - 1, 227, mute: true);
						}
						else
						{
							PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 1);
						}
					}
					else if (Main.tile[i, j - 1].liquid == byte.MaxValue && Main.tile[i, j - 2].liquid == byte.MaxValue)
					{
						PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 5);
					}
				}
				if (Main.tile[i, j + 1].active() || exoticPlant)
				{
					return;
				}
				for (int num12 = i - num; num12 < i + num; num12++)
				{
					for (int num13 = j - num; num13 < j + num; num13++)
					{
						if (Main.tile[num12, num13].active() && Main.tile[num12, num13].type == 227)
						{
							return;
						}
					}
				}
				if (Main.tile[i, j].type == 0)
				{
					PlaceTile(i, j + 1, 227, mute: true, forced: false, -1, 7);
				}
			}
		}

		private static int MossConversion(int thisType, int otherType)
		{
			if (TileID.Sets.tileMossBrick[thisType] && otherType == 38)
			{
				return thisType;
			}
			if (Main.tileMoss[thisType] && otherType == 1)
			{
				return thisType;
			}
			return thisType switch
			{
				182 => 515, 
				515 => 182, 
				180 => 513, 
				513 => 180, 
				179 => 512, 
				512 => 179, 
				381 => 517, 
				517 => 381, 
				534 => 535, 
				535 => 534, 
				536 => 537, 
				537 => 536, 
				539 => 540, 
				540 => 539, 
				183 => 516, 
				516 => 183, 
				181 => 514, 
				514 => 181, 
				_ => 0, 
			};
		}

		public static void UpdateWorld()
		{
			if (gen)
			{
				return;
			}
			AllowedToSpreadInfections = true;
			CreativePowers.StopBiomeSpreadPower power = CreativePowerManager.Instance.GetPower<CreativePowers.StopBiomeSpreadPower>();
			if (power != null && power.GetIsUnlocked())
			{
				AllowedToSpreadInfections = !power.Enabled;
			}
			int wallDist = 3;
			Wiring.UpdateMech();
			TileEntity.UpdateStart();
			foreach (TileEntity value in TileEntity.ByID.Values)
			{
				value.Update();
			}
			TileEntity.UpdateEnd();
			UpdateLunarApocalypse();
			if (Main.netMode != 1)
			{
				totalD++;
				if (totalD >= 30)
				{
					totalD = 0;
					CountTiles(totalX);
					totalX++;
					if (totalX >= Main.maxTilesX)
					{
						totalX = 0;
					}
				}
			}
			Liquid.skipCount++;
			if (Liquid.skipCount > 1)
			{
				Liquid.UpdateLiquid();
				Liquid.skipCount = 0;
			}
			int worldUpdateRate = GetWorldUpdateRate();
			if (worldUpdateRate == 0)
			{
				return;
			}
			float num = 3E-05f * (float)worldUpdateRate;
			float num2 = 1.5E-05f * (float)worldUpdateRate;
			bool checkNPCSpawns = false;
			spawnDelay++;
			if (Main.invasionType > 0 || Main.eclipse)
			{
				spawnDelay = 0;
			}
			if (spawnDelay >= 20)
			{
				checkNPCSpawns = true;
				spawnDelay = 0;
				if (prioritizedTownNPCType != 37)
				{
					for (int i = 0; i < 200; i++)
					{
						if (Main.npc[i].active && Main.npc[i].homeless && Main.npc[i].townNPC && Main.npc[i].type != 368)
						{
							prioritizedTownNPCType = Main.npc[i].type;
							break;
						}
					}
				}
			}
			float num3 = (float)(Main.maxTilesX * Main.maxTilesY) * num;
			int num4 = 151;
			int num5 = (int)MathHelper.Lerp(num4, (float)num4 * 2.8f, MathHelper.Clamp((float)Main.maxTilesX / 4200f - 1f, 0f, 1f));
			for (int j = 0; (float)j < num3; j++)
			{
				if (Main.rand.Next(num5 * 100) == 0)
				{
					PlantAlch();
				}
				int i2 = genRand.Next(10, Main.maxTilesX - 10);
				int j2 = genRand.Next(10, (int)Main.worldSurface - 1);
				UpdateWorld_OvergroundTile(i2, j2, checkNPCSpawns, wallDist);
			}
			for (int k = 0; (float)k < (float)(Main.maxTilesX * Main.maxTilesY) * num2; k++)
			{
				int i3 = genRand.Next(10, Main.maxTilesX - 10);
				int j3 = genRand.Next((int)Main.worldSurface - 1, Main.maxTilesY - 20);
				UpdateWorld_UndergroundTile(i3, j3, checkNPCSpawns, wallDist);
			}
			if (Main.dayTime)
			{
				return;
			}
			for (int l = 0; l < Main.dayRate; l++)
			{
				float num6 = Main.maxTilesX / 4200;
				num6 *= Star.starfallBoost;
				if (!((float)Main.rand.Next(8000) < 10f * num6))
				{
					continue;
				}
				int num7 = 12;
				int num8 = Main.rand.Next(Main.maxTilesX - 50) + 100;
				num8 *= 16;
				int num9 = Main.rand.Next((int)((double)Main.maxTilesY * 0.05));
				num9 *= 16;
				Vector2 position = new Vector2(num8, num9);
				int num10 = -1;
				if (Main.expertMode && Main.rand.Next(15) == 0)
				{
					int num11 = Player.FindClosest(position, 1, 1);
					if ((double)Main.player[num11].position.Y < Main.worldSurface * 16.0 && Main.player[num11].afkCounter < 3600)
					{
						int num12 = Main.rand.Next(1, 640);
						position.X = Main.player[num11].position.X + (float)Main.rand.Next(-num12, num12 + 1);
						num10 = num11;
					}
				}
				if (!Collision.SolidCollision(position, 16, 16))
				{
					float num13 = Main.rand.Next(-100, 101);
					float num14 = Main.rand.Next(200) + 100;
					float num15 = (float)Math.Sqrt(num13 * num13 + num14 * num14);
					num15 = (float)num7 / num15;
					num13 *= num15;
					num14 *= num15;
					Projectile.NewProjectile(position.X, position.Y, num13, num14, 720, 0, 0f, Main.myPlayer, 0f, num10);
				}
			}
		}

		public static int GetWorldUpdateRate()
		{
			int result = Math.Min(Main.desiredWorldTilesUpdateRate, 24);
			if (CreativePowerManager.Instance.GetPower<CreativePowers.FreezeTime>().Enabled)
			{
				result = 0;
			}
			return result;
		}

		private static void UpdateWorld_OvergroundTile(int i, int j, bool checkNPCSpawns, int wallDist)
		{
			int num = i - 1;
			int num2 = i + 2;
			int num3 = j - 1;
			int num4 = j + 2;
			if (num < 10)
			{
				num = 10;
			}
			if (num2 > Main.maxTilesX - 10)
			{
				num2 = Main.maxTilesX - 10;
			}
			if (num3 < 10)
			{
				num3 = 10;
			}
			if (num4 > Main.maxTilesY - 10)
			{
				num4 = Main.maxTilesY - 10;
			}
			if (Main.tile[i, j] == null)
			{
				return;
			}
			if (Main.tileAlch[Main.tile[i, j].type])
			{
				GrowAlch(i, j);
			}
			else if ((double)j < Main.worldSurface + 10.0 && (i < beachDistance || i > Main.maxTilesX - beachDistance) && !Main.tile[i, j].nactive())
			{
				int num5 = 3000;
				num5 -= (int)(Math.Abs(Main.windSpeedCurrent) * 1250f);
				if (Main.raining)
				{
					num5 -= (int)(1250f * Main.maxRaining);
				}
				if (num5 < 300)
				{
					num5 = 300;
				}
				if (genRand.Next(num5) == 0)
				{
					int k;
					for (k = j; (double)k < Main.worldSurface + 10.0 && !Main.tile[i, k].nactive() && k - j < 15; k++)
					{
					}
					if (Main.tile[i, k].nactive() && Main.tile[i, k].type == 53 && SolidTileAllowBottomSlope(i, k))
					{
						k--;
						int num6 = genRand.Next(2, 5);
						int num7 = genRand.Next(8, 11);
						int num8 = 0;
						for (int l = i - num7; l <= i + num7; l++)
						{
							for (int m = k - num7; m <= k + num7; m++)
							{
								if (Main.tile[l, m].active() && (Main.tile[l, m].type == 324 || Main.tile[l, m].type == 81))
								{
									num8++;
								}
							}
						}
						if (num8 < num6)
						{
							if (genRand.Next(2) == 0 && Main.tile[i, k].liquid >= 230)
							{
								PlaceTile(i, k, 81);
								if (Main.netMode == 2 && Main.tile[i, k].active())
								{
									NetMessage.SendTileSquare(-1, i, k, 3);
								}
							}
							else
							{
								PlaceTile(i, k, 324, mute: false, forced: false, -1, RollRandomSeaShellStyle());
								if (Main.netMode == 2 && Main.tile[i, k].active())
								{
									NetMessage.SendTileSquare(-1, i, k, 3);
								}
							}
						}
					}
				}
			}
			if ((Main.tile[i, j].type == 596 || Main.tile[i, j].type == 616 || Main.tile[i, j].type == 595 || Main.tile[i, j].type == 615) && (Main.tile[i, j + 1].type == 199 || Main.tile[i, j + 1].type == 23))
			{
				KillTile(i, j);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, j, 4);
				}
			}
			if ((Main.tile[i, j].type == 571 || (Main.tile[i, j].type == 60 && Main.tile[i, j - 1].liquid > 0)) && genRand.Next(5) == 0 && (!Main.tile[i, j - 1].active() || Main.tile[i, j - 1].type == 61 || Main.tile[i, j - 1].type == 74 || Main.tile[i, j - 1].type == 518) && (Main.tile[i, j].type != 60 || genRand.Next(30) == 0) && PlaceBamboo(i, j - 1))
			{
				NetMessage.SendTileSquare(-1, i, j, 3);
			}
			if (Main.tile[i, j].type == 518)
			{
				if (Main.tile[i, j].liquid == 0 || ((int)Main.tile[i, j].liquid / 16 >= 9 && SolidTile(i, j - 1)) || (Main.tile[i, j - 1].liquid > 0 && Main.tile[i, j - 1].active()))
				{
					KillTile(i, j);
					if (Main.netMode == 2)
					{
						NetMessage.SendData(17, -1, -1, null, 0, i, j);
					}
				}
				else
				{
					CheckLilyPad(i, j);
				}
			}
			else if (Main.tile[i, j].type == 519)
			{
				CheckCatTail(i, j);
				if (Main.tile[i, j].active() && genRand.Next(8) == 0)
				{
					GrowCatTail(i, j);
					CheckCatTail(i, j);
				}
			}
			else if (Main.tile[i, j].liquid > 32)
			{
				if (Main.tile[i, j].active())
				{
					if (TileID.Sets.SlowlyDiesInWater[Main.tile[i, j].type])
					{
						KillTile(i, j);
						if (Main.netMode == 2)
						{
							NetMessage.SendData(17, -1, -1, null, 0, i, j);
						}
					}
					else if (Main.tile[i, j].type == 60)
					{
						UpdateWorld_GrassGrowth(i, j, num, num2, num3, num4, underground: false);
					}
				}
				else if (genRand.Next(600) == 0)
				{
					PlaceTile(i, j, 518, mute: true);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, j, 3);
					}
				}
				else if (genRand.Next(600) == 0)
				{
					PlaceTile(i, j, 519, mute: true);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, j, 3);
					}
				}
			}
			else if (Main.tile[i, j].nactive())
			{
				hardUpdateWorld(i, j);
				if (Main.rand.Next(3000) == 0)
				{
					plantDye(i, j);
				}
				else if (Main.hardMode && ((double)i < (double)Main.maxTilesX * 0.4 || (double)i > (double)Main.maxTilesX * 0.6) && Main.rand.Next(15000) == 0)
				{
					plantDye(i, j, exoticPlant: true);
				}
				if (Main.tile[i, j].type == 80)
				{
					if (genRand.Next(15) == 0)
					{
						GrowCactus(i, j);
					}
				}
				else if (Main.tile[i, j].type == 529)
				{
					if (CheckSeaOat(i, j) && genRand.Next(20) == 0)
					{
						GrowSeaOat(i, j);
					}
				}
				else if (TileID.Sets.Conversion.Sand[Main.tile[i, j].type])
				{
					if (!Main.tile[i, num3].active())
					{
						if (genRand.Next(25) == 0)
						{
							PlaceOasisPlant(i, num3, 530);
							if (Main.tile[i, num3].type == 530 && Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i, num3, 4);
							}
						}
						if (genRand.Next(20) != 0 || !PlantSeaOat(i, num3))
						{
							if (i < oceanDistance || i > Main.maxTilesX - oceanDistance)
							{
								if (genRand.Next(500) == 0)
								{
									int num9 = 7;
									int num10 = 6;
									int num11 = 0;
									for (int n = i - num9; n <= i + num9; n++)
									{
										for (int num12 = num3 - num9; num12 <= num3 + num9; num12++)
										{
											if (Main.tile[n, num12].active() && Main.tile[n, num12].type == 81)
											{
												num11++;
											}
										}
									}
									if (num11 < num10 && Main.tile[i, num3].liquid == byte.MaxValue && Main.tile[i, num3 - 1].liquid == byte.MaxValue && Main.tile[i, num3 - 2].liquid == byte.MaxValue && Main.tile[i, num3 - 3].liquid == byte.MaxValue && Main.tile[i, num3 - 4].liquid == byte.MaxValue)
									{
										PlaceTile(i, num3, 81, mute: true);
										if (Main.netMode == 2 && Main.tile[i, num3].active())
										{
											NetMessage.SendTileSquare(-1, i, num3, 1);
										}
									}
								}
							}
							else if (i > beachDistance + 20 && i < Main.maxTilesX - beachDistance - 20 && genRand.Next(300) == 0)
							{
								GrowCactus(i, j);
							}
						}
					}
				}
				else if (Main.tile[i, j].type == 530)
				{
					if (!OasisPlantWaterCheck(i, j, boost: true))
					{
						KillTile(i, j);
						if (Main.netMode == 2)
						{
							NetMessage.SendData(17, -1, -1, null, 0, i, j);
						}
					}
				}
				else if (Main.tile[i, j].type == 147 || Main.tile[i, j].type == 161 || Main.tile[i, j].type == 163 || Main.tile[i, j].type == 164 || Main.tile[i, j].type == 200)
				{
					if (Main.rand.Next(10) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 2].active())
					{
						int num13 = i - 3;
						int num14 = i + 4;
						int num15 = 0;
						for (int num16 = num13; num16 < num14; num16++)
						{
							if (Main.tile[num16, j].type == 165 && Main.tile[num16, j].active())
							{
								num15++;
							}
							if (Main.tile[num16, j + 1].type == 165 && Main.tile[num16, j + 1].active())
							{
								num15++;
							}
							if (Main.tile[num16, j + 2].type == 165 && Main.tile[num16, j + 2].active())
							{
								num15++;
							}
							if (Main.tile[num16, j + 3].type == 165 && Main.tile[num16, j + 3].active())
							{
								num15++;
							}
						}
						if (num15 < 2)
						{
							PlaceTight(i, j + 1);
							SquareTileFrame(i, j + 1);
							if (Main.netMode == 2 && Main.tile[i, j + 1].active())
							{
								NetMessage.SendTileSquare(-1, i, j + 1, 3);
							}
						}
					}
				}
				else if (Main.tile[i, j].type == 254)
				{
					if (Main.rand.Next((Main.tile[i, j].frameX + 10) / 10) == 0)
					{
						GrowPumpkin(i, j, 254);
					}
				}
				else if (Main.tile[i, j].type == 78 || Main.tile[i, j].type == 380 || Main.tile[i, j].type == 579)
				{
					if (!Main.tile[i, num3].active() && genRand.Next(2) == 0)
					{
						PlaceTile(i, num3, 3, mute: true);
						if (Main.netMode == 2 && Main.tile[i, num3].active())
						{
							NetMessage.SendTileSquare(-1, i, num3, 1);
						}
					}
				}
				else if (TileID.Sets.SpreadOverground[Main.tile[i, j].type])
				{
					UpdateWorld_GrassGrowth(i, j, num, num2, num3, num4, underground: false);
				}
				else if (Main.tileMoss[Main.tile[i, j].type] || TileID.Sets.tileMossBrick[Main.tile[i, j].type])
				{
					if ((double)genRand.NextFloat() < 0.5)
					{
						int type = Main.tile[i, j].type;
						bool flag = false;
						for (int num17 = num; num17 < num2; num17++)
						{
							for (int num18 = num3; num18 < num4; num18++)
							{
								if ((i != num17 || j != num18) && Main.tile[num17, num18].active() && (Main.tile[num17, num18].type == 1 || Main.tile[num17, num18].type == 38))
								{
									int type2 = Main.tile[num17, num18].type;
									SpreadGrass(num17, num18, Main.tile[num17, num18].type, MossConversion(type, type2), repeat: false, Main.tile[i, j].color());
									if (Main.tile[num17, num18].type == type)
									{
										SquareTileFrame(num17, num18);
										flag = true;
									}
								}
							}
						}
						if (Main.netMode == 2 && flag)
						{
							NetMessage.SendTileSquare(-1, i, j, 3);
						}
						if (genRand.Next(6) == 0)
						{
							int num19 = i;
							int num20 = j;
							switch (genRand.Next(4))
							{
							case 0:
								num19--;
								break;
							case 1:
								num19++;
								break;
							case 2:
								num20--;
								break;
							default:
								num20++;
								break;
							}
							if (!Main.tile[num19, num20].active())
							{
								if (PlaceTile(num19, num20, 184, mute: true))
								{
									Main.tile[num19, num20].color(Main.tile[i, j].color());
								}
								if (Main.netMode == 2 && Main.tile[num19, num20].active())
								{
									NetMessage.SendTileSquare(-1, num19, num20, 1);
								}
							}
						}
					}
				}
				else if (Main.tile[i, j].type == 20)
				{
					if (genRand.Next(20) == 0)
					{
						bool flag2 = PlayerLOS(i, j);
						bool flag3 = false;
						flag3 = ((Main.tile[i, j].frameX < 324 || Main.tile[i, j].frameX >= 540) ? GrowTree(i, j) : GrowPalmTree(i, j));
						if (flag3 && flag2)
						{
							TreeGrowFXCheck(i, j);
						}
					}
				}
				else if (Main.tile[i, j].type == 595)
				{
					if (genRand.Next(5) == 0)
					{
						int num21 = Main.tile[i, j].frameX / 54;
						int treeTileType = 596;
						if (num21 == 0)
						{
							treeTileType = 596;
						}
						if (TryGrowingTreeByType(treeTileType, i, j) && PlayerLOS(i, j))
						{
							TreeGrowFXCheck(i, j);
						}
					}
				}
				else if (Main.tile[i, j].type == 615)
				{
					if (genRand.Next(5) == 0)
					{
						int num22 = Main.tile[i, j].frameX / 54;
						int treeTileType2 = 616;
						if (num22 == 0)
						{
							treeTileType2 = 616;
						}
						if (TryGrowingTreeByType(treeTileType2, i, j) && PlayerLOS(i, j))
						{
							TreeGrowFXCheck(i, j);
						}
					}
				}
				else if (Main.tile[i, j].type == 3 && genRand.Next(20) == 0)
				{
					if (Main.tile[i, j].frameX != 144)
					{
						Main.tile[i, j].type = 73;
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, j, 3);
						}
					}
				}
				else if (Main.tile[i, j].type == 110 && genRand.Next(20) == 0)
				{
					if (Main.tile[i, j].frameX < 144)
					{
						Main.tile[i, j].type = 113;
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, j, 3);
						}
					}
				}
				else if (Main.tile[i, j].type == 32 && genRand.Next(3) == 0)
				{
					GrowSpike(i, j, 32, 23);
				}
				else if (Main.tile[i, j].type == 352 && genRand.Next(3) == 0)
				{
					GrowSpike(i, j, 352, 199);
				}
			}
			else if (checkNPCSpawns)
			{
				TrySpawningTownNPC(i, j);
			}
			if (AllowedToSpreadInfections)
			{
				if (Main.tile[i, j].wall == 81 || Main.tile[i, j].wall == 83 || (Main.tile[i, j].type == 199 && Main.tile[i, j].active()))
				{
					int num23 = i + genRand.Next(-2, 3);
					int num24 = j + genRand.Next(-2, 3);
					if (Main.tile[num23, num24].wall >= 63 && Main.tile[num23, num24].wall <= 68)
					{
						bool flag4 = false;
						for (int num25 = i - wallDist; num25 < i + wallDist; num25++)
						{
							for (int num26 = j - wallDist; num26 < j + wallDist; num26++)
							{
								if (Main.tile[i, j].active())
								{
									int type3 = Main.tile[i, j].type;
									if (type3 == 199 || type3 == 200 || type3 == 201 || type3 == 203 || type3 == 205 || type3 == 234 || type3 == 352)
									{
										flag4 = true;
										break;
									}
								}
							}
						}
						if (flag4)
						{
							Main.tile[num23, num24].wall = 81;
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, num23, num24, 3);
							}
						}
					}
				}
				else if (Main.tile[i, j].wall == 69 || Main.tile[i, j].wall == 3 || (Main.tile[i, j].type == 23 && Main.tile[i, j].active()))
				{
					int num27 = i + genRand.Next(-2, 3);
					int num28 = j + genRand.Next(-2, 3);
					if (Main.tile[num27, num28].wall >= 63 && Main.tile[num27, num28].wall <= 68)
					{
						bool flag5 = false;
						for (int num29 = i - wallDist; num29 < i + wallDist; num29++)
						{
							for (int num30 = j - wallDist; num30 < j + wallDist; num30++)
							{
								if (Main.tile[num29, num30].active())
								{
									int type4 = Main.tile[num29, num30].type;
									if (type4 == 22 || type4 == 23 || type4 == 24 || type4 == 25 || type4 == 32 || type4 == 112 || type4 == 163)
									{
										flag5 = true;
										break;
									}
								}
							}
						}
						if (flag5)
						{
							Main.tile[num27, num28].wall = 69;
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, num27, num28, 3);
							}
						}
					}
				}
				else if (Main.tile[i, j].wall == 70 || (Main.tile[i, j].type == 109 && Main.tile[i, j].active()))
				{
					int num31 = i + genRand.Next(-2, 3);
					int num32 = j + genRand.Next(-2, 3);
					if (Main.tile[num31, num32].wall == 63 || Main.tile[num31, num32].wall == 65 || Main.tile[num31, num32].wall == 66 || Main.tile[num31, num32].wall == 68)
					{
						bool flag6 = false;
						for (int num33 = i - wallDist; num33 < i + wallDist; num33++)
						{
							for (int num34 = j - wallDist; num34 < j + wallDist; num34++)
							{
								if (Main.tile[num33, num34].active())
								{
									int type5 = Main.tile[num33, num34].type;
									if (type5 == 109 || type5 == 110 || type5 == 113 || type5 == 115 || type5 == 116 || type5 == 117 || type5 == 164)
									{
										flag6 = true;
										break;
									}
								}
							}
						}
						if (flag6)
						{
							Main.tile[num31, num32].wall = 70;
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, num31, num32, 3);
							}
						}
					}
				}
				SpreadDesertWalls(wallDist, i, j);
			}
			if (!Main.tile[i, j].nactive())
			{
				return;
			}
			if ((Main.tile[i, j].type == 2 || Main.tile[i, j].type == 52 || Main.tile[i, j].type == 382 || (Main.tile[i, j].type == 192 && genRand.Next(10) == 0)) && GrowMoreVines(i, j))
			{
				int maxValue = 60;
				if (Main.tile[i, j].type == 52 || Main.tile[i, j].type == 382)
				{
					maxValue = 20;
				}
				if (genRand.Next(maxValue) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
				{
					bool flag7 = false;
					ushort type6 = 52;
					if (Main.tile[i, j].type == 382)
					{
						type6 = 382;
					}
					else if (Main.tile[i, j].type != 52)
					{
						if (Main.tile[i, j].wall == 68 || Main.tile[i, j].wall == 65 || Main.tile[i, j].wall == 66 || Main.tile[i, j].wall == 63)
						{
							type6 = 382;
						}
						else if (Main.tile[i, j + 1].wall == 68 || Main.tile[i, j + 1].wall == 65 || Main.tile[i, j + 1].wall == 66 || Main.tile[i, j + 1].wall == 63)
						{
							type6 = 382;
						}
					}
					for (int num35 = j; num35 > j - 10; num35--)
					{
						if (Main.tile[i, num35].bottomSlope())
						{
							flag7 = false;
							break;
						}
						if (Main.tile[i, num35].active() && Main.tile[i, num35].type == 2 && !Main.tile[i, num35].bottomSlope())
						{
							flag7 = true;
							break;
						}
					}
					if (flag7)
					{
						int num36 = j + 1;
						Main.tile[i, num36].type = type6;
						Main.tile[i, num36].active(active: true);
						Main.tile[i, num36].color(Main.tile[i, j].color());
						SquareTileFrame(i, num36);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, num36, 3);
						}
					}
				}
			}
			else if (Main.tile[i, j].type == 61 && genRand.Next(3) == 0 && Main.tile[i, j].frameX < 144)
			{
				if (Main.rand.Next(4) == 0)
				{
					Main.tile[i, j].frameX = (short)(162 + genRand.Next(8) * 18);
				}
				Main.tile[i, j].type = 74;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, j, 3);
				}
			}
			if ((Main.tile[i, j].type == 60 || Main.tile[i, j].type == 62) && GrowMoreVines(i, j))
			{
				int maxValue2 = 30;
				if (Main.tile[i, j].type == 62)
				{
					maxValue2 = 10;
				}
				if (genRand.Next(maxValue2) != 0 || Main.tile[i, j + 1].active() || Main.tile[i, j + 1].lava())
				{
					return;
				}
				bool flag8 = false;
				for (int num37 = j; num37 > j - 10; num37--)
				{
					if (Main.tile[i, num37].bottomSlope())
					{
						flag8 = false;
						break;
					}
					if (Main.tile[i, num37].active() && Main.tile[i, num37].type == 60 && !Main.tile[i, num37].bottomSlope())
					{
						flag8 = true;
						break;
					}
				}
				if (flag8)
				{
					int num38 = j + 1;
					Main.tile[i, num38].type = 62;
					Main.tile[i, num38].active(active: true);
					SquareTileFrame(i, num38);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, num38, 3);
					}
				}
			}
			else if ((Main.tile[i, j].type == 70 || Main.tile[i, j].type == 528) && GrowMoreVines(i, j))
			{
				int maxValue3 = 70;
				if (Main.tile[i, j].type == 528)
				{
					maxValue3 = 7;
				}
				if (genRand.Next(maxValue3) != 0 || Main.tile[i, j + 1].active() || Main.tile[i, j + 1].lava())
				{
					return;
				}
				bool flag9 = false;
				for (int num39 = j; num39 > j - 10; num39--)
				{
					if (Main.tile[i, num39].bottomSlope())
					{
						flag9 = false;
						break;
					}
					if (Main.tile[i, num39].active() && Main.tile[i, num39].type == 70 && !Main.tile[i, num39].bottomSlope())
					{
						flag9 = true;
						break;
					}
				}
				if (flag9)
				{
					int num40 = j + 1;
					Main.tile[i, num40].type = 528;
					Main.tile[i, num40].active(active: true);
					SquareTileFrame(i, num40);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, num40, 3);
					}
				}
			}
			else if ((Main.tile[i, j].type == 109 || Main.tile[i, j].type == 115) && GrowMoreVines(i, j))
			{
				int maxValue4 = 60;
				if (Main.tile[i, j].type == 115)
				{
					maxValue4 = 20;
				}
				if (genRand.Next(maxValue4) != 0 || Main.tile[i, j + 1].active() || Main.tile[i, j + 1].lava())
				{
					return;
				}
				bool flag10 = false;
				for (int num41 = j; num41 > j - 10; num41--)
				{
					if (Main.tile[i, num41].bottomSlope())
					{
						flag10 = false;
						break;
					}
					if (Main.tile[i, num41].active() && Main.tile[i, num41].type == 109 && !Main.tile[i, num41].bottomSlope())
					{
						flag10 = true;
						break;
					}
				}
				if (flag10)
				{
					int num42 = j + 1;
					Main.tile[i, num42].type = 115;
					Main.tile[i, num42].active(active: true);
					SquareTileFrame(i, num42);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, num42, 3);
					}
				}
			}
			else
			{
				if ((Main.tile[i, j].type != 199 && Main.tile[i, j].type != 205) || !GrowMoreVines(i, j))
				{
					return;
				}
				int maxValue5 = 60;
				if (Main.tile[i, j].type == 205)
				{
					maxValue5 = 20;
				}
				if (genRand.Next(maxValue5) != 0 || Main.tile[i, j + 1].active() || Main.tile[i, j + 1].lava())
				{
					return;
				}
				bool flag11 = false;
				for (int num43 = j; num43 > j - 10; num43--)
				{
					if (Main.tile[i, num43].bottomSlope())
					{
						flag11 = false;
						break;
					}
					if (Main.tile[i, num43].active() && Main.tile[i, num43].type == 199 && !Main.tile[i, num43].bottomSlope())
					{
						flag11 = true;
						break;
					}
				}
				if (flag11)
				{
					int num44 = j + 1;
					Main.tile[i, num44].type = 205;
					Main.tile[i, num44].active(active: true);
					SquareTileFrame(i, num44);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, num44, 3);
					}
				}
			}
		}

		private static void UpdateWorld_UndergroundTile(int i, int j, bool checkNPCSpawns, int wallDist)
		{
			int num = i - 1;
			int num2 = i + 2;
			int num3 = j - 1;
			int num4 = j + 2;
			if (num < 10)
			{
				num = 10;
			}
			if (num2 > Main.maxTilesX - 10)
			{
				num2 = Main.maxTilesX - 10;
			}
			if (num3 < 10)
			{
				num3 = 10;
			}
			if (num4 > Main.maxTilesY - 10)
			{
				num4 = Main.maxTilesY - 10;
			}
			if (Main.tile[i, j] == null)
			{
				return;
			}
			if (Main.tileAlch[Main.tile[i, j].type])
			{
				GrowAlch(i, j);
			}
			else if (Main.tile[i, j].nactive())
			{
				hardUpdateWorld(i, j);
				if (Main.rand.Next(2500) == 0)
				{
					plantDye(i, j);
				}
				else if (Main.hardMode && Main.rand.Next(10000) == 0)
				{
					plantDye(i, j, exoticPlant: true);
				}
				if (Main.tile[i, j].type == 519)
				{
					CheckCatTail(i, j);
					if (Main.tile[i, j].active() && genRand.Next(2) == 0)
					{
						GrowCatTail(i, j);
						CheckCatTail(i, j);
					}
				}
				if (Main.tile[i, j].type == 549)
				{
					GrowCheckSeaweed(i, j);
				}
				else if (Main.tile[i, j].type == 53 && !Main.tile[i, j].topSlope() && !Main.tile[i, j].halfBrick() && !Main.tile[i, j - 1].active() && genRand.Next(20) == 0)
				{
					GrowCheckSeaweed(i, j);
				}
				else if (TileID.Sets.SpreadUnderground[Main.tile[i, j].type])
				{
					UpdateWorld_GrassGrowth(i, j, num, num2, num3, num4, underground: true);
				}
				else if (Main.tile[i, j].type == 32)
				{
					GrowSpike(i, j, 32, 23);
				}
				else if (Main.tile[i, j].type == 352 && genRand.Next(3) == 0)
				{
					GrowSpike(i, j, 352, 199);
				}
				else if (Main.tile[i, j].type == 61 && genRand.Next(3) == 0)
				{
					if (Main.tile[i, j].frameX < 144)
					{
						if (Main.rand.Next(4) == 0)
						{
							Main.tile[i, j].frameX = (short)(162 + genRand.Next(8) * 18);
						}
						Main.tile[i, j].type = 74;
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, j, 3);
						}
					}
				}
				else if ((Main.tile[i, j].type == 60 || Main.tile[i, j].type == 62) && genRand.Next(5) == 0 && GrowMoreVines(i, j))
				{
					if (!Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
					{
						bool flag = false;
						for (int num5 = j; num5 > j - 10; num5--)
						{
							if (Main.tile[i, num5].bottomSlope())
							{
								flag = false;
								break;
							}
							if (Main.tile[i, num5].active() && Main.tile[i, num5].type == 60 && !Main.tile[i, num5].bottomSlope())
							{
								flag = true;
								break;
							}
						}
						if (flag)
						{
							int num6 = j + 1;
							Main.tile[i, num6].type = 62;
							Main.tile[i, num6].active(active: true);
							SquareTileFrame(i, num6);
							Main.tile[i, num6].color(Main.tile[i, num6 - 1].color());
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i, num6, 3);
							}
						}
					}
				}
				else if ((Main.tile[i, j].type == 70 || Main.tile[i, j].type == 528) && GrowMoreVines(i, j))
				{
					if (!Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
					{
						int maxValue = 70;
						if (Main.tile[i, j].type == 528)
						{
							maxValue = 7;
						}
						if (genRand.Next(maxValue) == 0)
						{
							bool flag2 = false;
							for (int num7 = j; num7 > j - 10; num7--)
							{
								if (Main.tile[i, num7].bottomSlope())
								{
									flag2 = false;
									break;
								}
								if (Main.tile[i, num7].active() && Main.tile[i, num7].type == 70 && !Main.tile[i, num7].bottomSlope())
								{
									flag2 = true;
									break;
								}
							}
							if (flag2)
							{
								int num8 = j + 1;
								Main.tile[i, num8].type = 528;
								Main.tile[i, num8].active(active: true);
								Main.tile[i, num8].color(Main.tile[i, num8 - 1].color());
								SquareTileFrame(i, num8);
								if (Main.netMode == 2)
								{
									NetMessage.SendTileSquare(-1, i, num8, 3);
								}
							}
						}
					}
				}
				else if ((Main.tile[i, j].type == 60 || Main.tile[i, j].type == 62) && genRand.Next(80) == 0 && !PlayerLOS(i, j))
				{
					bool flag3 = true;
					int num9 = j;
					if (Main.tile[i, j].type == 60)
					{
						num9++;
					}
					for (int k = i; k < i + 2; k++)
					{
						int num10 = num9 - 1;
						if (!AnchorValid(Framing.GetTileSafely(k, num10), AnchorType.SolidTile) || Main.tile[k, num10].bottomSlope())
						{
							flag3 = false;
						}
						if (Main.tile[k, num10].liquid > 0 || Main.wallHouse[Main.tile[k, num10].wall])
						{
							flag3 = false;
						}
						if (!flag3)
						{
							break;
						}
						for (int l = num9; l < num9 + 2; l++)
						{
							if ((Main.tile[k, l].active() && (!Main.tileCut[Main.tile[k, l].type] || Main.tile[k, l].type == 444)) || Main.tile[k, l].lava())
							{
								flag3 = false;
							}
							if (!flag3)
							{
								break;
							}
						}
						if (!flag3)
						{
							break;
						}
					}
					if (flag3 && CountNearBlocksTypes(i, j, 20, 1, 444) > 0)
					{
						flag3 = false;
					}
					if (flag3)
					{
						for (int m = i; m < i + 2; m++)
						{
							Main.tile[m, num9 - 1].slope(0);
							Main.tile[m, num9 - 1].halfBrick(halfBrick: false);
							for (int n = num9; n < num9 + 2; n++)
							{
								if (Main.tile[m, n].active())
								{
									KillTile(m, n);
								}
							}
						}
						for (int num11 = i; num11 < i + 2; num11++)
						{
							for (int num12 = num9; num12 < num9 + 2; num12++)
							{
								Main.tile[num11, num12].active(active: true);
								Main.tile[num11, num12].type = 444;
								Main.tile[num11, num12].frameX = (short)((num11 - i) * 18);
								Main.tile[num11, num12].frameY = (short)((num12 - num9) * 18);
							}
						}
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, num9, 3);
						}
					}
				}
				else if (Main.tile[i, j].type == 69)
				{
					GrowSpike(i, j, 69, 60);
				}
				else if (Main.tile[i, j].type == 147 || Main.tile[i, j].type == 161 || Main.tile[i, j].type == 163 || Main.tile[i, j].type == 164 || Main.tile[i, j].type == 200)
				{
					if (Main.rand.Next(10) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 2].active())
					{
						int num13 = i - 3;
						int num14 = i + 4;
						int num15 = 0;
						for (int num16 = num13; num16 < num14; num16++)
						{
							if (Main.tile[num16, j].type == 165 && Main.tile[num16, j].active())
							{
								num15++;
							}
							if (Main.tile[num16, j + 1].type == 165 && Main.tile[num16, j + 1].active())
							{
								num15++;
							}
							if (Main.tile[num16, j + 2].type == 165 && Main.tile[num16, j + 2].active())
							{
								num15++;
							}
							if (Main.tile[num16, j + 3].type == 165 && Main.tile[num16, j + 3].active())
							{
								num15++;
							}
						}
						if (num15 < 2)
						{
							PlaceTight(i, j + 1);
							SquareTileFrame(i, j + 1);
							if (Main.netMode == 2 && Main.tile[i, j + 1].active())
							{
								NetMessage.SendTileSquare(-1, i, j + 1, 3);
							}
						}
					}
				}
				else if (Main.tileMoss[Main.tile[i, j].type] || TileID.Sets.tileMossBrick[Main.tile[i, j].type])
				{
					int type = Main.tile[i, j].type;
					bool flag4 = false;
					for (int num17 = num; num17 < num2; num17++)
					{
						for (int num18 = num3; num18 < num4; num18++)
						{
							if ((i != num17 || j != num18) && Main.tile[num17, num18].active() && (Main.tile[num17, num18].type == 1 || Main.tile[num17, num18].type == 38))
							{
								int type2 = Main.tile[num17, num18].type;
								SpreadGrass(num17, num18, Main.tile[num17, num18].type, MossConversion(type, type2), repeat: false, Main.tile[i, j].color());
								if (Main.tile[num17, num18].type == type)
								{
									SquareTileFrame(num17, num18);
									flag4 = true;
								}
							}
						}
					}
					if (Main.netMode == 2 && flag4)
					{
						NetMessage.SendTileSquare(-1, i, j, 3);
					}
					if (genRand.Next(6) == 0)
					{
						int num19 = i;
						int num20 = j;
						switch (genRand.Next(4))
						{
						case 0:
							num19--;
							break;
						case 1:
							num19++;
							break;
						case 2:
							num20--;
							break;
						default:
							num20++;
							break;
						}
						if (!Main.tile[num19, num20].active())
						{
							if (PlaceTile(num19, num20, 184, mute: true))
							{
								Main.tile[num19, num20].color(Main.tile[i, j].color());
							}
							if (Main.netMode == 2 && Main.tile[num19, num20].active())
							{
								NetMessage.SendTileSquare(-1, num19, num20, 1);
							}
						}
					}
				}
				else if (Main.tile[i, j].type == 590)
				{
					if (genRand.Next(5) == 0)
					{
						int num21 = Main.tile[i, j].frameX / 54;
						int treeTileType = 587;
						switch (num21)
						{
						case 0:
							treeTileType = 583;
							break;
						case 1:
							treeTileType = 584;
							break;
						case 2:
							treeTileType = 585;
							break;
						case 3:
							treeTileType = 586;
							break;
						case 4:
							treeTileType = 587;
							break;
						case 5:
							treeTileType = 588;
							break;
						case 6:
							treeTileType = 589;
							break;
						}
						if (TryGrowingTreeByType(treeTileType, i, j) && PlayerLOS(i, j))
						{
							TreeGrowFXCheck(i, j);
						}
					}
				}
				else if (Main.tile[i, j].type == 595)
				{
					if (genRand.Next(5) == 0)
					{
						int num22 = Main.tile[i, j].frameX / 54;
						int treeTileType2 = 596;
						if (num22 == 0)
						{
							treeTileType2 = 596;
						}
						if (TryGrowingTreeByType(treeTileType2, i, j) && PlayerLOS(i, j))
						{
							TreeGrowFXCheck(i, j);
						}
					}
				}
				else if (Main.tile[i, j].type == 615 && genRand.Next(5) == 0)
				{
					int num23 = Main.tile[i, j].frameX / 54;
					int treeTileType3 = 616;
					if (num23 == 0)
					{
						treeTileType3 = 616;
					}
					if (TryGrowingTreeByType(treeTileType3, i, j) && PlayerLOS(i, j))
					{
						TreeGrowFXCheck(i, j);
					}
				}
			}
			else
			{
				if (Main.tile[i, j].wall == 62 && Main.tile[i, j].liquid == 0 && genRand.Next(10) == 0)
				{
					int num24 = genRand.Next(2, 4);
					int num25 = i - num24;
					int num26 = i + num24;
					int num27 = j - num24;
					int num28 = j + num24;
					bool flag5 = false;
					for (int num29 = num25; num29 <= num26; num29++)
					{
						for (int num30 = num27; num30 <= num28; num30++)
						{
							if (SolidTile(num29, num30))
							{
								flag5 = true;
								break;
							}
						}
					}
					if (flag5 && !Main.tile[i, j].active())
					{
						PlaceTile(i, j, 51, mute: true);
						TileFrame(i, j, resetFrame: true);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, j, 3);
						}
					}
				}
				if (checkNPCSpawns)
				{
					TrySpawningTownNPC(i, j);
				}
			}
			if (!AllowedToSpreadInfections)
			{
				return;
			}
			if (Main.tile[i, j].wall == 81 || Main.tile[i, j].wall == 83 || (Main.tile[i, j].type == 199 && Main.tile[i, j].active()))
			{
				int num31 = i + genRand.Next(-2, 3);
				int num32 = j + genRand.Next(-2, 3);
				if (Main.tile[num31, num32].wall >= 63 && Main.tile[num31, num32].wall <= 68)
				{
					bool flag6 = false;
					for (int num33 = i - wallDist; num33 < i + wallDist; num33++)
					{
						for (int num34 = j - wallDist; num34 < j + wallDist; num34++)
						{
							if (Main.tile[num33, num34].active())
							{
								int type3 = Main.tile[num33, num34].type;
								if (type3 == 199 || type3 == 200 || type3 == 201 || type3 == 203 || type3 == 205 || type3 == 234 || type3 == 352)
								{
									flag6 = true;
									break;
								}
							}
						}
					}
					if (flag6)
					{
						Main.tile[num31, num32].wall = 81;
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num31, num32, 3);
						}
					}
				}
			}
			else if (Main.tile[i, j].wall == 69 || Main.tile[i, j].wall == 3 || (Main.tile[i, j].type == 23 && Main.tile[i, j].active()))
			{
				int num35 = i + genRand.Next(-2, 3);
				int num36 = j + genRand.Next(-2, 3);
				if (Main.tile[num35, num36].wall >= 63 && Main.tile[num35, num36].wall <= 68)
				{
					bool flag7 = false;
					for (int num37 = i - wallDist; num37 < i + wallDist; num37++)
					{
						for (int num38 = j - wallDist; num38 < j + wallDist; num38++)
						{
							if (Main.tile[num37, num38].active())
							{
								int type4 = Main.tile[num37, num38].type;
								if (type4 == 22 || type4 == 23 || type4 == 24 || type4 == 25 || type4 == 32 || type4 == 112 || type4 == 163)
								{
									flag7 = true;
									break;
								}
							}
						}
					}
					if (flag7)
					{
						Main.tile[num35, num36].wall = 69;
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num35, num36, 3);
						}
					}
				}
			}
			else if (Main.tile[i, j].wall == 70 || (Main.tile[i, j].type == 109 && Main.tile[i, j].active()))
			{
				int num39 = i + genRand.Next(-2, 3);
				int num40 = j + genRand.Next(-2, 3);
				if (Main.tile[num39, num40].wall == 63 || Main.tile[num39, num40].wall == 65 || Main.tile[num39, num40].wall == 66 || Main.tile[num39, num40].wall == 68)
				{
					bool flag8 = false;
					for (int num41 = i - wallDist; num41 < i + wallDist; num41++)
					{
						for (int num42 = j - wallDist; num42 < j + wallDist; num42++)
						{
							if (Main.tile[num41, num42].active())
							{
								int type5 = Main.tile[num41, num42].type;
								if (type5 == 109 || type5 == 110 || type5 == 113 || type5 == 115 || type5 == 116 || type5 == 117 || type5 == 164)
								{
									flag8 = true;
									break;
								}
							}
						}
					}
					if (flag8)
					{
						Main.tile[num39, num40].wall = 70;
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num39, num40, 3);
						}
					}
				}
			}
			SpreadDesertWalls(wallDist, i, j);
		}

		private static void UpdateWorld_GrassGrowth(int i, int j, int minI, int maxI, int minJ, int maxJ, bool underground)
		{
			if (underground)
			{
				int type = Main.tile[i, j].type;
				int num = -1;
				int num2 = -1;
				int maxValue = 1;
				switch (type)
				{
				case 23:
					num = 0;
					num2 = 24;
					maxValue = 2;
					if (!AllowedToSpreadInfections)
					{
						return;
					}
					break;
				case 199:
					num = 0;
					num2 = 201;
					maxValue = 2;
					if (!AllowedToSpreadInfections)
					{
						return;
					}
					break;
				case 60:
					num = 59;
					num2 = 61;
					maxValue = 10;
					break;
				case 70:
					num = 59;
					num2 = 71;
					maxValue = 10;
					break;
				}
				bool flag = false;
				if (num2 != -1 && !Main.tile[i, minJ].active() && genRand.Next(maxValue) == 0)
				{
					flag = true;
					if (PlaceTile(i, minJ, num2, mute: true))
					{
						Main.tile[i, minJ].color(Main.tile[i, j].color());
					}
					if (Main.netMode == 2 && Main.tile[i, minJ].active())
					{
						NetMessage.SendTileSquare(-1, i, minJ, 1);
					}
				}
				if (num != -1)
				{
					bool flag2 = false;
					for (int k = minI; k < maxI; k++)
					{
						for (int l = minJ; l < maxJ; l++)
						{
							if ((i != k || j != l) && Main.tile[k, l].active() && Main.tile[k, l].type == num)
							{
								SpreadGrass(k, l, num, type, repeat: false, Main.tile[i, j].color());
								if (Main.tile[k, l].type == type)
								{
									SquareTileFrame(k, l);
									flag2 = true;
								}
							}
						}
					}
					if (Main.netMode == 2 && flag2)
					{
						NetMessage.SendTileSquare(-1, i, j, 3);
					}
				}
				switch (type)
				{
				case 60:
				{
					if (flag || genRand.Next(25) != 0 || Main.tile[i, minJ].liquid != 0)
					{
						break;
					}
					if (Main.hardMode && NPC.downedMechBoss1 && NPC.downedMechBoss2 && NPC.downedMechBoss3 && genRand.Next(60) == 0)
					{
						bool flag3 = true;
						int num3 = 150;
						for (int m = i - num3; m < i + num3; m += 2)
						{
							for (int n = j - num3; n < j + num3; n += 2)
							{
								if (m > 1 && m < Main.maxTilesX - 2 && n > 1 && n < Main.maxTilesY - 2 && Main.tile[m, n].active() && Main.tile[m, n].type == 238)
								{
									flag3 = false;
									break;
								}
							}
						}
						if (flag3)
						{
							PlaceJunglePlant(i, minJ, 238, 0, 0);
							SquareTileFrame(i, minJ);
							SquareTileFrame(i + 2, minJ);
							SquareTileFrame(i - 1, minJ);
							if (Main.tile[i, minJ].type == 238 && Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i, minJ, 5);
							}
						}
					}
					int maxValue2 = (Main.expertMode ? 30 : 40);
					if (Main.hardMode && NPC.downedMechBossAny && genRand.Next(maxValue2) == 0)
					{
						bool flag4 = true;
						int num4 = 60;
						if (Main.expertMode)
						{
							num4 -= 10;
						}
						for (int num5 = i - num4; num5 < i + num4; num5 += 2)
						{
							for (int num6 = j - num4; num6 < j + num4; num6 += 2)
							{
								if (num5 > 1 && num5 < Main.maxTilesX - 2 && num6 > 1 && num6 < Main.maxTilesY - 2 && Main.tile[num5, num6].active() && Main.tile[num5, num6].type == 236)
								{
									flag4 = false;
									break;
								}
							}
						}
						if (flag4)
						{
							PlaceJunglePlant(i, minJ, 236, genRand.Next(3), 0);
							SquareTileFrame(i, minJ);
							SquareTileFrame(i + 1, minJ + 1);
							if (Main.tile[i, minJ].type == 236 && Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i, minJ, 4);
							}
						}
						break;
					}
					PlaceJunglePlant(i, minJ, 233, genRand.Next(8), 0);
					if (Main.tile[i, minJ].type != 233)
					{
						break;
					}
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, minJ, 4);
						break;
					}
					PlaceJunglePlant(i, minJ, 233, genRand.Next(12), 1);
					if (Main.tile[i, minJ].type == 233 && Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, minJ, 3);
					}
					break;
				}
				case 70:
					if (Main.tile[i, j - 1].liquid > 0)
					{
						PlaceCatTail(i, j - 1);
					}
					if (genRand.Next(300) == 0 && GrowShroom(i, j) && PlayerLOS(i, j))
					{
						TreeGrowFXCheck(i, j - 1);
					}
					break;
				}
				return;
			}
			int num7 = Main.tile[i, j].type;
			switch (num7)
			{
			case 2:
			case 23:
			case 32:
			case 109:
			case 199:
			case 352:
			case 477:
			case 492:
			{
				if (Main.halloween && genRand.Next(75) == 0 && (num7 == 2 || num7 == 109))
				{
					int num10 = 100;
					int num11 = 0;
					for (int num12 = i - num10; num12 < i + num10; num12 += 2)
					{
						for (int num13 = j - num10; num13 < j + num10; num13 += 2)
						{
							if (num12 > 1 && num12 < Main.maxTilesX - 2 && num13 > 1 && num13 < Main.maxTilesY - 2 && Main.tile[num12, num13].active() && Main.tile[num12, num13].type == 254)
							{
								num11++;
							}
						}
					}
					if (num11 < 6)
					{
						PlacePumpkin(i, minJ);
						if (Main.netMode == 2 && Main.tile[i, minJ].type == 254)
						{
							NetMessage.SendTileSquare(-1, i, minJ, 4);
						}
					}
				}
				if (!Main.tile[i, minJ].active() && Main.tile[i, minJ].liquid == 0)
				{
					int num14 = -1;
					if (num7 == 2 && genRand.Next(12) == 0)
					{
						num14 = 3;
					}
					else if (num7 == 23 && genRand.Next(10) == 0)
					{
						num14 = 24;
					}
					else if (num7 == 109 && genRand.Next(10) == 0)
					{
						num14 = 110;
					}
					else if (num7 == 199 && genRand.Next(10) == 0)
					{
						num14 = 201;
					}
					if (num14 != -1 && PlaceTile(i, minJ, num14, mute: true))
					{
						Main.tile[i, minJ].color(Main.tile[i, j].color());
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, minJ, 1);
						}
					}
				}
				bool flag6 = false;
				switch (num7)
				{
				case 32:
					num7 = 23;
					if (!AllowedToSpreadInfections)
					{
						return;
					}
					break;
				case 352:
					num7 = 199;
					if (!AllowedToSpreadInfections)
					{
						return;
					}
					break;
				case 477:
					num7 = 2;
					break;
				case 492:
					num7 = 109;
					break;
				}
				bool flag7 = AllowedToSpreadInfections && (num7 == 23 || num7 == 199 || num7 == 109 || num7 == 492);
				for (int num15 = minI; num15 < maxI; num15++)
				{
					for (int num16 = minJ; num16 < maxJ; num16++)
					{
						if ((i == num15 && j == num16) || !Main.tile[num15, num16].active())
						{
							continue;
						}
						int type2 = Main.tile[num15, num16].type;
						if (!flag7 && type2 != 0)
						{
							continue;
						}
						if (type2 == 0 || ((num7 == 23 || num7 == 199) && (type2 == 2 || type2 == 109 || type2 == 477 || type2 == 492)))
						{
							SpreadGrass(num15, num16, 0, num7, repeat: false, Main.tile[i, j].color());
							if (num7 == 23 || num7 == 199)
							{
								if (!AllowedToSpreadInfections)
								{
									continue;
								}
								SpreadGrass(num15, num16, 2, num7, repeat: false, Main.tile[i, j].color());
								SpreadGrass(num15, num16, 109, num7, repeat: false, Main.tile[i, j].color());
								SpreadGrass(num15, num16, 477, num7, repeat: false, Main.tile[i, j].color());
								SpreadGrass(num15, num16, 492, num7, repeat: false, Main.tile[i, j].color());
							}
							if (Main.tile[num15, num16].type == num7)
							{
								SquareTileFrame(num15, num16);
								flag6 = true;
							}
						}
						if (type2 == 0 || ((num7 == 109 || num7 == 492) && (type2 == 2 || type2 == 477 || type2 == 23 || type2 == 199)))
						{
							SpreadGrass(num15, num16, 0, num7, repeat: false, Main.tile[i, j].color());
							if (num7 == 109)
							{
								SpreadGrass(num15, num16, 2, num7, repeat: false, Main.tile[i, j].color());
							}
							switch (num7)
							{
							case 492:
								SpreadGrass(num15, num16, 477, num7, repeat: false, Main.tile[i, j].color());
								break;
							case 109:
								SpreadGrass(num15, num16, 477, 492, repeat: false, Main.tile[i, j].color());
								break;
							}
							if ((num7 == 492 || num7 == 109) && AllowedToSpreadInfections)
							{
								SpreadGrass(num15, num16, 23, 109, repeat: false, Main.tile[i, j].color());
							}
							if ((num7 == 492 || num7 == 109) && AllowedToSpreadInfections)
							{
								SpreadGrass(num15, num16, 199, 109, repeat: false, Main.tile[i, j].color());
							}
							if (Main.tile[num15, num16].type == num7)
							{
								SquareTileFrame(num15, num16);
								flag6 = true;
							}
						}
					}
				}
				if (Main.netMode == 2 && flag6)
				{
					NetMessage.SendTileSquare(-1, i, j, 3);
				}
				break;
			}
			case 70:
			{
				if (!Main.tile[i, j].inActive())
				{
					if (!Main.tile[i, minJ].active() && genRand.Next(10) == 0)
					{
						PlaceTile(i, minJ, 71, mute: true);
						if (Main.tile[i, minJ].active())
						{
							Main.tile[i, minJ].color(Main.tile[i, j].color());
						}
						if (Main.netMode == 2 && Main.tile[i, minJ].active())
						{
							NetMessage.SendTileSquare(-1, i, minJ, 1);
						}
					}
					if (genRand.Next(300) == 0)
					{
						bool flag8 = PlayerLOS(i, j);
						if (GrowTree(i, j) && flag8)
						{
							TreeGrowFXCheck(i, j - 1);
						}
					}
				}
				bool flag9 = false;
				for (int num17 = minI; num17 < maxI; num17++)
				{
					for (int num18 = minJ; num18 < maxJ; num18++)
					{
						if ((i != num17 || j != num18) && Main.tile[num17, num18].active() && Main.tile[num17, num18].type == 59)
						{
							SpreadGrass(num17, num18, 59, num7, repeat: false, Main.tile[i, j].color());
							if (Main.tile[num17, num18].type == num7)
							{
								SquareTileFrame(num17, num18);
								flag9 = true;
							}
						}
					}
				}
				if (Main.netMode == 2 && flag9)
				{
					NetMessage.SendTileSquare(-1, i, j, 3);
				}
				break;
			}
			case 60:
			{
				if (!Main.tile[i, minJ].active() && genRand.Next(7) == 0)
				{
					PlaceTile(i, minJ, 61, mute: true);
					if (Main.tile[i, minJ].active())
					{
						Main.tile[i, minJ].color(Main.tile[i, j].color());
					}
					if (Main.netMode == 2 && Main.tile[i, minJ].active())
					{
						NetMessage.SendTileSquare(-1, i, minJ, 1);
					}
				}
				else if (genRand.Next(500) == 0 && (!Main.tile[i, minJ].active() || Main.tile[i, minJ].type == 61 || Main.tile[i, minJ].type == 74 || Main.tile[i, minJ].type == 69))
				{
					if (GrowTree(i, j) && PlayerLOS(i, j))
					{
						TreeGrowFXCheck(i, j - 1);
					}
				}
				else if (genRand.Next(25) == 0 && Main.tile[i, minJ].liquid == 0)
				{
					PlaceJunglePlant(i, minJ, 233, genRand.Next(8), 0);
					if (Main.tile[i, minJ].type == 233)
					{
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, minJ, 4);
						}
						else
						{
							PlaceJunglePlant(i, minJ, 233, genRand.Next(12), 1);
							if (Main.tile[i, minJ].type == 233 && Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i, minJ, 3);
							}
						}
					}
				}
				bool flag5 = false;
				for (int num8 = minI; num8 < maxI; num8++)
				{
					for (int num9 = minJ; num9 < maxJ; num9++)
					{
						if ((i != num8 || j != num9) && Main.tile[num8, num9].active() && Main.tile[num8, num9].type == 59)
						{
							SpreadGrass(num8, num9, 59, num7, repeat: false, Main.tile[i, j].color());
							if (Main.tile[num8, num9].type == num7)
							{
								SquareTileFrame(num8, num9);
								flag5 = true;
							}
						}
					}
				}
				if (Main.netMode == 2 && flag5)
				{
					NetMessage.SendTileSquare(-1, i, j, 3);
				}
				break;
			}
			}
		}

		private static void TrySpawningTownNPC(int x, int y)
		{
			bool flag = Main.tileSolid[379];
			Main.tileSolid[379] = true;
			if (prioritizedTownNPCType > 0)
			{
				if (Main.tile[x, y].wall == 34)
				{
					if (Main.rand.Next(4) == 0)
					{
						SpawnTownNPC(x, y);
					}
				}
				else
				{
					SpawnTownNPC(x, y);
				}
			}
			Main.tileSolid[379] = flag;
		}

		public static void SpreadDesertWalls(int wallDist, int i, int j)
		{
			if (!WallID.Sets.Conversion.Sandstone[Main.tile[i, j].wall] && (!Main.tile[i, j].active() || !TileID.Sets.Conversion.Sandstone[Main.tile[i, j].type]) && !WallID.Sets.Conversion.HardenedSand[Main.tile[i, j].wall])
			{
				return;
			}
			int num = 0;
			int wall = Main.tile[i, j].wall;
			int type = Main.tile[i, j].type;
			if (WallID.Sets.Corrupt[wall] || TileID.Sets.Corrupt[type])
			{
				num = 1;
			}
			if (WallID.Sets.Hallow[wall] || TileID.Sets.Hallow[type])
			{
				num = 2;
			}
			if (WallID.Sets.Crimson[wall] || TileID.Sets.Crimson[type])
			{
				num = 3;
			}
			if (num == 0)
			{
				return;
			}
			int num2 = i + genRand.Next(-2, 3);
			int num3 = j + genRand.Next(-2, 3);
			bool flag = false;
			if (WallID.Sets.Conversion.PureSand[Main.tile[num2, num3].wall])
			{
				switch (num)
				{
				case 3:
				{
					for (int m = i - wallDist; m < i + wallDist; m++)
					{
						for (int n = j - wallDist; n < j + wallDist; n++)
						{
							if (Main.tile[m, n].active() && TileID.Sets.Crimson[Main.tile[m, n].type])
							{
								flag = true;
								break;
							}
						}
						if (flag)
						{
							break;
						}
					}
					break;
				}
				case 2:
				{
					for (int num4 = i - wallDist; num4 < i + wallDist; num4++)
					{
						for (int num5 = j - wallDist; num5 < j + wallDist; num5++)
						{
							if (Main.tile[num4, num5].active() && TileID.Sets.Hallow[Main.tile[num4, num5].type])
							{
								flag = true;
								break;
							}
						}
						if (flag)
						{
							break;
						}
					}
					break;
				}
				case 1:
				{
					for (int k = i - wallDist; k < i + wallDist; k++)
					{
						for (int l = j - wallDist; l < j + wallDist; l++)
						{
							if (Main.tile[k, l].active() && TileID.Sets.Corrupt[Main.tile[k, l].type])
							{
								flag = true;
								break;
							}
						}
						if (flag)
						{
							break;
						}
					}
					break;
				}
				}
			}
			if (!flag)
			{
				return;
			}
			ushort? num6 = null;
			if (WallID.Sets.Conversion.Sandstone[Main.tile[num2, num3].wall])
			{
				switch (num)
				{
				case 3:
					num6 = 221;
					break;
				case 2:
					num6 = 222;
					break;
				case 1:
					num6 = 220;
					break;
				}
			}
			if (WallID.Sets.Conversion.HardenedSand[Main.tile[num2, num3].wall])
			{
				switch (num)
				{
				case 3:
					num6 = 218;
					break;
				case 2:
					num6 = 219;
					break;
				case 1:
					num6 = 217;
					break;
				}
			}
			if (num6.HasValue && Main.tile[num2, num3].wall != num6.Value)
			{
				Main.tile[num2, num3].wall = num6.Value;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, num2, num3, 3);
				}
			}
		}

		public static void PlaceWall(int i, int j, int type, bool mute = false)
		{
			if (i <= 1 || j <= 1 || i >= Main.maxTilesX - 2 || j >= Main.maxTilesY - 2)
			{
				return;
			}
			if (Main.tile[i, j] == null)
			{
				Main.tile[i, j] = new Tile();
			}
			if (Main.tile[i, j].wall == 0)
			{
				Main.tile[i, j].wall = (ushort)type;
				SquareWallFrame(i, j);
				if (!mute)
				{
					SoundEngine.PlaySound(0, i * 16, j * 16);
				}
			}
		}

		public static void SpreadGrass(int i, int j, int dirt = 0, int grass = 2, bool repeat = true, byte color = 0)
		{
			try
			{
				if (!InWorld(i, j, 1))
				{
					return;
				}
				if (gen && (grass == 199 || grass == 23))
				{
					int num = beachDistance;
					if ((!((double)i > (double)Main.maxTilesX * 0.45) || !((double)i <= (double)Main.maxTilesX * 0.55)) && i >= num && i < Main.maxTilesX - num)
					{
						goto IL_00bc;
					}
				}
				else if ((!gen && (grass == 199 || grass == 23)) || (Main.tile[i, j].type == dirt && Main.tile[i, j].active() && (!((double)j >= Main.worldSurface) || dirt != 0)))
				{
					goto IL_00bc;
				}
				goto end_IL_0000;
				IL_00bc:
				int num2 = i - 1;
				int num3 = i + 2;
				int num4 = j - 1;
				int num5 = j + 2;
				if (num2 < 0)
				{
					num2 = 0;
				}
				if (num3 > Main.maxTilesX)
				{
					num3 = Main.maxTilesX;
				}
				if (num4 < 0)
				{
					num4 = 0;
				}
				if (num5 > Main.maxTilesY)
				{
					num5 = Main.maxTilesY;
				}
				bool flag = true;
				for (int k = num2; k < num3; k++)
				{
					for (int l = num4; l < num5; l++)
					{
						if (!Main.tile[k, l].active() || !Main.tileSolid[Main.tile[k, l].type])
						{
							flag = false;
						}
						if (Main.tile[k, l].lava() && Main.tile[k, l].liquid > 0)
						{
							flag = true;
							break;
						}
					}
				}
				if (flag || !TileID.Sets.CanBeClearedDuringGeneration[Main.tile[i, j].type] || (grass == 23 && Main.tile[i, j - 1].type == 27) || (grass == 199 && Main.tile[i, j - 1].type == 27) || (grass == 109 && Main.tile[i, j - 1].type == 27))
				{
					return;
				}
				Main.tile[i, j].type = (ushort)grass;
				Main.tile[i, j].color(color);
				for (int m = num2; m < num3; m++)
				{
					for (int n = num4; n < num5; n++)
					{
						if (!Main.tile[m, n].active() || Main.tile[m, n].type != dirt)
						{
							continue;
						}
						try
						{
							if (repeat && grassSpread < 1000)
							{
								grassSpread++;
								SpreadGrass(m, n, dirt, grass, repeat: true, 0);
								grassSpread--;
							}
						}
						catch
						{
						}
					}
				}
				end_IL_0000:;
			}
			catch
			{
			}
		}

		public static void ChasmRunnerSideways(int i, int j, int direction, int steps)
		{
			float num = steps;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(10, 21) * 0.1f * (float)direction;
			vector2.Y = (float)genRand.Next(-10, 10) * 0.01f;
			double num2 = genRand.Next(5) + 7;
			while (num2 > 0.0)
			{
				if (num > 0f)
				{
					num2 += (double)genRand.Next(3);
					num2 -= (double)genRand.Next(3);
					if (num2 < 7.0)
					{
						num2 = 7.0;
					}
					if (num2 > 20.0)
					{
						num2 = 20.0;
					}
					if (num == 1f && num2 < 10.0)
					{
						num2 = 10.0;
					}
				}
				else
				{
					num2 -= (double)genRand.Next(4);
				}
				if ((double)vector.Y > Main.rockLayer && num > 0f)
				{
					num = 0f;
				}
				num -= 1f;
				int num3 = (int)((double)vector.X - num2 * 0.5);
				int num4 = (int)((double)vector.X + num2 * 0.5);
				int num5 = (int)((double)vector.Y - num2 * 0.5);
				int num6 = (int)((double)vector.Y + num2 * 0.5);
				if (num3 < 0)
				{
					num3 = 0;
				}
				if (num4 > Main.maxTilesX - 1)
				{
					num4 = Main.maxTilesX - 1;
				}
				if (num5 < 0)
				{
					num5 = 0;
				}
				if (num6 > Main.maxTilesY)
				{
					num6 = Main.maxTilesY;
				}
				for (int k = num3; k < num4; k++)
				{
					for (int l = num5; l < num6; l++)
					{
						if ((double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < num2 * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[k, l].type != 31 && Main.tile[k, l].type != 22)
						{
							Main.tile[k, l].active(active: false);
						}
					}
				}
				vector += vector2;
				vector2.Y += (float)genRand.Next(-10, 10) * 0.1f;
				if (vector.Y < (float)(j - 20))
				{
					vector2.Y += (float)genRand.Next(20) * 0.01f;
				}
				if (vector.Y > (float)(j + 20))
				{
					vector2.Y -= (float)genRand.Next(20) * 0.01f;
				}
				if ((double)vector2.Y < -0.5)
				{
					vector2.Y = -0.5f;
				}
				if ((double)vector2.Y > 0.5)
				{
					vector2.Y = 0.5f;
				}
				vector2.X += (float)genRand.Next(-10, 11) * 0.01f;
				switch (direction)
				{
				case -1:
					if ((double)vector2.X > -0.5)
					{
						vector2.X = -0.5f;
					}
					if (vector2.X < -2f)
					{
						vector2.X = -2f;
					}
					break;
				case 1:
					if ((double)vector2.X < 0.5)
					{
						vector2.X = 0.5f;
					}
					if (vector2.X > 2f)
					{
						vector2.X = 2f;
					}
					break;
				}
				num3 = (int)((double)vector.X - num2 * 1.1);
				num4 = (int)((double)vector.X + num2 * 1.1);
				num5 = (int)((double)vector.Y - num2 * 1.1);
				num6 = (int)((double)vector.Y + num2 * 1.1);
				if (num3 < 1)
				{
					num3 = 1;
				}
				if (num4 > Main.maxTilesX - 1)
				{
					num4 = Main.maxTilesX - 1;
				}
				if (num5 < 0)
				{
					num5 = 0;
				}
				if (num6 > Main.maxTilesY)
				{
					num6 = Main.maxTilesY;
				}
				for (int m = num3; m < num4; m++)
				{
					for (int n = num5; n < num6; n++)
					{
						if ((double)(Math.Abs((float)m - vector.X) + Math.Abs((float)n - vector.Y)) < num2 * 1.1 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[m, n].wall != 3)
						{
							if (Main.tile[m, n].type != 25 && n > j + genRand.Next(3, 20))
							{
								Main.tile[m, n].active(active: true);
							}
							Main.tile[m, n].active(active: true);
							if (Main.tile[m, n].type != 31 && Main.tile[m, n].type != 22)
							{
								Main.tile[m, n].type = 25;
							}
							if (Main.tile[m, n].wall == 2)
							{
								Main.tile[m, n].wall = 0;
							}
						}
					}
				}
				for (int num7 = num3; num7 < num4; num7++)
				{
					for (int num8 = num5; num8 < num6; num8++)
					{
						if ((double)(Math.Abs((float)num7 - vector.X) + Math.Abs((float)num8 - vector.Y)) < num2 * 1.1 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[num7, num8].wall != 3)
						{
							if (Main.tile[num7, num8].type != 31 && Main.tile[num7, num8].type != 22)
							{
								Main.tile[num7, num8].type = 25;
							}
							Main.tile[num7, num8].active(active: true);
							PlaceWall(num7, num8, 3, mute: true);
						}
					}
				}
			}
			if (genRand.Next(3) == 0)
			{
				int num9 = (int)vector.X;
				int num10;
				for (num10 = (int)vector.Y; !Main.tile[num9, num10].active(); num10++)
				{
				}
				TileRunner(num9, num10, genRand.Next(2, 6), genRand.Next(3, 7), 22);
			}
		}

		public static void CrimStart(int i, int j)
		{
			int crimDir = 1;
			int k = j;
			if ((double)k > Main.worldSurface)
			{
				k = (int)Main.worldSurface;
			}
			for (; !SolidTile(i, k); k++)
			{
			}
			int num = k;
			Vector2 position = new Vector2(i, k);
			Vector2 vector = new Vector2((float)genRand.Next(-20, 21) * 0.1f, (float)genRand.Next(20, 201) * 0.01f);
			if (vector.X < 0f)
			{
				crimDir = -1;
			}
			float num2 = genRand.Next(15, 26);
			bool flag = true;
			int num3 = 0;
			while (flag)
			{
				num2 += (float)genRand.Next(-50, 51) * 0.01f;
				if (num2 < 15f)
				{
					num2 = 15f;
				}
				if (num2 > 25f)
				{
					num2 = 25f;
				}
				for (int l = (int)(position.X - num2 / 2f); (float)l < position.X + num2 / 2f; l++)
				{
					for (int m = (int)(position.Y - num2 / 2f); (float)m < position.Y + num2 / 2f; m++)
					{
						if (m > num)
						{
							if ((double)(Math.Abs((float)l - position.X) + Math.Abs((float)m - position.Y)) < (double)num2 * 0.3)
							{
								Main.tile[l, m].active(active: false);
								Main.tile[l, m].wall = 83;
							}
							else if ((double)(Math.Abs((float)l - position.X) + Math.Abs((float)m - position.Y)) < (double)num2 * 0.8 && Main.tile[l, m].wall != 83)
							{
								Main.tile[l, m].active(active: true);
								Main.tile[l, m].type = 203;
								if ((double)(Math.Abs((float)l - position.X) + Math.Abs((float)m - position.Y)) < (double)num2 * 0.6)
								{
									Main.tile[l, m].wall = 83;
								}
							}
						}
						else if ((double)(Math.Abs((float)l - position.X) + Math.Abs((float)m - position.Y)) < (double)num2 * 0.3 && Main.tile[l, m].active())
						{
							Main.tile[l, m].active(active: false);
							Main.tile[l, m].wall = 83;
						}
					}
				}
				if (position.X > (float)(i + 50))
				{
					num3 = -100;
				}
				if (position.X < (float)(i - 50))
				{
					num3 = 100;
				}
				if (num3 < 0)
				{
					vector.X -= (float)genRand.Next(20, 51) * 0.01f;
				}
				else if (num3 > 0)
				{
					vector.X += (float)genRand.Next(20, 51) * 0.01f;
				}
				else
				{
					vector.X += (float)genRand.Next(-50, 51) * 0.01f;
				}
				vector.Y += (float)genRand.Next(-50, 51) * 0.01f;
				if ((double)vector.Y < 0.25)
				{
					vector.Y = 0.25f;
				}
				if (vector.Y > 2f)
				{
					vector.Y = 2f;
				}
				if (vector.X < -2f)
				{
					vector.X = -2f;
				}
				if (vector.X > 2f)
				{
					vector.X = 2f;
				}
				position += vector;
				if ((double)position.Y > Main.worldSurface + 100.0)
				{
					flag = false;
				}
			}
			num2 = genRand.Next(40, 55);
			for (int n = 0; n < 50; n++)
			{
				int num4 = (int)position.X + genRand.Next(-20, 21);
				int num5 = (int)position.Y + genRand.Next(-20, 21);
				for (int num6 = (int)((float)num4 - num2 / 2f); (float)num6 < (float)num4 + num2 / 2f; num6++)
				{
					for (int num7 = (int)((float)num5 - num2 / 2f); (float)num7 < (float)num5 + num2 / 2f; num7++)
					{
						float num8 = Math.Abs(num6 - num4);
						float num9 = Math.Abs(num7 - num5);
						float num10 = 1f + (float)genRand.Next(-20, 21) * 0.01f;
						float num11 = 1f + (float)genRand.Next(-20, 21) * 0.01f;
						float num12 = num8 * num10;
						num9 *= num11;
						double num13 = Math.Sqrt(num12 * num12 + num9 * num9);
						if (num13 < (double)num2 * 0.25)
						{
							Main.tile[num6, num7].active(active: false);
							Main.tile[num6, num7].wall = 83;
						}
						else if (num13 < (double)num2 * 0.4 && Main.tile[num6, num7].wall != 83)
						{
							Main.tile[num6, num7].active(active: true);
							Main.tile[num6, num7].type = 203;
							if (num13 < (double)num2 * 0.35)
							{
								Main.tile[num6, num7].wall = 83;
							}
						}
					}
				}
			}
			int num14 = genRand.Next(5, 9);
			Vector2[] array = new Vector2[num14];
			for (int num15 = 0; num15 < num14; num15++)
			{
				int num16 = (int)position.X;
				int num17 = (int)position.Y;
				int num18 = 0;
				bool flag2 = true;
				Vector2 vector2 = new Vector2((float)genRand.Next(-20, 21) * 0.15f, (float)genRand.Next(0, 21) * 0.15f);
				while (flag2)
				{
					vector2 = new Vector2((float)genRand.Next(-20, 21) * 0.15f, (float)genRand.Next(0, 21) * 0.15f);
					while ((double)(Math.Abs(vector2.X) + Math.Abs(vector2.Y)) < 1.5)
					{
						vector2 = new Vector2((float)genRand.Next(-20, 21) * 0.15f, (float)genRand.Next(0, 21) * 0.15f);
					}
					flag2 = false;
					for (int num19 = 0; num19 < num15; num19++)
					{
						if ((double)vector.X > (double)array[num19].X - 0.75 && (double)vector.X < (double)array[num19].X + 0.75 && (double)vector.Y > (double)array[num19].Y - 0.75 && (double)vector.Y < (double)array[num19].Y + 0.75)
						{
							flag2 = true;
							num18++;
							break;
						}
					}
					if (num18 > 10000)
					{
						break;
					}
				}
				array[num15] = vector2;
				CrimVein(new Vector2(num16, num17), vector2);
			}
			int num20 = Main.maxTilesX;
			int num21 = 0;
			position.X = i;
			position.Y = num;
			num2 = genRand.Next(25, 35);
			float num22 = genRand.Next(0, 6);
			for (int num23 = 0; num23 < 50; num23++)
			{
				if (num22 > 0f)
				{
					float num24 = (float)genRand.Next(10, 30) * 0.01f;
					num22 -= num24;
					position.Y -= num24;
				}
				int num25 = (int)position.X + genRand.Next(-2, 3);
				int num26 = (int)position.Y + genRand.Next(-2, 3);
				for (int num27 = (int)((float)num25 - num2 / 2f); (float)num27 < (float)num25 + num2 / 2f; num27++)
				{
					for (int num28 = (int)((float)num26 - num2 / 2f); (float)num28 < (float)num26 + num2 / 2f; num28++)
					{
						float num29 = Math.Abs(num27 - num25);
						float num30 = Math.Abs(num28 - num26);
						float num31 = 1f + (float)genRand.Next(-20, 21) * 0.005f;
						float num32 = 1f + (float)genRand.Next(-20, 21) * 0.005f;
						float num33 = num29 * num31;
						num30 *= num32;
						double num34 = Math.Sqrt(num33 * num33 + num30 * num30);
						if (num34 < (double)num2 * 0.2 * ((double)genRand.Next(90, 111) * 0.01))
						{
							Main.tile[num27, num28].active(active: false);
							Main.tile[num27, num28].wall = 83;
						}
						else
						{
							if (!(num34 < (double)num2 * 0.45))
							{
								continue;
							}
							if (num27 < num20)
							{
								num20 = num27;
							}
							if (num27 > num21)
							{
								num21 = num27;
							}
							if (Main.tile[num27, num28].wall != 83)
							{
								Main.tile[num27, num28].active(active: true);
								Main.tile[num27, num28].type = 203;
								if (num34 < (double)num2 * 0.35)
								{
									Main.tile[num27, num28].wall = 83;
								}
							}
						}
					}
				}
			}
			for (int num35 = num20; num35 <= num21; num35++)
			{
				int num36;
				for (num36 = num; (Main.tile[num35, num36].type == 203 && Main.tile[num35, num36].active()) || Main.tile[num35, num36].wall == 83; num36++)
				{
				}
				int num37 = genRand.Next(15, 20);
				for (; !Main.tile[num35, num36].active(); num36++)
				{
					if (num37 <= 0)
					{
						break;
					}
					if (Main.tile[num35, num36].wall == 83)
					{
						break;
					}
					num37--;
					Main.tile[num35, num36].type = 203;
					Main.tile[num35, num36].active(active: true);
				}
			}
			CrimEnt(position, crimDir);
		}

		public static void CrimPlaceHearts()
		{
			int num = 16;
			for (int i = 0; i < heartCount; i++)
			{
				num = genRand.Next(16, 21);
				int num2 = (int)heartPos[i].X;
				int num3 = (int)heartPos[i].Y;
				for (int j = num2 - num / 2; j < num2 + num / 2; j++)
				{
					for (int k = num3 - num / 2; k < num3 + num / 2; k++)
					{
						float num4 = Math.Abs(j - num2);
						float num5 = Math.Abs(k - num3);
						if (Math.Sqrt(num4 * num4 + num5 * num5) < (double)num * 0.4)
						{
							Main.tile[j, k].active(active: true);
							Main.tile[j, k].type = 203;
							Main.tile[j, k].wall = 83;
						}
					}
				}
			}
			for (int l = 0; l < heartCount; l++)
			{
				num = genRand.Next(10, 14);
				int num6 = (int)heartPos[l].X;
				int num7 = (int)heartPos[l].Y;
				for (int m = num6 - num / 2; m < num6 + num / 2; m++)
				{
					for (int n = num7 - num / 2; n < num7 + num / 2; n++)
					{
						float num8 = Math.Abs(m - num6);
						float num9 = Math.Abs(n - num7);
						if (Math.Sqrt(num8 * num8 + num9 * num9) < (double)num * 0.3)
						{
							Main.tile[m, n].active(active: false);
							Main.tile[m, n].wall = 83;
						}
					}
				}
			}
			for (int num10 = 0; num10 < heartCount; num10++)
			{
				AddShadowOrb((int)heartPos[num10].X, (int)heartPos[num10].Y);
			}
		}

		public static void CrimEnt(Vector2 position, int crimDir)
		{
			float num = 0f;
			float num2 = genRand.Next(6, 11);
			bool flag = true;
			Vector2 vector = new Vector2(2f, (float)genRand.Next(-20, 0) * 0.01f);
			vector.X *= -crimDir;
			while (flag)
			{
				num += 1f;
				if (num >= 20f)
				{
					flag = false;
				}
				num2 += (float)genRand.Next(-10, 11) * 0.02f;
				if (num2 < 6f)
				{
					num2 = 6f;
				}
				if (num2 > 10f)
				{
					num2 = 10f;
				}
				for (int i = (int)(position.X - num2 / 2f); (float)i < position.X + num2 / 2f; i++)
				{
					for (int j = (int)(position.Y - num2 / 2f); (float)j < position.Y + num2 / 2f; j++)
					{
						float num3 = Math.Abs((float)i - position.X);
						float num4 = Math.Abs((float)j - position.Y);
						if (Math.Sqrt(num3 * num3 + num4 * num4) < (double)num2 * 0.5 && Main.tile[i, j].active() && Main.tile[i, j].type == 203)
						{
							Main.tile[i, j].active(active: false);
							flag = true;
							num = 0f;
						}
					}
				}
				position += vector;
			}
		}

		public static void CrimVein(Vector2 position, Vector2 velocity)
		{
			float num = genRand.Next(15, 26);
			bool flag = true;
			Vector2 vector = velocity;
			Vector2 vector2 = position;
			int num2 = genRand.Next(100, 150);
			if (velocity.Y < 0f)
			{
				num2 -= 25;
			}
			while (flag)
			{
				num += (float)genRand.Next(-50, 51) * 0.02f;
				if (num < 15f)
				{
					num = 15f;
				}
				if (num > 25f)
				{
					num = 25f;
				}
				for (int i = (int)(position.X - num / 2f); (float)i < position.X + num / 2f; i++)
				{
					for (int j = (int)(position.Y - num / 2f); (float)j < position.Y + num / 2f; j++)
					{
						float num3 = Math.Abs((float)i - position.X);
						float num4 = Math.Abs((float)j - position.Y);
						double num5 = Math.Sqrt(num3 * num3 + num4 * num4);
						if (num5 < (double)num * 0.2)
						{
							Main.tile[i, j].active(active: false);
							Main.tile[i, j].wall = 83;
						}
						else if (num5 < (double)num * 0.5 && Main.tile[i, j].wall != 83)
						{
							Main.tile[i, j].active(active: true);
							Main.tile[i, j].type = 203;
							if (num5 < (double)num * 0.4)
							{
								Main.tile[i, j].wall = 83;
							}
						}
					}
				}
				velocity.X += (float)genRand.Next(-50, 51) * 0.05f;
				velocity.Y += (float)genRand.Next(-50, 51) * 0.05f;
				if ((double)velocity.Y < (double)vector.Y - 0.75)
				{
					velocity.Y = vector.Y - 0.75f;
				}
				if ((double)velocity.Y > (double)vector.Y + 0.75)
				{
					velocity.Y = vector.Y + 0.75f;
				}
				if ((double)velocity.X < (double)vector.X - 0.75)
				{
					velocity.X = vector.X - 0.75f;
				}
				if ((double)velocity.X > (double)vector.X + 0.75)
				{
					velocity.X = vector.X + 0.75f;
				}
				position += velocity;
				if (Math.Abs(position.X - vector2.X) + Math.Abs(position.Y - vector2.Y) > (float)num2)
				{
					flag = false;
				}
			}
			heartPos[heartCount] = position;
			heartCount++;
		}

		public static void ChasmRunner(int i, int j, int steps, bool makeOrb = false)
		{
			bool flag = false;
			bool flag2 = false;
			bool flag3 = false;
			if (!makeOrb)
			{
				flag2 = true;
			}
			float num = steps;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-10, 11) * 0.1f;
			vector2.Y = (float)genRand.Next(11) * 0.2f + 0.5f;
			int num2 = 5;
			double num3 = genRand.Next(5) + 7;
			while (num3 > 0.0)
			{
				if (num > 0f)
				{
					num3 += (double)genRand.Next(3);
					num3 -= (double)genRand.Next(3);
					if (num3 < 7.0)
					{
						num3 = 7.0;
					}
					if (num3 > 20.0)
					{
						num3 = 20.0;
					}
					if (num == 1f && num3 < 10.0)
					{
						num3 = 10.0;
					}
				}
				else if ((double)vector.Y > Main.worldSurface + 45.0)
				{
					num3 -= (double)genRand.Next(4);
				}
				if ((double)vector.Y > Main.rockLayer && num > 0f)
				{
					num = 0f;
				}
				num -= 1f;
				if (!flag && (double)vector.Y > Main.worldSurface + 20.0)
				{
					flag = true;
					ChasmRunnerSideways((int)vector.X, (int)vector.Y, -1, genRand.Next(20, 40));
					ChasmRunnerSideways((int)vector.X, (int)vector.Y, 1, genRand.Next(20, 40));
				}
				int num4;
				int num5;
				int num6;
				int num7;
				if (num > (float)num2)
				{
					num4 = (int)((double)vector.X - num3 * 0.5);
					num5 = (int)((double)vector.X + num3 * 0.5);
					num6 = (int)((double)vector.Y - num3 * 0.5);
					num7 = (int)((double)vector.Y + num3 * 0.5);
					if (num4 < 0)
					{
						num4 = 0;
					}
					if (num5 > Main.maxTilesX - 1)
					{
						num5 = Main.maxTilesX - 1;
					}
					if (num6 < 0)
					{
						num6 = 0;
					}
					if (num7 > Main.maxTilesY)
					{
						num7 = Main.maxTilesY;
					}
					for (int k = num4; k < num5; k++)
					{
						for (int l = num6; l < num7; l++)
						{
							if ((double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < num3 * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[k, l].type != 31 && Main.tile[k, l].type != 22)
							{
								Main.tile[k, l].active(active: false);
							}
						}
					}
				}
				if (num <= 2f && (double)vector.Y < Main.worldSurface + 45.0)
				{
					num = 2f;
				}
				if (num <= 0f)
				{
					if (!flag2)
					{
						flag2 = true;
						AddShadowOrb((int)vector.X, (int)vector.Y);
					}
					else if (!flag3)
					{
						flag3 = false;
						bool flag4 = false;
						int num8 = 0;
						while (!flag4)
						{
							int num9 = genRand.Next((int)vector.X - 25, (int)vector.X + 25);
							int num10 = genRand.Next((int)vector.Y - 50, (int)vector.Y);
							if (num9 < 5)
							{
								num9 = 5;
							}
							if (num9 > Main.maxTilesX - 5)
							{
								num9 = Main.maxTilesX - 5;
							}
							if (num10 < 5)
							{
								num10 = 5;
							}
							if (num10 > Main.maxTilesY - 5)
							{
								num10 = Main.maxTilesY - 5;
							}
							if ((double)num10 > Main.worldSurface)
							{
								if (!IsTileNearby(num9, num10, 26, 3))
								{
									Place3x2(num9, num10, 26);
								}
								if (Main.tile[num9, num10].type == 26)
								{
									flag4 = true;
									continue;
								}
								num8++;
								if (num8 >= 10000)
								{
									flag4 = true;
								}
							}
							else
							{
								flag4 = true;
							}
						}
					}
				}
				vector += vector2;
				vector2.X += (float)genRand.Next(-10, 11) * 0.01f;
				if ((double)vector2.X > 0.3)
				{
					vector2.X = 0.3f;
				}
				if ((double)vector2.X < -0.3)
				{
					vector2.X = -0.3f;
				}
				num4 = (int)((double)vector.X - num3 * 1.1);
				num5 = (int)((double)vector.X + num3 * 1.1);
				num6 = (int)((double)vector.Y - num3 * 1.1);
				num7 = (int)((double)vector.Y + num3 * 1.1);
				if (num4 < 1)
				{
					num4 = 1;
				}
				if (num5 > Main.maxTilesX - 1)
				{
					num5 = Main.maxTilesX - 1;
				}
				if (num6 < 0)
				{
					num6 = 0;
				}
				if (num7 > Main.maxTilesY)
				{
					num7 = Main.maxTilesY;
				}
				for (int m = num4; m < num5; m++)
				{
					for (int n = num6; n < num7; n++)
					{
						if ((double)(Math.Abs((float)m - vector.X) + Math.Abs((float)n - vector.Y)) < num3 * 1.1 * (1.0 + (double)genRand.Next(-10, 11) * 0.015))
						{
							if (Main.tile[m, n].type != 25 && n > j + genRand.Next(3, 20))
							{
								Main.tile[m, n].active(active: true);
							}
							if (steps <= num2)
							{
								Main.tile[m, n].active(active: true);
							}
							if (Main.tile[m, n].type != 31)
							{
								Main.tile[m, n].type = 25;
							}
						}
					}
				}
				for (int num11 = num4; num11 < num5; num11++)
				{
					for (int num12 = num6; num12 < num7; num12++)
					{
						if ((double)(Math.Abs((float)num11 - vector.X) + Math.Abs((float)num12 - vector.Y)) < num3 * 1.1 * (1.0 + (double)genRand.Next(-10, 11) * 0.015))
						{
							if (Main.tile[num11, num12].type != 31)
							{
								Main.tile[num11, num12].type = 25;
							}
							if (steps <= num2)
							{
								Main.tile[num11, num12].active(active: true);
							}
							if (num12 > j + genRand.Next(3, 20))
							{
								Main.tile[num11, num12].wall = 3;
							}
						}
					}
				}
			}
		}

		public static void GERunner(int i, int j, float speedX = 0f, float speedY = 0f, bool good = true)
		{
			int num = 0;
			for (int k = 20; k < Main.maxTilesX - 20; k++)
			{
				for (int l = 20; l < Main.maxTilesY - 20; l++)
				{
					if (Main.tile[k, l].active() && Main.tile[k, l].type == 225)
					{
						num++;
					}
				}
			}
			bool flag = false;
			if (num > 200000)
			{
				flag = true;
			}
			int num2 = genRand.Next(200, 250);
			float num3 = Main.maxTilesX / 4200;
			num2 = (int)((float)num2 * num3);
			double num4 = num2;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-10, 11) * 0.1f;
			vector2.Y = (float)genRand.Next(-10, 11) * 0.1f;
			if (speedX != 0f || speedY != 0f)
			{
				vector2.X = speedX;
				vector2.Y = speedY;
			}
			bool flag2 = true;
			while (flag2)
			{
				int num5 = (int)((double)vector.X - num4 * 0.5);
				int num6 = (int)((double)vector.X + num4 * 0.5);
				int num7 = (int)((double)vector.Y - num4 * 0.5);
				int num8 = (int)((double)vector.Y + num4 * 0.5);
				if (num5 < 0)
				{
					num5 = 0;
				}
				if (num6 > Main.maxTilesX)
				{
					num6 = Main.maxTilesX;
				}
				if (num7 < 0)
				{
					num7 = 0;
				}
				if (num8 > Main.maxTilesY - 5)
				{
					num8 = Main.maxTilesY - 5;
				}
				for (int m = num5; m < num6; m++)
				{
					for (int n = num7; n < num8; n++)
					{
						if (!((double)(Math.Abs((float)m - vector.X) + Math.Abs((float)n - vector.Y)) < (double)num2 * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015)))
						{
							continue;
						}
						if (good)
						{
							if (Main.tile[m, n].wall == 63 || Main.tile[m, n].wall == 65 || Main.tile[m, n].wall == 66 || Main.tile[m, n].wall == 68 || Main.tile[m, n].wall == 69 || Main.tile[m, n].wall == 81)
							{
								Main.tile[m, n].wall = 70;
							}
							else if (Main.tile[m, n].wall == 216)
							{
								Main.tile[m, n].wall = 219;
							}
							else if (Main.tile[m, n].wall == 187)
							{
								Main.tile[m, n].wall = 222;
							}
							if (Main.tile[m, n].wall == 3 || Main.tile[m, n].wall == 83)
							{
								Main.tile[m, n].wall = 28;
							}
							if (flag && Main.tile[m, n].type == 225)
							{
								Main.tile[m, n].type = 117;
								SquareTileFrame(m, n);
							}
							else if (flag && Main.tile[m, n].type == 230)
							{
								Main.tile[m, n].type = 402;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 2)
							{
								Main.tile[m, n].type = 109;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 1)
							{
								Main.tile[m, n].type = 117;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 53 || Main.tile[m, n].type == 123)
							{
								Main.tile[m, n].type = 116;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 23 || Main.tile[m, n].type == 199)
							{
								Main.tile[m, n].type = 109;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 25 || Main.tile[m, n].type == 203)
							{
								Main.tile[m, n].type = 117;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 112 || Main.tile[m, n].type == 234)
							{
								Main.tile[m, n].type = 116;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 161 || Main.tile[m, n].type == 163 || Main.tile[m, n].type == 200)
							{
								Main.tile[m, n].type = 164;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 396)
							{
								Main.tile[m, n].type = 403;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 397)
							{
								Main.tile[m, n].type = 402;
								SquareTileFrame(m, n);
							}
						}
						else if (crimson)
						{
							if (Main.tile[m, n].wall == 63 || Main.tile[m, n].wall == 65 || Main.tile[m, n].wall == 66 || Main.tile[m, n].wall == 68)
							{
								Main.tile[m, n].wall = 81;
							}
							else if (Main.tile[m, n].wall == 216)
							{
								Main.tile[m, n].wall = 218;
							}
							else if (Main.tile[m, n].wall == 187)
							{
								Main.tile[m, n].wall = 221;
							}
							if (flag && Main.tile[m, n].type == 225)
							{
								Main.tile[m, n].type = 203;
								SquareTileFrame(m, n);
							}
							else if (flag && Main.tile[m, n].type == 230)
							{
								Main.tile[m, n].type = 399;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 2)
							{
								Main.tile[m, n].type = 199;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 1)
							{
								Main.tile[m, n].type = 203;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 53 || Main.tile[m, n].type == 123)
							{
								Main.tile[m, n].type = 234;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 109)
							{
								Main.tile[m, n].type = 199;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 117)
							{
								Main.tile[m, n].type = 203;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 116)
							{
								Main.tile[m, n].type = 234;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 161 || Main.tile[m, n].type == 164)
							{
								Main.tile[m, n].type = 200;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 396)
							{
								Main.tile[m, n].type = 401;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 397)
							{
								Main.tile[m, n].type = 399;
								SquareTileFrame(m, n);
							}
						}
						else
						{
							if (Main.tile[m, n].wall == 63 || Main.tile[m, n].wall == 65 || Main.tile[m, n].wall == 66 || Main.tile[m, n].wall == 68)
							{
								Main.tile[m, n].wall = 69;
							}
							else if (Main.tile[m, n].wall == 216)
							{
								Main.tile[m, n].wall = 217;
							}
							else if (Main.tile[m, n].wall == 187)
							{
								Main.tile[m, n].wall = 220;
							}
							if (flag && Main.tile[m, n].type == 225)
							{
								Main.tile[m, n].type = 25;
								SquareTileFrame(m, n);
							}
							else if (flag && Main.tile[m, n].type == 230)
							{
								Main.tile[m, n].type = 398;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 2)
							{
								Main.tile[m, n].type = 23;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 1)
							{
								Main.tile[m, n].type = 25;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 53 || Main.tile[m, n].type == 123)
							{
								Main.tile[m, n].type = 112;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 109)
							{
								Main.tile[m, n].type = 23;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 117)
							{
								Main.tile[m, n].type = 25;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 116)
							{
								Main.tile[m, n].type = 112;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 161 || Main.tile[m, n].type == 164)
							{
								Main.tile[m, n].type = 163;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 396)
							{
								Main.tile[m, n].type = 400;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 397)
							{
								Main.tile[m, n].type = 398;
								SquareTileFrame(m, n);
							}
						}
					}
				}
				vector += vector2;
				vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
				if (vector2.X > speedX + 1f)
				{
					vector2.X = speedX + 1f;
				}
				if (vector2.X < speedX - 1f)
				{
					vector2.X = speedX - 1f;
				}
				if (vector.X < (float)(-num2) || vector.Y < (float)(-num2) || vector.X > (float)(Main.maxTilesX + num2) || vector.Y > (float)(Main.maxTilesY + num2))
				{
					flag2 = false;
				}
			}
		}

		private static bool badOceanCaveTiles(int x, int y)
		{
			if (Main.tile[x, y].wall == 83 || Main.tile[x, y].wall == 3 || Main.wallDungeon[Main.tile[x, y].wall] || Main.tile[x, y].type == 203 || Main.tile[x, y].type == 25 || Main.tileDungeon[Main.tile[x, y].type] || Main.tile[x, y].type == 26 || Main.tile[x, y].type == 31)
			{
				return true;
			}
			return false;
		}

		public static void oceanCave(int i, int j)
		{
			if (numOceanCaveTreasure >= maxOceanCaveTreasure)
			{
				numOceanCaveTreasure = 0;
			}
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			if (i < Main.maxTilesX / 2)
			{
				vector2.X = 0.25f + genRand.NextFloat() * 0.25f;
			}
			else
			{
				vector2.X = -0.35f - genRand.NextFloat() * 0.5f;
			}
			vector2.Y = 0.4f + genRand.NextFloat() * 0.25f;
			ushort num = 264;
			ushort num2 = 53;
			ushort num3 = 397;
			double num4 = genRand.Next(17, 25);
			double num5 = genRand.Next(600, 800);
			double num6 = 4.0;
			bool flag = true;
			while (num4 > num6 && num5 > 0.0)
			{
				bool flag2 = true;
				bool flag3 = true;
				bool flag4 = true;
				if (vector.X > (float)(beachDistance - 50) && vector.X < (float)(Main.maxTilesX - beachDistance + 50))
				{
					num4 *= 0.95999997854232788;
					num5 *= 0.95999997854232788;
				}
				if (num4 < num6 + 2.0 || num5 < 20.0)
				{
					flag4 = false;
				}
				if (flag)
				{
					num4 -= 0.01 + (double)genRand.NextFloat() * 0.01;
					num5 -= 0.5;
				}
				else
				{
					num4 -= 0.02 + (double)genRand.NextFloat() * 0.02;
					num5 -= 1.0;
				}
				if (flag4)
				{
					oceanCaveTreasure[numOceanCaveTreasure].X = (int)vector.X;
					oceanCaveTreasure[numOceanCaveTreasure].Y = (int)vector.Y;
				}
				int num7 = (int)((double)vector.X - num4 * 3.0);
				int num8 = (int)((double)vector.X + num4 * 3.0);
				int num9 = (int)((double)vector.Y - num4 * 3.0);
				int num10 = (int)((double)vector.Y + num4 * 3.0);
				if (num7 < 1)
				{
					num7 = 1;
				}
				if (num8 > Main.maxTilesX - 1)
				{
					num8 = Main.maxTilesX - 1;
				}
				if (num9 < 1)
				{
					num9 = 1;
				}
				if (num10 > Main.maxTilesY - 1)
				{
					num10 = Main.maxTilesY - 1;
				}
				for (int k = num7; k < num8; k++)
				{
					for (int l = num9; l < num10; l++)
					{
						if (badOceanCaveTiles(k, l))
						{
							continue;
						}
						float num11 = new Vector2(Math.Abs((float)k - vector.X), Math.Abs((float)l - vector.Y)).Length();
						if (flag4 && (double)num11 < num4 * 0.5 + 1.0)
						{
							Main.tile[k, l].type = num;
							Main.tile[k, l].active(active: false);
						}
						else if ((double)num11 < num4 * 1.5 + 1.0 && Main.tile[k, l].type != num)
						{
							if ((float)l < vector.Y)
							{
								if ((vector2.X < 0f && (float)k < vector.X) || (vector2.X > 0f && (float)k > vector.X))
								{
									if ((double)num11 < num4 * 1.1 + 1.0)
									{
										Main.tile[k, l].type = num3;
										if (Main.tile[k, l].liquid == byte.MaxValue)
										{
											Main.tile[k, l].wall = 0;
										}
									}
									else if (Main.tile[k, l].type != num3)
									{
										Main.tile[k, l].type = num2;
									}
								}
							}
							else if ((vector2.X < 0f && k < i) || (vector2.X > 0f && k > i))
							{
								if (Main.tile[k, l].liquid == byte.MaxValue)
								{
									Main.tile[k, l].wall = 0;
								}
								Main.tile[k, l].type = num2;
								Main.tile[k, l].active(active: true);
								if (k == (int)vector.X && flag2)
								{
									flag2 = false;
									int num12 = 50 + genRand.Next(3);
									int num13 = 43 + genRand.Next(3);
									int num14 = 20 + genRand.Next(3);
									int num15 = k;
									int num16 = k + num14;
									if (vector2.X < 0f)
									{
										num15 = k - num14;
										num16 = k;
									}
									if (num5 < 100.0)
									{
										num12 = (int)((double)(float)num12 * (num5 / 100.0));
										num13 = (int)((double)(float)num13 * (num5 / 100.0));
										num14 = (int)((double)(float)num14 * (num5 / 100.0));
									}
									if (num4 < num6 + 5.0)
									{
										double num17 = (num4 - num6) / 5.0;
										num12 = (int)((double)(float)num12 * num17);
										num13 = (int)((double)(float)num13 * num17);
										num14 = (int)((double)(float)num14 * num17);
									}
									for (int m = num15; m <= num16; m++)
									{
										for (int n = l; n < l + num12 && !badOceanCaveTiles(m, n); n++)
										{
											if (n > l + num13)
											{
												if (SolidTile(m, n) && Main.tile[m, n].type != num2)
												{
													break;
												}
												Main.tile[m, n].type = num3;
											}
											else
											{
												Main.tile[m, n].type = num2;
											}
											Main.tile[m, n].active(active: true);
											if (genRand.Next(3) == 0)
											{
												Main.tile[m - 1, n].type = num2;
												Main.tile[m - 1, n].active(active: true);
											}
											if (genRand.Next(3) == 0)
											{
												Main.tile[m + 1, n].type = num2;
												Main.tile[m + 1, n].active(active: true);
											}
										}
									}
								}
							}
						}
						if ((double)num11 < num4 * 1.3 + 1.0 && l > j - 10)
						{
							Main.tile[k, l].liquid = byte.MaxValue;
						}
						if (!flag3 || k != (int)vector.X || !((float)l > vector.Y))
						{
							continue;
						}
						flag3 = false;
						int num18 = 100;
						int num19 = 2;
						for (int num20 = k - num19; num20 <= k + num19; num20++)
						{
							for (int num21 = l; num21 < l + num18; num21++)
							{
								if (!badOceanCaveTiles(num20, num21))
								{
									Main.tile[num20, num21].liquid = byte.MaxValue;
								}
							}
						}
					}
				}
				vector += vector2;
				vector2.X += genRand.NextFloat() * 0.1f - 0.05f;
				vector2.Y += genRand.NextFloat() * 0.1f - 0.05f;
				if (flag)
				{
					if ((double)vector.Y > (Main.worldSurface * 2.0 + Main.rockLayer) / 3.0 && vector.Y > (float)(j + 30))
					{
						flag = false;
					}
					vector2.Y = MathHelper.Clamp(vector2.Y, 0.35f, 1f);
				}
				else
				{
					if (vector.X < (float)(Main.maxTilesX / 2))
					{
						if (vector2.X < 0.5f)
						{
							vector2.X += 0.02f;
						}
					}
					else if (vector2.X > -0.5f)
					{
						vector2.X -= 0.02f;
					}
					if (!flag4)
					{
						if (vector2.Y < 0f)
						{
							vector2.Y *= 0.95f;
						}
						vector2.Y += 0.04f;
					}
					else if ((double)vector.Y < (Main.worldSurface * 4.0 + Main.rockLayer) / 5.0)
					{
						if (vector2.Y < 0f)
						{
							vector2.Y *= 0.97f;
						}
						vector2.Y += 0.02f;
					}
					else if (vector2.Y > -0.1f)
					{
						vector2.Y *= 0.99f;
						vector2.Y -= 0.01f;
					}
					vector2.Y = MathHelper.Clamp(vector2.Y, -1f, 1f);
				}
				if (vector.X < (float)(Main.maxTilesX / 2))
				{
					vector2.X = MathHelper.Clamp(vector2.X, 0.1f, 1f);
				}
				else
				{
					vector2.X = MathHelper.Clamp(vector2.X, -1f, -0.1f);
				}
			}
			numOceanCaveTreasure++;
		}

		public static void TileRunner(int i, int j, double strength, int steps, int type, bool addTile = false, float speedX = 0f, float speedY = 0f, bool noYChange = false, bool overRide = true, int ignoreTileType = -1)
		{
			if (drunkWorldGen)
			{
				strength *= (double)(1f + (float)genRand.Next(-80, 81) * 0.01f);
				steps = (int)((float)steps * (1f + (float)genRand.Next(-80, 81) * 0.01f));
			}
			if (getGoodWorldGen && type != 57)
			{
				strength *= (double)(1f + (float)genRand.Next(-80, 81) * 0.015f);
				steps += genRand.Next(3);
			}
			double num = strength;
			float num2 = steps;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-10, 11) * 0.1f;
			vector2.Y = (float)genRand.Next(-10, 11) * 0.1f;
			if (speedX != 0f || speedY != 0f)
			{
				vector2.X = speedX;
				vector2.Y = speedY;
			}
			bool flag = type == 368;
			bool flag2 = type == 367;
			bool lava = false;
			if (getGoodWorldGen && genRand.Next(4) == 0)
			{
				lava = true;
			}
			while (num > 0.0 && num2 > 0f)
			{
				if (drunkWorldGen && genRand.Next(30) == 0)
				{
					vector.X += (float)genRand.Next(-100, 101) * 0.05f;
					vector.Y += (float)genRand.Next(-100, 101) * 0.05f;
				}
				if (vector.Y < 0f && num2 > 0f && type == 59)
				{
					num2 = 0f;
				}
				num = strength * (double)(num2 / (float)steps);
				num2 -= 1f;
				int num3 = (int)((double)vector.X - num * 0.5);
				int num4 = (int)((double)vector.X + num * 0.5);
				int num5 = (int)((double)vector.Y - num * 0.5);
				int num6 = (int)((double)vector.Y + num * 0.5);
				if (num3 < 1)
				{
					num3 = 1;
				}
				if (num4 > Main.maxTilesX - 1)
				{
					num4 = Main.maxTilesX - 1;
				}
				if (num5 < 1)
				{
					num5 = 1;
				}
				if (num6 > Main.maxTilesY - 1)
				{
					num6 = Main.maxTilesY - 1;
				}
				for (int k = num3; k < num4; k++)
				{
					if (k < beachDistance + 50 || k >= Main.maxTilesX - beachDistance - 50)
					{
						lava = false;
					}
					for (int l = num5; l < num6; l++)
					{
						if ((drunkWorldGen && l < Main.maxTilesY - 300 && type == 57) || (ignoreTileType >= 0 && Main.tile[k, l].active() && Main.tile[k, l].type == ignoreTileType) || !((double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < strength * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015)))
						{
							continue;
						}
						if (mudWall && (double)l > Main.worldSurface && Main.tile[k, l - 1].wall != 2 && l < Main.maxTilesY - 210 - genRand.Next(3) && (double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < strength * 0.45 * (1.0 + (double)genRand.Next(-10, 11) * 0.01))
						{
							if (l > lavaLine - genRand.Next(0, 4) - 50)
							{
								if (Main.tile[k, l - 1].wall != 64 && Main.tile[k, l + 1].wall != 64 && Main.tile[k - 1, l].wall != 64 && Main.tile[k, l + 1].wall != 64)
								{
									PlaceWall(k, l, 15, mute: true);
								}
							}
							else if (Main.tile[k, l - 1].wall != 15 && Main.tile[k, l + 1].wall != 15 && Main.tile[k - 1, l].wall != 15 && Main.tile[k, l + 1].wall != 15)
							{
								PlaceWall(k, l, 64, mute: true);
							}
						}
						if (type < 0)
						{
							if (Main.tile[k, l].type == 53)
							{
								continue;
							}
							if (type == -2 && Main.tile[k, l].active() && (l < waterLine || l > lavaLine))
							{
								Main.tile[k, l].liquid = byte.MaxValue;
								Main.tile[k, l].lava(lava);
								if (l > lavaLine)
								{
									Main.tile[k, l].lava(lava: true);
								}
							}
							Main.tile[k, l].active(active: false);
							continue;
						}
						if (flag && (double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < strength * 0.3 * (1.0 + (double)genRand.Next(-10, 11) * 0.01))
						{
							PlaceWall(k, l, 180, mute: true);
						}
						if (flag2 && (double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < strength * 0.3 * (1.0 + (double)genRand.Next(-10, 11) * 0.01))
						{
							PlaceWall(k, l, 178, mute: true);
						}
						if (overRide || !Main.tile[k, l].active())
						{
							Tile tile = Main.tile[k, l];
							bool flag3 = false;
							flag3 = Main.tileStone[type] && tile.type != 1;
							if (!TileID.Sets.CanBeClearedDuringGeneration[tile.type])
							{
								flag3 = true;
							}
							switch (tile.type)
							{
							case 53:
								if (type == 59 && UndergroundDesertLocation.Contains(k, l))
								{
									flag3 = true;
								}
								if (type == 40)
								{
									flag3 = true;
								}
								if ((double)l < Main.worldSurface && type != 59)
								{
									flag3 = true;
								}
								break;
							case 45:
							case 147:
							case 189:
							case 190:
							case 196:
							case 460:
								flag3 = true;
								break;
							case 396:
							case 397:
								flag3 = !TileID.Sets.Ore[type];
								break;
							case 1:
								if (type == 59 && (double)l < Main.worldSurface + (double)genRand.Next(-50, 50))
								{
									flag3 = true;
								}
								break;
							case 367:
							case 368:
								if (type == 59)
								{
									flag3 = true;
								}
								break;
							}
							if (!flag3)
							{
								tile.type = (ushort)type;
							}
						}
						if (addTile)
						{
							Main.tile[k, l].active(active: true);
							Main.tile[k, l].liquid = 0;
							Main.tile[k, l].lava(lava: false);
						}
						if (noYChange && (double)l < Main.worldSurface && type != 59)
						{
							Main.tile[k, l].wall = 2;
						}
						if (type == 59 && l > waterLine && Main.tile[k, l].liquid > 0)
						{
							Main.tile[k, l].lava(lava: false);
							Main.tile[k, l].liquid = 0;
						}
					}
				}
				vector += vector2;
				if ((!drunkWorldGen || genRand.Next(3) != 0) && num > 50.0)
				{
					vector += vector2;
					num2 -= 1f;
					vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
					vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
					if (num > 100.0)
					{
						vector += vector2;
						num2 -= 1f;
						vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
						vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
						if (num > 150.0)
						{
							vector += vector2;
							num2 -= 1f;
							vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
							vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
							if (num > 200.0)
							{
								vector += vector2;
								num2 -= 1f;
								vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
								vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
								if (num > 250.0)
								{
									vector += vector2;
									num2 -= 1f;
									vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
									vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
									if (num > 300.0)
									{
										vector += vector2;
										num2 -= 1f;
										vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
										vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
										if (num > 400.0)
										{
											vector += vector2;
											num2 -= 1f;
											vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
											vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
											if (num > 500.0)
											{
												vector += vector2;
												num2 -= 1f;
												vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
												vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
												if (num > 600.0)
												{
													vector += vector2;
													num2 -= 1f;
													vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
													vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
													if (num > 700.0)
													{
														vector += vector2;
														num2 -= 1f;
														vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
														vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
														if (num > 800.0)
														{
															vector += vector2;
															num2 -= 1f;
															vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
															vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
															if (num > 900.0)
															{
																vector += vector2;
																num2 -= 1f;
																vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
																vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
				if (drunkWorldGen)
				{
					vector2.X += (float)genRand.Next(-10, 11) * 0.25f;
				}
				if (vector2.X > 1f)
				{
					vector2.X = 1f;
				}
				if (vector2.X < -1f)
				{
					vector2.X = -1f;
				}
				if (!noYChange)
				{
					vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
					if (vector2.Y > 1f)
					{
						vector2.Y = 1f;
					}
					if (vector2.Y < -1f)
					{
						vector2.Y = -1f;
					}
				}
				else if (type != 59 && num < 3.0)
				{
					if (vector2.Y > 1f)
					{
						vector2.Y = 1f;
					}
					if (vector2.Y < -1f)
					{
						vector2.Y = -1f;
					}
				}
				if (type == 59 && !noYChange)
				{
					if ((double)vector2.Y > 0.5)
					{
						vector2.Y = 0.5f;
					}
					if ((double)vector2.Y < -0.5)
					{
						vector2.Y = -0.5f;
					}
					if ((double)vector.Y < Main.rockLayer + 100.0)
					{
						vector2.Y = 1f;
					}
					if (vector.Y > (float)(Main.maxTilesY - 300))
					{
						vector2.Y = -1f;
					}
				}
			}
		}

		public static void DirtyRockRunner(int i, int j)
		{
			double num = genRand.Next(2, 6);
			float num2 = genRand.Next(5, 50);
			float num3 = num2;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-10, 11) * 0.1f;
			vector2.Y = (float)genRand.Next(-10, 11) * 0.1f;
			while (num > 0.0 && num3 > 0f)
			{
				double num4 = num * (double)(num3 / num2);
				num3 -= 1f;
				int num5 = (int)((double)vector.X - num4 * 0.5);
				int num6 = (int)((double)vector.X + num4 * 0.5);
				int num7 = (int)((double)vector.Y - num4 * 0.5);
				int num8 = (int)((double)vector.Y + num4 * 0.5);
				if (num5 < 0)
				{
					num5 = 0;
				}
				if (num6 > Main.maxTilesX)
				{
					num6 = Main.maxTilesX;
				}
				if (num7 < 0)
				{
					num7 = 0;
				}
				if (num8 > Main.maxTilesY)
				{
					num8 = Main.maxTilesY;
				}
				for (int k = num5; k < num6; k++)
				{
					for (int l = num7; l < num8; l++)
					{
						if ((double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < num * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[k, l].wall == 2)
						{
							Main.tile[k, l].wall = 59;
						}
					}
				}
				vector += vector2;
				vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
				if (vector2.X > 1f)
				{
					vector2.X = 1f;
				}
				if (vector2.X < -1f)
				{
					vector2.X = -1f;
				}
				vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
				if (vector2.Y > 1f)
				{
					vector2.Y = 1f;
				}
				if (vector2.Y < -1f)
				{
					vector2.Y = -1f;
				}
			}
		}

		public static void MudWallRunner(int i, int j)
		{
			double num = genRand.Next(8, 21);
			float num2 = genRand.Next(8, 33);
			float num3 = num2;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-10, 11) * 0.1f;
			vector2.Y = (float)genRand.Next(-10, 11) * 0.1f;
			while (num > 0.0 && num3 > 0f)
			{
				double num4 = num * (double)(num3 / num2);
				num3 -= 1f;
				int num5 = (int)((double)vector.X - num4 * 0.5);
				int num6 = (int)((double)vector.X + num4 * 0.5);
				int num7 = (int)((double)vector.Y - num4 * 0.5);
				int num8 = (int)((double)vector.Y + num4 * 0.5);
				if (num5 < 0)
				{
					num5 = 0;
				}
				if (num6 > Main.maxTilesX)
				{
					num6 = Main.maxTilesX;
				}
				if (num7 < 0)
				{
					num7 = 0;
				}
				if (num8 > Main.maxTilesY)
				{
					num8 = Main.maxTilesY;
				}
				for (int k = num5; k < num6; k++)
				{
					for (int l = num7; l < num8; l++)
					{
						if ((double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < num * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && (double)l > Main.worldSurface)
						{
							Main.tile[k, l].wall = 0;
						}
					}
				}
				vector += vector2;
				vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
				if (vector2.X > 1f)
				{
					vector2.X = 1f;
				}
				if (vector2.X < -1f)
				{
					vector2.X = -1f;
				}
				vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
				if (vector2.Y > 1f)
				{
					vector2.Y = 1f;
				}
				if (vector2.Y < -1f)
				{
					vector2.Y = -1f;
				}
			}
		}

		public static void SnowCloudIsland(int i, int j)
		{
			double num = genRand.Next(100, 150);
			double num2 = num;
			float num3 = genRand.Next(20, 30);
			int num4 = i;
			int num5 = i;
			int num6 = i;
			int num7 = j;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			while (vector2.X > -2f && vector2.X < 2f)
			{
				vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			}
			vector2.Y = (float)genRand.Next(-20, -10) * 0.02f;
			while (num > 0.0 && num3 > 0f)
			{
				num -= (double)genRand.Next(4);
				num3 -= 1f;
				int num8 = (int)((double)vector.X - num * 0.5);
				int num9 = (int)((double)vector.X + num * 0.5);
				int num10 = (int)((double)vector.Y - num * 0.5);
				int num11 = (int)((double)vector.Y + num * 0.5);
				if (num8 < 0)
				{
					num8 = 0;
				}
				if (num9 > Main.maxTilesX)
				{
					num9 = Main.maxTilesX;
				}
				if (num10 < 0)
				{
					num10 = 0;
				}
				if (num11 > Main.maxTilesY)
				{
					num11 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				float num12 = vector.Y + 1f;
				for (int k = num8; k < num9; k++)
				{
					if (genRand.Next(2) == 0)
					{
						num12 += (float)genRand.Next(-1, 2);
					}
					if (num12 < vector.Y)
					{
						num12 = vector.Y;
					}
					if (num12 > vector.Y + 2f)
					{
						num12 = vector.Y + 2f;
					}
					for (int l = num10; l < num11; l++)
					{
						if (!((float)l > num12))
						{
							continue;
						}
						float num13 = Math.Abs((float)k - vector.X);
						float num14 = Math.Abs((float)l - vector.Y) * 3f;
						if (Math.Sqrt(num13 * num13 + num14 * num14) < num2 * 0.4)
						{
							if (k < num4)
							{
								num4 = k;
							}
							if (k > num5)
							{
								num5 = k;
							}
							if (l < num6)
							{
								num6 = l;
							}
							if (l > num7)
							{
								num7 = l;
							}
							Main.tile[k, l].active(active: true);
							Main.tile[k, l].type = 189;
							SquareTileFrame(k, l);
						}
					}
				}
				vector += vector2;
				vector2.X += (float)genRand.Next(-20, 21) * 0.05f;
				if (vector2.X > 1f)
				{
					vector2.X = 1f;
				}
				if (vector2.X < -1f)
				{
					vector2.X = -1f;
				}
				if ((double)vector2.Y > 0.2)
				{
					vector2.Y = -0.2f;
				}
				if ((double)vector2.Y < -0.2)
				{
					vector2.Y = -0.2f;
				}
			}
			int num15 = num4;
			int num17;
			for (num15 += genRand.Next(5); num15 < num5; num15 += genRand.Next(num17, (int)((double)num17 * 1.5)))
			{
				int num16 = num7;
				while (!Main.tile[num15, num16].active())
				{
					num16--;
				}
				num16 += genRand.Next(-3, 4);
				num17 = genRand.Next(4, 8);
				int num18 = 189;
				if (genRand.Next(4) == 0)
				{
					num18 = 460;
				}
				for (int m = num15 - num17; m <= num15 + num17; m++)
				{
					for (int n = num16 - num17; n <= num16 + num17; n++)
					{
						if (n > num6)
						{
							float num19 = Math.Abs(m - num15);
							float num20 = Math.Abs(n - num16) * 2;
							if (Math.Sqrt(num19 * num19 + num20 * num20) < (double)(num17 + genRand.Next(2)))
							{
								Main.tile[m, n].active(active: true);
								Main.tile[m, n].type = (ushort)num18;
								SquareTileFrame(m, n);
							}
						}
					}
				}
			}
			num = genRand.Next(80, 95);
			num2 = num;
			num3 = genRand.Next(10, 15);
			vector.X = i;
			vector.Y = num6;
			vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			while (vector2.X > -2f && vector2.X < 2f)
			{
				vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			}
			vector2.Y = (float)genRand.Next(-20, -10) * 0.02f;
			while (num > 0.0 && num3 > 0f)
			{
				num -= (double)genRand.Next(4);
				num3 -= 1f;
				int num8 = (int)((double)vector.X - num * 0.5);
				int num9 = (int)((double)vector.X + num * 0.5);
				int num10 = num6 - 1;
				int num11 = (int)((double)vector.Y + num * 0.5);
				if (num8 < 0)
				{
					num8 = 0;
				}
				if (num9 > Main.maxTilesX)
				{
					num9 = Main.maxTilesX;
				}
				if (num10 < 0)
				{
					num10 = 0;
				}
				if (num11 > Main.maxTilesY)
				{
					num11 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				float num21 = vector.Y + 1f;
				for (int num22 = num8; num22 < num9; num22++)
				{
					if (genRand.Next(2) == 0)
					{
						num21 += (float)genRand.Next(-1, 2);
					}
					if (num21 < vector.Y)
					{
						num21 = vector.Y;
					}
					if (num21 > vector.Y + 2f)
					{
						num21 = vector.Y + 2f;
					}
					for (int num23 = num10; num23 < num11; num23++)
					{
						if ((float)num23 > num21)
						{
							float num24 = Math.Abs((float)num22 - vector.X);
							float num25 = Math.Abs((float)num23 - vector.Y) * 3f;
							if (Math.Sqrt(num24 * num24 + num25 * num25) < num2 * 0.4 && Main.tile[num22, num23].type == 189)
							{
								Main.tile[num22, num23].type = 147;
								SquareTileFrame(num22, num23);
							}
						}
					}
				}
				vector += vector2;
				vector2.X += (float)genRand.Next(-20, 21) * 0.05f;
				if (vector2.X > 1f)
				{
					vector2.X = 1f;
				}
				if (vector2.X < -1f)
				{
					vector2.X = -1f;
				}
				if ((double)vector2.Y > 0.2)
				{
					vector2.Y = -0.2f;
				}
				if ((double)vector2.Y < -0.2)
				{
					vector2.Y = -0.2f;
				}
			}
			int num26 = num4;
			num26 += genRand.Next(5);
			while (num26 < num5)
			{
				int num27 = num7;
				while ((!Main.tile[num26, num27].active() || Main.tile[num26, num27].type != 0) && num26 < num5)
				{
					num27--;
					if (num27 < num6)
					{
						num27 = num7;
						num26 += genRand.Next(1, 4);
					}
				}
				if (num26 >= num5)
				{
					continue;
				}
				num27 += genRand.Next(0, 4);
				int num28 = genRand.Next(2, 5);
				int num29 = 189;
				for (int num30 = num26 - num28; num30 <= num26 + num28; num30++)
				{
					for (int num31 = num27 - num28; num31 <= num27 + num28; num31++)
					{
						if (num31 > num6)
						{
							float num32 = Math.Abs(num30 - num26);
							float num33 = Math.Abs(num31 - num27) * 2;
							if (Math.Sqrt(num32 * num32 + num33 * num33) < (double)num28)
							{
								Main.tile[num30, num31].type = (ushort)num29;
								SquareTileFrame(num30, num31);
							}
						}
					}
				}
				num26 += genRand.Next(num28, (int)((double)num28 * 1.5));
			}
			for (int num34 = num4 - 20; num34 <= num5 + 20; num34++)
			{
				for (int num35 = num6 - 20; num35 <= num7 + 20; num35++)
				{
					bool flag = true;
					for (int num36 = num34 - 1; num36 <= num34 + 1; num36++)
					{
						for (int num37 = num35 - 1; num37 <= num35 + 1; num37++)
						{
							if (!Main.tile[num36, num37].active())
							{
								flag = false;
							}
						}
					}
					if (flag)
					{
						Main.tile[num34, num35].wall = 73;
						SquareWallFrame(num34, num35);
					}
				}
			}
			for (int num38 = num4; num38 <= num5; num38++)
			{
				int num39;
				for (num39 = num6 - 10; !Main.tile[num38, num39 + 1].active(); num39++)
				{
				}
				if (num39 >= num7 || Main.tile[num38, num39 + 1].type != 189)
				{
					continue;
				}
				if (genRand.Next(10) == 0)
				{
					int num40 = genRand.Next(1, 3);
					for (int num41 = num38 - num40; num41 <= num38 + num40; num41++)
					{
						if (Main.tile[num41, num39].type == 189 && WillWaterPlacedHereStayPut(num41, num39))
						{
							Main.tile[num41, num39].active(active: false);
							Main.tile[num41, num39].liquid = byte.MaxValue;
							Main.tile[num41, num39].lava(lava: false);
							SquareTileFrame(num38, num39);
						}
						if (Main.tile[num41, num39 + 1].type == 189 && WillWaterPlacedHereStayPut(num41, num39 + 1))
						{
							Main.tile[num41, num39 + 1].active(active: false);
							Main.tile[num41, num39 + 1].liquid = byte.MaxValue;
							Main.tile[num41, num39 + 1].lava(lava: false);
							SquareTileFrame(num38, num39 + 1);
						}
						if (num41 > num38 - num40 && num41 < num38 + 2 && Main.tile[num41, num39 + 2].type == 189 && WillWaterPlacedHereStayPut(num41, num39 + 2))
						{
							Main.tile[num41, num39 + 2].active(active: false);
							Main.tile[num41, num39 + 2].liquid = byte.MaxValue;
							Main.tile[num41, num39 + 2].lava(lava: false);
							SquareTileFrame(num38, num39 + 2);
						}
					}
				}
				if (genRand.Next(5) == 0 && WillWaterPlacedHereStayPut(num38, num39))
				{
					Main.tile[num38, num39].liquid = byte.MaxValue;
				}
				Main.tile[num38, num39].lava(lava: false);
				SquareTileFrame(num38, num39);
			}
			int num42 = genRand.Next(4);
			for (int num43 = 0; num43 <= num42; num43++)
			{
				int num44 = genRand.Next(num4 - 5, num5 + 5);
				int num45 = num6 - genRand.Next(20, 40);
				int num46 = genRand.Next(4, 8);
				int num47 = 189;
				if (genRand.Next(2) == 0)
				{
					num47 = 460;
				}
				for (int num48 = num44 - num46; num48 <= num44 + num46; num48++)
				{
					for (int num49 = num45 - num46; num49 <= num45 + num46; num49++)
					{
						float num50 = Math.Abs(num48 - num44);
						float num51 = Math.Abs(num49 - num45) * 2;
						if (Math.Sqrt(num50 * num50 + num51 * num51) < (double)(num46 + genRand.Next(-1, 2)))
						{
							Main.tile[num48, num49].active(active: true);
							Main.tile[num48, num49].type = (ushort)num47;
							SquareTileFrame(num48, num49);
						}
					}
				}
				for (int num52 = num44 - num46 + 2; num52 <= num44 + num46 - 2; num52++)
				{
					int num53;
					for (num53 = num45 - num46; !Main.tile[num52, num53].active(); num53++)
					{
					}
					if (WillWaterPlacedHereStayPut(num52, num53))
					{
						Main.tile[num52, num53].active(active: false);
						Main.tile[num52, num53].liquid = byte.MaxValue;
						SquareTileFrame(num52, num53);
					}
				}
			}
		}

		public static void DesertCloudIsland(int i, int j)
		{
			double num = genRand.Next(100, 150);
			double num2 = num;
			float num3 = genRand.Next(20, 30);
			int num4 = i;
			int num5 = i;
			int num6 = i;
			int num7 = j;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			while (vector2.X > -2f && vector2.X < 2f)
			{
				vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			}
			vector2.Y = (float)genRand.Next(-20, -10) * 0.02f;
			while (num > 0.0 && num3 > 0f)
			{
				num -= (double)genRand.Next(4);
				num3 -= 1f;
				int num8 = (int)((double)vector.X - num * 0.5);
				int num9 = (int)((double)vector.X + num * 0.5);
				int num10 = (int)((double)vector.Y - num * 0.5);
				int num11 = (int)((double)vector.Y + num * 0.5);
				if (num8 < 0)
				{
					num8 = 0;
				}
				if (num9 > Main.maxTilesX)
				{
					num9 = Main.maxTilesX;
				}
				if (num10 < 0)
				{
					num10 = 0;
				}
				if (num11 > Main.maxTilesY)
				{
					num11 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				float num12 = vector.Y + 1f;
				for (int k = num8; k < num9; k++)
				{
					if (genRand.Next(2) == 0)
					{
						num12 += (float)genRand.Next(-1, 2);
					}
					if (num12 < vector.Y)
					{
						num12 = vector.Y;
					}
					if (num12 > vector.Y + 2f)
					{
						num12 = vector.Y + 2f;
					}
					for (int l = num10; l < num11; l++)
					{
						if (!((float)l > num12))
						{
							continue;
						}
						float num13 = Math.Abs((float)k - vector.X);
						float num14 = Math.Abs((float)l - vector.Y) * 3f;
						if (Math.Sqrt(num13 * num13 + num14 * num14) < num2 * 0.4)
						{
							if (k < num4)
							{
								num4 = k;
							}
							if (k > num5)
							{
								num5 = k;
							}
							if (l < num6)
							{
								num6 = l;
							}
							if (l > num7)
							{
								num7 = l;
							}
							Main.tile[k, l].active(active: true);
							Main.tile[k, l].type = 189;
							SquareTileFrame(k, l);
						}
					}
				}
				vector += vector2;
				vector2.X += (float)genRand.Next(-20, 21) * 0.05f;
				if (vector2.X > 1f)
				{
					vector2.X = 1f;
				}
				if (vector2.X < -1f)
				{
					vector2.X = -1f;
				}
				if ((double)vector2.Y > 0.2)
				{
					vector2.Y = -0.2f;
				}
				if ((double)vector2.Y < -0.2)
				{
					vector2.Y = -0.2f;
				}
			}
			int num15 = num4;
			int num17;
			for (num15 += genRand.Next(5); num15 < num5; num15 += genRand.Next(num17, (int)((double)num17 * 1.5)))
			{
				int num16 = num7;
				while (!Main.tile[num15, num16].active())
				{
					num16--;
				}
				num16 += genRand.Next(-3, 4);
				num17 = genRand.Next(4, 8);
				int num18 = 189;
				if (genRand.Next(4) == 0)
				{
					num18 = 196;
				}
				for (int m = num15 - num17; m <= num15 + num17; m++)
				{
					for (int n = num16 - num17; n <= num16 + num17; n++)
					{
						if (n > num6)
						{
							float num19 = Math.Abs(m - num15);
							float num20 = Math.Abs(n - num16) * 2;
							if (Math.Sqrt(num19 * num19 + num20 * num20) < (double)(num17 + genRand.Next(2)))
							{
								Main.tile[m, n].active(active: true);
								Main.tile[m, n].type = (ushort)num18;
								SquareTileFrame(m, n);
							}
						}
					}
				}
			}
			num = genRand.Next(80, 95);
			num2 = num;
			num3 = genRand.Next(10, 15);
			vector.X = i;
			vector.Y = num6;
			vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			while (vector2.X > -2f && vector2.X < 2f)
			{
				vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			}
			vector2.Y = (float)genRand.Next(-20, -10) * 0.02f;
			while (num > 0.0 && num3 > 0f)
			{
				num -= (double)genRand.Next(4);
				num3 -= 1f;
				int num8 = (int)((double)vector.X - num * 0.5);
				int num9 = (int)((double)vector.X + num * 0.5);
				int num10 = num6 - 1;
				int num11 = (int)((double)vector.Y + num * 0.5);
				if (num8 < 0)
				{
					num8 = 0;
				}
				if (num9 > Main.maxTilesX)
				{
					num9 = Main.maxTilesX;
				}
				if (num10 < 0)
				{
					num10 = 0;
				}
				if (num11 > Main.maxTilesY)
				{
					num11 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				float num21 = vector.Y + 1f;
				for (int num22 = num8; num22 < num9; num22++)
				{
					if (genRand.Next(2) == 0)
					{
						num21 += (float)genRand.Next(-1, 2);
					}
					if (num21 < vector.Y)
					{
						num21 = vector.Y;
					}
					if (num21 > vector.Y + 2f)
					{
						num21 = vector.Y + 2f;
					}
					for (int num23 = num10; num23 < num11; num23++)
					{
						if ((float)num23 > num21)
						{
							float num24 = Math.Abs((float)num22 - vector.X);
							float num25 = Math.Abs((float)num23 - vector.Y) * 3f;
							if (Math.Sqrt(num24 * num24 + num25 * num25) < num2 * 0.4 && Main.tile[num22, num23].type == 189)
							{
								Main.tile[num22, num23].type = 53;
								SquareTileFrame(num22, num23);
							}
						}
					}
				}
				vector += vector2;
				vector2.X += (float)genRand.Next(-20, 21) * 0.05f;
				if (vector2.X > 1f)
				{
					vector2.X = 1f;
				}
				if (vector2.X < -1f)
				{
					vector2.X = -1f;
				}
				if ((double)vector2.Y > 0.2)
				{
					vector2.Y = -0.2f;
				}
				if ((double)vector2.Y < -0.2)
				{
					vector2.Y = -0.2f;
				}
			}
			int num26 = num4;
			num26 += genRand.Next(5);
			while (num26 < num5)
			{
				int num27 = num7;
				while ((!Main.tile[num26, num27].active() || Main.tile[num26, num27].type != 0) && num26 < num5)
				{
					num27--;
					if (num27 < num6)
					{
						num27 = num7;
						num26 += genRand.Next(1, 4);
					}
				}
				if (num26 >= num5)
				{
					continue;
				}
				num27 += genRand.Next(0, 4);
				int num28 = genRand.Next(2, 5);
				int num29 = 189;
				for (int num30 = num26 - num28; num30 <= num26 + num28; num30++)
				{
					for (int num31 = num27 - num28; num31 <= num27 + num28; num31++)
					{
						if (num31 > num6)
						{
							float num32 = Math.Abs(num30 - num26);
							float num33 = Math.Abs(num31 - num27) * 2;
							if (Math.Sqrt(num32 * num32 + num33 * num33) < (double)num28)
							{
								Main.tile[num30, num31].type = (ushort)num29;
								SquareTileFrame(num30, num31);
							}
						}
					}
				}
				num26 += genRand.Next(num28, (int)((double)num28 * 1.5));
			}
			for (int num34 = num4 - 20; num34 <= num5 + 20; num34++)
			{
				for (int num35 = num6 - 20; num35 <= num7 + 20; num35++)
				{
					bool flag = true;
					for (int num36 = num34 - 1; num36 <= num34 + 1; num36++)
					{
						for (int num37 = num35 - 1; num37 <= num35 + 1; num37++)
						{
							if (!Main.tile[num36, num37].active())
							{
								flag = false;
							}
						}
					}
					if (flag)
					{
						Main.tile[num34, num35].wall = 73;
						SquareWallFrame(num34, num35);
					}
				}
			}
			for (int num38 = num4; num38 <= num5; num38++)
			{
				int num39;
				for (num39 = num6 - 10; !Main.tile[num38, num39 + 1].active(); num39++)
				{
				}
				if (num39 >= num7 || Main.tile[num38, num39 + 1].type != 189)
				{
					continue;
				}
				if (genRand.Next(10) == 0)
				{
					int num40 = genRand.Next(1, 3);
					for (int num41 = num38 - num40; num41 <= num38 + num40; num41++)
					{
						if (Main.tile[num41, num39].type == 189 && WillWaterPlacedHereStayPut(num41, num39))
						{
							Main.tile[num41, num39].active(active: false);
							Main.tile[num41, num39].liquid = byte.MaxValue;
							Main.tile[num41, num39].lava(lava: false);
							SquareTileFrame(num38, num39);
						}
						if (Main.tile[num41, num39 + 1].type == 189 && WillWaterPlacedHereStayPut(num41, num39 + 1))
						{
							Main.tile[num41, num39 + 1].active(active: false);
							Main.tile[num41, num39 + 1].liquid = byte.MaxValue;
							Main.tile[num41, num39 + 1].lava(lava: false);
							SquareTileFrame(num38, num39 + 1);
						}
						if (num41 > num38 - num40 && num41 < num38 + 2 && Main.tile[num41, num39 + 2].type == 189 && WillWaterPlacedHereStayPut(num41, num39 + 2))
						{
							Main.tile[num41, num39 + 2].active(active: false);
							Main.tile[num41, num39 + 2].liquid = byte.MaxValue;
							Main.tile[num41, num39 + 2].lava(lava: false);
							SquareTileFrame(num38, num39 + 2);
						}
					}
				}
				if (genRand.Next(5) == 0 && WillWaterPlacedHereStayPut(num38, num39))
				{
					Main.tile[num38, num39].liquid = byte.MaxValue;
				}
				Main.tile[num38, num39].lava(lava: false);
				SquareTileFrame(num38, num39);
			}
			int num42 = genRand.Next(4);
			for (int num43 = 0; num43 <= num42; num43++)
			{
				int num44 = genRand.Next(num4 - 5, num5 + 5);
				int num45 = num6 - genRand.Next(20, 40);
				int num46 = genRand.Next(4, 8);
				int num47 = 189;
				if (genRand.Next(2) == 0)
				{
					num47 = 196;
				}
				for (int num48 = num44 - num46; num48 <= num44 + num46; num48++)
				{
					for (int num49 = num45 - num46; num49 <= num45 + num46; num49++)
					{
						float num50 = Math.Abs(num48 - num44);
						float num51 = Math.Abs(num49 - num45) * 2;
						if (Math.Sqrt(num50 * num50 + num51 * num51) < (double)(num46 + genRand.Next(-1, 2)))
						{
							Main.tile[num48, num49].active(active: true);
							Main.tile[num48, num49].type = (ushort)num47;
							SquareTileFrame(num48, num49);
						}
					}
				}
				for (int num52 = num44 - num46 + 2; num52 <= num44 + num46 - 2; num52++)
				{
					int num53;
					for (num53 = num45 - num46; !Main.tile[num52, num53].active(); num53++)
					{
					}
					if (WillWaterPlacedHereStayPut(num52, num53))
					{
						Main.tile[num52, num53].active(active: false);
						Main.tile[num52, num53].liquid = byte.MaxValue;
						SquareTileFrame(num52, num53);
					}
				}
			}
		}

		public static void CloudIsland(int i, int j)
		{
			double num = genRand.Next(100, 150);
			double num2 = num;
			float num3 = genRand.Next(20, 30);
			int num4 = i;
			int num5 = i;
			int num6 = i;
			int num7 = j;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			while (vector2.X > -2f && vector2.X < 2f)
			{
				vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			}
			vector2.Y = (float)genRand.Next(-20, -10) * 0.02f;
			while (num > 0.0 && num3 > 0f)
			{
				num -= (double)genRand.Next(4);
				num3 -= 1f;
				int num8 = (int)((double)vector.X - num * 0.5);
				int num9 = (int)((double)vector.X + num * 0.5);
				int num10 = (int)((double)vector.Y - num * 0.5);
				int num11 = (int)((double)vector.Y + num * 0.5);
				if (num8 < 0)
				{
					num8 = 0;
				}
				if (num9 > Main.maxTilesX)
				{
					num9 = Main.maxTilesX;
				}
				if (num10 < 0)
				{
					num10 = 0;
				}
				if (num11 > Main.maxTilesY)
				{
					num11 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				float num12 = vector.Y + 1f;
				for (int k = num8; k < num9; k++)
				{
					if (genRand.Next(2) == 0)
					{
						num12 += (float)genRand.Next(-1, 2);
					}
					if (num12 < vector.Y)
					{
						num12 = vector.Y;
					}
					if (num12 > vector.Y + 2f)
					{
						num12 = vector.Y + 2f;
					}
					for (int l = num10; l < num11; l++)
					{
						if (!((float)l > num12))
						{
							continue;
						}
						float num13 = Math.Abs((float)k - vector.X);
						float num14 = Math.Abs((float)l - vector.Y) * 3f;
						if (Math.Sqrt(num13 * num13 + num14 * num14) < num2 * 0.4)
						{
							if (k < num4)
							{
								num4 = k;
							}
							if (k > num5)
							{
								num5 = k;
							}
							if (l < num6)
							{
								num6 = l;
							}
							if (l > num7)
							{
								num7 = l;
							}
							Main.tile[k, l].active(active: true);
							Main.tile[k, l].type = 189;
							SquareTileFrame(k, l);
						}
					}
				}
				vector += vector2;
				vector2.X += (float)genRand.Next(-20, 21) * 0.05f;
				if (vector2.X > 1f)
				{
					vector2.X = 1f;
				}
				if (vector2.X < -1f)
				{
					vector2.X = -1f;
				}
				if ((double)vector2.Y > 0.2)
				{
					vector2.Y = -0.2f;
				}
				if ((double)vector2.Y < -0.2)
				{
					vector2.Y = -0.2f;
				}
			}
			int num15 = num4;
			int num17;
			for (num15 += genRand.Next(5); num15 < num5; num15 += genRand.Next(num17, (int)((double)num17 * 1.5)))
			{
				int num16 = num7;
				while (!Main.tile[num15, num16].active())
				{
					num16--;
				}
				num16 += genRand.Next(-3, 4);
				num17 = genRand.Next(4, 8);
				int num18 = 189;
				if (genRand.Next(4) == 0)
				{
					num18 = 196;
				}
				for (int m = num15 - num17; m <= num15 + num17; m++)
				{
					for (int n = num16 - num17; n <= num16 + num17; n++)
					{
						if (n > num6)
						{
							float num19 = Math.Abs(m - num15);
							float num20 = Math.Abs(n - num16) * 2;
							if (Math.Sqrt(num19 * num19 + num20 * num20) < (double)(num17 + genRand.Next(2)))
							{
								Main.tile[m, n].active(active: true);
								Main.tile[m, n].type = (ushort)num18;
								SquareTileFrame(m, n);
							}
						}
					}
				}
			}
			num = genRand.Next(80, 95);
			num2 = num;
			num3 = genRand.Next(10, 15);
			vector.X = i;
			vector.Y = num6;
			vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			while (vector2.X > -2f && vector2.X < 2f)
			{
				vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			}
			vector2.Y = (float)genRand.Next(-20, -10) * 0.02f;
			while (num > 0.0 && num3 > 0f)
			{
				num -= (double)genRand.Next(4);
				num3 -= 1f;
				int num8 = (int)((double)vector.X - num * 0.5);
				int num9 = (int)((double)vector.X + num * 0.5);
				int num10 = num6 - 1;
				int num11 = (int)((double)vector.Y + num * 0.5);
				if (num8 < 0)
				{
					num8 = 0;
				}
				if (num9 > Main.maxTilesX)
				{
					num9 = Main.maxTilesX;
				}
				if (num10 < 0)
				{
					num10 = 0;
				}
				if (num11 > Main.maxTilesY)
				{
					num11 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				float num21 = vector.Y + 1f;
				for (int num22 = num8; num22 < num9; num22++)
				{
					if (genRand.Next(2) == 0)
					{
						num21 += (float)genRand.Next(-1, 2);
					}
					if (num21 < vector.Y)
					{
						num21 = vector.Y;
					}
					if (num21 > vector.Y + 2f)
					{
						num21 = vector.Y + 2f;
					}
					for (int num23 = num10; num23 < num11; num23++)
					{
						if ((float)num23 > num21)
						{
							float num24 = Math.Abs((float)num22 - vector.X);
							float num25 = Math.Abs((float)num23 - vector.Y) * 3f;
							if (Math.Sqrt(num24 * num24 + num25 * num25) < num2 * 0.4 && Main.tile[num22, num23].type == 189)
							{
								Main.tile[num22, num23].type = 0;
								SquareTileFrame(num22, num23);
							}
						}
					}
				}
				vector += vector2;
				vector2.X += (float)genRand.Next(-20, 21) * 0.05f;
				if (vector2.X > 1f)
				{
					vector2.X = 1f;
				}
				if (vector2.X < -1f)
				{
					vector2.X = -1f;
				}
				if ((double)vector2.Y > 0.2)
				{
					vector2.Y = -0.2f;
				}
				if ((double)vector2.Y < -0.2)
				{
					vector2.Y = -0.2f;
				}
			}
			int num26 = num4;
			num26 += genRand.Next(5);
			while (num26 < num5)
			{
				int num27 = num7;
				while ((!Main.tile[num26, num27].active() || Main.tile[num26, num27].type != 0) && num26 < num5)
				{
					num27--;
					if (num27 < num6)
					{
						num27 = num7;
						num26 += genRand.Next(1, 4);
					}
				}
				if (num26 >= num5)
				{
					continue;
				}
				num27 += genRand.Next(0, 4);
				int num28 = genRand.Next(2, 5);
				int num29 = 189;
				for (int num30 = num26 - num28; num30 <= num26 + num28; num30++)
				{
					for (int num31 = num27 - num28; num31 <= num27 + num28; num31++)
					{
						if (num31 > num6)
						{
							float num32 = Math.Abs(num30 - num26);
							float num33 = Math.Abs(num31 - num27) * 2;
							if (Math.Sqrt(num32 * num32 + num33 * num33) < (double)num28)
							{
								Main.tile[num30, num31].type = (ushort)num29;
								SquareTileFrame(num30, num31);
							}
						}
					}
				}
				num26 += genRand.Next(num28, (int)((double)num28 * 1.5));
			}
			for (int num34 = num4 - 20; num34 <= num5 + 20; num34++)
			{
				for (int num35 = num6 - 20; num35 <= num7 + 20; num35++)
				{
					bool flag = true;
					for (int num36 = num34 - 1; num36 <= num34 + 1; num36++)
					{
						for (int num37 = num35 - 1; num37 <= num35 + 1; num37++)
						{
							if (!Main.tile[num36, num37].active())
							{
								flag = false;
							}
						}
					}
					if (flag)
					{
						Main.tile[num34, num35].wall = 73;
						SquareWallFrame(num34, num35);
					}
				}
			}
			for (int num38 = num4; num38 <= num5; num38++)
			{
				int num39;
				for (num39 = num6 - 10; !Main.tile[num38, num39 + 1].active(); num39++)
				{
				}
				if (num39 >= num7 || Main.tile[num38, num39 + 1].type != 189)
				{
					continue;
				}
				if (genRand.Next(10) == 0)
				{
					int num40 = genRand.Next(1, 3);
					for (int num41 = num38 - num40; num41 <= num38 + num40; num41++)
					{
						if (Main.tile[num41, num39].type == 189 && WillWaterPlacedHereStayPut(num41, num39))
						{
							Main.tile[num41, num39].active(active: false);
							Main.tile[num41, num39].liquid = byte.MaxValue;
							Main.tile[num41, num39].lava(lava: false);
							SquareTileFrame(num38, num39);
						}
						if (Main.tile[num41, num39 + 1].type == 189 && WillWaterPlacedHereStayPut(num41, num39 + 1))
						{
							Main.tile[num41, num39 + 1].active(active: false);
							Main.tile[num41, num39 + 1].liquid = byte.MaxValue;
							Main.tile[num41, num39 + 1].lava(lava: false);
							SquareTileFrame(num38, num39 + 1);
						}
						if (num41 > num38 - num40 && num41 < num38 + 2 && Main.tile[num41, num39 + 2].type == 189 && WillWaterPlacedHereStayPut(num41, num39 + 2))
						{
							Main.tile[num41, num39 + 2].active(active: false);
							Main.tile[num41, num39 + 2].liquid = byte.MaxValue;
							Main.tile[num41, num39 + 2].lava(lava: false);
							SquareTileFrame(num38, num39 + 2);
						}
					}
				}
				if (genRand.Next(5) == 0 && WillWaterPlacedHereStayPut(num38, num39))
				{
					Main.tile[num38, num39].liquid = byte.MaxValue;
				}
				Main.tile[num38, num39].lava(lava: false);
				SquareTileFrame(num38, num39);
			}
			int num42 = genRand.Next(4);
			for (int num43 = 0; num43 <= num42; num43++)
			{
				int num44 = genRand.Next(num4 - 5, num5 + 5);
				int num45 = num6 - genRand.Next(20, 40);
				int num46 = genRand.Next(4, 8);
				int num47 = 189;
				if (genRand.Next(2) == 0)
				{
					num47 = 196;
				}
				for (int num48 = num44 - num46; num48 <= num44 + num46; num48++)
				{
					for (int num49 = num45 - num46; num49 <= num45 + num46; num49++)
					{
						float num50 = Math.Abs(num48 - num44);
						float num51 = Math.Abs(num49 - num45) * 2;
						if (Math.Sqrt(num50 * num50 + num51 * num51) < (double)(num46 + genRand.Next(-1, 2)))
						{
							Main.tile[num48, num49].active(active: true);
							Main.tile[num48, num49].type = (ushort)num47;
							SquareTileFrame(num48, num49);
						}
					}
				}
				for (int num52 = num44 - num46 + 2; num52 <= num44 + num46 - 2; num52++)
				{
					int num53;
					for (num53 = num45 - num46; !Main.tile[num52, num53].active(); num53++)
					{
					}
					if (WillWaterPlacedHereStayPut(num52, num53))
					{
						Main.tile[num52, num53].active(active: false);
						Main.tile[num52, num53].liquid = byte.MaxValue;
						SquareTileFrame(num52, num53);
					}
				}
			}
		}

		public static bool WillWaterPlacedHereStayPut(int x, int y)
		{
			if (((Main.tile[x, y + 1].active() && Main.tileSolid[Main.tile[x, y + 1].type] && !Main.tileSolidTop[Main.tile[x, y + 1].type]) || Main.tile[x, y + 1].liquid == byte.MaxValue) && ((Main.tile[x - 1, y].active() && Main.tileSolid[Main.tile[x - 1, y].type] && !Main.tileSolidTop[Main.tile[x - 1, y].type]) || Main.tile[x - 1, y].liquid == byte.MaxValue) && ((Main.tile[x + 1, y].active() && Main.tileSolid[Main.tile[x + 1, y].type] && !Main.tileSolidTop[Main.tile[x + 1, y].type]) || Main.tile[x + 1, y].liquid == byte.MaxValue))
			{
				return true;
			}
			return false;
		}

		public static void CloudLake(int i, int j)
		{
			double num = genRand.Next(100, 150);
			double num2 = num;
			float num3 = genRand.Next(20, 30);
			int num4 = i;
			int num5 = i;
			int num6 = i;
			int num7 = j;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			while (vector2.X > -2f && vector2.X < 2f)
			{
				vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			}
			vector2.Y = (float)genRand.Next(-20, -10) * 0.02f;
			while (num > 0.0 && num3 > 0f)
			{
				num -= (double)genRand.Next(4);
				num3 -= 1f;
				int num8 = (int)((double)vector.X - num * 0.5);
				int num9 = (int)((double)vector.X + num * 0.5);
				int num10 = (int)((double)vector.Y - num * 0.5);
				int num11 = (int)((double)vector.Y + num * 0.5);
				if (num8 < 0)
				{
					num8 = 0;
				}
				if (num9 > Main.maxTilesX)
				{
					num9 = Main.maxTilesX;
				}
				if (num10 < 0)
				{
					num10 = 0;
				}
				if (num11 > Main.maxTilesY)
				{
					num11 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				float num12 = vector.Y + 1f;
				for (int k = num8; k < num9; k++)
				{
					if (genRand.Next(2) == 0)
					{
						num12 += (float)genRand.Next(-1, 2);
					}
					if (num12 < vector.Y)
					{
						num12 = vector.Y;
					}
					if (num12 > vector.Y + 2f)
					{
						num12 = vector.Y + 2f;
					}
					for (int l = num10; l < num11; l++)
					{
						if (!((float)l > num12))
						{
							continue;
						}
						float num13 = Math.Abs((float)k - vector.X);
						float num14 = Math.Abs((float)l - vector.Y) * 3f;
						if (Math.Sqrt(num13 * num13 + num14 * num14) < num2 * 0.4)
						{
							if (k < num4)
							{
								num4 = k;
							}
							if (k > num5)
							{
								num5 = k;
							}
							if (l < num6)
							{
								num6 = l;
							}
							if (l > num7)
							{
								num7 = l;
							}
							Main.tile[k, l].active(active: true);
							Main.tile[k, l].type = 189;
							SquareTileFrame(k, l);
						}
					}
				}
				vector += vector2;
				vector2.X += (float)genRand.Next(-20, 21) * 0.05f;
				if (vector2.X > 1f)
				{
					vector2.X = 1f;
				}
				if (vector2.X < -1f)
				{
					vector2.X = -1f;
				}
				if ((double)vector2.Y > 0.2)
				{
					vector2.Y = -0.2f;
				}
				if ((double)vector2.Y < -0.2)
				{
					vector2.Y = -0.2f;
				}
			}
			int num15 = num4;
			int num17;
			for (num15 += genRand.Next(5); num15 < num5; num15 += genRand.Next(num17, (int)((double)num17 * 1.5)))
			{
				int num16 = num7;
				while (!Main.tile[num15, num16].active())
				{
					num16--;
				}
				num16 += genRand.Next(-3, 4);
				num17 = genRand.Next(4, 8);
				int num18 = 189;
				if (genRand.Next(4) == 0)
				{
					num18 = 196;
				}
				for (int m = num15 - num17; m <= num15 + num17; m++)
				{
					for (int n = num16 - num17; n <= num16 + num17; n++)
					{
						if (n > num6)
						{
							float num19 = Math.Abs(m - num15);
							float num20 = Math.Abs(n - num16) * 2;
							if (Math.Sqrt(num19 * num19 + num20 * num20) < (double)(num17 + genRand.Next(2)))
							{
								Main.tile[m, n].active(active: true);
								Main.tile[m, n].type = (ushort)num18;
								SquareTileFrame(m, n);
							}
						}
					}
				}
			}
			num = genRand.Next(80, 95);
			num2 = num;
			num3 = genRand.Next(10, 15);
			vector.X = i;
			vector.Y = num6;
			vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			while (vector2.X > -2f && vector2.X < 2f)
			{
				vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			}
			vector2.Y = (float)genRand.Next(-20, -10) * 0.02f;
			while (num > 0.0 && num3 > 0f)
			{
				num -= (double)genRand.Next(4);
				num3 -= 1f;
				int num8 = (int)((double)vector.X - num * 0.5);
				int num9 = (int)((double)vector.X + num * 0.5);
				int num10 = num6 - 1;
				int num11 = (int)((double)vector.Y + num * 0.5);
				if (num8 < 0)
				{
					num8 = 0;
				}
				if (num9 > Main.maxTilesX)
				{
					num9 = Main.maxTilesX;
				}
				if (num10 < 0)
				{
					num10 = 0;
				}
				if (num11 > Main.maxTilesY)
				{
					num11 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				float num21 = vector.Y + 1f;
				for (int num22 = num8; num22 < num9; num22++)
				{
					if (genRand.Next(2) == 0)
					{
						num21 += (float)genRand.Next(-1, 2);
					}
					if (num21 < vector.Y)
					{
						num21 = vector.Y;
					}
					if (num21 > vector.Y + 2f)
					{
						num21 = vector.Y + 2f;
					}
					for (int num23 = num10; num23 < num11; num23++)
					{
						if (!((float)num23 > num21 - 2f))
						{
							continue;
						}
						float num24 = Math.Abs((float)num22 - vector.X);
						float num25 = Math.Abs((float)num23 - vector.Y) * 3f;
						if (!(Math.Sqrt(num24 * num24 + num25 * num25) < num2 * 0.4) || Main.tile[num22, num23].type != 189)
						{
							continue;
						}
						Main.tile[num22, num23].active(active: false);
						if ((float)num23 > num21 + 1f)
						{
							if (WillWaterPlacedHereStayPut(num22, num23))
							{
								Main.tile[num22, num23].liquid = byte.MaxValue;
							}
							Main.tile[num22, num23].honey(honey: false);
							Main.tile[num22, num23].lava(lava: false);
						}
					}
				}
				vector += vector2;
				vector2.X += (float)genRand.Next(-20, 21) * 0.05f;
				if (vector2.X > 1f)
				{
					vector2.X = 1f;
				}
				if (vector2.X < -1f)
				{
					vector2.X = -1f;
				}
				if ((double)vector2.Y > 0.2)
				{
					vector2.Y = -0.2f;
				}
				if (vector2.Y < 0f)
				{
					vector2.Y = 0f;
				}
			}
			for (int num26 = num4 - 20; num26 <= num5 + 20; num26++)
			{
				for (int num27 = num6 - 20; num27 <= num7 + 20; num27++)
				{
					bool flag = true;
					for (int num28 = num26 - 1; num28 <= num26 + 1; num28++)
					{
						for (int num29 = num27 - 1; num29 <= num27 + 1; num29++)
						{
							if (!Main.tile[num28, num29].active())
							{
								flag = false;
							}
						}
					}
					if (flag)
					{
						Main.tile[num26, num27].wall = 73;
					}
				}
			}
			for (int num30 = num4; num30 <= num5; num30++)
			{
				int num31;
				for (num31 = num6 - 10; !Main.tile[num30, num31 + 1].active(); num31++)
				{
				}
				if (num31 >= num7 || Main.tile[num30, num31 + 1].type != 189)
				{
					continue;
				}
				if (genRand.Next(10) == 0)
				{
					int num32 = genRand.Next(1, 3);
					for (int num33 = num30 - num32; num33 <= num30 + num32; num33++)
					{
						if (Main.tile[num33, num31].type == 189 && WillWaterPlacedHereStayPut(num33, num31))
						{
							Main.tile[num33, num31].active(active: false);
							Main.tile[num33, num31].liquid = byte.MaxValue;
							Main.tile[num33, num31].lava(lava: false);
							SquareTileFrame(num30, num31);
						}
						if (Main.tile[num33, num31 + 1].type == 189 && WillWaterPlacedHereStayPut(num33, num31 + 1))
						{
							Main.tile[num33, num31 + 1].active(active: false);
							Main.tile[num33, num31 + 1].liquid = byte.MaxValue;
							Main.tile[num33, num31 + 1].lava(lava: false);
							SquareTileFrame(num30, num31 + 1);
						}
						if (num33 > num30 - num32 && num33 < num30 + 2 && Main.tile[num33, num31 + 2].type == 189 && WillWaterPlacedHereStayPut(num33, num31 + 2))
						{
							Main.tile[num33, num31 + 2].active(active: false);
							Main.tile[num33, num31 + 2].liquid = byte.MaxValue;
							Main.tile[num33, num31 + 2].lava(lava: false);
							SquareTileFrame(num30, num31 + 2);
						}
					}
				}
				if (genRand.Next(5) == 0 && WillWaterPlacedHereStayPut(num30, num31))
				{
					Main.tile[num30, num31].liquid = byte.MaxValue;
				}
				Main.tile[num30, num31].lava(lava: false);
				SquareTileFrame(num30, num31);
			}
			int num34 = genRand.Next(1, 4);
			for (int num35 = 0; num35 <= num34; num35++)
			{
				int num36 = genRand.Next(num4 - 5, num5 + 5);
				int num37 = num6 - genRand.Next(20, 40);
				int num38 = genRand.Next(4, 8);
				int num39 = 189;
				if (genRand.Next(4) != 0)
				{
					num39 = 196;
				}
				for (int num40 = num36 - num38; num40 <= num36 + num38; num40++)
				{
					for (int num41 = num37 - num38; num41 <= num37 + num38; num41++)
					{
						float num42 = Math.Abs(num40 - num36);
						float num43 = Math.Abs(num41 - num37) * 2;
						if (Math.Sqrt(num42 * num42 + num43 * num43) < (double)(num38 + genRand.Next(-1, 2)))
						{
							Main.tile[num40, num41].active(active: true);
							Main.tile[num40, num41].type = (ushort)num39;
							SquareTileFrame(num40, num41);
						}
					}
				}
				for (int num44 = num36 - num38 + 2; num44 <= num36 + num38 - 2; num44++)
				{
					int num45;
					for (num45 = num37 - num38; !Main.tile[num44, num45].active(); num45++)
					{
					}
					if (WillWaterPlacedHereStayPut(num44, num45))
					{
						Main.tile[num44, num45].active(active: false);
						Main.tile[num44, num45].liquid = byte.MaxValue;
						SquareTileFrame(num44, num45);
					}
				}
			}
		}

		public static void FloatingIsland(int i, int j)
		{
			double num = genRand.Next(80, 120);
			double num2 = num;
			float num3 = genRand.Next(20, 25);
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			while (vector2.X > -2f && vector2.X < 2f)
			{
				vector2.X = (float)genRand.Next(-20, 21) * 0.2f;
			}
			vector2.Y = (float)genRand.Next(-20, -10) * 0.02f;
			while (num > 0.0 && num3 > 0f)
			{
				num -= (double)genRand.Next(4);
				num3 -= 1f;
				int num4 = (int)((double)vector.X - num * 0.5);
				int num5 = (int)((double)vector.X + num * 0.5);
				int num6 = (int)((double)vector.Y - num * 0.5);
				int num7 = (int)((double)vector.Y + num * 0.5);
				if (num4 < 0)
				{
					num4 = 0;
				}
				if (num5 > Main.maxTilesX)
				{
					num5 = Main.maxTilesX;
				}
				if (num6 < 0)
				{
					num6 = 0;
				}
				if (num7 > Main.maxTilesY)
				{
					num7 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				float num8 = vector.Y + 1f;
				for (int k = num4; k < num5; k++)
				{
					if (genRand.Next(2) == 0)
					{
						num8 += (float)genRand.Next(-1, 2);
					}
					if (num8 < vector.Y)
					{
						num8 = vector.Y;
					}
					if (num8 > vector.Y + 2f)
					{
						num8 = vector.Y + 2f;
					}
					for (int l = num6; l < num7; l++)
					{
						if (!((float)l > num8))
						{
							continue;
						}
						float num9 = Math.Abs((float)k - vector.X);
						float num10 = Math.Abs((float)l - vector.Y) * 2f;
						if (Math.Sqrt(num9 * num9 + num10 * num10) < num2 * 0.4)
						{
							Main.tile[k, l].active(active: true);
							if (Main.tile[k, l].type == 59)
							{
								Main.tile[k, l].type = 0;
							}
						}
					}
				}
				num4 = (int)((double)vector.X - num * 0.4);
				num5 = (int)((double)vector.X + num * 0.4);
				num6 = (int)((double)vector.Y - num * 0.4);
				num7 = (int)((double)vector.Y + num * 0.4);
				if (num4 < 0)
				{
					num4 = 0;
				}
				if (num5 > Main.maxTilesX)
				{
					num5 = Main.maxTilesX;
				}
				if (num6 < 0)
				{
					num6 = 0;
				}
				if (num7 > Main.maxTilesY)
				{
					num7 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				for (int m = num4; m < num5; m++)
				{
					for (int n = num6; n < num7; n++)
					{
						if ((float)n > vector.Y + 2f)
						{
							float num11 = Math.Abs((float)m - vector.X);
							float num12 = Math.Abs((float)n - vector.Y) * 2f;
							if (Math.Sqrt(num11 * num11 + num12 * num12) < num2 * 0.4)
							{
								Main.tile[m, n].wall = 2;
							}
						}
					}
				}
				vector += vector2;
				vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
				if (vector2.X > 1f)
				{
					vector2.X = 1f;
				}
				if (vector2.X < -1f)
				{
					vector2.X = -1f;
				}
				if ((double)vector2.Y > 0.2)
				{
					vector2.Y = -0.2f;
				}
				if ((double)vector2.Y < -0.2)
				{
					vector2.Y = -0.2f;
				}
			}
		}

		public static void Caverer(int X, int Y)
		{
			switch (genRand.Next(2))
			{
			case 0:
			{
				int num4 = genRand.Next(7, 9);
				float num5 = (float)genRand.Next(100) * 0.01f;
				float num6 = 1f - num5;
				if (genRand.Next(2) == 0)
				{
					num5 = 0f - num5;
				}
				if (genRand.Next(2) == 0)
				{
					num6 = 0f - num6;
				}
				Vector2 vector2 = new Vector2(X, Y);
				for (int j = 0; j < num4; j++)
				{
					vector2 = digTunnel(vector2.X, vector2.Y, num5, num6, genRand.Next(6, 20), genRand.Next(4, 9));
					num5 += (float)genRand.Next(-20, 21) * 0.1f;
					num6 += (float)genRand.Next(-20, 21) * 0.1f;
					if ((double)num5 < -1.5)
					{
						num5 = -1.5f;
					}
					if ((double)num5 > 1.5)
					{
						num5 = 1.5f;
					}
					if ((double)num6 < -1.5)
					{
						num6 = -1.5f;
					}
					if ((double)num6 > 1.5)
					{
						num6 = 1.5f;
					}
					float num7 = (float)genRand.Next(100) * 0.01f;
					float num8 = 1f - num7;
					if (genRand.Next(2) == 0)
					{
						num7 = 0f - num7;
					}
					if (genRand.Next(2) == 0)
					{
						num8 = 0f - num8;
					}
					Vector2 vector3 = digTunnel(vector2.X, vector2.Y, num7, num8, genRand.Next(30, 50), genRand.Next(3, 6));
					TileRunner((int)vector3.X, (int)vector3.Y, genRand.Next(10, 20), genRand.Next(5, 10), -1);
				}
				break;
			}
			case 1:
			{
				int num = genRand.Next(15, 30);
				float num2 = (float)genRand.Next(100) * 0.01f;
				float num3 = 1f - num2;
				if (genRand.Next(2) == 0)
				{
					num2 = 0f - num2;
				}
				if (genRand.Next(2) == 0)
				{
					num3 = 0f - num3;
				}
				Vector2 vector = new Vector2(X, Y);
				for (int i = 0; i < num; i++)
				{
					vector = digTunnel(vector.X, vector.Y, num2, num3, genRand.Next(5, 15), genRand.Next(2, 6), Wet: true);
					num2 += (float)genRand.Next(-20, 21) * 0.1f;
					num3 += (float)genRand.Next(-20, 21) * 0.1f;
					if ((double)num2 < -1.5)
					{
						num2 = -1.5f;
					}
					if ((double)num2 > 1.5)
					{
						num2 = 1.5f;
					}
					if ((double)num3 < -1.5)
					{
						num3 = -1.5f;
					}
					if ((double)num3 > 1.5)
					{
						num3 = 1.5f;
					}
				}
				break;
			}
			}
		}

		public static Vector2 digTunnel(float X, float Y, float xDir, float yDir, int Steps, int Size, bool Wet = false)
		{
			float num = X;
			float num2 = Y;
			try
			{
				float num3 = 0f;
				float num4 = 0f;
				float num5 = Size;
				num = MathHelper.Clamp(num, num5 + 1f, (float)Main.maxTilesX - num5 - 1f);
				num2 = MathHelper.Clamp(num2, num5 + 1f, (float)Main.maxTilesY - num5 - 1f);
				for (int i = 0; i < Steps; i++)
				{
					for (int j = (int)(num - num5); (float)j <= num + num5; j++)
					{
						for (int k = (int)(num2 - num5); (float)k <= num2 + num5; k++)
						{
							if ((double)(Math.Abs((float)j - num) + Math.Abs((float)k - num2)) < (double)num5 * (1.0 + (double)genRand.Next(-10, 11) * 0.005) && j >= 0 && j < Main.maxTilesX && k >= 0 && k < Main.maxTilesY)
							{
								Main.tile[j, k].active(active: false);
								if (Wet)
								{
									Main.tile[j, k].liquid = byte.MaxValue;
								}
							}
						}
					}
					num5 += (float)genRand.Next(-50, 51) * 0.03f;
					if ((double)num5 < (double)Size * 0.6)
					{
						num5 = (float)Size * 0.6f;
					}
					if (num5 > (float)(Size * 2))
					{
						num5 = (float)Size * 2f;
					}
					num3 += (float)genRand.Next(-20, 21) * 0.01f;
					num4 += (float)genRand.Next(-20, 21) * 0.01f;
					if (num3 < -1f)
					{
						num3 = -1f;
					}
					if (num3 > 1f)
					{
						num3 = 1f;
					}
					if (num4 < -1f)
					{
						num4 = -1f;
					}
					if (num4 > 1f)
					{
						num4 = 1f;
					}
					num += (xDir + num3) * 0.6f;
					num2 += (yDir + num4) * 0.6f;
				}
			}
			catch
			{
			}
			return new Vector2(num, num2);
		}

		public static void IslandHouse(int i, int j, int islandStyle)
		{
			byte type = 202;
			byte wall = 82;
			Vector2 vector = new Vector2(i, j);
			int num = 1;
			if (genRand.Next(2) == 0)
			{
				num = -1;
			}
			int num2 = genRand.Next(7, 12);
			int num3 = genRand.Next(5, 7);
			vector.X = i + (num2 + 2) * num;
			for (int k = j - 15; k < j + 30; k++)
			{
				if (Main.tile[(int)vector.X, k].active())
				{
					vector.Y = k - 1;
					break;
				}
			}
			vector.X = i;
			int num4 = (int)(vector.X - (float)num2 - 1f);
			int num5 = (int)(vector.X + (float)num2 + 1f);
			int num6 = (int)(vector.Y - (float)num3 - 1f);
			int num7 = (int)(vector.Y + 2f);
			if (num4 < 0)
			{
				num4 = 0;
			}
			if (num5 > Main.maxTilesX)
			{
				num5 = Main.maxTilesX;
			}
			if (num6 < 0)
			{
				num6 = 0;
			}
			if (num7 > Main.maxTilesY)
			{
				num7 = Main.maxTilesY;
			}
			for (int l = num4; l <= num5; l++)
			{
				for (int m = num6 - 1; m < num7 + 1; m++)
				{
					if (m != num6 - 1 || (l != num4 && l != num5))
					{
						Main.tile[l, m].active(active: true);
						Main.tile[l, m].liquid = 0;
						Main.tile[l, m].type = type;
						Main.tile[l, m].wall = 0;
						Main.tile[l, m].halfBrick(halfBrick: false);
						Main.tile[l, m].slope(0);
					}
				}
			}
			num4 = (int)(vector.X - (float)num2);
			num5 = (int)(vector.X + (float)num2);
			num6 = (int)(vector.Y - (float)num3);
			num7 = (int)(vector.Y + 1f);
			if (num4 < 0)
			{
				num4 = 0;
			}
			if (num5 > Main.maxTilesX)
			{
				num5 = Main.maxTilesX;
			}
			if (num6 < 0)
			{
				num6 = 0;
			}
			if (num7 > Main.maxTilesY)
			{
				num7 = Main.maxTilesY;
			}
			for (int n = num4; n <= num5; n++)
			{
				for (int num8 = num6; num8 < num7; num8++)
				{
					if ((num8 != num6 || (n != num4 && n != num5)) && Main.tile[n, num8].wall == 0)
					{
						Main.tile[n, num8].active(active: false);
						Main.tile[n, num8].wall = wall;
					}
				}
			}
			int num9 = i + (num2 + 1) * num;
			int num10 = (int)vector.Y;
			for (int num11 = num9 - 2; num11 <= num9 + 2; num11++)
			{
				Main.tile[num11, num10].active(active: false);
				Main.tile[num11, num10 - 1].active(active: false);
				Main.tile[num11, num10 - 2].active(active: false);
			}
			PlaceTile(num9, num10, 10, mute: true, forced: false, -1, 9);
			num9 = i + (num2 + 1) * -num - num;
			for (int num12 = num6; num12 <= num7 + 1; num12++)
			{
				Main.tile[num9, num12].active(active: true);
				Main.tile[num9, num12].liquid = 0;
				Main.tile[num9, num12].type = type;
				Main.tile[num9, num12].wall = 0;
				Main.tile[num9, num12].halfBrick(halfBrick: false);
				Main.tile[num9, num12].slope(0);
			}
			int contain = 0;
			int num13 = houseCount;
			if (num13 > 2)
			{
				num13 = genRand.Next(3);
			}
			switch (num13)
			{
			case 0:
				contain = 159;
				break;
			case 1:
				contain = 65;
				break;
			case 2:
				contain = 158;
				break;
			}
			if (getGoodWorldGen)
			{
				AddBuriedChest(i, num10 - 3, contain, notNearOtherChests: false, 2, trySlope: false, 0);
			}
			else
			{
				AddBuriedChest(i, num10 - 3, contain, notNearOtherChests: false, 13, trySlope: false, 0);
			}
			if (islandStyle > 0)
			{
				for (int num14 = 0; num14 < 100000; num14++)
				{
					int num15 = i + genRand.Next(-50, 51);
					int num16 = num10 + genRand.Next(21);
					if ((num14 >= 50000 || Main.tile[num15, num16].type != 202) && !Main.tile[num15, num16].active())
					{
						Place2xX(num15, num16, 207, islandStyle);
						if (Main.tile[num15, num16].active())
						{
							SwitchFountain(num15, num16);
							break;
						}
					}
				}
			}
			houseCount++;
			int num17 = i - num2 / 2 + 1;
			int num18 = i + num2 / 2 - 1;
			int num19 = 1;
			if (num2 > 10)
			{
				num19 = 2;
			}
			int num20 = (num6 + num7) / 2 - 1;
			for (int num21 = num17 - num19; num21 <= num17 + num19; num21++)
			{
				for (int num22 = num20 - 1; num22 <= num20 + 1; num22++)
				{
					Main.tile[num21, num22].wall = 21;
				}
			}
			for (int num23 = num18 - num19; num23 <= num18 + num19; num23++)
			{
				for (int num24 = num20 - 1; num24 <= num20 + 1; num24++)
				{
					Main.tile[num23, num24].wall = 21;
				}
			}
			int num25 = i + (num2 / 2 + 1) * -num;
			PlaceTile(num25, num7 - 1, 14, mute: true, forced: false, -1, 7);
			PlaceTile(num25 - 2, num7 - 1, 15, mute: true, forced: false, 0, 10);
			Main.tile[num25 - 2, num7 - 1].frameX += 18;
			Main.tile[num25 - 2, num7 - 2].frameX += 18;
			PlaceTile(num25 + 2, num7 - 1, 15, mute: true, forced: false, 0, 10);
			int i2 = num4 + 1;
			int j2 = num6;
			PlaceTile(i2, j2, 91, mute: true, forced: false, -1, genRand.Next(7, 10));
			i2 = num5 - 1;
			j2 = num6;
			PlaceTile(i2, j2, 91, mute: true, forced: false, -1, genRand.Next(7, 10));
			if (num > 0)
			{
				i2 = num4;
				j2 = num6 + 1;
			}
			else
			{
				i2 = num5;
				j2 = num6 + 1;
			}
			PlaceTile(i2, j2, 91, mute: true, forced: false, -1, genRand.Next(7, 10));
			if (islandStyle != 1)
			{
				return;
			}
			int num26 = genRand.Next(3, 6);
			for (int num27 = 0; num27 < 100000; num27++)
			{
				int num28 = i + genRand.Next(-50, 51);
				int num29 = num10 + genRand.Next(-10, 21);
				if (!Main.tile[num28, num29].active())
				{
					GrowPalmTree(num28, num29 + 1);
					if (Main.tile[num28, num29].active())
					{
						num26--;
					}
				}
				if (num26 <= 0)
				{
					break;
				}
			}
		}

		public static void Mountinater(int i, int j)
		{
			double num = genRand.Next(80, 120);
			double num2 = num;
			float num3 = genRand.Next(40, 55);
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = (float)j + num3 / 2f;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-10, 11) * 0.1f;
			vector2.Y = (float)genRand.Next(-20, -10) * 0.1f;
			while (num > 0.0 && num3 > 0f)
			{
				num -= (double)genRand.Next(4);
				num3 -= 1f;
				int num4 = (int)((double)vector.X - num * 0.5);
				int num5 = (int)((double)vector.X + num * 0.5);
				int num6 = (int)((double)vector.Y - num * 0.5);
				int num7 = (int)((double)vector.Y + num * 0.5);
				if (num4 < 0)
				{
					num4 = 0;
				}
				if (num5 > Main.maxTilesX)
				{
					num5 = Main.maxTilesX;
				}
				if (num6 < 0)
				{
					num6 = 0;
				}
				if (num7 > Main.maxTilesY)
				{
					num7 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				for (int k = num4; k < num5; k++)
				{
					for (int l = num6; l < num7; l++)
					{
						float num8 = Math.Abs((float)k - vector.X);
						float num9 = Math.Abs((float)l - vector.Y);
						if (Math.Sqrt(num8 * num8 + num9 * num9) < num2 * 0.4 && !Main.tile[k, l].active())
						{
							Main.tile[k, l].active(active: true);
							Main.tile[k, l].type = 0;
						}
					}
				}
				vector += vector2;
				vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
				vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
				if ((double)vector2.X > 0.5)
				{
					vector2.X = 0.5f;
				}
				if ((double)vector2.X < -0.5)
				{
					vector2.X = -0.5f;
				}
				if ((double)vector2.Y > -0.5)
				{
					vector2.Y = -0.5f;
				}
				if ((double)vector2.Y < -1.5)
				{
					vector2.Y = -1.5f;
				}
			}
		}

		public static void MakeWateryIceThing(int i, int j)
		{
			if (Main.tile[i, j].liquid <= 0 || Main.tile[i, j].active() || Main.tile[i, j].lava())
			{
				return;
			}
			int num = j;
			while (!Main.tile[i, num].active() && Main.tile[i, num].liquid > 0)
			{
				num++;
				if (num > Main.maxTilesY - 50)
				{
					return;
				}
			}
			if (Main.tile[i, num].type != 147 && Main.tile[i, num].type != 161)
			{
				return;
			}
			num--;
			while (Main.tile[i, num].liquid > 0)
			{
				num--;
				if (num < 10)
				{
					return;
				}
			}
			if (Main.tile[i, num].active())
			{
				return;
			}
			num++;
			if (!Main.tile[i, num].active())
			{
				int num2 = i;
				while (!Main.tile[num2, num].active() && Main.tile[num2, num].liquid > 0 && Main.tile[num2, num - 1].liquid == 0 && !Main.tile[num2, num - 1].active() && !Main.tile[num2 - 1, num].halfBrick())
				{
					PlaceTile(num2, num, 162, mute: true);
					num2--;
				}
				for (num2 = i + 1; !Main.tile[num2, num].active() && Main.tile[num2, num].liquid > 0 && Main.tile[num2, num - 1].liquid == 0 && !Main.tile[num2, num - 1].active() && !Main.tile[num2 + 1, num].halfBrick(); num2++)
				{
					PlaceTile(num2, num, 162, mute: true);
				}
			}
		}

		public static void Lakinater(int i, int j, float strengthMultiplier = 1f)
		{
			double num = (float)genRand.Next(25, 50) * strengthMultiplier;
			double num2 = num;
			float num3 = genRand.Next(30, 80);
			if (genRand.Next(5) == 0)
			{
				num *= 1.5;
				num2 *= 1.5;
				num3 *= 1.2f;
			}
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = (float)j - num3 * 0.3f;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-10, 11) * 0.1f;
			vector2.Y = (float)genRand.Next(-20, -10) * 0.1f;
			while (num > 0.0 && num3 > 0f)
			{
				if ((double)vector.Y + num2 * 0.5 > Main.worldSurface)
				{
					num3 = 0f;
				}
				num -= (double)genRand.Next(3);
				num3 -= 1f;
				int num4 = (int)((double)vector.X - num * 0.5);
				int num5 = (int)((double)vector.X + num * 0.5);
				int num6 = (int)((double)vector.Y - num * 0.5);
				int num7 = (int)((double)vector.Y + num * 0.5);
				if (num4 < 0)
				{
					num4 = 0;
				}
				if (num5 > Main.maxTilesX)
				{
					num5 = Main.maxTilesX;
				}
				if (num6 < 0)
				{
					num6 = 0;
				}
				if (num7 > Main.maxTilesY)
				{
					num7 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				for (int k = num4; k < num5; k++)
				{
					for (int l = num6; l < num7; l++)
					{
						float num8 = Math.Abs((float)k - vector.X);
						float num9 = Math.Abs((float)l - vector.Y);
						if (Math.Sqrt(num8 * num8 + num9 * num9) < num2 * 0.4)
						{
							if (Main.tile[k, l].active())
							{
								Main.tile[k, l].liquid = byte.MaxValue;
							}
							Main.tile[k, l].active(active: false);
						}
					}
				}
				vector += vector2;
				vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
				vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
				if ((double)vector2.X > 0.5)
				{
					vector2.X = 0.5f;
				}
				if ((double)vector2.X < -0.5)
				{
					vector2.X = -0.5f;
				}
				if ((double)vector2.Y > 1.5)
				{
					vector2.Y = 1.5f;
				}
				if ((double)vector2.Y < 0.5)
				{
					vector2.Y = 0.5f;
				}
			}
		}

		public static void SonOfLakinater(int i, int j, float strengthMultiplier = 1f)
		{
			bool lava = false;
			if (getGoodWorldGen && genRand.Next(3) == 0)
			{
				lava = true;
			}
			double num = (float)genRand.Next(15, 31) * strengthMultiplier;
			float num2 = genRand.Next(30, 61);
			if (genRand.Next(5) == 0)
			{
				num *= 1.2999999523162842;
				num2 *= 1.3f;
			}
			if (drunkWorldGen)
			{
				num *= 1.2999999523162842;
				num2 *= 1.3f;
			}
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			float num3 = genRand.NextFloat() * 0.002f;
			Vector2 vector2 = default(Vector2);
			if (genRand.Next(4) != 0)
			{
				vector2.X = (float)genRand.Next(-15, 16) * 0.01f;
			}
			else
			{
				vector2.X = (float)genRand.Next(-50, 51) * 0.01f;
				num3 = genRand.NextFloat() * 0.004f + 0.001f;
			}
			vector2.Y = (float)genRand.Next(101) * 0.01f;
			double num4 = num;
			float num5 = num2;
			while (num > 3.0 && num2 > 0f)
			{
				num -= (double)((float)genRand.Next(11) * 0.1f);
				num2 -= 1f;
				int num6 = (int)((double)vector.X - num * 4.0);
				int num7 = (int)((double)vector.X + num * 4.0);
				int num8 = (int)((double)vector.Y - num * 3.0);
				int num9 = (int)((double)vector.Y + num * 2.0);
				if (num6 < 0)
				{
					num6 = 0;
				}
				if (num7 > Main.maxTilesX)
				{
					num7 = Main.maxTilesX;
				}
				if (num8 < 0)
				{
					num8 = 0;
				}
				if (num9 > Main.maxTilesY)
				{
					num9 = Main.maxTilesY;
				}
				num4 = num;
				for (int k = num6; k < num7; k++)
				{
					for (int l = num8; l < num9; l++)
					{
						float value = Math.Abs((float)k - vector.X) * 0.6f;
						float value2 = Math.Abs((float)l - vector.Y) * 1.4f;
						float value3 = Math.Abs((float)k - vector.X) * 0.3f;
						float value4 = Math.Abs((float)l - vector.Y) * 5f;
						value = MathHelper.Lerp(value, value3, num2 / num5);
						value2 = MathHelper.Lerp(value2, value4, num2 / num5);
						double num10 = Math.Sqrt(value * value + value2 * value2);
						int num11 = j + 5;
						if (num10 < num4 * 0.4)
						{
							if (l >= j)
							{
								if (l <= j + 1)
								{
									if (WillWaterPlacedHereStayPut(k, l))
									{
										Main.tile[k, l].liquid = byte.MaxValue;
										Main.tile[k, l].lava(lava);
									}
								}
								else
								{
									Main.tile[k, l].liquid = byte.MaxValue;
									Main.tile[k, l].lava(lava);
								}
							}
							Main.tile[k, l].active(active: false);
							if (!gen)
							{
								SquareTileFrame(k, l);
							}
							if (Main.tile[k, l].type == 59 || Main.tile[k, l].type == 60)
							{
								SpreadGrass(k - 1, l, 59, 60, repeat: true, 0);
								SpreadGrass(k + 1, l, 59, 60, repeat: true, 0);
								SpreadGrass(k, l + 1, 59, 60, repeat: true, 0);
							}
						}
						else if (l > j + 1 && num10 < num4 && Main.tile[k, l].liquid == 0)
						{
							if ((double)Math.Abs((float)k - vector.X) * 0.8 < num4 && Main.tile[k, l].wall > 0 && Main.tile[k - 1, l].wall > 0 && Main.tile[k + 1, l].wall > 0 && Main.tile[k, l + 1].wall > 0)
							{
								Main.tile[k, l].active(active: true);
							}
						}
						else
						{
							if (l >= j || num2 != num5 - 1f || !((double)l > worldSurfaceLow - 20.0) || TileID.Sets.Clouds[Main.tile[k, l].type])
							{
								continue;
							}
							value = (float)Math.Abs(k - i) * 0.7f;
							value2 = (float)Math.Abs(l - num11) * 1.35f;
							num10 = Math.Sqrt(value * value + value2 * value2);
							float num12 = (float)num4 * 0.4f;
							float num13 = (float)Math.Abs(k - i) / (float)(num7 - i);
							num13 = 1f - num13;
							num13 *= 2.3f;
							num13 *= num13;
							num13 *= num13;
							if (l < num11 && (double)value < (double)num12 + (double)Math.Abs(l - num11) * 0.5 * (double)num13)
							{
								Main.tile[k, l].active(active: false);
								if (Main.tile[k, l].type == 59 || Main.tile[k, l].type == 60)
								{
									SpreadGrass(k - 1, l, 59, 60, repeat: true, 0);
									SpreadGrass(k + 1, l, 59, 60, repeat: true, 0);
									SpreadGrass(k, l + 1, 59, 60, repeat: true, 0);
								}
							}
						}
					}
				}
				vector += vector2;
				vector2.X += (float)genRand.Next(-100, 101) * num3;
				vector2.Y += (float)genRand.Next(-100, 101) * 0.01f;
				if (vector2.X > 1f)
				{
					vector2.X = 1f;
				}
				if (vector2.X < -1f)
				{
					vector2.X = -1f;
				}
				if (vector2.Y > 1f)
				{
					vector2.Y = 1f;
				}
				float num14 = 0.5f * (1f - num2 / num5);
				if (vector2.Y < num14)
				{
					vector2.Y = num14;
				}
			}
		}

		public static void ShroomPatch(int i, int j)
		{
			double num = genRand.Next(80, 100);
			float num2 = genRand.Next(20, 26);
			float num3 = Main.maxTilesX / 4200;
			if (getGoodWorldGen)
			{
				num3 *= 2f;
			}
			num *= (double)num3;
			num2 *= num3;
			float num4 = num2 - 1f;
			double num5 = num;
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = (float)j - num2 * 0.3f;
			Vector2 vector2 = default(Vector2);
			vector2.X = (float)genRand.Next(-100, 101) * 0.005f;
			vector2.Y = (float)genRand.Next(-200, -100) * 0.005f;
			while (num > 0.0 && num2 > 0f)
			{
				num -= (double)genRand.Next(3);
				num2 -= 1f;
				int num6 = (int)((double)vector.X - num * 0.5);
				int num7 = (int)((double)vector.X + num * 0.5);
				int num8 = (int)((double)vector.Y - num * 0.5);
				int num9 = (int)((double)vector.Y + num * 0.5);
				if (num6 < 0)
				{
					num6 = 0;
				}
				if (num7 > Main.maxTilesX)
				{
					num7 = Main.maxTilesX;
				}
				if (num8 < 0)
				{
					num8 = 0;
				}
				if (num9 > Main.maxTilesY)
				{
					num9 = Main.maxTilesY;
				}
				num5 = num * (double)genRand.Next(80, 120) * 0.01;
				for (int k = num6; k < num7; k++)
				{
					for (int l = num8; l < num9; l++)
					{
						float num10 = Math.Abs((float)k - vector.X);
						float num11 = Math.Abs(((float)l - vector.Y) * 2.3f);
						double num12 = Math.Sqrt(num10 * num10 + num11 * num11);
						if (num12 < num5 * 0.8 && Main.tile[k, l].lava())
						{
							Main.tile[k, l].liquid = 0;
						}
						if (num12 < num5 * 0.2 && (float)l < vector.Y)
						{
							Main.tile[k, l].active(active: false);
							if (Main.tile[k, l].wall > 0)
							{
								Main.tile[k, l].wall = 80;
							}
						}
						else if (num12 < num5 * 0.4 * (0.95 + (double)genRand.NextFloat() * 0.1))
						{
							Main.tile[k, l].type = 59;
							if (num2 == num4 && (float)l > vector.Y)
							{
								Main.tile[k, l].active(active: true);
							}
							if (Main.tile[k, l].wall > 0)
							{
								Main.tile[k, l].wall = 80;
							}
						}
					}
				}
				vector += vector2;
				vector.X += vector2.X;
				vector2.X += (float)genRand.Next(-100, 110) * 0.005f;
				vector2.Y -= (float)genRand.Next(110) * 0.005f;
				if ((double)vector2.X > -0.5 && (double)vector2.X < 0.5)
				{
					if (vector2.X < 0f)
					{
						vector2.X = -0.5f;
					}
					else
					{
						vector2.X = 0.5f;
					}
				}
				if ((double)vector2.X > 0.5)
				{
					vector2.X = 0.5f;
				}
				if ((double)vector2.X < -0.5)
				{
					vector2.X = -0.5f;
				}
				if ((double)vector2.Y > 0.5)
				{
					vector2.Y = 0.5f;
				}
				if ((double)vector2.Y < -0.5)
				{
					vector2.Y = -0.5f;
				}
				for (int m = 0; m < 2; m++)
				{
					int num13 = (int)vector.X + genRand.Next(-20, 20);
					int num14 = (int)vector.Y + genRand.Next(0, 20);
					while (!Main.tile[num13, num14].active() && Main.tile[num13, num14].type != 59)
					{
						num13 = (int)vector.X + genRand.Next(-20, 20);
						num14 = (int)vector.Y + genRand.Next(0, 20);
					}
					int num15 = genRand.Next(10, 20);
					int steps = genRand.Next(10, 20);
					TileRunner(num13, num14, num15, steps, 59, addTile: false, 0f, 2f, noYChange: true);
				}
			}
		}

		public static void Cavinator(int i, int j, int steps)
		{
			double num = genRand.Next(7, 15);
			double num2 = num;
			int num3 = 1;
			if (genRand.Next(2) == 0)
			{
				num3 = -1;
			}
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			int num4 = genRand.Next(20, 40);
			Vector2 vector2 = default(Vector2);
			vector2.Y = (float)genRand.Next(10, 20) * 0.01f;
			vector2.X = num3;
			while (num4 > 0)
			{
				num4--;
				int num5 = (int)((double)vector.X - num * 0.5);
				int num6 = (int)((double)vector.X + num * 0.5);
				int num7 = (int)((double)vector.Y - num * 0.5);
				int num8 = (int)((double)vector.Y + num * 0.5);
				if (num5 < 0)
				{
					num5 = 0;
				}
				if (num6 > Main.maxTilesX)
				{
					num6 = Main.maxTilesX;
				}
				if (num7 < 0)
				{
					num7 = 0;
				}
				if (num8 > Main.maxTilesY)
				{
					num8 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				for (int k = num5; k < num6; k++)
				{
					for (int l = num7; l < num8; l++)
					{
						float num9 = Math.Abs((float)k - vector.X);
						float num10 = Math.Abs((float)l - vector.Y);
						if (Math.Sqrt(num9 * num9 + num10 * num10) < num2 * 0.4 && TileID.Sets.CanBeClearedDuringGeneration[Main.tile[k, l].type] && Main.tile[k, l].type != 53)
						{
							Main.tile[k, l].active(active: false);
						}
					}
				}
				vector += vector2;
				vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
				vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
				if (vector2.X > (float)num3 + 0.5f)
				{
					vector2.X = (float)num3 + 0.5f;
				}
				if (vector2.X < (float)num3 - 0.5f)
				{
					vector2.X = (float)num3 - 0.5f;
				}
				if (vector2.Y > 2f)
				{
					vector2.Y = 2f;
				}
				if (vector2.Y < 0f)
				{
					vector2.Y = 0f;
				}
			}
			if (steps > 0 && (double)(int)vector.Y < Main.rockLayer + 50.0)
			{
				Cavinator((int)vector.X, (int)vector.Y, steps - 1);
			}
		}

		public static void CaveOpenater(int i, int j)
		{
			double num = genRand.Next(7, 12);
			double num2 = num;
			int num3 = 1;
			if (genRand.Next(2) == 0)
			{
				num3 = -1;
			}
			if (genRand.Next(10) != 0)
			{
				num3 = ((i < Main.maxTilesX / 2) ? 1 : (-1));
			}
			Vector2 vector = default(Vector2);
			vector.X = i;
			vector.Y = j;
			int num4 = 100;
			Vector2 vector2 = default(Vector2);
			vector2.Y = 0f;
			vector2.X = num3;
			while (num4 > 0)
			{
				Tile tile = Main.tile[(int)vector.X, (int)vector.Y];
				if (tile.wall == 0 || (tile.active() && !TileID.Sets.CanBeClearedDuringGeneration[tile.type]))
				{
					num4 = 0;
				}
				num4--;
				int num5 = (int)((double)vector.X - num * 0.5);
				int num6 = (int)((double)vector.X + num * 0.5);
				int num7 = (int)((double)vector.Y - num * 0.5);
				int num8 = (int)((double)vector.Y + num * 0.5);
				if (num5 < 0)
				{
					num5 = 0;
				}
				if (num6 > Main.maxTilesX)
				{
					num6 = Main.maxTilesX;
				}
				if (num7 < 0)
				{
					num7 = 0;
				}
				if (num8 > Main.maxTilesY)
				{
					num8 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				for (int k = num5; k < num6; k++)
				{
					for (int l = num7; l < num8; l++)
					{
						float num9 = Math.Abs((float)k - vector.X);
						float num10 = Math.Abs((float)l - vector.Y);
						if (Math.Sqrt(num9 * num9 + num10 * num10) < num2 * 0.4 && TileID.Sets.CanBeClearedDuringGeneration[Main.tile[k, l].type])
						{
							Main.tile[k, l].active(active: false);
						}
					}
				}
				vector += vector2;
				vector2.X += (float)genRand.Next(-10, 11) * 0.05f;
				vector2.Y += (float)genRand.Next(-10, 11) * 0.05f;
				if (vector2.X > (float)num3 + 0.5f)
				{
					vector2.X = (float)num3 + 0.5f;
				}
				if (vector2.X < (float)num3 - 0.5f)
				{
					vector2.X = (float)num3 - 0.5f;
				}
				if (vector2.Y > 0f)
				{
					vector2.Y = 0f;
				}
				if ((double)vector2.Y < -0.5)
				{
					vector2.Y = -0.5f;
				}
			}
		}

		public static void DiamondTileFrame(int i, int j)
		{
			TileFrame(i - 1, j);
			TileFrame(i, j - 1);
			TileFrame(i, j + 1);
			TileFrame(i + 1, j);
		}

		public static void SquareTileFrame(int i, int j, bool resetFrame = true)
		{
			TileFrame(i - 1, j - 1);
			TileFrame(i - 1, j);
			TileFrame(i - 1, j + 1);
			TileFrame(i, j - 1);
			TileFrame(i, j, resetFrame);
			TileFrame(i, j + 1);
			TileFrame(i + 1, j - 1);
			TileFrame(i + 1, j);
			TileFrame(i + 1, j + 1);
		}

		public static void SquareWallFrame(int i, int j, bool resetFrame = true)
		{
			Framing.WallFrame(i - 1, j - 1);
			Framing.WallFrame(i - 1, j);
			Framing.WallFrame(i - 1, j + 1);
			Framing.WallFrame(i, j - 1);
			Framing.WallFrame(i, j, resetFrame);
			Framing.WallFrame(i, j + 1);
			Framing.WallFrame(i + 1, j - 1);
			Framing.WallFrame(i + 1, j);
			Framing.WallFrame(i + 1, j + 1);
		}

		public static void SectionTileFrameWithCheck(int startX, int startY, int endX, int endY)
		{
			int sectionX = Netplay.GetSectionX(startX);
			int sectionY = Netplay.GetSectionY(startY);
			int sectionX2 = Netplay.GetSectionX(endX);
			int sectionY2 = Netplay.GetSectionY(endY);
			for (int i = sectionX; i <= sectionX2; i++)
			{
				for (int j = sectionY; j <= sectionY2; j++)
				{
					if (Main.sectionManager.SectionLoaded(i, j) && !Main.sectionManager.SectionFramed(i, j))
					{
						SectionTileFrame(i, j, i, j);
						if (Main.sectionManager.FrameSectionsLeft == 0)
						{
							return;
						}
					}
				}
			}
		}

		public static void SectionTileFrame(int startX, int startY, int endX, int endY)
		{
			Main.mapTime = Main.mapTimeMax + 10;
			noMapUpdate = true;
			int num = startX * 200;
			int num2 = (endX + 1) * 200;
			int num3 = startY * 150;
			int num4 = (endY + 1) * 150;
			if (num < 1)
			{
				num = 1;
			}
			if (num3 < 1)
			{
				num3 = 1;
			}
			if (num > Main.maxTilesX - 2)
			{
				num = Main.maxTilesX - 2;
			}
			if (num3 > Main.maxTilesY - 2)
			{
				num3 = Main.maxTilesY - 2;
			}
			if (num2 > Main.maxTilesX - 2)
			{
				num2 = Main.maxTilesX - 2;
			}
			if (num4 > Main.maxTilesY - 2)
			{
				num4 = Main.maxTilesY - 2;
			}
			for (int i = num - 1; i < num2 + 1; i++)
			{
				for (int j = num3 - 1; j < num4 + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					TileFrame(i, j, resetFrame: true, noBreak: true);
					Framing.WallFrame(i, j, resetFrame: true);
				}
			}
			for (int k = startX; k <= endX; k++)
			{
				for (int l = startY; l <= endY; l++)
				{
					Main.sectionManager.SetSectionFramed(k, l);
				}
			}
			noMapUpdate = false;
		}

		public static void RangeFrame(int startX, int startY, int endX, int endY)
		{
			int num = endX + 1;
			int num2 = endY + 1;
			for (int i = startX - 1; i < num + 1; i++)
			{
				for (int j = startY - 1; j < num2 + 1; j++)
				{
					TileFrame(i, j);
					Framing.WallFrame(i, j);
				}
			}
		}

		public static void WaterCheck()
		{
			Liquid.tilesIgnoreWater(ignoreSolids: true);
			Liquid.numLiquid = 0;
			LiquidBuffer.numLiquidBuffer = 0;
			for (int i = 1; i < Main.maxTilesX - 1; i++)
			{
				for (int num = Main.maxTilesY - 2; num > 0; num--)
				{
					Tile tile = Main.tile[i, num];
					tile.checkingLiquid(checkingLiquid: false);
					if (tile.liquid > 0 && tile.nactive() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type])
					{
						tile.liquid = 0;
					}
					else if (tile.liquid > 0)
					{
						if (tile.active())
						{
							if (tile.lava())
							{
								if (TileObjectData.CheckLavaDeath(tile))
								{
									KillTile(i, num);
								}
							}
							else if (TileObjectData.CheckWaterDeath(tile))
							{
								KillTile(i, num);
							}
						}
						Tile tile2 = Main.tile[i, num + 1];
						if ((!tile2.nactive() || !Main.tileSolid[tile2.type] || Main.tileSolidTop[tile2.type]) && tile2.liquid < byte.MaxValue)
						{
							if (tile2.liquid > 250)
							{
								tile2.liquid = byte.MaxValue;
							}
							else
							{
								Liquid.AddWater(i, num);
							}
						}
						Tile tile3 = Main.tile[i - 1, num];
						Tile tile4 = Main.tile[i + 1, num];
						if ((!tile3.nactive() || !Main.tileSolid[tile3.type] || Main.tileSolidTop[tile3.type]) && tile3.liquid != tile.liquid)
						{
							Liquid.AddWater(i, num);
						}
						else if ((!tile4.nactive() || !Main.tileSolid[tile4.type] || Main.tileSolidTop[tile4.type]) && tile4.liquid != tile.liquid)
						{
							Liquid.AddWater(i, num);
						}
						if (tile.lava())
						{
							if (tile3.liquid > 0 && !tile3.lava())
							{
								Liquid.AddWater(i, num);
							}
							else if (tile4.liquid > 0 && !tile4.lava())
							{
								Liquid.AddWater(i, num);
							}
							else if (Main.tile[i, num - 1].liquid > 0 && !Main.tile[i, num - 1].lava())
							{
								Liquid.AddWater(i, num);
							}
							else if (tile2.liquid > 0 && !tile2.lava())
							{
								Liquid.AddWater(i, num);
							}
						}
					}
				}
			}
			Liquid.tilesIgnoreWater(ignoreSolids: false);
		}

		public static void EveryTileFrame()
		{
			Stopwatch stopwatch = new Stopwatch();
			stopwatch.Start();
			noLiquidCheck = true;
			noTileActions = true;
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				float num = (float)i / (float)Main.maxTilesX;
				Main.statusText = Lang.gen[55].Value + " " + (int)(num * 100f + 1f) + "%";
				for (int j = 0; j < Main.maxTilesY; j++)
				{
					if (Main.tile[i, j].active())
					{
						TileFrame(i, j, resetFrame: true);
					}
					if (Main.tile[i, j].wall > 0)
					{
						Framing.WallFrame(i, j, resetFrame: true);
					}
				}
			}
			noLiquidCheck = false;
			noTileActions = false;
			_ = stopwatch.ElapsedMilliseconds;
		}

		public static void PlantCheck(int x, int y)
		{
			x = Utils.Clamp(x, 1, Main.maxTilesX - 2);
			y = Utils.Clamp(y, 1, Main.maxTilesY - 2);
			for (int i = x - 1; i <= x + 1; i++)
			{
				for (int j = y - 1; j <= y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						return;
					}
				}
			}
			int num = -1;
			int num2 = Main.tile[x, y].type;
			_ = x - 1;
			_ = 0;
			_ = x + 1;
			_ = Main.maxTilesX;
			_ = y - 1;
			_ = 0;
			if (y + 1 >= Main.maxTilesY)
			{
				num = num2;
			}
			if (x - 1 >= 0 && Main.tile[x - 1, y] != null && Main.tile[x - 1, y].nactive())
			{
				_ = Main.tile[x - 1, y].type;
			}
			if (x + 1 < Main.maxTilesX && Main.tile[x + 1, y] != null && Main.tile[x + 1, y].nactive())
			{
				_ = Main.tile[x + 1, y].type;
			}
			if (y - 1 >= 0 && Main.tile[x, y - 1] != null && Main.tile[x, y - 1].nactive())
			{
				_ = Main.tile[x, y - 1].type;
			}
			if (y + 1 < Main.maxTilesY && Main.tile[x, y + 1] != null && Main.tile[x, y + 1].nactive() && !Main.tile[x, y + 1].halfBrick() && Main.tile[x, y + 1].slope() == 0)
			{
				num = Main.tile[x, y + 1].type;
			}
			if (x - 1 >= 0 && y - 1 >= 0 && Main.tile[x - 1, y - 1] != null && Main.tile[x - 1, y - 1].nactive())
			{
				_ = Main.tile[x - 1, y - 1].type;
			}
			if (x + 1 < Main.maxTilesX && y - 1 >= 0 && Main.tile[x + 1, y - 1] != null && Main.tile[x + 1, y - 1].nactive())
			{
				_ = Main.tile[x + 1, y - 1].type;
			}
			if (x - 1 >= 0 && y + 1 < Main.maxTilesY && Main.tile[x - 1, y + 1] != null && Main.tile[x - 1, y + 1].nactive())
			{
				_ = Main.tile[x - 1, y + 1].type;
			}
			if (x + 1 < Main.maxTilesX && y + 1 < Main.maxTilesY && Main.tile[x + 1, y + 1] != null && Main.tile[x + 1, y + 1].nactive())
			{
				_ = Main.tile[x + 1, y + 1].type;
			}
			if ((num2 != 3 || num == 2 || num == 477 || num == 78 || num == 380 || num == 579) && (num2 != 73 || num == 2 || num == 477 || num == 78 || num == 380 || num == 579) && (num2 != 24 || num == 23) && (num2 != 61 || num == 60) && (num2 != 74 || num == 60) && (num2 != 71 || num == 70) && (num2 != 110 || num == 109 || num == 492) && (num2 != 113 || num == 109 || num == 492) && (num2 != 201 || num == 199))
			{
				return;
			}
			if ((num2 == 3 || num2 == 73) && num != 2 && num != 477 && Main.tile[x, y].frameX >= 162)
			{
				Main.tile[x, y].frameX = 126;
			}
			if (num2 == 74 && num != 60 && Main.tile[x, y].frameX >= 162)
			{
				Main.tile[x, y].frameX = 126;
			}
			switch (num)
			{
			case 23:
				num2 = 24;
				if (Main.tile[x, y].frameX >= 162)
				{
					Main.tile[x, y].frameX = 126;
				}
				break;
			case 2:
			case 477:
				num2 = ((num2 != 113) ? 3 : 73);
				break;
			case 109:
			case 492:
				num2 = ((num2 != 73) ? 110 : 113);
				break;
			case 199:
				num2 = 201;
				break;
			case 70:
				num2 = 71;
				while (Main.tile[x, y].frameX > 72)
				{
					Main.tile[x, y].frameX -= 72;
				}
				break;
			}
			if (num2 != Main.tile[x, y].type)
			{
				Main.tile[x, y].type = (ushort)num2;
			}
			else
			{
				KillTile(x, y);
			}
		}

		public static bool CanPoundTile(int x, int y)
		{
			if (Main.tile[x, y] == null)
			{
				Main.tile[x, y] = new Tile();
			}
			if (Main.tile[x, y - 1] == null)
			{
				Main.tile[x, y - 1] = new Tile();
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = new Tile();
			}
			switch (Main.tile[x, y].type)
			{
			case 10:
			case 48:
			case 137:
			case 138:
			case 232:
			case 380:
			case 387:
			case 388:
			case 476:
			case 484:
				return false;
			default:
				if (gen)
				{
					if (Main.tile[x, y].type == 190)
					{
						return false;
					}
					if (Main.tile[x, y].type == 30)
					{
						return false;
					}
				}
				if (Main.tile[x, y - 1].active())
				{
					switch (Main.tile[x, y - 1].type)
					{
					case 21:
					case 26:
					case 77:
					case 88:
					case 235:
					case 237:
					case 441:
					case 467:
					case 468:
					case 470:
					case 475:
					case 488:
					case 597:
						return false;
					}
				}
				return CanKillTile(x, y);
			}
		}

		public static bool SlopeTile(int i, int j, int slope = 0, bool noEffects = false)
		{
			if (!CanPoundTile(i, j))
			{
				return false;
			}
			Main.tile[i, j].halfBrick(halfBrick: false);
			Main.tile[i, j].slope((byte)slope);
			if (!gen)
			{
				if (!noEffects)
				{
					KillTile(i, j, fail: true, effectOnly: true);
				}
				SoundEngine.PlaySound(0, i * 16, j * 16);
				SquareTileFrame(i, j);
				if (Main.tile[i, j].slope() == 0)
				{
					Rectangle rectangle = new Rectangle(i * 16, j * 16, 16, 16);
					for (int k = 0; k < 255; k++)
					{
						if (Main.player[k].active && !Main.player[k].dead && rectangle.Intersects(new Rectangle((int)Main.player[k].position.X, (int)Main.player[k].position.Y, Main.player[k].width, Main.player[k].height)))
						{
							Main.player[k].gfxOffY += Main.player[k].position.Y + (float)Main.player[k].height - (float)rectangle.Y;
							Main.player[k].position.Y = rectangle.Y - Main.player[k].height;
						}
					}
				}
			}
			return true;
		}

		public static bool PoundTile(int i, int j)
		{
			if (!CanPoundTile(i, j))
			{
				return false;
			}
			if (!Main.tile[i, j].halfBrick())
			{
				Main.tile[i, j].halfBrick(halfBrick: true);
			}
			else
			{
				Main.tile[i, j].halfBrick(halfBrick: false);
			}
			if (!gen)
			{
				KillTile(i, j, fail: true, effectOnly: true);
				SoundEngine.PlaySound(0, i * 16, j * 16);
				SquareTileFrame(i, j);
				if (!Main.tile[i, j].halfBrick())
				{
					Rectangle rectangle = new Rectangle(i * 16, j * 16, 16, 16);
					for (int k = 0; k < 255; k++)
					{
						if (Main.player[k].active && !Main.player[k].dead && rectangle.Intersects(new Rectangle((int)Main.player[k].position.X, (int)Main.player[k].position.Y, Main.player[k].width, Main.player[k].height)))
						{
							Main.player[k].gfxOffY += Main.player[k].position.Y + (float)Main.player[k].height - (float)rectangle.Y;
							Main.player[k].position.Y = rectangle.Y - Main.player[k].height;
						}
					}
				}
			}
			return true;
		}

		public static void PoundPlatform(int x, int y)
		{
			if (Main.tile[x, y].halfBrick())
			{
				PoundTile(x, y);
				if (Main.netMode == 1)
				{
					NetMessage.SendData(17, -1, -1, null, 7, x, y, 1f);
				}
				return;
			}
			int num = 1;
			int slope = 2;
			if (TileID.Sets.Platforms[Main.tile[x + 1, y - 1].type] || TileID.Sets.Platforms[Main.tile[x - 1, y + 1].type] || (SolidTile(x + 1, y) && !SolidTile(x - 1, y)))
			{
				num = 2;
				slope = 1;
			}
			if (Main.tile[x, y].slope() == 0)
			{
				SlopeTile(x, y, num);
				int num2 = Main.tile[x, y].slope();
				if (Main.netMode == 1)
				{
					NetMessage.SendData(17, -1, -1, null, 14, x, y, num2);
				}
				return;
			}
			if (Main.tile[x, y].slope() == num)
			{
				SlopeTile(x, y, slope);
				int num3 = Main.tile[x, y].slope();
				if (Main.netMode == 1)
				{
					NetMessage.SendData(17, -1, -1, null, 14, x, y, num3);
				}
				return;
			}
			SlopeTile(x, y);
			int num4 = Main.tile[x, y].slope();
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 14, x, y, num4);
			}
			PoundTile(x, y);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 7, x, y, 1f);
			}
		}

		public static int PlatformProperSides(int x, int y, bool acceptNonOpposing = false)
		{
			Tile tile = Main.tile[x, y];
			if (!tile.active() || !TileID.Sets.Platforms[tile.type])
			{
				return 0;
			}
			int num = tile.slope();
			int num2 = -1;
			if (num == 1)
			{
				num2 = 2;
			}
			if (num == 2)
			{
				num2 = 1;
			}
			int num3 = 0;
			int num4 = 1;
			int num5 = 0;
			if (num == 1)
			{
				num5 = 1;
			}
			if (num == 2)
			{
				num5 = -1;
			}
			if (acceptNonOpposing)
			{
				if (Main.tile[x + num4, y + num5].active() && TileID.Sets.Platforms[Main.tile[x + num4, y + num5].type] && Main.tile[x + num4, y + num5].slope() != num2)
				{
					num3++;
				}
			}
			else if (Main.tile[x + num4, y + num5].active() && TileID.Sets.Platforms[Main.tile[x + num4, y + num5].type] && Main.tile[x + num4, y + num5].slope() == num)
			{
				num3++;
			}
			num4 *= -1;
			num5 *= -1;
			if (acceptNonOpposing)
			{
				if (Main.tile[x + num4, y + num5].active() && TileID.Sets.Platforms[Main.tile[x + num4, y + num5].type] && Main.tile[x + num4, y + num5].slope() != num2)
				{
					num3++;
				}
			}
			else if (Main.tile[x + num4, y + num5].active() && TileID.Sets.Platforms[Main.tile[x + num4, y + num5].type] && Main.tile[x + num4, y + num5].slope() == num)
			{
				num3++;
			}
			return num3;
		}

		public static bool UpdateMapTile(int i, int j, bool addToList = true)
		{
			bool result = false;
			if (Main.mapEnabled && !noMapUpdate && !gen && Main.Map[i, j].Light > 0 && Main.Map.UpdateType(i, j) && addToList)
			{
				result = true;
				if (MapHelper.numUpdateTile < MapHelper.maxUpdateTile - 1)
				{
					MapHelper.updateTileX[MapHelper.numUpdateTile] = (short)i;
					MapHelper.updateTileY[MapHelper.numUpdateTile] = (short)j;
					MapHelper.numUpdateTile++;
				}
				else
				{
					Main.refreshMap = true;
				}
			}
			return result;
		}

		public static void TileMergeAttemptFrametest(int i, int j, int myType, int lookfor, int up, int down, int left, int right, int upLeft, int upRight, int downLeft, int downRight)
		{
			if (up == lookfor)
			{
				TileFrame(i, j - 1);
				if (mergeDown)
				{
					up = myType;
				}
			}
			if (down == lookfor)
			{
				TileFrame(i, j + 1);
				if (mergeUp)
				{
					down = myType;
				}
			}
			if (left == lookfor)
			{
				TileFrame(i - 1, j);
				if (mergeRight)
				{
					left = myType;
				}
			}
			if (right == lookfor)
			{
				TileFrame(i + 1, j);
				if (mergeLeft)
				{
					right = myType;
				}
			}
			if (upLeft == lookfor)
			{
				upLeft = myType;
			}
			if (upRight == lookfor)
			{
				upRight = myType;
			}
			if (downLeft == lookfor)
			{
				downLeft = myType;
			}
			if (downRight == lookfor)
			{
				downRight = myType;
			}
		}

		public static void TileMergeAttemptFrametest(int i, int j, int myType, bool[] lookfor, int up, int down, int left, int right, int upLeft, int upRight, int downLeft, int downRight)
		{
			if (up > -1 && lookfor[up])
			{
				TileFrame(i, j - 1);
				if (mergeDown)
				{
					up = myType;
				}
			}
			if (down > -1 && lookfor[down])
			{
				TileFrame(i, j + 1);
				if (mergeUp)
				{
					down = myType;
				}
			}
			if (left > -1 && lookfor[left])
			{
				TileFrame(i - 1, j);
				if (mergeRight)
				{
					left = myType;
				}
			}
			if (right > -1 && lookfor[right])
			{
				TileFrame(i + 1, j);
				if (mergeLeft)
				{
					right = myType;
				}
			}
			if (upLeft > -1 && lookfor[upLeft])
			{
				upLeft = myType;
			}
			if (upRight > -1 && lookfor[upRight])
			{
				upRight = myType;
			}
			if (downLeft > -1 && lookfor[downLeft])
			{
				downLeft = myType;
			}
			if (downRight > -1 && lookfor[downRight])
			{
				downRight = myType;
			}
		}

		public static void TileMergeAttempt(int myType, int lookfor, int up, int down, int left, int right)
		{
			if (lookfor == up)
			{
				up = myType;
			}
			if (lookfor == down)
			{
				down = myType;
			}
			if (lookfor == left)
			{
				left = myType;
			}
			if (lookfor == right)
			{
				right = myType;
			}
		}

		public static void TileMergeAttempt(int myType, int lookfor, int up, int down, int left, int right, int upLeft, int upRight, int downLeft, int downRight)
		{
			if (lookfor == up)
			{
				up = myType;
			}
			if (lookfor == down)
			{
				down = myType;
			}
			if (lookfor == left)
			{
				left = myType;
			}
			if (lookfor == right)
			{
				right = myType;
			}
			if (lookfor == upLeft)
			{
				upLeft = myType;
			}
			if (lookfor == upRight)
			{
				upRight = myType;
			}
			if (lookfor == downLeft)
			{
				downLeft = myType;
			}
			if (lookfor == downRight)
			{
				downRight = myType;
			}
		}

		public static void TileMergeAttempt(int myType, bool[] lookfor, int up, int down, int left, int right, int upLeft, int upRight, int downLeft, int downRight)
		{
			if (up > -1 && lookfor[up])
			{
				up = myType;
			}
			if (down > -1 && lookfor[down])
			{
				down = myType;
			}
			if (left > -1 && lookfor[left])
			{
				left = myType;
			}
			if (right > -1 && lookfor[right])
			{
				right = myType;
			}
			if (upLeft > -1 && lookfor[upLeft])
			{
				upLeft = myType;
			}
			if (upRight > -1 && lookfor[upRight])
			{
				upRight = myType;
			}
			if (downLeft > -1 && lookfor[downLeft])
			{
				downLeft = myType;
			}
			if (downRight > -1 && lookfor[downRight])
			{
				downRight = myType;
			}
		}

		public static void TileMergeAttempt(int myType, bool[] lookfor, bool[] exclude, int up, int down, int left, int right, int upLeft, int upRight, int downLeft, int downRight)
		{
			if (up > -1 && !exclude[up] && lookfor[up])
			{
				up = myType;
			}
			if (down > -1 && !exclude[down] && lookfor[down])
			{
				down = myType;
			}
			if (left > -1 && !exclude[left] && lookfor[left])
			{
				left = myType;
			}
			if (right > -1 && !exclude[right] && lookfor[right])
			{
				right = myType;
			}
			if (upLeft > -1 && !exclude[upLeft] && lookfor[upLeft])
			{
				upLeft = myType;
			}
			if (upRight > -1 && !exclude[upRight] && lookfor[upRight])
			{
				upRight = myType;
			}
			if (downLeft > -1 && !exclude[downLeft] && lookfor[downLeft])
			{
				downLeft = myType;
			}
			if (downRight > -1 && !exclude[downRight] && lookfor[downRight])
			{
				downRight = myType;
			}
		}

		public static void TileMergeAttemptWeird(int myType, int changeTo, bool[] exclude, int up, int down, int left, int right, int upLeft, int upRight, int downLeft, int downRight)
		{
			if (up > -1 && !exclude[up] && up != myType)
			{
				up = changeTo;
			}
			if (down > -1 && !exclude[down] && down != myType)
			{
				down = changeTo;
			}
			if (left > -1 && !exclude[left] && left != myType)
			{
				left = changeTo;
			}
			if (right > -1 && !exclude[right] && right != myType)
			{
				right = changeTo;
			}
			if (upLeft > -1 && !exclude[upLeft] && upLeft != myType)
			{
				upLeft = changeTo;
			}
			if (upRight > -1 && !exclude[upRight] && upRight != myType)
			{
				upRight = changeTo;
			}
			if (downLeft > -1 && !exclude[downLeft] && downLeft != myType)
			{
				downLeft = changeTo;
			}
			if (downRight > -1 && !exclude[downRight] && downRight != myType)
			{
				downRight = changeTo;
			}
		}

		public static int GetTileMossColor(int tileType)
		{
			switch (tileType)
			{
			default:
				return -1;
			case 179:
			case 512:
				return 0;
			case 180:
			case 513:
				return 1;
			case 181:
			case 514:
				return 2;
			case 182:
			case 515:
				return 3;
			case 183:
			case 516:
				return 4;
			case 381:
			case 517:
				return 5;
			case 534:
			case 535:
				return 6;
			case 536:
			case 537:
				return 7;
			case 539:
			case 540:
				return 8;
			}
		}

		public static void CheckFoodPlatter(int x, int y, int type)
		{
			if (Main.tile[x, y] == null || destroyObject || SolidTileAllowBottomSlope(x, y + 1))
			{
				return;
			}
			if (type == 520)
			{
				int num = TEFoodPlatter.Find(x, y);
				if (num != -1 && ((TEFoodPlatter)TileEntity.ByID[num]).item.stack > 0)
				{
					((TEFoodPlatter)TileEntity.ByID[num]).DropItem();
					if (Main.netMode != 2)
					{
						Main.LocalPlayer.InterruptItemUsageIfOverTile(520);
					}
				}
			}
			destroyObject = true;
			if (Main.tile[x, y].type == type)
			{
				KillTile(x, y);
			}
			if (type == 520)
			{
				TEFoodPlatter.Kill(x, y);
			}
			destroyObject = false;
		}

		public static void TileFrame(int i, int j, bool resetFrame = false, bool noBreak = false)
		{
			bool addToList = false;
			try
			{
				if (i > 5 && j > 5 && i < Main.maxTilesX - 5 && j < Main.maxTilesY - 5 && Main.tile[i, j] != null)
				{
					if (SkipFramingBecauseOfGen && !Main.tileFrameImportant[Main.tile[i, j].type])
					{
						return;
					}
					addToList = UpdateMapTile(i, j);
					Tile tile = Main.tile[i, j];
					if (!tile.active())
					{
						tile.halfBrick(halfBrick: false);
						tile.color(0);
						tile.slope(0);
					}
					if (tile.liquid > 0 && Main.netMode != 1 && !noLiquidCheck)
					{
						Liquid.AddWater(i, j);
					}
					if (tile.active())
					{
						if (noBreak && Main.tileFrameImportant[tile.type] && tile.type != 4)
						{
							return;
						}
						int num = tile.type;
						if (Main.tileStone[num])
						{
							num = 1;
						}
						int frameX = tile.frameX;
						int frameY = tile.frameY;
						Rectangle rectangle = new Rectangle(-1, -1, 0, 0);
						if (Main.tileFrameImportant[tile.type])
						{
							switch (num)
							{
							case 518:
								CheckLilyPad(i, j);
								break;
							case 519:
								CheckCatTail(i, j);
								break;
							case 549:
								CheckUnderwaterPlant(549, i, j);
								break;
							case 571:
								CheckBamboo(i, j);
								break;
							case 4:
								CheckTorch(i, j);
								break;
							case 442:
								CheckProjectilePressurePad(i, j);
								break;
							case 136:
							{
								Tile tile8 = Main.tile[i, j - 1];
								Tile tile9 = Main.tile[i, j + 1];
								Tile tile2 = Main.tile[i - 1, j];
								Tile tile3 = Main.tile[i + 1, j];
								Tile tile4 = Main.tile[i - 1, j + 1];
								Tile tile5 = Main.tile[i + 1, j + 1];
								Tile tile6 = Main.tile[i - 1, j - 1];
								Tile tile7 = Main.tile[i + 1, j - 1];
								int num20 = -1;
								int num21 = -1;
								int num22 = -1;
								int tree = -1;
								int tree2 = -1;
								int tree3 = -1;
								int tree4 = -1;
								if (tile8 != null && tile8.nactive())
								{
									_ = tile8.type;
								}
								if (tile9 != null && tile9.nactive() && !tile9.halfBrick() && !tile9.topSlope())
								{
									num20 = tile9.type;
								}
								if (tile2 != null && tile2.nactive())
								{
									num21 = tile2.type;
								}
								if (tile3 != null && tile3.nactive())
								{
									num22 = tile3.type;
								}
								if (tile4 != null && tile4.nactive())
								{
									tree = tile4.type;
								}
								if (tile5 != null && tile5.nactive())
								{
									tree2 = tile5.type;
								}
								if (tile6 != null && tile6.nactive())
								{
									tree3 = tile6.type;
								}
								if (tile7 != null && tile7.nactive())
								{
									tree4 = tile7.type;
								}
								if (num20 >= 0 && Main.tileSolid[num20] && !Main.tileNoAttach[num20] && !tile9.halfBrick() && (tile9.slope() == 0 || tile9.bottomSlope()))
								{
									tile.frameX = 0;
								}
								else if ((num21 >= 0 && Main.tileSolid[num21] && !Main.tileNoAttach[num21] && (tile2.leftSlope() || tile2.slope() == 0) && !tile2.halfBrick()) || (num21 >= 0 && TileID.Sets.IsBeam[num21]) || (IsTreeType(num21) && IsTreeType(tree3) && IsTreeType(tree)))
								{
									tile.frameX = 18;
								}
								else if ((num22 >= 0 && Main.tileSolid[num22] && !Main.tileNoAttach[num22] && (tile3.rightSlope() || tile3.slope() == 0) && !tile3.halfBrick()) || (num22 >= 0 && TileID.Sets.IsBeam[num22]) || (IsTreeType(num22) && IsTreeType(tree4) && IsTreeType(tree2)))
								{
									tile.frameX = 36;
								}
								else if (tile.wall > 0)
								{
									tile.frameX = 54;
								}
								else
								{
									KillTile(i, j);
								}
								break;
							}
							case 129:
							case 149:
							{
								Tile tile8 = Main.tile[i, j - 1];
								Tile tile9 = Main.tile[i, j + 1];
								Tile tile2 = Main.tile[i - 1, j];
								Tile tile3 = Main.tile[i + 1, j];
								int num23 = -1;
								int num24 = -1;
								int num25 = -1;
								int num26 = -1;
								if (tile8 != null && tile8.nactive() && !tile8.bottomSlope())
								{
									num24 = tile8.type;
								}
								if (tile9 != null && tile9.nactive() && !tile9.halfBrick() && !tile9.topSlope())
								{
									num23 = tile9.type;
								}
								if (tile2 != null && tile2.nactive())
								{
									num25 = tile2.type;
								}
								if (tile3 != null && tile3.nactive())
								{
									num26 = tile3.type;
								}
								if (num23 >= 0 && Main.tileSolid[num23] && !Main.tileSolidTop[num23])
								{
									tile.frameY = 0;
								}
								else if (num25 >= 0 && Main.tileSolid[num25] && !Main.tileSolidTop[num25])
								{
									tile.frameY = 54;
								}
								else if (num26 >= 0 && Main.tileSolid[num26] && !Main.tileSolidTop[num26])
								{
									tile.frameY = 36;
								}
								else if (num24 >= 0 && Main.tileSolid[num24] && !Main.tileSolidTop[num24])
								{
									tile.frameY = 18;
								}
								else
								{
									KillTile(i, j);
								}
								break;
							}
							default:
								if (num != 461)
								{
									switch (num)
									{
									case 178:
									{
										Tile tile8 = Main.tile[i, j - 1];
										Tile tile9 = Main.tile[i, j + 1];
										Tile tile2 = Main.tile[i - 1, j];
										Tile tile3 = Main.tile[i + 1, j];
										int num10 = -1;
										int num11 = -1;
										int num12 = -1;
										int num13 = -1;
										if (tile8 != null && tile8.nactive() && !tile8.bottomSlope())
										{
											num11 = tile8.type;
										}
										if (tile9 != null && tile9.nactive() && !tile9.halfBrick() && !tile9.topSlope())
										{
											num10 = tile9.type;
										}
										if (tile2 != null && tile2.nactive() && !tile2.halfBrick() && !tile2.rightSlope())
										{
											num12 = tile2.type;
										}
										if (tile3 != null && tile3.nactive() && !tile3.halfBrick() && !tile3.leftSlope())
										{
											num13 = tile3.type;
										}
										if (num12 == 10)
										{
											num12 = -1;
										}
										if (num13 == 10)
										{
											num13 = -1;
										}
										short num14 = (short)(genRand.Next(3) * 18);
										if (num10 >= 0 && Main.tileSolid[num10] && !Main.tileSolidTop[num10])
										{
											if (tile.frameY < 0 || tile.frameY > 36)
											{
												tile.frameY = num14;
											}
										}
										else if (num12 >= 0 && Main.tileSolid[num12] && !Main.tileSolidTop[num12])
										{
											if (tile.frameY < 108 || tile.frameY > 54)
											{
												tile.frameY = (short)(108 + num14);
											}
										}
										else if (num13 >= 0 && Main.tileSolid[num13] && !Main.tileSolidTop[num13])
										{
											if (tile.frameY < 162 || tile.frameY > 198)
											{
												tile.frameY = (short)(162 + num14);
											}
										}
										else if (num11 >= 0 && Main.tileSolid[num11] && !Main.tileSolidTop[num11])
										{
											if (tile.frameY < 54 || tile.frameY > 90)
											{
												tile.frameY = (short)(54 + num14);
											}
										}
										else
										{
											KillTile(i, j);
										}
										break;
									}
									case 184:
									{
										Tile tile8 = Main.tile[i, j - 1];
										Tile tile9 = Main.tile[i, j + 1];
										Tile tile2 = Main.tile[i - 1, j];
										Tile tile3 = Main.tile[i + 1, j];
										int num15 = -1;
										int num16 = -1;
										int num17 = -1;
										int num18 = -1;
										if (tile8 != null && tile8.active() && !tile8.bottomSlope())
										{
											num16 = tile8.type;
										}
										if (tile9 != null && tile9.active() && !tile9.halfBrick() && !tile9.topSlope())
										{
											num15 = tile9.type;
										}
										if (tile2 != null && tile2.active())
										{
											num17 = tile2.type;
										}
										if (tile3 != null && tile3.active())
										{
											num18 = tile3.type;
										}
										short num19 = (short)(genRand.Next(3) * 18);
										if (num15 >= 0 && GetTileMossColor(num15) != -1)
										{
											tile.frameX = (short)(22 * GetTileMossColor(num15));
											if (tile.frameY < 0 || tile.frameY > 36)
											{
												tile.frameY = num19;
											}
										}
										else if (num16 >= 0 && GetTileMossColor(num16) != -1)
										{
											tile.frameX = (short)(22 * GetTileMossColor(num16));
											if (tile.frameY < 54 || tile.frameY > 90)
											{
												tile.frameY = (short)(54 + num19);
											}
										}
										else if (num17 >= 0 && GetTileMossColor(num17) != -1)
										{
											tile.frameX = (short)(22 * GetTileMossColor(num17));
											if (tile.frameY < 108 || tile.frameY > 54)
											{
												tile.frameY = (short)(108 + num19);
											}
										}
										else if (num18 >= 0 && GetTileMossColor(num18) != -1)
										{
											tile.frameX = (short)(22 * GetTileMossColor(num18));
											if (tile.frameY < 162 || tile.frameY > 198)
											{
												tile.frameY = (short)(162 + num19);
											}
										}
										else
										{
											KillTile(i, j);
										}
										break;
									}
									case 529:
										if (!SolidTileAllowBottomSlope(i, j + 1))
										{
											KillTile(i, j);
											break;
										}
										_ = Main.tile[i, j].frameY / 34;
										if (!TileID.Sets.Conversion.Sand[Main.tile[i, j + 1].type])
										{
											KillTile(i, j);
										}
										break;
									case 3:
									case 24:
									case 61:
									case 71:
									case 73:
									case 74:
									case 110:
									case 113:
									case 201:
										PlantCheck(i, j);
										break;
									case 227:
										CheckDye(i, j);
										break;
									case 579:
										CheckRockGolemHead(i, j);
										break;
									case 12:
									case 31:
										CheckOrb(i, j, num);
										break;
									case 165:
										CheckTight(i, j);
										break;
									case 324:
										if (!SolidTileAllowBottomSlope(i, j + 1))
										{
											KillTile(i, j);
										}
										break;
									case 235:
										Check3x1(i, j, num);
										break;
									case 185:
										CheckPile(i, j);
										break;
									default:
										if (num != 296 && num != 297 && num != 309 && num != 358 && num != 359 && num != 413 && num != 414 && num != 542 && num != 550 && num != 551 && num != 553 && num != 554 && num != 558 && num != 559 && num != 599 && num != 600 && num != 601 && num != 602 && num != 603 && num != 604 && num != 605 && num != 606 && num != 607 && num != 608 && num != 609 && num != 610 && num != 611 && num != 612)
										{
											if (num == 10)
											{
												CheckDoorClosed(i, j, tile, num);
												break;
											}
											if (num == 11)
											{
												CheckDoorOpen(i, j, tile);
												break;
											}
											if (num == 314)
											{
												Minecart.FrameTrack(i, j, pound: false);
												break;
											}
											if (num == 380)
											{
												Tile tile2 = Main.tile[i - 1, j];
												if (tile2 == null)
												{
													break;
												}
												Tile tile3 = Main.tile[i + 1, j];
												if (tile3 == null)
												{
													break;
												}
												Tile tile4 = Main.tile[i - 1, j + 1];
												if (tile4 == null)
												{
													break;
												}
												Tile tile5 = Main.tile[i + 1, j + 1];
												if (tile5 == null)
												{
													break;
												}
												Tile tile6 = Main.tile[i - 1, j - 1];
												if (tile6 == null)
												{
													break;
												}
												Tile tile7 = Main.tile[i + 1, j - 1];
												if (tile7 != null)
												{
													int num2 = -1;
													int num3 = -1;
													if (tile2 != null && tile2.active())
													{
														num3 = (Main.tileStone[tile2.type] ? 1 : tile2.type);
													}
													if (tile3 != null && tile3.active())
													{
														num2 = (Main.tileStone[tile3.type] ? 1 : tile3.type);
													}
													if (num2 >= 0 && !Main.tileSolid[num2])
													{
														num2 = -1;
													}
													if (num3 >= 0 && !Main.tileSolid[num3])
													{
														num3 = -1;
													}
													if (num3 == num && num2 == num)
													{
														rectangle.X = 18;
													}
													else if (num3 == num && num2 != num)
													{
														rectangle.X = 36;
													}
													else if (num3 != num && num2 == num)
													{
														rectangle.X = 0;
													}
													else
													{
														rectangle.X = 54;
													}
													tile.frameX = (short)rectangle.X;
												}
												break;
											}
											if (num >= 0 && TileID.Sets.Platforms[num])
											{
												Tile tile2 = Main.tile[i - 1, j];
												if (tile2 == null)
												{
													break;
												}
												Tile tile3 = Main.tile[i + 1, j];
												if (tile3 == null)
												{
													break;
												}
												Tile tile4 = Main.tile[i - 1, j + 1];
												if (tile4 == null)
												{
													break;
												}
												Tile tile5 = Main.tile[i + 1, j + 1];
												if (tile5 == null)
												{
													break;
												}
												Tile tile6 = Main.tile[i - 1, j - 1];
												if (tile6 == null)
												{
													break;
												}
												Tile tile7 = Main.tile[i + 1, j - 1];
												if (tile7 == null)
												{
													break;
												}
												int num4 = -1;
												int num5 = -1;
												if (tile2 != null && tile2.active())
												{
													num5 = (Main.tileStone[tile2.type] ? 1 : ((!TileID.Sets.Platforms[tile2.type]) ? tile2.type : num));
												}
												if (tile3 != null && tile3.active())
												{
													num4 = (Main.tileStone[tile3.type] ? 1 : ((!TileID.Sets.Platforms[tile3.type]) ? tile3.type : num));
												}
												if (num4 >= 0 && !Main.tileSolid[num4])
												{
													num4 = -1;
												}
												if (num5 >= 0 && !Main.tileSolid[num5])
												{
													num5 = -1;
												}
												if (num5 == num && tile2.halfBrick() != tile.halfBrick())
												{
													num5 = -1;
												}
												if (num4 == num && tile3.halfBrick() != tile.halfBrick())
												{
													num4 = -1;
												}
												if (num5 != -1 && num5 != num && tile.halfBrick())
												{
													num5 = -1;
												}
												if (num4 != -1 && num4 != num && tile.halfBrick())
												{
													num4 = -1;
												}
												if (num5 == -1 && tile6.active() && tile6.type == num && tile6.slope() == 1)
												{
													num5 = num;
												}
												if (num4 == -1 && tile7.active() && tile7.type == num && tile7.slope() == 2)
												{
													num4 = num;
												}
												if (num5 == num && tile2.slope() == 2 && num4 != num)
												{
													num4 = -1;
												}
												if (num4 == num && tile3.slope() == 1 && num5 != num)
												{
													num5 = -1;
												}
												if (tile.slope() == 1)
												{
													if (TileID.Sets.Platforms[tile3.type] && tile3.slope() == 0 && !tile3.halfBrick())
													{
														rectangle.X = 468;
													}
													else if (!tile5.active() && (!TileID.Sets.Platforms[tile5.type] || tile5.slope() == 2))
													{
														if (!tile2.active() && (!TileID.Sets.Platforms[tile6.type] || tile6.slope() != 1))
														{
															rectangle.X = 432;
														}
														else
														{
															rectangle.X = 360;
														}
													}
													else if (!tile2.active() && (!TileID.Sets.Platforms[tile6.type] || tile6.slope() != 1))
													{
														rectangle.X = 396;
													}
													else
													{
														rectangle.X = 180;
													}
												}
												else if (tile.slope() == 2)
												{
													if (TileID.Sets.Platforms[tile2.type] && tile2.slope() == 0 && !tile2.halfBrick())
													{
														rectangle.X = 450;
													}
													else if (!tile4.active() && (!TileID.Sets.Platforms[tile4.type] || tile4.slope() == 1))
													{
														if (!tile3.active() && (!TileID.Sets.Platforms[tile7.type] || tile7.slope() != 2))
														{
															rectangle.X = 414;
														}
														else
														{
															rectangle.X = 342;
														}
													}
													else if (!tile3.active() && (!TileID.Sets.Platforms[tile7.type] || tile7.slope() != 2))
													{
														rectangle.X = 378;
													}
													else
													{
														rectangle.X = 144;
													}
												}
												else if (num5 == num && num4 == num)
												{
													if (tile2.slope() == 2 && tile3.slope() == 1)
													{
														rectangle.X = 252;
													}
													else if (tile2.slope() == 2)
													{
														rectangle.X = 216;
													}
													else if (tile3.slope() == 1)
													{
														rectangle.X = 234;
													}
													else
													{
														rectangle.X = 0;
													}
												}
												else if (num5 == num && num4 == -1)
												{
													if (tile2.slope() == 2)
													{
														rectangle.X = 270;
													}
													else
													{
														rectangle.X = 18;
													}
												}
												else if (num5 == -1 && num4 == num)
												{
													if (tile3.slope() == 1)
													{
														rectangle.X = 288;
													}
													else
													{
														rectangle.X = 36;
													}
												}
												else if (num5 != num && num4 == num)
												{
													rectangle.X = 54;
												}
												else if (num5 == num && num4 != num)
												{
													rectangle.X = 72;
												}
												else if (num5 != num && num5 != -1 && num4 == -1)
												{
													rectangle.X = 108;
												}
												else if (num5 == -1 && num4 != num && num4 != -1)
												{
													rectangle.X = 126;
												}
												else
												{
													rectangle.X = 90;
												}
												tile.frameX = (short)rectangle.X;
												break;
											}
											switch (num)
											{
											case 233:
											case 236:
											case 238:
												CheckJunglePlant(i, j, num);
												break;
											case 530:
												CheckOasisPlant(i, j);
												break;
											case 240:
											case 440:
												Check3x3Wall(i, j);
												break;
											case 245:
												Check2x3Wall(i, j);
												break;
											case 246:
												Check3x2Wall(i, j);
												break;
											case 241:
												Check4x3Wall(i, j);
												break;
											case 242:
												Check6x4Wall(i, j);
												break;
											case 464:
											case 466:
												Check5x4(i, j, num);
												break;
											case 334:
												CheckWeaponsRack(i, j);
												break;
											case 471:
												TEWeaponsRack.Framing_CheckTile(i, j);
												break;
											case 34:
											case 454:
												CheckChand(i, j, num);
												break;
											case 547:
												Check2x5(i, j, num);
												break;
											case 548:
											case 614:
												Check3x6(i, j, num);
												break;
											case 613:
												Check3x5(i, j, num);
												break;
											default:
												if (num != 354 && num != 406 && num != 412 && num != 355 && num != 452 && num != 455 && num != 491 && num != 499)
												{
													switch (num)
													{
													case 15:
													case 20:
													case 216:
													case 338:
													case 390:
													case 493:
													case 497:
													case 590:
													case 595:
													case 615:
														Check1x2(i, j, (ushort)num);
														break;
													default:
														if (num < 391 || num > 394)
														{
															switch (num)
															{
															case 405:
															case 486:
															case 488:
															case 532:
															case 533:
															case 544:
															case 552:
															case 555:
															case 556:
															case 582:
															case 619:
																break;
															case 36:
															case 135:
															case 141:
															case 144:
															case 210:
															case 239:
															case 428:
															case 593:
																Check1x1(i, j, num);
																return;
															case 476:
																CheckGolf1x1(i, j, num);
																return;
															case 494:
																CheckGolf1x1(i, j, num);
																return;
															case 419:
															case 420:
															case 423:
															case 424:
															case 429:
															case 445:
																CheckLogicTiles(i, j, num);
																return;
															case 16:
															case 18:
															case 29:
															case 103:
															case 134:
															case 462:
																Check2x1(i, j, (ushort)num);
																return;
															case 13:
															case 33:
															case 49:
															case 50:
															case 78:
															case 174:
															case 372:
																CheckOnTable1x1(i, j, num);
																return;
															default:
																if (TileID.Sets.BasicChest[num])
																{
																	CheckChest(i, j, num);
																	return;
																}
																switch (num)
																{
																case 128:
																	CheckMan(i, j);
																	break;
																case 269:
																	CheckWoman(i, j);
																	break;
																case 470:
																	TEDisplayDoll.Framing_CheckTile(i, j);
																	break;
																case 475:
																	TEHatRack.Framing_CheckTile(i, j);
																	break;
																case 597:
																	TETeleportationPylon.Framing_CheckTile(i, j);
																	break;
																case 27:
																	CheckSunflower(i, j);
																	break;
																case 28:
																	CheckPot(i, j);
																	break;
																case 171:
																	CheckXmasTree(i, j);
																	break;
																default:
																	if (!TileID.Sets.BasicChestFake[num] && num != 457)
																	{
																		switch (num)
																		{
																		case 335:
																		case 411:
																		case 490:
																		case 564:
																		case 565:
																		case 594:
																			Check2x2(i, j, num);
																			break;
																		default:
																			if (num < 316 || num > 318)
																			{
																				switch (num)
																				{
																				case 172:
																				case 360:
																				case 505:
																				case 521:
																				case 522:
																				case 523:
																				case 524:
																				case 525:
																				case 526:
																				case 527:
																				case 543:
																				case 568:
																				case 569:
																				case 570:
																				case 580:
																				case 598:
																				case 620:
																					break;
																				case 376:
																				case 443:
																				case 444:
																				case 485:
																					CheckSuper(i, j, num);
																					return;
																				case 91:
																					CheckBanner(i, j, (byte)num);
																					return;
																				case 35:
																				case 139:
																					CheckMB(i, j, (byte)num);
																					return;
																				case 386:
																				case 387:
																					CheckTrapDoor(i, j, num);
																					return;
																				case 388:
																				case 389:
																					CheckTallGate(i, j, num);
																					return;
																				case 92:
																				case 93:
																				case 453:
																					Check1xX(i, j, (short)num);
																					return;
																				case 104:
																				case 105:
																				case 207:
																				case 320:
																				case 337:
																				case 349:
																				case 356:
																				case 378:
																				case 410:
																				case 456:
																				case 465:
																				case 480:
																				case 489:
																				case 506:
																				case 509:
																				case 531:
																				case 545:
																				case 560:
																				case 591:
																				case 592:
																					Check2xX(i, j, (ushort)num);
																					return;
																				case 101:
																				case 102:
																				case 463:
																				case 617:
																					Check3x4(i, j, num);
																					return;
																				case 42:
																				case 270:
																				case 271:
																				case 572:
																				case 581:
																					Check1x2Top(i, j, (ushort)num);
																					return;
																				case 55:
																				case 85:
																				case 395:
																				case 425:
																				case 510:
																				case 511:
																				case 573:
																					CheckSign(i, j, (ushort)num);
																					return;
																				case 520:
																					CheckFoodPlatter(i, j, (ushort)num);
																					return;
																				case 209:
																					CheckCannon(i, j, num);
																					return;
																				case 79:
																				case 90:
																				case 487:
																					Check4x2(i, j, num);
																					return;
																				case 94:
																				case 95:
																				case 97:
																				case 98:
																				case 99:
																				case 100:
																				case 125:
																				case 126:
																				case 173:
																				case 282:
																				case 287:
																				case 319:
																				case 621:
																				case 622:
																					Check2x2(i, j, num);
																					return;
																				case 96:
																					Check2x2Style(i, j, num);
																					return;
																				case 81:
																				{
																					Tile tile8 = Main.tile[i, j - 1];
																					Tile tile9 = Main.tile[i, j + 1];
																					Tile tile2 = Main.tile[i - 1, j];
																					Tile tile3 = Main.tile[i + 1, j];
																					int num8 = -1;
																					int num9 = -1;
																					if (tile8 != null && tile8.active())
																					{
																						num9 = tile8.type;
																					}
																					if (tile9 != null && tile9.active())
																					{
																						num8 = tile9.type;
																					}
																					if (num9 != -1)
																					{
																						KillTile(i, j);
																					}
																					else if (num8 < 0 || !Main.tileSolid[num8] || tile9.halfBrick() || tile9.topSlope())
																					{
																						KillTile(i, j);
																					}
																					return;
																				}
																				default:
																				{
																					if (Main.tileAlch[num])
																					{
																						CheckAlch(i, j);
																						return;
																					}
																					CheckTreeSettings settings;
																					switch (num)
																					{
																					case 72:
																					{
																						Tile tile8 = Main.tile[i, j - 1];
																						Tile tile9 = Main.tile[i, j + 1];
																						int num6 = -1;
																						int num7 = -1;
																						if (tile8 != null && tile8.active())
																						{
																							num7 = tile8.type;
																						}
																						if (tile9 != null && tile9.active())
																						{
																							num6 = tile9.type;
																						}
																						if (num6 != num && num6 != 70)
																						{
																							KillTile(i, j);
																						}
																						else if (num7 != num && tile.frameX == 0)
																						{
																							tile.frameNumber((byte)genRand.Next(3));
																							if (tile.frameNumber() == 0)
																							{
																								tile.frameX = 18;
																								tile.frameY = 0;
																							}
																							if (tile.frameNumber() == 1)
																							{
																								tile.frameX = 18;
																								tile.frameY = 18;
																							}
																							if (tile.frameNumber() == 2)
																							{
																								tile.frameX = 18;
																								tile.frameY = 36;
																							}
																						}
																						break;
																					}
																					case 5:
																						CheckTree(i, j);
																						break;
																					case 583:
																					case 584:
																					case 585:
																					case 586:
																					case 587:
																					case 588:
																					case 589:
																						settings = new CheckTreeSettings
																						{
																							IsGroundValid = GemTreeGroundTest
																						};
																						CheckTreeWithSettings(i, j, settings);
																						break;
																					case 596:
																						settings = new CheckTreeSettings
																						{
																							IsGroundValid = VanityTreeGroundTest
																						};
																						CheckTreeWithSettings(i, j, settings);
																						break;
																					case 616:
																						settings = new CheckTreeSettings
																						{
																							IsGroundValid = VanityTreeGroundTest
																						};
																						CheckTreeWithSettings(i, j, settings);
																						break;
																					case 323:
																						CheckPalmTree(i, j);
																						break;
																					case 567:
																						CheckGnome(i, j);
																						break;
																					}
																					return;
																				}
																				}
																			}
																			goto case 132;
																		case 132:
																		case 138:
																		case 142:
																		case 143:
																		case 288:
																		case 289:
																		case 290:
																		case 291:
																		case 292:
																		case 293:
																		case 294:
																		case 295:
																		case 484:
																			Check2x2(i, j, num);
																			break;
																		}
																		break;
																	}
																	goto case 254;
																case 254:
																	Check2x2Style(i, j, num);
																	break;
																}
																return;
															}
														}
														goto case 14;
													case 14:
													case 17:
													case 26:
													case 77:
													case 86:
													case 87:
													case 88:
													case 89:
													case 114:
													case 133:
													case 186:
													case 187:
													case 215:
													case 217:
													case 218:
													case 237:
													case 244:
													case 285:
													case 286:
													case 298:
													case 299:
													case 310:
													case 339:
													case 361:
													case 362:
													case 363:
													case 364:
													case 377:
													case 469:
													case 538:
														Check3x2(i, j, (ushort)num);
														break;
													}
													break;
												}
												goto case 106;
											case 106:
											case 212:
											case 219:
											case 220:
											case 228:
											case 231:
											case 243:
											case 247:
											case 283:
											case 300:
											case 301:
											case 302:
											case 303:
											case 304:
											case 305:
											case 306:
											case 307:
											case 308:
												Check3x3(i, j, (ushort)num);
												break;
											}
											break;
										}
										goto case 275;
									case 275:
									case 276:
									case 277:
									case 278:
									case 279:
									case 280:
									case 281:
										Check6x3(i, j, num);
										break;
									}
									break;
								}
								goto case 373;
							case 373:
							case 374:
							case 375:
							{
								Tile tile8 = Main.tile[i, j - 1];
								if (tile8 == null || !tile8.active() || tile8.bottomSlope() || !Main.tileSolid[tile8.type] || Main.tileSolidTop[tile8.type])
								{
									KillTile(i, j);
								}
								break;
							}
							}
							return;
						}
						if (num < 255 || num > 268)
						{
							switch (num)
							{
							case 385:
							case 446:
							case 447:
							case 448:
								break;
							default:
							{
								Tile tile8 = Main.tile[i, j - 1];
								Tile tile9 = Main.tile[i, j + 1];
								Tile tile2 = Main.tile[i - 1, j];
								Tile tile3 = Main.tile[i + 1, j];
								Tile tile4 = Main.tile[i - 1, j + 1];
								Tile tile5 = Main.tile[i + 1, j + 1];
								Tile tile6 = Main.tile[i - 1, j - 1];
								Tile tile7 = Main.tile[i + 1, j - 1];
								int upLeft = -1;
								int up = -1;
								int upRight = -1;
								int left = -1;
								int right = -1;
								int downLeft = -1;
								int down = -1;
								int downRight = -1;
								if (tile2 != null && tile2.active())
								{
									left = (Main.tileStone[tile2.type] ? 1 : tile2.type);
									if (tile2.slope() == 1 || tile2.slope() == 3)
									{
										left = -1;
									}
								}
								if (tile3 != null && tile3.active())
								{
									right = (Main.tileStone[tile3.type] ? 1 : tile3.type);
									if (tile3.slope() == 2 || tile3.slope() == 4)
									{
										right = -1;
									}
								}
								if (tile8 != null && tile8.active())
								{
									up = (Main.tileStone[tile8.type] ? 1 : tile8.type);
									if (tile8.slope() == 3 || tile8.slope() == 4)
									{
										up = -1;
									}
								}
								if (tile9 != null && tile9.active())
								{
									down = (Main.tileStone[tile9.type] ? 1 : tile9.type);
									if (tile9.slope() == 1 || tile9.slope() == 2)
									{
										down = -1;
									}
								}
								if (tile6 != null && tile6.active())
								{
									upLeft = (Main.tileStone[tile6.type] ? 1 : tile6.type);
								}
								if (tile7 != null && tile7.active())
								{
									upRight = (Main.tileStone[tile7.type] ? 1 : tile7.type);
								}
								if (tile4 != null && tile4.active())
								{
									downLeft = (Main.tileStone[tile4.type] ? 1 : tile4.type);
								}
								if (tile5 != null && tile5.active())
								{
									downRight = (Main.tileStone[tile5.type] ? 1 : tile5.type);
								}
								if (tile.slope() == 2)
								{
									up = -1;
									left = -1;
								}
								if (tile.slope() == 1)
								{
									up = -1;
									right = -1;
								}
								if (tile.slope() == 4)
								{
									down = -1;
									left = -1;
								}
								if (tile.slope() == 3)
								{
									down = -1;
									right = -1;
								}
								switch (num)
								{
								case 147:
									TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Ices, up, down, left, right, upLeft, upRight, downLeft, downRight);
									break;
								case 161:
								case 163:
								case 164:
								case 200:
									TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Snow, up, down, left, right, upLeft, upRight, downLeft, downRight);
									break;
								case 162:
									TileMergeAttempt(num, Main.tileBrick, TileID.Sets.IcesSnow, up, down, left, right, upLeft, upRight, downLeft, downRight);
									break;
								default:
									if (Main.tileBrick[num])
									{
										if (num == 60 || num == 70)
										{
											TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Mud, up, down, left, right, upLeft, upRight, downLeft, downRight);
										}
										else
										{
											TileMergeAttempt(num, Main.tileBrick, up, down, left, right, upLeft, upRight, downLeft, downRight);
										}
									}
									else if (Main.tilePile[num])
									{
										TileMergeAttempt(num, Main.tilePile, up, down, left, right, upLeft, upRight, downLeft, downRight);
									}
									break;
								}
								if ((num == 1 || Main.tileMoss[num] || num == 117 || num == 25 || num == 203) && down == 165)
								{
									if (tile9.frameY == 72)
									{
										down = num;
									}
									else if (tile9.frameY == 0)
									{
										down = num;
									}
								}
								if ((num == 1 || Main.tileMoss[num] || num == 117 || num == 25 || num == 203) && up == 165)
								{
									if (tile8.frameY == 90)
									{
										up = num;
									}
									else if (tile8.frameY == 54)
									{
										up = num;
									}
								}
								if (num == 225)
								{
									if (down == 165)
									{
										down = num;
									}
									if (up == 165)
									{
										up = num;
									}
								}
								if ((num == 200 || num == 161 || num == 147 || num == 163 || num == 164) && down == 165)
								{
									down = num;
								}
								if ((tile.slope() == 1 || tile.slope() == 2) && down > -1 && !TileID.Sets.Platforms[down])
								{
									down = num;
								}
								if (up > -1 && (tile8.slope() == 1 || tile8.slope() == 2) && !TileID.Sets.Platforms[up])
								{
									up = num;
								}
								if ((tile.slope() == 3 || tile.slope() == 4) && up > -1 && !TileID.Sets.Platforms[up])
								{
									up = num;
								}
								if (down > -1 && (tile9.slope() == 3 || tile9.slope() == 4) && !TileID.Sets.Platforms[down])
								{
									down = num;
								}
								if (num == 124)
								{
									if (up > -1 && Main.tileSolid[up] && !TileID.Sets.Platforms[up])
									{
										up = num;
									}
									if (down > -1 && Main.tileSolid[down] && !TileID.Sets.Platforms[down])
									{
										down = num;
									}
								}
								if (up > -1 && tile8.halfBrick() && !TileID.Sets.Platforms[up])
								{
									up = num;
								}
								if (left > -1 && tile2.halfBrick())
								{
									if (tile.halfBrick())
									{
										left = num;
									}
									else if (tile2.type != num)
									{
										left = -1;
									}
								}
								if (right > -1 && tile3.halfBrick())
								{
									if (tile.halfBrick())
									{
										right = num;
									}
									else if (tile3.type != num)
									{
										right = -1;
									}
								}
								if (tile.halfBrick())
								{
									if (left != num)
									{
										left = -1;
									}
									if (right != num)
									{
										right = -1;
									}
									up = -1;
								}
								if (tile9 != null && tile9.halfBrick())
								{
									down = -1;
								}
								if (!Main.tileSolid[num])
								{
									switch (num)
									{
									case 49:
										CheckOnTable1x1(i, j, (byte)num);
										return;
									case 80:
										CactusFrame(i, j);
										return;
									}
								}
								mergeUp = false;
								mergeDown = false;
								mergeLeft = false;
								mergeRight = false;
								int num27 = 0;
								if (resetFrame)
								{
									num27 = genRand.Next(0, 3);
									tile.frameNumber((byte)num27);
								}
								else
								{
									num27 = tile.frameNumber();
								}
								if (Main.tileLargeFrames[num] == 1)
								{
									int num28 = j % 4;
									int num29 = i % 3;
									num27 = (new int[4, 3]
									{
										{
											2,
											4,
											2
										},
										{
											1,
											3,
											1
										},
										{
											2,
											2,
											4
										},
										{
											1,
											1,
											3
										}
									})[num28, num29] - 1;
								}
								if (Main.tileLargeFrames[num] == 2)
								{
									int num30 = i % 2;
									int num31 = j % 2;
									num27 = num30 + num31 * 2;
								}
								TileMergeAttempt(num, Main.tileBlendAll, up, down, left, right, upLeft, upRight, downLeft, downRight);
								if (Main.tileBlendAll[num])
								{
									Main.tileSolid[10] = false;
									Main.tileSolid[387] = false;
									TileMergeAttempt(num, Main.tileSolid, Main.tileSolidTop, up, down, left, right, upLeft, upRight, downLeft, downRight);
									Main.tileSolid[10] = true;
									Main.tileSolid[387] = true;
								}
								if (TileID.Sets.ForcedDirtMerging[num])
								{
									if (up == 0)
									{
										up = num;
									}
									if (down == 0)
									{
										down = num;
									}
									if (left == 0)
									{
										left = num;
									}
									if (right == 0)
									{
										right = num;
									}
									if (upLeft == 0)
									{
										upLeft = num;
									}
									if (upRight == 0)
									{
										upRight = num;
									}
									if (downLeft == 0)
									{
										downLeft = num;
									}
									if (downRight == 0)
									{
										downRight = num;
									}
								}
								switch (num)
								{
								case 0:
								{
									if (up > -1 && Main.tileMergeDirt[up])
									{
										TileFrame(i, j - 1);
										if (mergeDown)
										{
											up = num;
										}
									}
									else if (up == 147)
									{
										TileFrame(i, j - 1);
										if (mergeDown)
										{
											up = num;
										}
									}
									if (down > -1 && Main.tileMergeDirt[down])
									{
										TileFrame(i, j + 1);
										if (mergeUp)
										{
											down = num;
										}
									}
									else if (down == 147)
									{
										TileFrame(i, j + 1);
										if (mergeUp)
										{
											down = num;
										}
									}
									if (left > -1 && Main.tileMergeDirt[left])
									{
										TileFrame(i - 1, j);
										if (mergeRight)
										{
											left = num;
										}
									}
									else if (left == 147)
									{
										TileFrame(i - 1, j);
										if (mergeRight)
										{
											left = num;
										}
									}
									if (right > -1 && Main.tileMergeDirt[right])
									{
										TileFrame(i + 1, j);
										if (mergeLeft)
										{
											right = num;
										}
									}
									else if (right == 147)
									{
										TileFrame(i + 1, j);
										if (mergeLeft)
										{
											right = num;
										}
									}
									bool[] mergesWithDirtInASpecialWay = TileID.Sets.Conversion.MergesWithDirtInASpecialWay;
									if (up > -1 && mergesWithDirtInASpecialWay[up])
									{
										up = num;
									}
									if (down > -1 && mergesWithDirtInASpecialWay[down])
									{
										down = num;
									}
									if (left > -1 && mergesWithDirtInASpecialWay[left])
									{
										left = num;
									}
									if (right > -1 && mergesWithDirtInASpecialWay[right])
									{
										right = num;
									}
									if (upLeft > -1 && Main.tileMergeDirt[upLeft])
									{
										upLeft = num;
									}
									else if (upLeft > -1 && mergesWithDirtInASpecialWay[upLeft])
									{
										upLeft = num;
									}
									if (upRight > -1 && Main.tileMergeDirt[upRight])
									{
										upRight = num;
									}
									else if (upRight > -1 && mergesWithDirtInASpecialWay[upRight])
									{
										upRight = num;
									}
									if (downLeft > -1 && Main.tileMergeDirt[downLeft])
									{
										downLeft = num;
									}
									else if (downLeft > -1 && mergesWithDirtInASpecialWay[downLeft])
									{
										downLeft = num;
									}
									if (downRight > -1 && Main.tileMergeDirt[downRight])
									{
										downRight = num;
									}
									else if (downRight > -1 && mergesWithDirtInASpecialWay[downRight])
									{
										downRight = num;
									}
									TileMergeAttempt(-2, 59, up, down, left, right, upLeft, upRight, downLeft, downRight);
									TileMergeAttempt(num, 191, up, down, left, right, upLeft, upRight, downLeft, downRight);
									if (up > -1 && TileID.Sets.ForcedDirtMerging[up])
									{
										up = num;
									}
									if (down > -1 && TileID.Sets.ForcedDirtMerging[down])
									{
										down = num;
									}
									if (left > -1 && TileID.Sets.ForcedDirtMerging[left])
									{
										left = num;
									}
									if (right > -1 && TileID.Sets.ForcedDirtMerging[right])
									{
										right = num;
									}
									if (upLeft > -1 && TileID.Sets.ForcedDirtMerging[upLeft])
									{
										upLeft = num;
									}
									if (upRight > -1 && TileID.Sets.ForcedDirtMerging[upRight])
									{
										upRight = num;
									}
									if (downLeft > -1 && TileID.Sets.ForcedDirtMerging[downLeft])
									{
										downLeft = num;
									}
									if (downRight > -1 && TileID.Sets.ForcedDirtMerging[downRight])
									{
										downRight = num;
									}
									break;
								}
								case 213:
									if (up > -1 && Main.tileSolid[up] && !Main.tileSolidTop[up])
									{
										up = num;
									}
									if (down > -1 && Main.tileSolid[down])
									{
										down = num;
									}
									if (up != num)
									{
										if (left > -1 && Main.tileSolid[left])
										{
											left = num;
										}
										if (right > -1 && Main.tileSolid[right])
										{
											right = num;
										}
									}
									break;
								case 53:
									TileMergeAttemptFrametest(i, j, num, 397, up, down, left, right, upLeft, upRight, downLeft, downRight);
									TileMergeAttemptFrametest(i, j, num, 396, up, down, left, right, upLeft, upRight, downLeft, downRight);
									break;
								case 234:
									TileMergeAttemptFrametest(i, j, num, 399, up, down, left, right, upLeft, upRight, downLeft, downRight);
									TileMergeAttemptFrametest(i, j, num, 401, up, down, left, right, upLeft, upRight, downLeft, downRight);
									break;
								case 112:
									TileMergeAttemptFrametest(i, j, num, 398, up, down, left, right, upLeft, upRight, downLeft, downRight);
									TileMergeAttemptFrametest(i, j, num, 400, up, down, left, right, upLeft, upRight, downLeft, downRight);
									break;
								case 116:
									TileMergeAttemptFrametest(i, j, num, 402, up, down, left, right, upLeft, upRight, downLeft, downRight);
									TileMergeAttemptFrametest(i, j, num, 403, up, down, left, right, upLeft, upRight, downLeft, downRight);
									break;
								}
								if (Main.tileMergeDirt[num])
								{
									TileMergeAttempt(-2, 0, up, down, left, right, upLeft, upRight, downLeft, downRight);
									if (num == 1)
									{
										if ((double)j > Main.rockLayer)
										{
											TileMergeAttemptFrametest(i, j, num, 59, up, down, left, right, upLeft, upRight, downLeft, downRight);
										}
										TileMergeAttemptFrametest(i, j, num, 57, up, down, left, right, upLeft, upRight, downLeft, downRight);
									}
								}
								else
								{
									switch (num)
									{
									case 58:
									case 75:
									case 76:
										TileMergeAttempt(-2, 57, up, down, left, right, upLeft, upRight, downLeft, downRight);
										break;
									case 57:
										TileMergeAttempt(-2, 1, up, down, left, right, upLeft, upRight, downLeft, downRight);
										TileMergeAttemptFrametest(i, j, num, TileID.Sets.HellSpecial, up, down, left, right, upLeft, upRight, downLeft, downRight);
										break;
									case 59:
										if ((double)j > Main.rockLayer)
										{
											TileMergeAttempt(-2, 1, up, down, left, right, upLeft, upRight, downLeft, downRight);
										}
										TileMergeAttempt(num, TileID.Sets.GrassSpecial, up, down, left, right, upLeft, upRight, downLeft, downRight);
										TileMergeAttemptFrametest(i, j, num, TileID.Sets.JungleSpecial, up, down, left, right, upLeft, upRight, downLeft, downRight);
										if ((double)j < Main.rockLayer)
										{
											TileMergeAttemptFrametest(i, j, num, 0, up, down, left, right, upLeft, upRight, downLeft, downRight);
										}
										else
										{
											TileMergeAttempt(num, 0, up, down, left, right);
										}
										break;
									case 211:
										TileMergeAttempt(59, 60, up, down, left, right);
										TileMergeAttempt(-2, 59, up, down, left, right, upLeft, upRight, downLeft, downRight);
										break;
									case 225:
									case 226:
										TileMergeAttempt(-2, 59, up, down, left, right, upLeft, upRight, downLeft, downRight);
										break;
									case 60:
										TileMergeAttempt(59, 211, up, down, left, right);
										break;
									case 189:
										TileMergeAttemptFrametest(i, j, num, TileID.Sets.MergesWithClouds, up, down, left, right, upLeft, upRight, downLeft, downRight);
										break;
									case 196:
										TileMergeAttempt(-2, 189, up, down, left, right, upLeft, upRight, downLeft, downRight);
										TileMergeAttempt(num, 460, up, down, left, right, upLeft, upRight, downLeft, downRight);
										break;
									case 460:
										TileMergeAttempt(-2, 189, up, down, left, right, upLeft, upRight, downLeft, downRight);
										TileMergeAttempt(num, 196, up, down, left, right, upLeft, upRight, downLeft, downRight);
										break;
									case 147:
										TileMergeAttemptFrametest(i, j, num, TileID.Sets.IcesSlush, up, down, left, right, upLeft, upRight, downLeft, downRight);
										break;
									case 161:
									case 163:
									case 164:
									case 200:
									case 224:
										TileMergeAttempt(-2, 147, up, down, left, right, upLeft, upRight, downLeft, downRight);
										break;
									case 162:
										TileMergeAttempt(-2, TileID.Sets.IcesSnow, up, down, left, right, upLeft, upRight, downLeft, downRight);
										break;
									case 32:
										if (down == 23)
										{
											down = num;
										}
										break;
									case 352:
										if (down == 199)
										{
											down = num;
										}
										break;
									case 69:
										if (down == 60)
										{
											down = num;
										}
										break;
									case 51:
										TileMergeAttempt(num, TileID.Sets.AllTiles, Main.tileNoAttach, up, down, left, right, upLeft, upRight, downLeft, downRight);
										break;
									case 192:
										TileMergeAttemptFrametest(i, j, num, 191, up, down, left, right, upLeft, upRight, downLeft, downRight);
										break;
									case 191:
										TileMergeAttempt(-2, 192, up, down, left, right, upLeft, upRight, downLeft, downRight);
										TileMergeAttempt(num, 0, up, down, left, right, upLeft, upRight, downLeft, downRight);
										break;
									case 384:
										TileMergeAttemptFrametest(i, j, num, 383, up, down, left, right, upLeft, upRight, downLeft, downRight);
										break;
									case 383:
										TileMergeAttempt(-2, 384, up, down, left, right, upLeft, upRight, downLeft, downRight);
										TileMergeAttempt(num, 59, up, down, left, right, upLeft, upRight, downLeft, downRight);
										break;
									case 407:
										TileMergeAttempt(-2, 404, up, down, left, right, upLeft, upRight, downLeft, downRight);
										break;
									case 404:
										TileMergeAttempt(-2, 396, up, down, left, right, upLeft, upRight, downLeft, downRight);
										TileMergeAttemptFrametest(i, j, num, 407, up, down, left, right, upLeft, upRight, downLeft, downRight);
										break;
									case 397:
										TileMergeAttempt(-2, 53, up, down, left, right, upLeft, upRight, downLeft, downRight);
										TileMergeAttemptFrametest(i, j, num, 396, up, down, left, right, upLeft, upRight, downLeft, downRight);
										break;
									case 396:
										TileMergeAttempt(-2, 397, up, down, left, right, upLeft, upRight, downLeft, downRight);
										TileMergeAttempt(-2, 53, up, down, left, right, upLeft, upRight, downLeft, downRight);
										TileMergeAttemptFrametest(i, j, num, 404, up, down, left, right, upLeft, upRight, downLeft, downRight);
										break;
									case 398:
										TileMergeAttempt(-2, 112, up, down, left, right, upLeft, upRight, downLeft, downRight);
										TileMergeAttemptFrametest(i, j, num, 400, up, down, left, right, upLeft, upRight, downLeft, downRight);
										break;
									case 400:
										TileMergeAttempt(-2, 398, up, down, left, right, upLeft, upRight, downLeft, downRight);
										TileMergeAttempt(-2, 112, up, down, left, right, upLeft, upRight, downLeft, downRight);
										break;
									case 399:
										TileMergeAttempt(-2, 234, up, down, left, right, upLeft, upRight, downLeft, downRight);
										TileMergeAttemptFrametest(i, j, num, 401, up, down, left, right, upLeft, upRight, downLeft, downRight);
										break;
									case 401:
										TileMergeAttempt(-2, 399, up, down, left, right, upLeft, upRight, downLeft, downRight);
										TileMergeAttempt(-2, 234, up, down, left, right, upLeft, upRight, downLeft, downRight);
										break;
									case 402:
										TileMergeAttempt(-2, 116, up, down, left, right, upLeft, upRight, downLeft, downRight);
										TileMergeAttemptFrametest(i, j, num, 403, up, down, left, right, upLeft, upRight, downLeft, downRight);
										break;
									case 403:
										TileMergeAttempt(-2, 402, up, down, left, right, upLeft, upRight, downLeft, downRight);
										TileMergeAttempt(-2, 116, up, down, left, right, upLeft, upRight, downLeft, downRight);
										break;
									}
								}
								if (num == 0)
								{
									TileMergeAttempt(num, Main.tileMoss, up, down, left, right, upLeft, upRight, downLeft, downRight);
									TileMergeAttempt(num, TileID.Sets.tileMossBrick, up, down, left, right, upLeft, upRight, downLeft, downRight);
								}
								else if (Main.tileMoss[num] || TileID.Sets.tileMossBrick[num])
								{
									TileMergeAttempt(num, 0, up, down, left, right, upLeft, upRight, downLeft, downRight);
								}
								else if (Main.tileStone[num] || num == 1)
								{
									TileMergeAttempt(num, Main.tileMoss, up, down, left, right, upLeft, upRight, downLeft, downRight);
								}
								else if (num == 38)
								{
									TileMergeAttempt(num, TileID.Sets.tileMossBrick, up, down, left, right, upLeft, upRight, downLeft, downRight);
								}
								if (TileID.Sets.Conversion.Grass[num])
								{
									TileMergeAttempt(num, TileID.Sets.Ore, up, down, left, right, upLeft, upRight, downLeft, downRight);
								}
								else if (TileID.Sets.Ore[num])
								{
									TileMergeAttempt(num, TileID.Sets.Conversion.Grass, up, down, left, right, upLeft, upRight, downLeft, downRight);
								}
								if (num == 59)
								{
									TileMergeAttempt(num, TileID.Sets.OreMergesWithMud, up, down, left, right, upLeft, upRight, downLeft, downRight);
								}
								else if (TileID.Sets.OreMergesWithMud[num])
								{
									TileMergeAttempt(num, 59, up, down, left, right, upLeft, upRight, downLeft, downRight);
								}
								bool flag = false;
								if (num == 2 || num == 23 || num == 60 || num == 477 || num == 492 || num == 70 || num == 109 || num == 199 || Main.tileMoss[num] || TileID.Sets.NeedsGrassFraming[num] || TileID.Sets.tileMossBrick[num])
								{
									flag = true;
									TileMergeAttemptWeird(num, -1, Main.tileSolid, up, down, left, right, upLeft, upRight, downLeft, downRight);
									int num32 = TileID.Sets.NeedsGrassFramingDirt[num];
									if (num == 60 || num == 70)
									{
										num32 = 59;
									}
									else if (Main.tileMoss[num])
									{
										num32 = 1;
									}
									else if (TileID.Sets.tileMossBrick[num])
									{
										num32 = 38;
									}
									else
									{
										switch (num)
										{
										case 2:
										case 477:
											TileMergeAttempt(num32, 23, up, down, left, right, upLeft, upRight, downLeft, downRight);
											break;
										case 23:
											TileMergeAttempt(num32, 2, up, down, left, right, upLeft, upRight, downLeft, downRight);
											break;
										}
									}
									if (up != num && up != num32 && (down == num || down == num32))
									{
										if (left == num32 && right == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 0;
												rectangle.Y = 198;
												break;
											case 1:
												rectangle.X = 18;
												rectangle.Y = 198;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 198;
												break;
											}
										}
										else if (left == num && right == num32)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 198;
												break;
											case 1:
												rectangle.X = 72;
												rectangle.Y = 198;
												break;
											default:
												rectangle.X = 90;
												rectangle.Y = 198;
												break;
											}
										}
									}
									else if (down != num && down != num32 && (up == num || up == num32))
									{
										if (left == num32 && right == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 0;
												rectangle.Y = 216;
												break;
											case 1:
												rectangle.X = 18;
												rectangle.Y = 216;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 216;
												break;
											}
										}
										else if (left == num && right == num32)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 216;
												break;
											case 1:
												rectangle.X = 72;
												rectangle.Y = 216;
												break;
											default:
												rectangle.X = 90;
												rectangle.Y = 216;
												break;
											}
										}
									}
									else if (left != num && left != num32 && (right == num || right == num32))
									{
										if (up == num32 && down == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 72;
												rectangle.Y = 144;
												break;
											case 1:
												rectangle.X = 72;
												rectangle.Y = 162;
												break;
											default:
												rectangle.X = 72;
												rectangle.Y = 180;
												break;
											}
										}
										else if (down == num && up == num32)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 72;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 72;
												rectangle.Y = 108;
												break;
											default:
												rectangle.X = 72;
												rectangle.Y = 126;
												break;
											}
										}
									}
									else if (right != num && right != num32 && (left == num || left == num32))
									{
										if (up == num32 && down == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 90;
												rectangle.Y = 144;
												break;
											case 1:
												rectangle.X = 90;
												rectangle.Y = 162;
												break;
											default:
												rectangle.X = 90;
												rectangle.Y = 180;
												break;
											}
										}
										else if (down == num && right == up)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 90;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 90;
												rectangle.Y = 108;
												break;
											default:
												rectangle.X = 90;
												rectangle.Y = 126;
												break;
											}
										}
									}
									else if (up == num && down == num && left == num && right == num)
									{
										if (upLeft != num && upRight != num && downLeft != num && downRight != num)
										{
											if (downRight == num32)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 108;
													rectangle.Y = 324;
													break;
												case 1:
													rectangle.X = 126;
													rectangle.Y = 324;
													break;
												default:
													rectangle.X = 144;
													rectangle.Y = 324;
													break;
												}
											}
											else if (upRight == num32)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 108;
													rectangle.Y = 342;
													break;
												case 1:
													rectangle.X = 126;
													rectangle.Y = 342;
													break;
												default:
													rectangle.X = 144;
													rectangle.Y = 342;
													break;
												}
											}
											else if (downLeft == num32)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 108;
													rectangle.Y = 360;
													break;
												case 1:
													rectangle.X = 126;
													rectangle.Y = 360;
													break;
												default:
													rectangle.X = 144;
													rectangle.Y = 360;
													break;
												}
											}
											else if (upLeft == num32)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 108;
													rectangle.Y = 378;
													break;
												case 1:
													rectangle.X = 126;
													rectangle.Y = 378;
													break;
												default:
													rectangle.X = 144;
													rectangle.Y = 378;
													break;
												}
											}
											else
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 144;
													rectangle.Y = 234;
													break;
												case 1:
													rectangle.X = 198;
													rectangle.Y = 234;
													break;
												default:
													rectangle.X = 252;
													rectangle.Y = 234;
													break;
												}
											}
										}
										else if (upLeft != num && downRight != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 36;
												rectangle.Y = 306;
												break;
											case 1:
												rectangle.X = 54;
												rectangle.Y = 306;
												break;
											default:
												rectangle.X = 72;
												rectangle.Y = 306;
												break;
											}
										}
										else if (upRight != num && downLeft != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 90;
												rectangle.Y = 306;
												break;
											case 1:
												rectangle.X = 108;
												rectangle.Y = 306;
												break;
											default:
												rectangle.X = 126;
												rectangle.Y = 306;
												break;
											}
										}
										else if (upLeft != num && upRight == num && downLeft == num && downRight == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 108;
												break;
											case 1:
												rectangle.X = 54;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 54;
												rectangle.Y = 180;
												break;
											}
										}
										else if (upLeft == num && upRight != num && downLeft == num && downRight == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 36;
												rectangle.Y = 108;
												break;
											case 1:
												rectangle.X = 36;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 180;
												break;
											}
										}
										else if (upLeft == num && upRight == num && downLeft != num && downRight == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 54;
												rectangle.Y = 126;
												break;
											default:
												rectangle.X = 54;
												rectangle.Y = 162;
												break;
											}
										}
										else if (upLeft == num && upRight == num && downLeft == num && downRight != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 36;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 36;
												rectangle.Y = 126;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 162;
												break;
											}
										}
									}
									else if (up == num && down == num32 && left == num && right == num && upLeft == -1 && upRight == -1)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 108;
											rectangle.Y = 18;
											break;
										case 1:
											rectangle.X = 126;
											rectangle.Y = 18;
											break;
										default:
											rectangle.X = 144;
											rectangle.Y = 18;
											break;
										}
									}
									else if (up == num32 && down == num && left == num && right == num && downLeft == -1 && downRight == -1)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 108;
											rectangle.Y = 36;
											break;
										case 1:
											rectangle.X = 126;
											rectangle.Y = 36;
											break;
										default:
											rectangle.X = 144;
											rectangle.Y = 36;
											break;
										}
									}
									else if (up == num && down == num && left == num32 && right == num && upRight == -1 && downRight == -1)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 198;
											rectangle.Y = 0;
											break;
										case 1:
											rectangle.X = 198;
											rectangle.Y = 18;
											break;
										default:
											rectangle.X = 198;
											rectangle.Y = 36;
											break;
										}
									}
									else if (up == num && down == num && left == num && right == num32 && upLeft == -1 && downLeft == -1)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 180;
											rectangle.Y = 0;
											break;
										case 1:
											rectangle.X = 180;
											rectangle.Y = 18;
											break;
										default:
											rectangle.X = 180;
											rectangle.Y = 36;
											break;
										}
									}
									else if (up == num && down == num32 && left == num && right == num)
									{
										if (upRight != -1)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 108;
												break;
											case 1:
												rectangle.X = 54;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 54;
												rectangle.Y = 180;
												break;
											}
										}
										else if (upLeft != -1)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 36;
												rectangle.Y = 108;
												break;
											case 1:
												rectangle.X = 36;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 180;
												break;
											}
										}
									}
									else if (up == num32 && down == num && left == num && right == num)
									{
										if (downRight != -1)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 54;
												rectangle.Y = 126;
												break;
											default:
												rectangle.X = 54;
												rectangle.Y = 162;
												break;
											}
										}
										else if (downLeft != -1)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 36;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 36;
												rectangle.Y = 126;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 162;
												break;
											}
										}
									}
									else if (up == num && down == num && left == num && right == num32)
									{
										if (upLeft != -1)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 54;
												rectangle.Y = 126;
												break;
											default:
												rectangle.X = 54;
												rectangle.Y = 162;
												break;
											}
										}
										else if (downLeft != -1)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 108;
												break;
											case 1:
												rectangle.X = 54;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 54;
												rectangle.Y = 180;
												break;
											}
										}
									}
									else if (up == num && down == num && left == num32 && right == num)
									{
										if (upRight != -1)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 36;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 36;
												rectangle.Y = 126;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 162;
												break;
											}
										}
										else if (downRight != -1)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 36;
												rectangle.Y = 108;
												break;
											case 1:
												rectangle.X = 36;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 180;
												break;
											}
										}
									}
									else if ((up == num32 && down == num && left == num && right == num) || (up == num && down == num32 && left == num && right == num) || (up == num && down == num && left == num32 && right == num) || (up == num && down == num && left == num && right == num32))
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 18;
											rectangle.Y = 18;
											break;
										case 1:
											rectangle.X = 36;
											rectangle.Y = 18;
											break;
										default:
											rectangle.X = 54;
											rectangle.Y = 18;
											break;
										}
									}
									if ((up == num || up == num32) && (down == num || down == num32) && (left == num || left == num32) && (right == num || right == num32))
									{
										if (upLeft != num && upLeft != num32 && (upRight == num || upRight == num32) && (downLeft == num || downLeft == num32) && (downRight == num || downRight == num32))
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 108;
												break;
											case 1:
												rectangle.X = 54;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 54;
												rectangle.Y = 180;
												break;
											}
										}
										else if (upRight != num && upRight != num32 && (upLeft == num || upLeft == num32) && (downLeft == num || downLeft == num32) && (downRight == num || downRight == num32))
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 36;
												rectangle.Y = 108;
												break;
											case 1:
												rectangle.X = 36;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 180;
												break;
											}
										}
										else if (downLeft != num && downLeft != num32 && (upLeft == num || upLeft == num32) && (upRight == num || upRight == num32) && (downRight == num || downRight == num32))
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 54;
												rectangle.Y = 126;
												break;
											default:
												rectangle.X = 54;
												rectangle.Y = 162;
												break;
											}
										}
										else if (downRight != num && downRight != num32 && (upLeft == num || upLeft == num32) && (downLeft == num || downLeft == num32) && (upRight == num || upRight == num32))
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 36;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 36;
												rectangle.Y = 126;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 162;
												break;
											}
										}
									}
									if (up != num32 && up != num && down == num && left != num32 && left != num && right == num && downRight != num32 && downRight != num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 90;
											rectangle.Y = 270;
											break;
										case 1:
											rectangle.X = 108;
											rectangle.Y = 270;
											break;
										default:
											rectangle.X = 126;
											rectangle.Y = 270;
											break;
										}
									}
									else if (up != num32 && up != num && down == num && left == num && right != num32 && right != num && downLeft != num32 && downLeft != num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 144;
											rectangle.Y = 270;
											break;
										case 1:
											rectangle.X = 162;
											rectangle.Y = 270;
											break;
										default:
											rectangle.X = 180;
											rectangle.Y = 270;
											break;
										}
									}
									else if (down != num32 && down != num && up == num && left != num32 && left != num && right == num && upRight != num32 && upRight != num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 90;
											rectangle.Y = 288;
											break;
										case 1:
											rectangle.X = 108;
											rectangle.Y = 288;
											break;
										default:
											rectangle.X = 126;
											rectangle.Y = 288;
											break;
										}
									}
									else if (down != num32 && down != num && up == num && left == num && right != num32 && right != num && upLeft != num32 && upLeft != num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 144;
											rectangle.Y = 288;
											break;
										case 1:
											rectangle.X = 162;
											rectangle.Y = 288;
											break;
										default:
											rectangle.X = 180;
											rectangle.Y = 288;
											break;
										}
									}
									else if (up != num && up != num32 && down == num && left == num && right == num && downLeft != num && downLeft != num32 && downRight != num && downRight != num32)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 144;
											rectangle.Y = 216;
											break;
										case 1:
											rectangle.X = 198;
											rectangle.Y = 216;
											break;
										default:
											rectangle.X = 252;
											rectangle.Y = 216;
											break;
										}
									}
									else if (down != num && down != num32 && up == num && left == num && right == num && upLeft != num && upLeft != num32 && upRight != num && upRight != num32)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 144;
											rectangle.Y = 252;
											break;
										case 1:
											rectangle.X = 198;
											rectangle.Y = 252;
											break;
										default:
											rectangle.X = 252;
											rectangle.Y = 252;
											break;
										}
									}
									else if (left != num && left != num32 && down == num && up == num && right == num && upRight != num && upRight != num32 && downRight != num && downRight != num32)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 126;
											rectangle.Y = 234;
											break;
										case 1:
											rectangle.X = 180;
											rectangle.Y = 234;
											break;
										default:
											rectangle.X = 234;
											rectangle.Y = 234;
											break;
										}
									}
									else if (right != num && right != num32 && down == num && up == num && left == num && upLeft != num && upLeft != num32 && downLeft != num && downLeft != num32)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 162;
											rectangle.Y = 234;
											break;
										case 1:
											rectangle.X = 216;
											rectangle.Y = 234;
											break;
										default:
											rectangle.X = 270;
											rectangle.Y = 234;
											break;
										}
									}
									else if (up != num32 && up != num && (down == num32 || down == num) && left == num32 && right == num32)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 36;
											rectangle.Y = 270;
											break;
										case 1:
											rectangle.X = 54;
											rectangle.Y = 270;
											break;
										default:
											rectangle.X = 72;
											rectangle.Y = 270;
											break;
										}
									}
									else if (down != num32 && down != num && (up == num32 || up == num) && left == num32 && right == num32)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 36;
											rectangle.Y = 288;
											break;
										case 1:
											rectangle.X = 54;
											rectangle.Y = 288;
											break;
										default:
											rectangle.X = 72;
											rectangle.Y = 288;
											break;
										}
									}
									else if (left != num32 && left != num && (right == num32 || right == num) && up == num32 && down == num32)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 0;
											rectangle.Y = 270;
											break;
										case 1:
											rectangle.X = 0;
											rectangle.Y = 288;
											break;
										default:
											rectangle.X = 0;
											rectangle.Y = 306;
											break;
										}
									}
									else if (right != num32 && right != num && (left == num32 || left == num) && up == num32 && down == num32)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 18;
											rectangle.Y = 270;
											break;
										case 1:
											rectangle.X = 18;
											rectangle.Y = 288;
											break;
										default:
											rectangle.X = 18;
											rectangle.Y = 306;
											break;
										}
									}
									else if (up == num && down == num32 && left == num32 && right == num32)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 198;
											rectangle.Y = 288;
											break;
										case 1:
											rectangle.X = 216;
											rectangle.Y = 288;
											break;
										default:
											rectangle.X = 234;
											rectangle.Y = 288;
											break;
										}
									}
									else if (up == num32 && down == num && left == num32 && right == num32)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 198;
											rectangle.Y = 270;
											break;
										case 1:
											rectangle.X = 216;
											rectangle.Y = 270;
											break;
										default:
											rectangle.X = 234;
											rectangle.Y = 270;
											break;
										}
									}
									else if (up == num32 && down == num32 && left == num && right == num32)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 198;
											rectangle.Y = 306;
											break;
										case 1:
											rectangle.X = 216;
											rectangle.Y = 306;
											break;
										default:
											rectangle.X = 234;
											rectangle.Y = 306;
											break;
										}
									}
									else if (up == num32 && down == num32 && left == num32 && right == num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 144;
											rectangle.Y = 306;
											break;
										case 1:
											rectangle.X = 162;
											rectangle.Y = 306;
											break;
										default:
											rectangle.X = 180;
											rectangle.Y = 306;
											break;
										}
									}
									if (up != num && up != num32 && down == num && left == num && right == num)
									{
										if ((downLeft == num32 || downLeft == num) && downRight != num32 && downRight != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 0;
												rectangle.Y = 324;
												break;
											case 1:
												rectangle.X = 18;
												rectangle.Y = 324;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 324;
												break;
											}
										}
										else if ((downRight == num32 || downRight == num) && downLeft != num32 && downLeft != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 324;
												break;
											case 1:
												rectangle.X = 72;
												rectangle.Y = 324;
												break;
											default:
												rectangle.X = 90;
												rectangle.Y = 324;
												break;
											}
										}
									}
									else if (down != num && down != num32 && up == num && left == num && right == num)
									{
										if ((upLeft == num32 || upLeft == num) && upRight != num32 && upRight != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 0;
												rectangle.Y = 342;
												break;
											case 1:
												rectangle.X = 18;
												rectangle.Y = 342;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 342;
												break;
											}
										}
										else if ((upRight == num32 || upRight == num) && upLeft != num32 && upLeft != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 342;
												break;
											case 1:
												rectangle.X = 72;
												rectangle.Y = 342;
												break;
											default:
												rectangle.X = 90;
												rectangle.Y = 342;
												break;
											}
										}
									}
									else if (left != num && left != num32 && up == num && down == num && right == num)
									{
										if ((upRight == num32 || upRight == num) && downRight != num32 && downRight != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 360;
												break;
											case 1:
												rectangle.X = 72;
												rectangle.Y = 360;
												break;
											default:
												rectangle.X = 90;
												rectangle.Y = 360;
												break;
											}
										}
										else if ((downRight == num32 || downRight == num) && upRight != num32 && upRight != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 0;
												rectangle.Y = 360;
												break;
											case 1:
												rectangle.X = 18;
												rectangle.Y = 360;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 360;
												break;
											}
										}
									}
									else if (right != num && right != num32 && up == num && down == num && left == num)
									{
										if ((upLeft == num32 || upLeft == num) && downLeft != num32 && downLeft != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 0;
												rectangle.Y = 378;
												break;
											case 1:
												rectangle.X = 18;
												rectangle.Y = 378;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 378;
												break;
											}
										}
										else if ((downLeft == num32 || downLeft == num) && upLeft != num32 && upLeft != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 378;
												break;
											case 1:
												rectangle.X = 72;
												rectangle.Y = 378;
												break;
											default:
												rectangle.X = 90;
												rectangle.Y = 378;
												break;
											}
										}
									}
									if ((up == num || up == num32) && (down == num || down == num32) && (left == num || left == num32) && (right == num || right == num32) && upLeft != -1 && upRight != -1 && downLeft != -1 && downRight != -1)
									{
										if ((i + j) % 2 == 1)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 108;
												rectangle.Y = 198;
												break;
											case 1:
												rectangle.X = 126;
												rectangle.Y = 198;
												break;
											default:
												rectangle.X = 144;
												rectangle.Y = 198;
												break;
											}
										}
										else
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 18;
												rectangle.Y = 18;
												break;
											case 1:
												rectangle.X = 36;
												rectangle.Y = 18;
												break;
											default:
												rectangle.X = 54;
												rectangle.Y = 18;
												break;
											}
										}
									}
									TileMergeAttempt(-2, num32, up, down, left, right, upLeft, upRight, downLeft, downRight);
								}
								TileMergeAttempt(num, Main.tileMerge[num], up, down, left, right, upLeft, upRight, downLeft, downRight);
								if (rectangle.X == -1 && rectangle.Y == -1 && (Main.tileMergeDirt[num] || (num > -1 && TileID.Sets.ChecksForMerge[num])))
								{
									if (!flag)
									{
										flag = true;
										TileMergeAttemptWeird(num, -1, Main.tileSolid, up, down, left, right, upLeft, upRight, downLeft, downRight);
									}
									if (up > -1 && up != num)
									{
										up = -1;
									}
									if (down > -1 && down != num)
									{
										down = -1;
									}
									if (left > -1 && left != num)
									{
										left = -1;
									}
									if (right > -1 && right != num)
									{
										right = -1;
									}
									if (up != -1 && down != -1 && left != -1 && right != -1)
									{
										if (up == -2 && down == num && left == num && right == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 144;
												rectangle.Y = 108;
												break;
											case 1:
												rectangle.X = 162;
												rectangle.Y = 108;
												break;
											default:
												rectangle.X = 180;
												rectangle.Y = 108;
												break;
											}
											mergeUp = true;
										}
										else if (up == num && down == -2 && left == num && right == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 144;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 162;
												rectangle.Y = 90;
												break;
											default:
												rectangle.X = 180;
												rectangle.Y = 90;
												break;
											}
											mergeDown = true;
										}
										else if (up == num && down == num && left == -2 && right == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 162;
												rectangle.Y = 126;
												break;
											case 1:
												rectangle.X = 162;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 162;
												rectangle.Y = 162;
												break;
											}
											mergeLeft = true;
										}
										else if (up == num && down == num && left == num && right == -2)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 144;
												rectangle.Y = 126;
												break;
											case 1:
												rectangle.X = 144;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 144;
												rectangle.Y = 162;
												break;
											}
											mergeRight = true;
										}
										else if (up == -2 && down == num && left == -2 && right == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 36;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 36;
												rectangle.Y = 126;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 162;
												break;
											}
											mergeUp = true;
											mergeLeft = true;
										}
										else if (up == -2 && down == num && left == num && right == -2)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 54;
												rectangle.Y = 126;
												break;
											default:
												rectangle.X = 54;
												rectangle.Y = 162;
												break;
											}
											mergeUp = true;
											mergeRight = true;
										}
										else if (up == num && down == -2 && left == -2 && right == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 36;
												rectangle.Y = 108;
												break;
											case 1:
												rectangle.X = 36;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 180;
												break;
											}
											mergeDown = true;
											mergeLeft = true;
										}
										else if (up == num && down == -2 && left == num && right == -2)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 108;
												break;
											case 1:
												rectangle.X = 54;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 54;
												rectangle.Y = 180;
												break;
											}
											mergeDown = true;
											mergeRight = true;
										}
										else if (up == num && down == num && left == -2 && right == -2)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 180;
												rectangle.Y = 126;
												break;
											case 1:
												rectangle.X = 180;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 180;
												rectangle.Y = 162;
												break;
											}
											mergeLeft = true;
											mergeRight = true;
										}
										else if (up == -2 && down == -2 && left == num && right == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 144;
												rectangle.Y = 180;
												break;
											case 1:
												rectangle.X = 162;
												rectangle.Y = 180;
												break;
											default:
												rectangle.X = 180;
												rectangle.Y = 180;
												break;
											}
											mergeUp = true;
											mergeDown = true;
										}
										else if (up == -2 && down == num && left == -2 && right == -2)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 198;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 198;
												rectangle.Y = 108;
												break;
											default:
												rectangle.X = 198;
												rectangle.Y = 126;
												break;
											}
											mergeUp = true;
											mergeLeft = true;
											mergeRight = true;
										}
										else if (up == num && down == -2 && left == -2 && right == -2)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 198;
												rectangle.Y = 144;
												break;
											case 1:
												rectangle.X = 198;
												rectangle.Y = 162;
												break;
											default:
												rectangle.X = 198;
												rectangle.Y = 180;
												break;
											}
											mergeDown = true;
											mergeLeft = true;
											mergeRight = true;
										}
										else if (up == -2 && down == -2 && left == num && right == -2)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 216;
												rectangle.Y = 144;
												break;
											case 1:
												rectangle.X = 216;
												rectangle.Y = 162;
												break;
											default:
												rectangle.X = 216;
												rectangle.Y = 180;
												break;
											}
											mergeUp = true;
											mergeDown = true;
											mergeRight = true;
										}
										else if (up == -2 && down == -2 && left == -2 && right == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 216;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 216;
												rectangle.Y = 108;
												break;
											default:
												rectangle.X = 216;
												rectangle.Y = 126;
												break;
											}
											mergeUp = true;
											mergeDown = true;
											mergeLeft = true;
										}
										else if (up == -2 && down == -2 && left == -2 && right == -2)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 108;
												rectangle.Y = 198;
												break;
											case 1:
												rectangle.X = 126;
												rectangle.Y = 198;
												break;
											default:
												rectangle.X = 144;
												rectangle.Y = 198;
												break;
											}
											mergeUp = true;
											mergeDown = true;
											mergeLeft = true;
											mergeRight = true;
										}
										else if (up == num && down == num && left == num && right == num)
										{
											if (upLeft == -2)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 18;
													rectangle.Y = 108;
													break;
												case 1:
													rectangle.X = 18;
													rectangle.Y = 144;
													break;
												default:
													rectangle.X = 18;
													rectangle.Y = 180;
													break;
												}
											}
											if (upRight == -2)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 0;
													rectangle.Y = 108;
													break;
												case 1:
													rectangle.X = 0;
													rectangle.Y = 144;
													break;
												default:
													rectangle.X = 0;
													rectangle.Y = 180;
													break;
												}
											}
											if (downLeft == -2)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 18;
													rectangle.Y = 90;
													break;
												case 1:
													rectangle.X = 18;
													rectangle.Y = 126;
													break;
												default:
													rectangle.X = 18;
													rectangle.Y = 162;
													break;
												}
											}
											if (downRight == -2)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 0;
													rectangle.Y = 90;
													break;
												case 1:
													rectangle.X = 0;
													rectangle.Y = 126;
													break;
												default:
													rectangle.X = 0;
													rectangle.Y = 162;
													break;
												}
											}
										}
									}
									else
									{
										if (num != 2 && num != 23 && num != 60 && num != 70 && num != 109 && num != 199 && num != 477 && num != 492)
										{
											if (up == -1 && down == -2 && left == num && right == num)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 234;
													rectangle.Y = 0;
													break;
												case 1:
													rectangle.X = 252;
													rectangle.Y = 0;
													break;
												default:
													rectangle.X = 270;
													rectangle.Y = 0;
													break;
												}
												mergeDown = true;
											}
											else if (up == -2 && down == -1 && left == num && right == num)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 234;
													rectangle.Y = 18;
													break;
												case 1:
													rectangle.X = 252;
													rectangle.Y = 18;
													break;
												default:
													rectangle.X = 270;
													rectangle.Y = 18;
													break;
												}
												mergeUp = true;
											}
											else if (up == num && down == num && left == -1 && right == -2)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 234;
													rectangle.Y = 36;
													break;
												case 1:
													rectangle.X = 252;
													rectangle.Y = 36;
													break;
												default:
													rectangle.X = 270;
													rectangle.Y = 36;
													break;
												}
												mergeRight = true;
											}
											else if (up == num && down == num && left == -2 && right == -1)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 234;
													rectangle.Y = 54;
													break;
												case 1:
													rectangle.X = 252;
													rectangle.Y = 54;
													break;
												default:
													rectangle.X = 270;
													rectangle.Y = 54;
													break;
												}
												mergeLeft = true;
											}
										}
										if (up != -1 && down != -1 && left == -1 && right == num)
										{
											if (up == -2 && down == num)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 72;
													rectangle.Y = 144;
													break;
												case 1:
													rectangle.X = 72;
													rectangle.Y = 162;
													break;
												default:
													rectangle.X = 72;
													rectangle.Y = 180;
													break;
												}
												mergeUp = true;
											}
											else if (down == -2 && up == num)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 72;
													rectangle.Y = 90;
													break;
												case 1:
													rectangle.X = 72;
													rectangle.Y = 108;
													break;
												default:
													rectangle.X = 72;
													rectangle.Y = 126;
													break;
												}
												mergeDown = true;
											}
										}
										else if (up != -1 && down != -1 && left == num && right == -1)
										{
											if (up == -2 && down == num)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 90;
													rectangle.Y = 144;
													break;
												case 1:
													rectangle.X = 90;
													rectangle.Y = 162;
													break;
												default:
													rectangle.X = 90;
													rectangle.Y = 180;
													break;
												}
												mergeUp = true;
											}
											else if (down == -2 && up == num)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 90;
													rectangle.Y = 90;
													break;
												case 1:
													rectangle.X = 90;
													rectangle.Y = 108;
													break;
												default:
													rectangle.X = 90;
													rectangle.Y = 126;
													break;
												}
												mergeDown = true;
											}
										}
										else if (up == -1 && down == num && left != -1 && right != -1)
										{
											if (left == -2 && right == num)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 0;
													rectangle.Y = 198;
													break;
												case 1:
													rectangle.X = 18;
													rectangle.Y = 198;
													break;
												default:
													rectangle.X = 36;
													rectangle.Y = 198;
													break;
												}
												mergeLeft = true;
											}
											else if (right == -2 && left == num)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 54;
													rectangle.Y = 198;
													break;
												case 1:
													rectangle.X = 72;
													rectangle.Y = 198;
													break;
												default:
													rectangle.X = 90;
													rectangle.Y = 198;
													break;
												}
												mergeRight = true;
											}
										}
										else if (up == num && down == -1 && left != -1 && right != -1)
										{
											if (left == -2 && right == num)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 0;
													rectangle.Y = 216;
													break;
												case 1:
													rectangle.X = 18;
													rectangle.Y = 216;
													break;
												default:
													rectangle.X = 36;
													rectangle.Y = 216;
													break;
												}
												mergeLeft = true;
											}
											else if (right == -2 && left == num)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 54;
													rectangle.Y = 216;
													break;
												case 1:
													rectangle.X = 72;
													rectangle.Y = 216;
													break;
												default:
													rectangle.X = 90;
													rectangle.Y = 216;
													break;
												}
												mergeRight = true;
											}
										}
										else if (up != -1 && down != -1 && left == -1 && right == -1)
										{
											if (up == -2 && down == -2)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 108;
													rectangle.Y = 216;
													break;
												case 1:
													rectangle.X = 108;
													rectangle.Y = 234;
													break;
												default:
													rectangle.X = 108;
													rectangle.Y = 252;
													break;
												}
												mergeUp = true;
												mergeDown = true;
											}
											else if (up == -2)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 126;
													rectangle.Y = 144;
													break;
												case 1:
													rectangle.X = 126;
													rectangle.Y = 162;
													break;
												default:
													rectangle.X = 126;
													rectangle.Y = 180;
													break;
												}
												mergeUp = true;
											}
											else if (down == -2)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 126;
													rectangle.Y = 90;
													break;
												case 1:
													rectangle.X = 126;
													rectangle.Y = 108;
													break;
												default:
													rectangle.X = 126;
													rectangle.Y = 126;
													break;
												}
												mergeDown = true;
											}
										}
										else if (up == -1 && down == -1 && left != -1 && right != -1)
										{
											if (left == -2 && right == -2)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 162;
													rectangle.Y = 198;
													break;
												case 1:
													rectangle.X = 180;
													rectangle.Y = 198;
													break;
												default:
													rectangle.X = 198;
													rectangle.Y = 198;
													break;
												}
												mergeLeft = true;
												mergeRight = true;
											}
											else if (left == -2)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 0;
													rectangle.Y = 252;
													break;
												case 1:
													rectangle.X = 18;
													rectangle.Y = 252;
													break;
												default:
													rectangle.X = 36;
													rectangle.Y = 252;
													break;
												}
												mergeLeft = true;
											}
											else if (right == -2)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 54;
													rectangle.Y = 252;
													break;
												case 1:
													rectangle.X = 72;
													rectangle.Y = 252;
													break;
												default:
													rectangle.X = 90;
													rectangle.Y = 252;
													break;
												}
												mergeRight = true;
											}
										}
										else if (up == -2 && down == -1 && left == -1 && right == -1)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 108;
												rectangle.Y = 144;
												break;
											case 1:
												rectangle.X = 108;
												rectangle.Y = 162;
												break;
											default:
												rectangle.X = 108;
												rectangle.Y = 180;
												break;
											}
											mergeUp = true;
										}
										else if (up == -1 && down == -2 && left == -1 && right == -1)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 108;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 108;
												rectangle.Y = 108;
												break;
											default:
												rectangle.X = 108;
												rectangle.Y = 126;
												break;
											}
											mergeDown = true;
										}
										else if (up == -1 && down == -1 && left == -2 && right == -1)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 0;
												rectangle.Y = 234;
												break;
											case 1:
												rectangle.X = 18;
												rectangle.Y = 234;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 234;
												break;
											}
											mergeLeft = true;
										}
										else if (up == -1 && down == -1 && left == -1 && right == -2)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 234;
												break;
											case 1:
												rectangle.X = 72;
												rectangle.Y = 234;
												break;
											default:
												rectangle.X = 90;
												rectangle.Y = 234;
												break;
											}
											mergeRight = true;
										}
									}
								}
								int num33 = tile.blockType();
								if (TileID.Sets.HasSlopeFrames[num])
								{
									if (num33 == 0)
									{
										bool flag2 = num == up && tile8.topSlope();
										bool flag3 = num == left && tile2.leftSlope();
										bool flag4 = num == right && tile3.rightSlope();
										bool flag5 = num == down && tile9.bottomSlope();
										int num34 = 0;
										int num35 = 0;
										if (flag2.ToInt() + flag3.ToInt() + flag4.ToInt() + flag5.ToInt() > 2)
										{
											int num36 = (tile8.slope() == 1).ToInt() + (tile3.slope() == 1).ToInt() + (tile9.slope() == 4).ToInt() + (tile2.slope() == 4).ToInt();
											int num37 = (tile8.slope() == 2).ToInt() + (tile3.slope() == 3).ToInt() + (tile9.slope() == 3).ToInt() + (tile2.slope() == 2).ToInt();
											if (num36 == num37)
											{
												num34 = 2;
												num35 = 4;
											}
											else if (num36 > num37)
											{
												bool num38 = num == upLeft && tile6.slope() == 0;
												bool flag6 = num == downRight && tile5.slope() == 0;
												if (num38 && flag6)
												{
													num35 = 4;
												}
												else if (flag6)
												{
													num34 = 6;
												}
												else
												{
													num34 = 7;
													num35 = 1;
												}
											}
											else
											{
												bool num39 = num == upRight && tile7.slope() == 0;
												bool flag7 = num == downLeft && tile4.slope() == 0;
												if (num39 && flag7)
												{
													num35 = 4;
													num34 = 1;
												}
												else if (flag7)
												{
													num34 = 7;
												}
												else
												{
													num34 = 6;
													num35 = 1;
												}
											}
											rectangle.X = (18 + num34) * 18;
											rectangle.Y = num35 * 18;
										}
										else
										{
											if (flag2 && flag3 && num == down && num == right)
											{
												num35 = 2;
											}
											else if (flag2 && flag4 && num == down && num == left)
											{
												num34 = 1;
												num35 = 2;
											}
											else if (flag4 && flag5 && num == up && num == left)
											{
												num34 = 1;
												num35 = 3;
											}
											else if (flag5 && flag3 && num == up && num == right)
											{
												num35 = 3;
											}
											if (num34 != 0 || num35 != 0)
											{
												rectangle.X = (18 + num34) * 18;
												rectangle.Y = num35 * 18;
											}
										}
									}
									if (num33 >= 2 && (rectangle.X < 0 || rectangle.Y < 0))
									{
										int num40 = -1;
										int num41 = -1;
										int num42 = -1;
										int num43 = 0;
										int num44 = 0;
										switch (num33)
										{
										case 2:
											num40 = left;
											num41 = down;
											num42 = downLeft;
											num43++;
											break;
										case 3:
											num40 = right;
											num41 = down;
											num42 = downRight;
											break;
										case 4:
											num40 = left;
											num41 = up;
											num42 = upLeft;
											num43++;
											num44++;
											break;
										case 5:
											num40 = right;
											num41 = up;
											num42 = upRight;
											num44++;
											break;
										}
										if (num != num40 || num != num41 || num != num42)
										{
											if (num == num40 && num == num41)
											{
												num43 += 2;
											}
											else if (num == num40)
											{
												num43 += 4;
											}
											else if (num == num41)
											{
												num43 += 4;
												num44 += 2;
											}
											else
											{
												num43 += 2;
												num44 += 2;
											}
										}
										rectangle.X = (18 + num43) * 18;
										rectangle.Y = num44 * 18;
									}
								}
								if (rectangle.X < 0 || rectangle.Y < 0)
								{
									if (!flag)
									{
										flag = true;
										TileMergeAttemptWeird(num, -1, Main.tileSolid, up, down, left, right, upLeft, upRight, downLeft, downRight);
									}
									if (num == 2 || num == 23 || num == 60 || num == 70 || num == 109 || num == 199 || num == 477 || num == 492 || Main.tileMoss[num] || TileID.Sets.tileMossBrick[num])
									{
										TileMergeAttempt(num, -2, up, down, left, right, upLeft, upRight, downLeft, downRight);
									}
									if (up == num && down == num && left == num && right == num)
									{
										if (upLeft != num && upRight != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 108;
												rectangle.Y = 18;
												break;
											case 1:
												rectangle.X = 126;
												rectangle.Y = 18;
												break;
											default:
												rectangle.X = 144;
												rectangle.Y = 18;
												break;
											}
										}
										else if (downLeft != num && downRight != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 108;
												rectangle.Y = 36;
												break;
											case 1:
												rectangle.X = 126;
												rectangle.Y = 36;
												break;
											default:
												rectangle.X = 144;
												rectangle.Y = 36;
												break;
											}
										}
										else if (upLeft != num && downLeft != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 180;
												rectangle.Y = 0;
												break;
											case 1:
												rectangle.X = 180;
												rectangle.Y = 18;
												break;
											default:
												rectangle.X = 180;
												rectangle.Y = 36;
												break;
											}
										}
										else if (upRight != num && downRight != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 198;
												rectangle.Y = 0;
												break;
											case 1:
												rectangle.X = 198;
												rectangle.Y = 18;
												break;
											default:
												rectangle.X = 198;
												rectangle.Y = 36;
												break;
											}
										}
										else
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 18;
												rectangle.Y = 18;
												break;
											case 1:
												rectangle.X = 36;
												rectangle.Y = 18;
												break;
											default:
												rectangle.X = 54;
												rectangle.Y = 18;
												break;
											}
										}
									}
									else if (up != num && down == num && left == num && right == num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 18;
											rectangle.Y = 0;
											break;
										case 1:
											rectangle.X = 36;
											rectangle.Y = 0;
											break;
										default:
											rectangle.X = 54;
											rectangle.Y = 0;
											break;
										}
									}
									else if (up == num && down != num && left == num && right == num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 18;
											rectangle.Y = 36;
											break;
										case 1:
											rectangle.X = 36;
											rectangle.Y = 36;
											break;
										default:
											rectangle.X = 54;
											rectangle.Y = 36;
											break;
										}
									}
									else if (up == num && down == num && left != num && right == num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 0;
											rectangle.Y = 0;
											break;
										case 1:
											rectangle.X = 0;
											rectangle.Y = 18;
											break;
										default:
											rectangle.X = 0;
											rectangle.Y = 36;
											break;
										}
									}
									else if (up == num && down == num && left == num && right != num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 72;
											rectangle.Y = 0;
											break;
										case 1:
											rectangle.X = 72;
											rectangle.Y = 18;
											break;
										default:
											rectangle.X = 72;
											rectangle.Y = 36;
											break;
										}
									}
									else if (up != num && down == num && left != num && right == num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 0;
											rectangle.Y = 54;
											break;
										case 1:
											rectangle.X = 36;
											rectangle.Y = 54;
											break;
										default:
											rectangle.X = 72;
											rectangle.Y = 54;
											break;
										}
									}
									else if (up != num && down == num && left == num && right != num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 18;
											rectangle.Y = 54;
											break;
										case 1:
											rectangle.X = 54;
											rectangle.Y = 54;
											break;
										default:
											rectangle.X = 90;
											rectangle.Y = 54;
											break;
										}
									}
									else if (up == num && down != num && left != num && right == num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 0;
											rectangle.Y = 72;
											break;
										case 1:
											rectangle.X = 36;
											rectangle.Y = 72;
											break;
										default:
											rectangle.X = 72;
											rectangle.Y = 72;
											break;
										}
									}
									else if (up == num && down != num && left == num && right != num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 18;
											rectangle.Y = 72;
											break;
										case 1:
											rectangle.X = 54;
											rectangle.Y = 72;
											break;
										default:
											rectangle.X = 90;
											rectangle.Y = 72;
											break;
										}
									}
									else if (up == num && down == num && left != num && right != num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 90;
											rectangle.Y = 0;
											break;
										case 1:
											rectangle.X = 90;
											rectangle.Y = 18;
											break;
										default:
											rectangle.X = 90;
											rectangle.Y = 36;
											break;
										}
									}
									else if (up != num && down != num && left == num && right == num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 108;
											rectangle.Y = 72;
											break;
										case 1:
											rectangle.X = 126;
											rectangle.Y = 72;
											break;
										default:
											rectangle.X = 144;
											rectangle.Y = 72;
											break;
										}
									}
									else if (up != num && down == num && left != num && right != num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 108;
											rectangle.Y = 0;
											break;
										case 1:
											rectangle.X = 126;
											rectangle.Y = 0;
											break;
										default:
											rectangle.X = 144;
											rectangle.Y = 0;
											break;
										}
									}
									else if (up == num && down != num && left != num && right != num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 108;
											rectangle.Y = 54;
											break;
										case 1:
											rectangle.X = 126;
											rectangle.Y = 54;
											break;
										default:
											rectangle.X = 144;
											rectangle.Y = 54;
											break;
										}
									}
									else if (up != num && down != num && left != num && right == num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 162;
											rectangle.Y = 0;
											break;
										case 1:
											rectangle.X = 162;
											rectangle.Y = 18;
											break;
										default:
											rectangle.X = 162;
											rectangle.Y = 36;
											break;
										}
									}
									else if (up != num && down != num && left == num && right != num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 216;
											rectangle.Y = 0;
											break;
										case 1:
											rectangle.X = 216;
											rectangle.Y = 18;
											break;
										default:
											rectangle.X = 216;
											rectangle.Y = 36;
											break;
										}
									}
									else if (up != num && down != num && left != num && right != num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 162;
											rectangle.Y = 54;
											break;
										case 1:
											rectangle.X = 180;
											rectangle.Y = 54;
											break;
										default:
											rectangle.X = 198;
											rectangle.Y = 54;
											break;
										}
									}
								}
								if (rectangle.X <= -1 || rectangle.Y <= -1)
								{
									if (num27 <= 0)
									{
										rectangle.X = 18;
										rectangle.Y = 18;
									}
									else if (num27 == 1)
									{
										rectangle.X = 36;
										rectangle.Y = 18;
									}
									if (num27 >= 2)
									{
										rectangle.X = 54;
										rectangle.Y = 18;
									}
								}
								if (Main.tileLargeFrames[num] == 1 && num27 == 3)
								{
									rectangle.Y += 90;
								}
								if (Main.tileLargeFrames[num] == 2 && num27 == 3)
								{
									rectangle.Y += 90;
								}
								tile.frameX = (short)rectangle.X;
								tile.frameY = (short)rectangle.Y;
								if (TileID.Sets.IsVine[num])
								{
									up = ((tile8 == null) ? num : ((!tile8.nactive()) ? (-1) : ((!tile8.bottomSlope()) ? tile8.type : (-1))));
									if (num != up)
									{
										bool num45 = up == 109 || up == 115;
										bool flag8 = up == 199 || up == 205;
										bool flag9 = up == 2 || up == 52;
										bool flag10 = up == 382;
										bool num46 = up == 70 || up == 528;
										ushort num47 = 0;
										if (num46)
										{
											num47 = 528;
										}
										if (num45)
										{
											num47 = 115;
										}
										if (flag8)
										{
											num47 = 205;
										}
										if (flag9 && num != 382)
										{
											num47 = 52;
										}
										if (flag10)
										{
											num47 = 382;
										}
										if (num47 != 0 && num47 != num)
										{
											tile.type = num47;
											SquareTileFrame(i, j);
											return;
										}
									}
									if (up != num)
									{
										bool flag11 = false;
										if (up == -1)
										{
											flag11 = true;
										}
										if (num == 52 && up != 2 && up != 192)
										{
											flag11 = true;
										}
										if (num == 382 && up != 2 && up != 192)
										{
											flag11 = true;
										}
										if (num == 62 && up != 60)
										{
											flag11 = true;
										}
										if (num == 115 && up != 109)
										{
											flag11 = true;
										}
										if (num == 528 && up != 70)
										{
											flag11 = true;
										}
										if (num == 205 && up != 199)
										{
											flag11 = true;
										}
										if (flag11)
										{
											KillTile(i, j);
										}
									}
								}
								if (!noTileActions && tile.active() && (num == 53 || num == 112 || num == 116 || num == 123 || num == 234 || num == 224 || num == 495 || num == 330 || num == 331 || num == 332 || num == 333))
								{
									if (Main.netMode == 0)
									{
										if (tile9 != null)
										{
											bool flag12 = false;
											if (!Main.tile[i, j + 1].nactive())
											{
												flag12 = true;
											}
											else if (!Main.tile[i, j + 2].nactive() && (!Main.tile[i, j + 1].active() || !Main.tileSolid[Main.tile[i, j + 1].type]))
											{
												flag12 = true;
											}
											if (flag12 && AllowsSandfall(tile8))
											{
												GetSandfallProjData(num, out var projType, out var dmg);
												tile.ClearTile();
												int num48 = Projectile.NewProjectile(i * 16 + 8, j * 16 + 8, 0f, 0.41f, projType, dmg, 0f, Main.myPlayer);
												Main.projectile[num48].ai[0] = 1f;
												SquareTileFrame(i, j);
											}
										}
									}
									else if (Main.netMode == 2 && tile9 != null && !tile9.nactive() && AllowsSandfall(tile8))
									{
										GetSandfallProjData(num, out var projType2, out var dmg2);
										tile.ClearTile();
										bool flag13 = false;
										for (int k = 0; k < 1000; k++)
										{
											if (Main.projectile[k].active && Main.projectile[k].owner == Main.myPlayer && Main.projectile[k].type == projType2 && Math.Abs(Main.projectile[k].timeLeft - 3600) < 60 && Main.projectile[k].Distance(new Vector2(i * 16 + 8, j * 16 + 10)) < 4f)
											{
												flag13 = true;
												break;
											}
										}
										if (!flag13)
										{
											int num49 = Projectile.NewProjectile(i * 16 + 8, j * 16 + 8, 0f, 2.5f, projType2, dmg2, 0f, Main.myPlayer);
											Main.projectile[num49].velocity.Y = 0.5f;
											Main.projectile[num49].position.Y += 2f;
											Main.projectile[num49].netUpdate = true;
										}
										NetMessage.SendTileSquare(-1, i, j, 1);
										SquareTileFrame(i, j);
									}
								}
								if (rectangle.X != frameX && rectangle.Y != frameY && frameX >= 0 && frameY >= 0)
								{
									tileReframeCount++;
									if (tileReframeCount < 25)
									{
										bool num50 = mergeUp;
										bool flag14 = mergeDown;
										bool flag15 = mergeLeft;
										bool flag16 = mergeRight;
										TileFrame(i - 1, j);
										TileFrame(i + 1, j);
										TileFrame(i, j - 1);
										TileFrame(i, j + 1);
										mergeUp = num50;
										mergeDown = flag14;
										mergeLeft = flag15;
										mergeRight = flag16;
									}
									tileReframeCount--;
								}
								goto end_IL_0002;
							}
							}
						}
						Framing.SelfFrame8Way(i, j, tile, resetFrame);
						return;
					}
				}
				end_IL_0002:;
			}
			catch
			{
			}
			if (i > 0 && j > 0)
			{
				UpdateMapTile(i, j, addToList);
			}
		}

		public static void CheckTorch(int x, int y)
		{
			for (int i = x - 1; i <= x + 1; i++)
			{
				for (int j = y - 1; j <= y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						return;
					}
				}
			}
			Tile tile = Main.tile[x, y];
			Tile tile2 = Main.tile[x, y - 1];
			Tile tile3 = Main.tile[x, y + 1];
			Tile tile4 = Main.tile[x - 1, y];
			Tile tile5 = Main.tile[x + 1, y];
			Tile tile6 = Main.tile[x - 1, y + 1];
			Tile tile7 = Main.tile[x + 1, y + 1];
			Tile tile8 = Main.tile[x - 1, y - 1];
			Tile tile9 = Main.tile[x + 1, y - 1];
			short num = 0;
			if (tile.frameX >= 66)
			{
				num = 66;
			}
			int num2 = -1;
			int num3 = -1;
			int num4 = -1;
			int tree = -1;
			int tree2 = -1;
			int tree3 = -1;
			int tree4 = -1;
			if (tile2 != null && tile2.active() && !tile2.bottomSlope())
			{
				_ = tile2.type;
			}
			if (tile3 != null && tile3.active() && ((TileID.Sets.Platforms[tile3.type] && TopEdgeCanBeAttachedTo(x, y + 1)) || (!tile3.halfBrick() && !tile3.topSlope())))
			{
				num2 = tile3.type;
			}
			if (tile4 != null && tile4.active() && (tile4.slope() == 0 || (int)tile4.slope() % 2 != 1))
			{
				num3 = tile4.type;
			}
			if (tile5 != null && tile5.active() && (tile5.slope() == 0 || (int)tile5.slope() % 2 != 0))
			{
				num4 = tile5.type;
			}
			if (tile6 != null && tile6.active())
			{
				tree = tile6.type;
			}
			if (tile7 != null && tile7.active())
			{
				tree2 = tile7.type;
			}
			if (tile8 != null && tile8.active())
			{
				tree3 = tile8.type;
			}
			if (tile9 != null && tile9.active())
			{
				tree4 = tile9.type;
			}
			if (num2 >= 0 && Main.tileSolid[num2] && (!Main.tileNoAttach[num2] || TileID.Sets.Platforms[num2]))
			{
				tile.frameX = num;
			}
			else if ((num3 >= 0 && Main.tileSolid[num3] && !Main.tileNoAttach[num3]) || (num3 >= 0 && TileID.Sets.IsBeam[num3]) || (IsTreeType(num3) && IsTreeType(tree3) && IsTreeType(tree)))
			{
				tile.frameX = (short)(22 + num);
			}
			else if ((num4 >= 0 && Main.tileSolid[num4] && !Main.tileNoAttach[num4]) || (num4 >= 0 && TileID.Sets.IsBeam[num4]) || (IsTreeType(num4) && IsTreeType(tree4) && IsTreeType(tree2)))
			{
				tile.frameX = (short)(44 + num);
			}
			else if (tile.wall > 0)
			{
				tile.frameX = num;
			}
			else
			{
				KillTile(x, y);
			}
		}

		public static void CheckProjectilePressurePad(int i, int j)
		{
			CheckProjectilePressurePad_GetPossiblePlacementDirections(i, j, out var canUp, out var canLeft, out var canRight, out var canDown);
			Tile tile = Main.tile[i, j];
			int num = tile.frameX / 22;
			bool flag = false;
			if (num switch
			{
				0 => !canDown, 
				1 => !canUp, 
				2 => !canLeft, 
				3 => !canRight, 
				_ => true, 
			})
			{
				if (canDown)
				{
					tile.frameX = 0;
				}
				else if (canUp)
				{
					tile.frameX = 22;
				}
				else if (canLeft)
				{
					tile.frameX = 44;
				}
				else if (canRight)
				{
					tile.frameX = 66;
				}
				else
				{
					KillTile(i, j);
				}
			}
		}

		private static void CheckProjectilePressurePad_GetPossiblePlacementDirections(int i, int j, out bool canUp, out bool canLeft, out bool canRight, out bool canDown)
		{
			canUp = false;
			canLeft = false;
			canRight = false;
			canDown = false;
			_ = Main.tile[i, j];
			Tile tile = Main.tile[i, j - 1];
			Tile tile2 = Main.tile[i, j + 1];
			Tile tile3 = Main.tile[i - 1, j];
			Tile tile4 = Main.tile[i + 1, j];
			Tile tile5 = Main.tile[i - 1, j + 1];
			Tile tile6 = Main.tile[i + 1, j + 1];
			Tile tile7 = Main.tile[i - 1, j - 1];
			Tile tile8 = Main.tile[i + 1, j - 1];
			int num = -1;
			int num2 = -1;
			int num3 = -1;
			int num4 = -1;
			int tree = -1;
			int tree2 = -1;
			int tree3 = -1;
			int tree4 = -1;
			if (tile != null && tile.nactive() && !tile.bottomSlope())
			{
				num2 = tile.type;
			}
			if (tile2 != null && tile2.nactive() && !tile2.halfBrick() && !tile2.topSlope())
			{
				num = tile2.type;
			}
			if (tile3 != null && tile3.nactive() && (tile3.slope() == 0 || (int)tile3.slope() % 2 != 1))
			{
				num3 = tile3.type;
			}
			if (tile4 != null && tile4.nactive() && (tile4.slope() == 0 || (int)tile4.slope() % 2 != 0))
			{
				num4 = tile4.type;
			}
			if (tile5 != null && tile5.nactive())
			{
				tree = tile5.type;
			}
			if (tile6 != null && tile6.nactive())
			{
				tree2 = tile6.type;
			}
			if (tile7 != null && tile7.nactive())
			{
				tree3 = tile7.type;
			}
			if (tile8 != null && tile8.nactive())
			{
				tree4 = tile8.type;
			}
			if (num >= 0 && Main.tileSolid[num] && (!Main.tileNoAttach[num] || TileID.Sets.Platforms[num]) && (tile2.bottomSlope() || tile2.slope() == 0) && !tile2.halfBrick())
			{
				canDown = true;
			}
			if (num2 >= 0 && Main.tileSolid[num2] && (!Main.tileNoAttach[num2] || (TileID.Sets.Platforms[num2] && tile.halfBrick())) && (tile.topSlope() || tile.slope() == 0 || tile.halfBrick()))
			{
				canUp = true;
			}
			if ((num3 >= 0 && Main.tileSolid[num3] && !Main.tileNoAttach[num3] && (tile3.leftSlope() || tile3.slope() == 0) && !tile3.halfBrick()) || (num3 >= 0 && TileID.Sets.IsBeam[num3]) || (IsTreeType(num3) && IsTreeType(tree3) && IsTreeType(tree)))
			{
				canLeft = true;
			}
			if ((num4 >= 0 && Main.tileSolid[num4] && !Main.tileNoAttach[num4] && (tile4.rightSlope() || tile4.slope() == 0) && !tile4.halfBrick()) || (num4 >= 0 && TileID.Sets.IsBeam[num4]) || (IsTreeType(num4) && IsTreeType(tree4) && IsTreeType(tree2)))
			{
				canRight = true;
			}
		}

		public static bool IsTreeType(int tree)
		{
			if (tree >= 0)
			{
				return TileID.Sets.IsATreeTrunk[tree];
			}
			return false;
		}

		public static int CanPlaceProjectilePressurePad(int x, int y, int type = 442, int style = 0, int direction = 0, int alternate = 0)
		{
			CheckProjectilePressurePad_GetPossiblePlacementDirections(x, y, out var canUp, out var canLeft, out var canRight, out var canDown);
			if (!canUp && !canDown && !canLeft && !canRight)
			{
				return -1;
			}
			switch (alternate)
			{
			case 0:
				if (!canDown)
				{
					return -1;
				}
				break;
			case 1:
				if (!canUp)
				{
					return -1;
				}
				break;
			case 2:
				if (!canLeft)
				{
					return -1;
				}
				break;
			case 3:
				if (!canRight)
				{
					return -1;
				}
				break;
			}
			return style;
		}

		private static void CheckDoorOpen(int i, int j, Tile tileCache)
		{
			if (destroyObject)
			{
				return;
			}
			int num = 0;
			int num2 = i;
			int num3 = j;
			short frameX = tileCache.frameX;
			int frameY = tileCache.frameY;
			int num4 = frameY / 54;
			num4 += tileCache.frameX / 72 * 36;
			num3 = j - frameY % 54 / 18;
			bool flag = false;
			switch (frameX % 72)
			{
			case 0:
				num2 = i;
				num = 1;
				break;
			case 18:
				num2 = i - 1;
				num = 1;
				break;
			case 36:
				num2 = i + 1;
				num = -1;
				break;
			case 54:
				num2 = i;
				num = -1;
				break;
			}
			Tile tile = Main.tile[num2, num3 - 1];
			Tile tile2 = Main.tile[num2, num3 + 3];
			if (tile == null)
			{
				tile = new Tile();
				Main.tile[num2, num3 - 1] = tile;
			}
			if (tile2 == null)
			{
				tile2 = new Tile();
				Main.tile[num2, num3 + 3] = tile2;
			}
			if (!SolidTile(tile) || !SolidTile(tile2))
			{
				flag = true;
				destroyObject = true;
				DropDoorItem(i, j, num4);
			}
			int num5 = num2;
			if (num == -1)
			{
				num5 = num2 - 1;
			}
			for (int k = num5; k < num5 + 2; k++)
			{
				for (int l = num3; l < num3 + 3; l++)
				{
					if (!flag)
					{
						Tile tile3 = Main.tile[k, l];
						if (!tile3.active() || tile3.type != 11)
						{
							destroyObject = true;
							DropDoorItem(i, j, num4);
							flag = true;
							k = num5;
							l = num3;
						}
					}
					if (flag)
					{
						KillTile(k, l);
					}
				}
			}
			destroyObject = false;
		}

		private static void CheckDoorClosed(int i, int j, Tile tileCache, int type)
		{
			if (!destroyObject)
			{
				int num = j;
				bool flag = false;
				int frameY = tileCache.frameY;
				int num2 = frameY / 54;
				num2 += tileCache.frameX / 54 * 36;
				num = j - frameY % 54 / 18;
				Tile tile = Main.tile[i, num - 1];
				Tile tile2 = Main.tile[i, num];
				Tile tile3 = Main.tile[i, num + 1];
				Tile tile4 = Main.tile[i, num + 2];
				Tile tile5 = Main.tile[i, num + 3];
				if (tile == null)
				{
					tile = new Tile();
					Main.tile[i, num - 1] = tile;
				}
				if (tile2 == null)
				{
					tile2 = new Tile();
					Main.tile[i, num] = tile2;
				}
				if (tile3 == null)
				{
					tile3 = new Tile();
					Main.tile[i, num + 1] = tile3;
				}
				if (tile4 == null)
				{
					tile4 = new Tile();
					Main.tile[i, num + 2] = tile4;
				}
				if (tile5 == null)
				{
					tile5 = new Tile();
					Main.tile[i, num + 3] = tile5;
				}
				if (!SolidTile(tile))
				{
					flag = true;
				}
				if (!SolidTile(tile5))
				{
					flag = true;
				}
				if (!tile2.active() || tile2.type != type)
				{
					flag = true;
				}
				if (!tile3.active() || tile3.type != type)
				{
					flag = true;
				}
				if (!tile4.active() || tile4.type != type)
				{
					flag = true;
				}
				if (flag)
				{
					destroyObject = true;
					KillTile(i, num);
					KillTile(i, num + 1);
					KillTile(i, num + 2);
					DropDoorItem(i, j, num2);
				}
				destroyObject = false;
			}
		}

		private static void GetSandfallProjData(int type, out int projType, out int dmg)
		{
			dmg = 10;
			switch (type)
			{
			case 112:
				projType = 56;
				break;
			case 59:
				projType = 39;
				break;
			case 116:
				projType = 67;
				break;
			case 123:
				projType = 71;
				break;
			case 224:
				projType = 179;
				break;
			case 234:
				projType = 241;
				break;
			case 330:
				projType = 411;
				dmg = 0;
				break;
			case 331:
				projType = 412;
				dmg = 0;
				break;
			case 332:
				projType = 413;
				dmg = 0;
				break;
			case 333:
				projType = 414;
				dmg = 0;
				break;
			case 495:
				projType = 812;
				break;
			default:
				projType = 31;
				break;
			}
		}

		public static bool AllowsSandfall(Tile tileTopCache)
		{
			bool result = true;
			if (tileTopCache.active() && (TileID.Sets.BasicChest[tileTopCache.type] || TileID.Sets.BasicChestFake[tileTopCache.type] || tileTopCache.type == 323 || tileTopCache.type == 88 || tileTopCache.type == 80 || tileTopCache.type == 77 || tileTopCache.type == 26 || tileTopCache.type == 475 || tileTopCache.type == 470 || tileTopCache.type == 597))
			{
				result = false;
			}
			return result;
		}

		public static void TriggerLunarApocalypse()
		{
			List<int> list = new List<int>
			{
				517,
				422,
				507,
				493
			};
			int[] array = new int[4];
			for (int i = 0; i < 4; i++)
			{
				array[i] = list[Main.rand.Next(list.Count)];
				list.Remove(array[i]);
			}
			int num = Main.maxTilesX / 5;
			int num2 = (int)Main.worldSurface;
			for (int j = 0; j < 4; j++)
			{
				int num3 = num * (1 + j);
				bool flag = false;
				for (int k = 0; k < 30; k++)
				{
					int num4 = Main.rand.Next(-100, 101);
					for (int num5 = num2; num5 > 100; num5--)
					{
						if (!Collision.SolidTiles(num3 + num4 - 10, num3 + num4 + 10, num5 - 20, num5 + 15) && !PlayerLOS(num3 + num4 - 10, num5) && !PlayerLOS(num3 + num4 + 10, num5) && !PlayerLOS(num3 + num4 - 10, num5 - 20) && !PlayerLOS(num3 + num4 + 10, num5 - 20))
						{
							int num6 = NPC.NewNPC((num3 + num4) * 16, num5 * 16, array[j]);
							if (Main.netMode == 2 && num6 < 200)
							{
								NetMessage.SendData(23, -1, -1, null, num6);
							}
							flag = true;
							break;
						}
					}
					if (flag)
					{
						break;
					}
				}
				if (!flag)
				{
					NPC.NewNPC(num3 * 16, (num2 - 40) * 16, array[j]);
				}
			}
			NPC.TowerActiveVortex = (NPC.TowerActiveNebula = (NPC.TowerActiveSolar = (NPC.TowerActiveStardust = true)));
			NPC.LunarApocalypseIsUp = true;
			NPC.ShieldStrengthTowerSolar = (NPC.ShieldStrengthTowerVortex = (NPC.ShieldStrengthTowerNebula = (NPC.ShieldStrengthTowerStardust = NPC.ShieldStrengthTowerMax)));
			NetMessage.SendData(101);
			MessageLunarApocalypse();
		}

		public static void UpdateLunarApocalypse()
		{
			if (!NPC.LunarApocalypseIsUp)
			{
				return;
			}
			bool flag = false;
			bool flag2 = false;
			bool flag3 = false;
			bool flag4 = false;
			bool flag5 = false;
			for (int i = 0; i < 200; i++)
			{
				if (Main.npc[i].active)
				{
					switch (Main.npc[i].type)
					{
					case 398:
						flag = true;
						break;
					case 517:
						flag2 = true;
						break;
					case 422:
						flag3 = true;
						break;
					case 507:
						flag4 = true;
						break;
					case 493:
						flag5 = true;
						break;
					}
				}
			}
			if (!flag2)
			{
				NPC.TowerActiveSolar = false;
			}
			if (!flag3)
			{
				NPC.TowerActiveVortex = false;
			}
			if (!flag4)
			{
				NPC.TowerActiveNebula = false;
			}
			if (!flag5)
			{
				NPC.TowerActiveStardust = false;
			}
			if (!NPC.TowerActiveSolar && !NPC.TowerActiveVortex && !NPC.TowerActiveNebula && !NPC.TowerActiveStardust && !flag)
			{
				StartImpendingDoom();
			}
		}

		public static void StartImpendingDoom()
		{
			NPC.LunarApocalypseIsUp = false;
			NPC.MoonLordCountdown = 3600;
			NetMessage.SendData(103, -1, -1, null, NPC.MoonLordCountdown);
			BroadcastText(NetworkText.FromKey(Lang.misc[52].Key), 50, 255, 130);
			if (Main.netMode != 1)
			{
				GetRidOfCultists();
			}
		}

		public static void GetRidOfCultists()
		{
			for (int i = 0; i < 200; i++)
			{
				if (Main.npc[i].active && (Main.npc[i].type == 437 || Main.npc[i].type == 438 || Main.npc[i].type == 379))
				{
					Main.npc[i].active = false;
					if (Main.netMode != 1)
					{
						NetMessage.SendData(23, -1, -1, null, i);
					}
				}
			}
		}

		public static void MessageLunarApocalypse()
		{
			if (NPC.LunarApocalypseIsUp)
			{
				int num = 0;
				if (!NPC.TowerActiveSolar)
				{
					num++;
				}
				if (!NPC.TowerActiveVortex)
				{
					num++;
				}
				if (!NPC.TowerActiveNebula)
				{
					num++;
				}
				if (!NPC.TowerActiveStardust)
				{
					num++;
				}
				BroadcastText(NetworkText.FromKey(Lang.misc[43 + num].Key), 175, 75, 255);
			}
		}

		public static void BroadcastText(NetworkText text, Vector4 color)
		{
			BroadcastText(text, new Color(color));
		}

		public static void BroadcastText(NetworkText text, Vector3 color)
		{
			BroadcastText(text, new Color(color));
		}

		public static void BroadcastText(NetworkText text, int r, int g, int b)
		{
			BroadcastText(text, new Color(r, g, b));
		}

		public static void BroadcastText(NetworkText text, byte r, byte g, byte b)
		{
			BroadcastText(text, new Color(r, g, b));
		}

		public static void BroadcastText(NetworkText text, Color color)
		{
			if (Main.netMode == 0)
			{
				Main.NewText(text.ToString(), color.R, color.G, color.B);
			}
			else if (Main.netMode == 2)
			{
				ChatHelper.BroadcastChatMessage(text, color);
			}
		}

		public static bool CanCutTile(int x, int y, TileCuttingContext context)
		{
			if (Main.tile[x, y + 1] != null && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 579)
			{
				if (Main.tile[x, y].type == 254)
				{
					return Main.tile[x, y].frameX >= 144;
				}
				return true;
			}
			return false;
		}

		public static bool InAPlaceWithWind(Vector2 position, int width, int height)
		{
			Point point = position.ToTileCoordinates();
			Point point2 = (position + new Vector2(width, height)).ToTileCoordinates();
			return InAPlaceWithWind(point.X, point.Y, 1 + point2.X - point.X, 1 + point2.Y - point.Y);
		}

		public static bool InAPlaceWithWind(int x, int y, int width, int height)
		{
			if ((double)y >= Main.worldSurface)
			{
				return false;
			}
			for (int i = 0; i < width; i++)
			{
				for (int j = 0; j < height; j++)
				{
					Tile tile = Main.tile[x + i, y + j];
					if (tile == null)
					{
						return false;
					}
					if (tile.liquid > 0 || (tile.wall > 0 && !WallID.Sets.AllowsWind[tile.wall]))
					{
						return false;
					}
				}
			}
			return true;
		}

		public static int[] CountTileTypesInWorld(params int[] oreTypes)
		{
			int[] array = new int[oreTypes.Length];
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				for (int j = 0; j < Main.maxTilesY; j++)
				{
					Tile tile = Main.tile[i, j];
					if (!tile.active())
					{
						continue;
					}
					for (int k = 0; k < oreTypes.Length; k++)
					{
						if (oreTypes[k] == tile.type)
						{
							array[k]++;
							break;
						}
					}
				}
			}
			return array;
		}
	}
}
